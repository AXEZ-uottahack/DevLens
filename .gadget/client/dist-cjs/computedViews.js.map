{
  "version": 3,
  "sources": ["../src/computedViews.ts"],
  "sourcesContent": ["import { assertOperationSuccess, type FieldSelection, type GadgetConnection, type VariablesOptions } from \"@gadgetinc/api-client-core\";\nimport {\n  fieldSelectionToQueryCompilerFields,\n  variableOptionsToVariables,\n  type AllFieldsSelected,\n  type AvailableSelection,\n  type DefaultSelection,\n  type Select,\n} from \"./utils.js\";\nimport { Call, compile, compileWithVariableValues, Var, type Variable } from \"tiny-graphql-query-compiler\";\n\n// Gelly query string template handler for gelly`{...}` literals.\nexport function gelly(strings: TemplateStringsArray): string {\n  if (strings.length != 1) throw new Error(`Gelly query string must be a fixed string. Use query variables to parameterize the query.`);\n  return strings[0];\n}\n\n// This is a function that represents a computed view that doesn't take any input parameters/variables.\n// Result is an explicit type parameter defining the shape of the full result.\nexport type ComputedViewFunctionWithoutVariables<Result> =\n  // Available, Options and Defaults are inferred at call time.\n  <\n    // Available is the full FieldSelection type derived from the shape of the Result type, i.e. all possible selections.\n    Available extends AvailableSelection<Result> & FieldSelection,\n    // Options holds the actual selection at call time.\n    Options extends { select?: Available | null },\n    // Defaults is the default selection to be used when one is not provided at call time,\n    // for views we default to everything being selected.\n    Defaults extends AllFieldsSelected<Available>\n  >(\n    options?: Options\n  ) => Promise<Select<Result, DefaultSelection<Available, Options, Defaults>>>;\n\n// Represents a computed view that doesn't take any input parameters/variables.\n// It includes the view function and the view metadata.\nexport interface ComputedViewWithoutVariables<Result> extends ComputedViewFunctionWithoutVariables<Result> {\n  type: \"computedView\";\n  operationName: string;\n  namespace: string | string[] | null;\n  defaultSelection: FieldSelection;\n  selection?: FieldSelection;\n  selectionType: AvailableSelection<Result>;\n  resultType: Result;\n}\n\n// This is a function that represents a computed view that takes input parameters/variables.\n// Result is an explicit type parameter defining the shape of the full result.\n// Variables is an explicit type parameter that describes the shape of the variables parameter.\nexport type ComputedViewFunctionWithVariables<Variables, Result> =\n  // Available, Options and Defaults are inferred at call time.\n  <\n    // Available is the full FieldSelection type derived from the shape of the Result type, i.e. all possible selections.\n    Available extends AvailableSelection<Result> & FieldSelection,\n    // Options holds the actual selection at call time.\n    Options extends { select?: Available | null },\n    // Defaults is the default selection to be used when one is not provided at call time,\n    // for views we default to everything being selected.\n    Defaults extends AllFieldsSelected<Available>\n  >(\n    variables: Variables,\n    options?: Options\n  ) => Promise<Select<Result, DefaultSelection<Available, Options, Defaults>>>;\n\n// Represents a computed view that takes input parameters/variables.\n// It includes the view function and the view metadata.\nexport interface ComputedViewWithVariables<Variables, Result> extends ComputedViewFunctionWithVariables<Variables, Result> {\n  type: \"computedView\";\n  operationName: string;\n  namespace: string | string[] | null;\n  variables: VariablesOptions;\n  variablesType: Variables;\n  defaultSelection: FieldSelection;\n  selection?: FieldSelection;\n  selectionType: AvailableSelection<Result>;\n  resultType: Result;\n}\n\nexport const computedViewOperation = (\n  operation: string,\n  defaultSelection: FieldSelection,\n  variables?: VariablesOptions,\n  selection?: FieldSelection,\n  namespace?: string | string[] | null\n): {\n  query: string;\n  variables: Record<string, any>;\n} => {\n  let fields = {\n    [operation]: Call(\n      variables ? variableOptionsToVariables(variables) : {},\n      fieldSelectionToQueryCompilerFields(selection ?? defaultSelection, true)\n    ),\n  };\n\n  if (namespace) {\n    fields = namespacify(namespace, fields);\n  }\n\n  return variables\n    ? compileWithVariableValues({ type: \"query\", name: operation, fields })\n    : { query: compile({ type: \"query\", name: operation, fields }), variables: {} };\n};\n\nexport const computedViewRunner = async (\n  connection: GadgetConnection,\n  operation: string,\n  defaultSelection: FieldSelection,\n  variableValues?: VariablesOptions,\n  selection?: FieldSelection,\n  namespace?: string | string[] | null\n): Promise<any> => {\n  const { query, variables } = computedViewOperation(operation, defaultSelection, variableValues, selection, namespace);\n  const response = await connection.currentClient.query(query, variables);\n  const dataPath = namespaceDataPath([operation], namespace);\n  return assertOperationSuccess(response, dataPath);\n};\n\nexport const inlineComputedViewOperation = (\n  query: string,\n  gqlFieldName: string,\n  variables?: Record<string, any>,\n  namespace?: string | string[] | null\n): {\n  query: string;\n  variables: Record<string, any>;\n} => {\n  const operation = gqlFieldName;\n  const vars: Record<string, Variable> = {\n    query: Var({ type: \"String\", value: query, required: true }),\n  };\n  if (variables) vars[\"variables\"] = Var({ type: \"JSONObject\", value: variables });\n  let fields = {\n    [operation]: Call(variableOptionsToVariables(vars)),\n  };\n  if (namespace) fields = namespacify(namespace, fields);\n  return compileWithVariableValues({ type: \"query\", name: operation, fields });\n};\n\nexport const inlineComputedViewRunner = async (\n  connection: GadgetConnection,\n  gqlFieldName: string,\n  viewQuery: string,\n  variables?: Record<string, any>,\n  namespace?: string | string[] | null\n): Promise<unknown> => {\n  const { query, variables: vars } = inlineComputedViewOperation(viewQuery, gqlFieldName, variables, namespace);\n  const response = await connection.currentClient.query(query, vars);\n  const dataPath = namespaceDataPath([gqlFieldName], namespace);\n  return assertOperationSuccess(response, dataPath);\n};\n\n/**\n * Had to duplicate these from api-client-core to make 0.15.20 tests happy,\n * Hopefully we can get rid of this duplication at some point\n *\n * Wrap a field selection in a set of namespaces\n **/\nfunction namespacify(namespace: string[] | string | undefined | null, fields: any) {\n  if (!namespace) return fields;\n  if (!Array.isArray(namespace)) {\n    namespace = [namespace];\n  }\n  if (namespace) {\n    for (let i = namespace.length - 1; i >= 0; i--) {\n      fields = {\n        [namespace[i]]: fields,\n      };\n    }\n  }\n  return fields;\n}\n\nconst namespaceDataPath = (dataPath: string[], namespace?: string[] | string | null) => {\n  if (namespace) {\n    dataPath.unshift(...(Array.isArray(namespace) ? namespace : [namespace]));\n  }\n  return dataPath;\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BAA0G;AAC1G,mBAOO;AACP,yCAA6E;AAGtE,SAAS,MAAM,SAAuC;AAC3D,MAAI,QAAQ,UAAU;AAAG,UAAM,IAAI,MAAM,2FAA2F;AACpI,SAAO,QAAQ,CAAC;AAClB;AA8DO,MAAM,wBAAwB,CACnC,WACA,kBACA,WACA,WACA,cAIG;AACH,MAAI,SAAS;AAAA,IACX,CAAC,SAAS,OAAG;AAAA,MACX,gBAAY,yCAA2B,SAAS,IAAI,CAAC;AAAA,UACrD,kDAAoC,aAAa,kBAAkB,IAAI;AAAA,IACzE;AAAA,EACF;AAEA,MAAI,WAAW;AACb,aAAS,YAAY,WAAW,MAAM;AAAA,EACxC;AAEA,SAAO,gBACH,8DAA0B,EAAE,MAAM,SAAS,MAAM,WAAW,OAAO,CAAC,IACpE,EAAE,WAAO,4CAAQ,EAAE,MAAM,SAAS,MAAM,WAAW,OAAO,CAAC,GAAG,WAAW,CAAC,EAAE;AAClF;AAEO,MAAM,qBAAqB,OAChC,YACA,WACA,kBACA,gBACA,WACA,cACiB;AACjB,QAAM,EAAE,OAAO,UAAU,IAAI,sBAAsB,WAAW,kBAAkB,gBAAgB,WAAW,SAAS;AACpH,QAAM,WAAW,MAAM,WAAW,cAAc,MAAM,OAAO,SAAS;AACtE,QAAM,WAAW,kBAAkB,CAAC,SAAS,GAAG,SAAS;AACzD,aAAO,+CAAuB,UAAU,QAAQ;AAClD;AAEO,MAAM,8BAA8B,CACzC,OACA,cACA,WACA,cAIG;AACH,QAAM,YAAY;AAClB,QAAM,OAAiC;AAAA,IACrC,WAAO,wCAAI,EAAE,MAAM,UAAU,OAAO,OAAO,UAAU,KAAK,CAAC;AAAA,EAC7D;AACA,MAAI;AAAW,SAAK,WAAW,QAAI,wCAAI,EAAE,MAAM,cAAc,OAAO,UAAU,CAAC;AAC/E,MAAI,SAAS;AAAA,IACX,CAAC,SAAS,OAAG,6CAAK,yCAA2B,IAAI,CAAC;AAAA,EACpD;AACA,MAAI;AAAW,aAAS,YAAY,WAAW,MAAM;AACrD,aAAO,8DAA0B,EAAE,MAAM,SAAS,MAAM,WAAW,OAAO,CAAC;AAC7E;AAEO,MAAM,2BAA2B,OACtC,YACA,cACA,WACA,WACA,cACqB;AACrB,QAAM,EAAE,OAAO,WAAW,KAAK,IAAI,4BAA4B,WAAW,cAAc,WAAW,SAAS;AAC5G,QAAM,WAAW,MAAM,WAAW,cAAc,MAAM,OAAO,IAAI;AACjE,QAAM,WAAW,kBAAkB,CAAC,YAAY,GAAG,SAAS;AAC5D,aAAO,+CAAuB,UAAU,QAAQ;AAClD;AAQA,SAAS,YAAY,WAAiD,QAAa;AACjF,MAAI,CAAC;AAAW,WAAO;AACvB,MAAI,CAAC,MAAM,QAAQ,SAAS,GAAG;AAC7B,gBAAY,CAAC,SAAS;AAAA,EACxB;AACA,MAAI,WAAW;AACb,aAAS,IAAI,UAAU,SAAS,GAAG,KAAK,GAAG,KAAK;AAC9C,eAAS;AAAA,QACP,CAAC,UAAU,CAAC,CAAC,GAAG;AAAA,MAClB;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAEA,MAAM,oBAAoB,CAAC,UAAoB,cAAyC;AACtF,MAAI,WAAW;AACb,aAAS,QAAQ,GAAI,MAAM,QAAQ,SAAS,IAAI,YAAY,CAAC,SAAS,CAAE;AAAA,EAC1E;AACA,SAAO;AACT;",
  "names": []
}
