{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/config/index.mjs"],"sourcesContent":["export const config = {\n    // When set to `true` the cell selectors could be defined as CSS selectors.\n    // If not, only JSON Markup selectors are taken into account.\n    useCSSSelectors: false,\n    // The class name prefix config is for advanced use only.\n    // Be aware that if you change the prefix, the JointJS CSS will no longer function properly.\n    classNamePrefix: 'joint-',\n    defaultTheme: 'default',\n    // The maximum delay required for two consecutive touchend events to be interpreted\n    // as a double-tap.\n    doubleTapInterval: 300\n};\n"],"names":[],"mappings":";;;AAAO,MAAM,SAAS;IAClB,2EAA2E;IAC3E,6DAA6D;IAC7D,iBAAiB;IACjB,yDAAyD;IACzD,4FAA4F;IAC5F,iBAAiB;IACjB,cAAc;IACd,mFAAmF;IACnF,mBAAmB;IACnB,mBAAmB;AACvB","ignoreList":[0]}},
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/V/index.mjs"],"sourcesContent":["// Vectorizer.\n// -----------\n\n// A tiny library for making your life easier when dealing with SVG.\n// The only Vectorizer dependency is the Geometry library.\n\nimport * as g from '../g/index.mjs';\n\nconst V = (function() {\n\n    var hasSvg = typeof window === 'object' && !!window.SVGAngle;\n\n    // SVG support is required.\n    if (!hasSvg) {\n\n        // Return a function that throws an error when it is used.\n        return function() {\n            throw new Error('SVG is required to use Vectorizer.');\n        };\n    }\n\n    // XML namespaces.\n    var ns = {\n        svg: 'http://www.w3.org/2000/svg',\n        xmlns: 'http://www.w3.org/2000/xmlns/',\n        xml: 'http://www.w3.org/XML/1998/namespace',\n        xlink: 'http://www.w3.org/1999/xlink',\n        xhtml: 'http://www.w3.org/1999/xhtml'\n    };\n\n    var SVGVersion = '1.1';\n\n    // Declare shorthands to the most used math functions.\n    var math = Math;\n    var PI = math.PI;\n    var atan2 = math.atan2;\n    var sqrt = math.sqrt;\n    var min = math.min;\n    var max = math.max;\n    var cos = math.cos;\n    var sin = math.sin;\n\n    var V = function(el, attrs, children) {\n\n        // This allows using V() without the new keyword.\n        if (!(this instanceof V)) {\n            return V.apply(Object.create(V.prototype), arguments);\n        }\n\n        if (!el) return;\n\n        if (V.isV(el)) {\n            el = el.node;\n        }\n\n        attrs = attrs || {};\n\n        if (V.isString(el)) {\n\n            el = el.trim();\n\n            if (el.toLowerCase() === 'svg') {\n\n                // Create a new SVG canvas.\n                el = V.createSvgDocument();\n\n            } else if (el[0] === '<') {\n\n                // Create element from an SVG string.\n                // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.\n\n                var svgDoc = V.createSvgDocument(el);\n\n                // Note that `V()` might also return an array should the SVG string passed as\n                // the first argument contain more than one root element.\n                if (svgDoc.childNodes.length > 1) {\n\n                    // Map child nodes to `V`s.\n                    var arrayOfVels = [];\n                    var i, len;\n\n                    for (i = 0, len = svgDoc.childNodes.length; i < len; i++) {\n\n                        var childNode = svgDoc.childNodes[i];\n                        arrayOfVels.push(new V(document.importNode(childNode, true)));\n                    }\n\n                    return arrayOfVels;\n                }\n\n                el = document.importNode(svgDoc.firstChild, true);\n\n            } else {\n\n                el = document.createElementNS(ns.svg, el);\n            }\n\n            V.ensureId(el);\n        }\n\n        this.node = el;\n\n        this.setAttributes(attrs);\n\n        if (children) {\n            this.append(children);\n        }\n\n        return this;\n    };\n\n    var VPrototype = V.prototype;\n\n    Object.defineProperty(VPrototype, 'id', {\n        enumerable: true,\n        get: function() {\n            return this.node.id;\n        },\n        set: function(id) {\n            this.node.id = id;\n        }\n    });\n\n    /**\n     * @param {SVGGElement} toElem\n     * @returns {SVGMatrix}\n     */\n    VPrototype.getTransformToElement = function(target) {\n        var node = this.node;\n        if (V.isSVGGraphicsElement(target) && V.isSVGGraphicsElement(node)) {\n            var targetCTM = V.toNode(target).getScreenCTM();\n            var nodeCTM = node.getScreenCTM();\n            if (targetCTM && nodeCTM) {\n                return targetCTM.inverse().multiply(nodeCTM);\n            }\n        }\n        // Could not get actual transformation matrix\n        return V.createSVGMatrix();\n    };\n\n    /**\n     * @param {SVGMatrix} matrix\n     * @param {Object=} opt\n     * @returns {Vectorizer|SVGMatrix} Setter / Getter\n     */\n    VPrototype.transform = function(matrix, opt) {\n\n        var node = this.node;\n        if (V.isUndefined(matrix)) {\n            return V.transformStringToMatrix(this.attr('transform'));\n        }\n\n        if (opt && opt.absolute) {\n            return this.attr('transform', V.matrixToTransformString(matrix));\n        }\n\n        var svgTransform = V.createSVGTransform(matrix);\n        node.transform.baseVal.appendItem(svgTransform);\n        return this;\n    };\n\n    VPrototype.translate = function(tx, ty, opt) {\n\n        opt = opt || {};\n        ty = ty || 0;\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n        // Is it a getter?\n        if (V.isUndefined(tx)) {\n            return transform.translate;\n        }\n\n        transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n\n        var newTx = opt.absolute ? tx : transform.translate.tx + tx;\n        var newTy = opt.absolute ? ty : transform.translate.ty + ty;\n        var newTranslate = 'translate(' + newTx + ',' + newTy + ')';\n\n        // Note that `translate()` is always the first transformation. This is\n        // usually the desired case.\n        this.attr('transform', (newTranslate + ' ' + transformAttr).trim());\n        return this;\n    };\n\n    VPrototype.rotate = function(angle, cx, cy, opt) {\n\n        opt = opt || {};\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n\n        // Is it a getter?\n        if (V.isUndefined(angle)) {\n            return transform.rotate;\n        }\n\n        transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n\n        angle %= 360;\n\n        var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;\n        var newOrigin = (cx !== undefined && cy !== undefined) ? ',' + cx + ',' + cy : '';\n        var newRotate = 'rotate(' + newAngle + newOrigin + ')';\n\n        this.attr('transform', (transformAttr + ' ' + newRotate).trim());\n        return this;\n    };\n\n    // Note that `scale` as the only transformation does not combine with previous values.\n    VPrototype.scale = function(sx, sy) {\n\n        sy = V.isUndefined(sy) ? sx : sy;\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n\n        // Is it a getter?\n        if (V.isUndefined(sx)) {\n            return transform.scale;\n        }\n\n        transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n\n        var newScale = 'scale(' + sx + ',' + sy + ')';\n\n        this.attr('transform', (transformAttr + ' ' + newScale).trim());\n        return this;\n    };\n\n    // Get SVGRect that contains coordinates and dimension of the real bounding box,\n    // i.e. after transformations are applied.\n    // If `target` is specified, bounding box will be computed relatively to `target` element.\n    VPrototype.bbox = function(withoutTransformations, target) {\n\n        var box;\n        var node = this.node;\n        var ownerSVGElement = node.ownerSVGElement;\n\n        // If the element is not in the live DOM, it does not have a bounding box defined and\n        // so fall back to 'zero' dimension element.\n        if (!ownerSVGElement) {\n            return new g.Rect(0, 0, 0, 0);\n        }\n\n        try {\n\n            box = node.getBBox();\n\n        } catch (e) {\n\n            // Fallback for IE.\n            box = {\n                x: node.clientLeft,\n                y: node.clientTop,\n                width: node.clientWidth,\n                height: node.clientHeight\n            };\n        }\n\n        if (withoutTransformations) {\n            return new g.Rect(box);\n        }\n\n        var matrix = this.getTransformToElement(target || ownerSVGElement);\n\n        return V.transformRect(box, matrix);\n    };\n\n    // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,\n    // i.e. after transformations are applied.\n    // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.\n    // Takes an (Object) `opt` argument (optional) with the following attributes:\n    // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this\n    // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();\n    VPrototype.getBBox = function(opt) {\n\n        var options = {};\n\n        var outputBBox;\n        var node = this.node;\n        var ownerSVGElement = node.ownerSVGElement;\n\n        // If the element is not in the live DOM, it does not have a bounding box defined and\n        // so fall back to 'zero' dimension element.\n        // If the element is not an SVGGraphicsElement, we could not measure the bounding box either\n        if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) {\n            return new g.Rect(0, 0, 0, 0);\n        }\n\n        if (opt) {\n            if (opt.target) { // check if target exists\n                options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects\n            }\n            if (opt.recursive) {\n                options.recursive = opt.recursive;\n            }\n        }\n\n        if (!options.recursive) {\n            try {\n                outputBBox = node.getBBox();\n            } catch (e) {\n                // Fallback for IE.\n                outputBBox = {\n                    x: node.clientLeft,\n                    y: node.clientTop,\n                    width: node.clientWidth,\n                    height: node.clientHeight\n                };\n            }\n\n            if (!options.target) {\n                // transform like this (that is, not at all)\n                return new g.Rect(outputBBox);\n            } else {\n                // transform like target\n                var matrix = this.getTransformToElement(options.target);\n                return V.transformRect(outputBBox, matrix);\n            }\n        } else { // if we want to calculate the bbox recursively\n            // browsers report correct bbox around svg elements (one that envelops the path lines tightly)\n            // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())\n            // this happens even if we wrap a single svg element into a group!\n            // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes\n\n            var children = this.children();\n            var n = children.length;\n\n            if (n === 0) {\n                return this.getBBox({ target: options.target, recursive: false });\n            }\n\n            // recursion's initial pass-through setting:\n            // recursive passes-through just keep the target as whatever was set up here during the initial pass-through\n            if (!options.target) {\n                // transform children/descendants like this (their parent/ancestor)\n                options.target = this;\n            } // else transform children/descendants like target\n\n            for (var i = 0; i < n; i++) {\n                var currentChild = children[i];\n\n                var childBBox;\n\n                // if currentChild is not a group element, get its bbox with a nonrecursive call\n                if (currentChild.children().length === 0) {\n                    childBBox = currentChild.getBBox({ target: options.target, recursive: false });\n                } else {\n                    // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call\n                    childBBox = currentChild.getBBox({ target: options.target, recursive: true });\n                }\n\n                if (!outputBBox) {\n                    // if this is the first iteration\n                    outputBBox = childBBox;\n                } else {\n                    // make a new bounding box rectangle that contains this child's bounding box and previous bounding box\n                    outputBBox = outputBBox.union(childBBox);\n                }\n            }\n\n            return outputBBox;\n        }\n    };\n\n    // Text() helpers\n\n    function createTextPathNode(attrs, vel) {\n        attrs || (attrs = {});\n        var textPathElement = V('textPath');\n        var d = attrs.d;\n        if (d && attrs['xlink:href'] === undefined) {\n            // If `opt.attrs` is a plain string, consider it to be directly the\n            // SVG path data for the text to go along (this is a shortcut).\n            // Otherwise if it is an object and contains the `d` property, then this is our path.\n            // Wrap the text in the SVG <textPath> element that points\n            // to a path defined by `opt.attrs` inside the `<defs>` element.\n            var linkedPath = V('path').attr('d', d).appendTo(vel.defs());\n            textPathElement.attr('xlink:href', '#' + linkedPath.id);\n        }\n        if (V.isObject(attrs)) {\n            // Set attributes on the `<textPath>`. The most important one\n            // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.\n            // Note that we also allow the following construct:\n            // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.\n            // In other words, one can completely skip the auto-creation of the path\n            // and use any other arbitrary path that is in the document.\n            textPathElement.attr(attrs);\n        }\n        return textPathElement.node;\n    }\n\n    function annotateTextLine(lineNode, lineAnnotations, opt) {\n        opt || (opt = {});\n        var includeAnnotationIndices = opt.includeAnnotationIndices;\n        var eol = opt.eol;\n        var lineHeight = opt.lineHeight;\n        var baseSize = opt.baseSize;\n        var maxFontSize = 0;\n        var fontMetrics = {};\n        var lastJ = lineAnnotations.length - 1;\n        for (var j = 0; j <= lastJ; j++) {\n            var annotation = lineAnnotations[j];\n            var fontSize = null;\n            if (V.isObject(annotation)) {\n                var annotationAttrs = annotation.attrs;\n                var vTSpan = V('tspan', annotationAttrs);\n                var tspanNode = vTSpan.node;\n                var t = annotation.t;\n                if (eol && j === lastJ) t += eol;\n                tspanNode.textContent = t;\n                // Per annotation className\n                var annotationClass = annotationAttrs['class'];\n                if (annotationClass) vTSpan.addClass(annotationClass);\n                // If `opt.includeAnnotationIndices` is `true`,\n                // set the list of indices of all the applied annotations\n                // in the `annotations` attribute. This list is a comma\n                // separated list of indices.\n                if (includeAnnotationIndices) vTSpan.attr('annotations', annotation.annotations);\n                // Check for max font size\n                fontSize = parseFloat(annotationAttrs['font-size']);\n                if (!isFinite(fontSize)) fontSize = baseSize;\n                if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n            } else {\n                if (eol && j === lastJ) annotation += eol;\n                tspanNode = document.createTextNode(annotation || ' ');\n                if (baseSize && baseSize > maxFontSize) maxFontSize = baseSize;\n            }\n            lineNode.appendChild(tspanNode);\n        }\n\n        if (maxFontSize) fontMetrics.maxFontSize = maxFontSize;\n        if (lineHeight) {\n            fontMetrics.lineHeight = lineHeight;\n        } else if (maxFontSize) {\n            fontMetrics.lineHeight = (maxFontSize * 1.2);\n        }\n        return fontMetrics;\n    }\n\n    var emRegex = /em$/;\n\n    function convertEmToPx(em, fontSize) {\n        var numerical = parseFloat(em);\n        if (emRegex.test(em)) return numerical * fontSize;\n        return numerical;\n    }\n\n    function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n        if (!Array.isArray(linesMetrics)) return 0;\n        var n = linesMetrics.length;\n        if (!n) return 0;\n        var lineMetrics = linesMetrics[0];\n        var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n        var rLineHeights = 0;\n        var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);\n        for (var i = 1; i < n; i++) {\n            lineMetrics = linesMetrics[i];\n            var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n            rLineHeights += iLineHeight;\n        }\n        var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n        var dy;\n        switch (alignment) {\n            case 'middle':\n                dy = (flMaxFont / 2) - (0.15 * llMaxFont) - (rLineHeights / 2);\n                break;\n            case 'bottom':\n                dy = -(0.25 * llMaxFont) - rLineHeights;\n                break;\n            case 'top':\n            default:\n                dy = (0.8 * flMaxFont);\n                break;\n        }\n        return dy;\n    }\n\n    VPrototype.text = function(content, opt) {\n\n        if (content && typeof content !== 'string') throw new Error('Vectorizer: text() expects the first argument to be a string.');\n\n        // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n        // IE would otherwise collapse all spaces into one.\n        content = V.sanitizeText(content);\n        opt || (opt = {});\n        // Should we allow the text to be selected?\n        var displayEmpty = opt.displayEmpty;\n        // End of Line character\n        var eol = opt.eol;\n        // Text along path\n        var textPath = opt.textPath;\n        // Vertical shift\n        var verticalAnchor = opt.textVerticalAnchor;\n        var namedVerticalAnchor = (verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top');\n        // Horizontal shift applied to all the lines but the first.\n        var x = opt.x;\n        if (x === undefined) x = this.attr('x') || 0;\n        // Annotations\n        var iai = opt.includeAnnotationIndices;\n        var annotations = opt.annotations;\n        if (annotations && !V.isArray(annotations)) annotations = [annotations];\n        // Shift all the <tspan> but first by one line (`1em`)\n        var defaultLineHeight = opt.lineHeight;\n        var autoLineHeight = (defaultLineHeight === 'auto');\n        var lineHeight = (autoLineHeight) ? '1.5em' : (defaultLineHeight || '1em');\n        // Clearing the element\n        this.empty();\n        this.attr({\n            // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.\n            'xml:space': 'preserve',\n            // An empty text gets rendered into the DOM in webkit-based browsers.\n            // In order to unify this behaviour across all browsers\n            // we rather hide the text element when it's empty.\n            'display': (content || displayEmpty) ? null : 'none'\n        });\n\n        // Set default font-size if none\n        var fontSize = parseFloat(this.attr('font-size'));\n        if (!fontSize) {\n            fontSize = 16;\n            if (namedVerticalAnchor || annotations) this.attr('font-size', fontSize);\n        }\n\n        var doc = document;\n        var containerNode;\n        if (textPath) {\n            // Now all the `<tspan>`s will be inside the `<textPath>`.\n            if (typeof textPath === 'string') textPath = { d: textPath };\n            containerNode = createTextPathNode(textPath, this);\n        } else {\n            containerNode = doc.createDocumentFragment();\n        }\n        var offset = 0;\n        var lines = content.split('\\n');\n        var linesMetrics = [];\n        var annotatedY;\n        for (var i = 0, lastI = lines.length - 1; i <= lastI; i++) {\n            var dy = lineHeight;\n            var lineClassName = 'v-line';\n            var lineNode = doc.createElementNS(ns.svg, 'tspan');\n            var line = lines[i];\n            var lineMetrics;\n            if (line) {\n                if (annotations) {\n                    // Find the *compacted* annotations for this line.\n                    var lineAnnotations = V.annotateString(line, annotations, {\n                        offset: -offset,\n                        includeAnnotationIndices: iai\n                    });\n                    lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n                        includeAnnotationIndices: iai,\n                        eol: (i !== lastI && eol),\n                        lineHeight: (autoLineHeight) ? null : lineHeight,\n                        baseSize: fontSize\n                    });\n                    // Get the line height based on the biggest font size in the annotations for this line.\n                    var iLineHeight = lineMetrics.lineHeight;\n                    if (iLineHeight && autoLineHeight && i !== 0) dy = iLineHeight;\n                    if (i === 0) annotatedY = lineMetrics.maxFontSize * 0.8;\n                } else {\n                    if (eol && i !== lastI) line += eol;\n                    lineNode.textContent = line;\n                }\n            } else {\n                // Make sure the textContent is never empty. If it is, add a dummy\n                // character and make it invisible, making the following lines correctly\n                // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n                lineNode.textContent = '-';\n                lineClassName += ' v-empty-line';\n                // 'opacity' needs to be specified with fill, stroke. Opacity without specification\n                // is not applied in Firefox\n                var lineNodeStyle = lineNode.style;\n                lineNodeStyle.fillOpacity = 0;\n                lineNodeStyle.strokeOpacity = 0;\n                if (annotations) {\n                    // Empty line with annotations.\n                    lineMetrics = {};\n                    lineAnnotations = V.findAnnotationsAtIndex(annotations, offset);\n                    let lineFontSize = fontSize;\n                    // Check if any of the annotations overrides the font size.\n                    for (let j = lineAnnotations.length; j > 0; j--) {\n                        const attrs = lineAnnotations[j - 1].attrs;\n                        if (!attrs || !('font-size' in attrs)) continue;\n                        const fs = parseFloat(attrs['font-size']);\n                        if (isFinite(fs)) {\n                            lineFontSize = fs;\n                            break;\n                        }\n                    }\n                    if (autoLineHeight) {\n                        if (i > 0) {\n                            dy = lineFontSize * 1.2;\n                        } else {\n                            annotatedY = lineFontSize * 0.8;\n                        }\n                    }\n                    // The font size is important for the native selection box height.\n                    lineNode.setAttribute('font-size', lineFontSize);\n                    lineMetrics.maxFontSize = lineFontSize;\n                }\n            }\n            if (lineMetrics) linesMetrics.push(lineMetrics);\n            if (i > 0) lineNode.setAttribute('dy', dy);\n            // Firefox requires 'x' to be set on the first line when inside a text path\n            if (i > 0 || textPath) lineNode.setAttribute('x', x);\n            lineNode.className.baseVal = lineClassName;\n            containerNode.appendChild(lineNode);\n            offset += line.length + 1;      // + 1 = newline character.\n        }\n        // Y Alignment calculation\n        if (namedVerticalAnchor) {\n            if (annotations) {\n                dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n            } else if (verticalAnchor === 'top') {\n                // A shortcut for top alignment. It does not depend on font-size nor line-height\n                dy = '0.8em';\n            } else {\n                var rh; // remaining height\n                if (lastI > 0) {\n                    rh = parseFloat(lineHeight) || 1;\n                    rh *= lastI;\n                    if (!emRegex.test(lineHeight)) rh /= fontSize;\n                } else {\n                    // Single-line text\n                    rh = 0;\n                }\n                switch (verticalAnchor) {\n                    case 'middle':\n                        dy = (0.3 - (rh / 2)) + 'em';\n                        break;\n                    case 'bottom':\n                        dy = (-rh - 0.3) + 'em';\n                        break;\n                }\n            }\n        } else {\n            if (verticalAnchor === 0) {\n                dy = '0em';\n            } else if (verticalAnchor) {\n                dy = verticalAnchor;\n            } else {\n                // No vertical anchor is defined\n                dy = 0;\n                // Backwards compatibility - we change the `y` attribute instead of `dy`.\n                if (this.attr('y') === null) this.attr('y', annotatedY || '0.8em');\n            }\n        }\n        containerNode.firstChild.setAttribute('dy', dy);\n        // Appending lines to the element.\n        this.append(containerNode);\n        return this;\n    };\n\n    /**\n     * @public\n     * @param {string} name\n     * @returns {Vectorizer}\n     */\n    VPrototype.removeAttr = function(name) {\n\n        const trueName = attributeNames[name];\n\n        const { ns, local } = V.qualifyAttr(trueName);\n        const el = this.node;\n\n        if (ns) {\n            if (el.hasAttributeNS(ns, local)) {\n                el.removeAttributeNS(ns, local);\n            }\n        } else if (el.hasAttribute(trueName)) {\n            el.removeAttribute(trueName);\n        }\n        return this;\n    };\n\n    VPrototype.attr = function(name, value) {\n\n        if (V.isUndefined(name)) {\n\n            // Return all attributes.\n            var attributes = this.node.attributes;\n            var attrs = {};\n\n            for (var i = 0; i < attributes.length; i++) {\n                attrs[attributes[i].name] = attributes[i].value;\n            }\n\n            return attrs;\n        }\n\n        if (V.isString(name) && V.isUndefined(value)) {\n            return this.node.getAttribute(attributeNames[name]);\n        }\n\n        if (typeof name === 'object') {\n\n            for (var attrName in name) {\n                if (name.hasOwnProperty(attrName)) {\n                    this.setAttribute(attrName, name[attrName]);\n                }\n            }\n\n        } else {\n\n            this.setAttribute(name, value);\n        }\n\n        return this;\n    };\n\n    VPrototype.normalizePath = function() {\n\n        var tagName = this.tagName();\n        if (tagName === 'PATH') {\n            this.attr('d', V.normalizePathData(this.attr('d')));\n        }\n\n        return this;\n    };\n\n    VPrototype.remove = function() {\n\n        if (this.node.parentNode) {\n            this.node.parentNode.removeChild(this.node);\n        }\n\n        return this;\n    };\n\n    VPrototype.empty = function() {\n\n        while (this.node.firstChild) {\n            this.node.removeChild(this.node.firstChild);\n        }\n\n        return this;\n    };\n\n    /**\n     * @private\n     * @param {object} attrs\n     * @returns {Vectorizer}\n     */\n    VPrototype.setAttributes = function(attrs) {\n\n        for (var key in attrs) {\n            if (attrs.hasOwnProperty(key)) {\n                this.setAttribute(key, attrs[key]);\n            }\n        }\n\n        return this;\n    };\n\n    VPrototype.append = function(els) {\n\n        if (!V.isArray(els)) {\n            els = [els];\n        }\n\n        for (var i = 0, len = els.length; i < len; i++) {\n            this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]\n        }\n\n        return this;\n    };\n\n    VPrototype.prepend = function(els) {\n\n        var child = this.node.firstChild;\n        return child ? V(child).before(els) : this.append(els);\n    };\n\n    VPrototype.before = function(els) {\n\n        var node = this.node;\n        var parent = node.parentNode;\n\n        if (parent) {\n\n            if (!V.isArray(els)) {\n                els = [els];\n            }\n\n            for (var i = 0, len = els.length; i < len; i++) {\n                parent.insertBefore(V.toNode(els[i]), node);\n            }\n        }\n\n        return this;\n    };\n\n    VPrototype.appendTo = function(node) {\n        V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]\n        return this;\n    };\n\n    VPrototype.svg = function() {\n\n        return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);\n    };\n\n    VPrototype.tagName = function() {\n\n        return this.node.tagName.toUpperCase();\n    };\n\n    VPrototype.defs = function() {\n        var context = this.svg() || this;\n        var defsNode = context.node.getElementsByTagName('defs')[0];\n        if (defsNode) return V(defsNode);\n        return V('defs').appendTo(context);\n    };\n\n    VPrototype.clone = function() {\n\n        var clone = V(this.node.cloneNode(true/* deep */));\n        // Note that clone inherits also ID. Therefore, we need to change it here.\n        clone.node.id = V.uniqueId();\n        return clone;\n    };\n\n    VPrototype.findOne = function(selector) {\n\n        var found = this.node.querySelector(selector);\n        return found ? V(found) : undefined;\n    };\n\n    VPrototype.find = function(selector) {\n\n        var vels = [];\n        var nodes = this.node.querySelectorAll(selector);\n\n        if (nodes) {\n\n            // Map DOM elements to `V`s.\n            for (var i = 0; i < nodes.length; i++) {\n                vels.push(V(nodes[i]));\n            }\n        }\n\n        return vels;\n    };\n\n    // Returns an array of V elements made from children of this.node.\n    VPrototype.children = function() {\n\n        var children = this.node.childNodes;\n\n        var outputArray = [];\n        for (var i = 0; i < children.length; i++) {\n            var currentChild = children[i];\n            if (currentChild.nodeType === 1) {\n                outputArray.push(V(children[i]));\n            }\n        }\n        return outputArray;\n    };\n\n    // Returns the V element from parentNode of this.node.\n    VPrototype.parent = function() {\n        return V(this.node.parentNode) || null;\n    },\n\n    // Find an index of an element inside its container.\n    VPrototype.index = function() {\n\n        var index = 0;\n        var node = this.node.previousSibling;\n\n        while (node) {\n            // nodeType 1 for ELEMENT_NODE\n            if (node.nodeType === 1) index++;\n            node = node.previousSibling;\n        }\n\n        return index;\n    };\n\n    VPrototype.findParentByClass = function(className, terminator) {\n\n        var ownerSVGElement = this.node.ownerSVGElement;\n        var node = this.node.parentNode;\n\n        while (node && node !== terminator && node !== ownerSVGElement) {\n\n            var vel = V(node);\n            if (vel.hasClass(className)) {\n                return vel;\n            }\n\n            node = node.parentNode;\n        }\n\n        return null;\n    };\n\n    // https://jsperf.com/get-common-parent\n    VPrototype.contains = function(el) {\n\n        var a = this.node;\n        var b = V.toNode(el);\n        var bup = b && b.parentNode;\n\n        return (a === bup) || !!(bup && bup.nodeType === 1 && (a.compareDocumentPosition(bup) & 16));\n    };\n\n    // Convert global point into the coordinate space of this element.\n    VPrototype.toLocalPoint = function(x, y) {\n\n        var svg = this.svg().node;\n\n        var p = svg.createSVGPoint();\n        p.x = x;\n        p.y = y;\n\n        try {\n\n            var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());\n            var globalToLocalMatrix = this.getTransformToElement(svg).inverse();\n\n        } catch (e) {\n            // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)\n            // We have to make do with the original coordianates.\n            return p;\n        }\n\n        return globalPoint.matrixTransform(globalToLocalMatrix);\n    };\n\n    VPrototype.translateCenterToPoint = function(p) {\n\n        var bbox = this.getBBox({ target: this.svg() });\n        var center = bbox.center();\n\n        this.translate(p.x - center.x, p.y - center.y);\n        return this;\n    };\n\n    // Efficiently auto-orient an element. This basically implements the orient=auto attribute\n    // of markers. The easiest way of understanding on what this does is to imagine the element is an\n    // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while\n    // being auto-oriented (properly rotated) towards the `reference` point.\n    // `target` is the element relative to which the transformations are applied. Usually a viewport.\n    VPrototype.translateAndAutoOrient = function(position, reference, target) {\n\n        position = new g.Point(position);\n        reference =  new g.Point(reference);\n        target || (target = this.svg());\n\n        // Clean-up previously set transformations except the scale. If we didn't clean up the\n        // previous transformations then they'd add up with the old ones. Scale is an exception as\n        // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the\n        // element is scaled by the factor 2, not 8.\n        var scale = this.scale();\n        this.attr('transform', '');\n        var bbox = this.getBBox({ target: target }).scale(scale.sx, scale.sy);\n\n        // 1. Translate to origin.\n        var translateToOrigin = V.createSVGTransform();\n        translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\n\n        // 2. Rotate around origin.\n        var rotateAroundOrigin = V.createSVGTransform();\n        var angle = position.angleBetween(reference, position.clone().offset(1, 0));\n        if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);\n\n        // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.\n        var translateFromOrigin = V.createSVGTransform();\n        var finalPosition = position.clone().move(reference, bbox.width / 2);\n        translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y);\n\n        // 4. Get the current transformation matrix of this node\n        var ctm = this.getTransformToElement(target);\n\n        // 5. Apply transformations and the scale\n        var transform = V.createSVGTransform();\n        transform.setMatrix(\n            translateFromOrigin.matrix.multiply(\n                rotateAroundOrigin.matrix.multiply(\n                    translateToOrigin.matrix.multiply(\n                        ctm.scale(scale.sx, scale.sy)))));\n\n        this.attr('transform', V.matrixToTransformString(transform.matrix));\n\n        return this;\n    };\n\n    VPrototype.animateAlongPath = function(attrs, path) {\n\n        path = V.toNode(path);\n\n        var id = V.ensureId(path);\n        var animateMotion = V('animateMotion', attrs);\n        var mpath = V('mpath', { 'xlink:href': '#' + id });\n\n        animateMotion.append(mpath);\n\n        this.append(animateMotion);\n        try {\n            animateMotion.node.beginElement();\n        } catch (e) {\n            // Fallback for IE 9.\n            // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present\n            if (document.documentElement.getAttribute('smiling') === 'fake') {\n                /* global getTargets:true, Animator:true, animators:true id2anim:true */\n                // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n                var animation = animateMotion.node;\n                animation.animators = [];\n\n                var animationID = animation.getAttribute('id');\n                if (animationID) id2anim[animationID] = animation;\n\n                var targets = getTargets(animation);\n                for (var i = 0, len = targets.length; i < len; i++) {\n                    var target = targets[i];\n                    var animator = new Animator(animation, target, i);\n                    animators.push(animator);\n                    animation.animators[i] = animator;\n                    animator.register();\n                }\n            }\n        }\n        return this;\n    };\n\n\n    // Split a string into an array of tokens.\n    // https://infra.spec.whatwg.org/#ascii-whitespace\n    const noHTMLWhitespaceRegex = /[^\\x20\\t\\r\\n\\f]+/g;\n    function getTokenList(str) {\n        if (!V.isString(str)) return [];\n        return str.trim().match(noHTMLWhitespaceRegex) || [];\n    }\n\n    VPrototype.hasClass = function(className) {\n        if (!V.isString(className)) return false;\n        return this.node.classList.contains(className.trim());\n    };\n\n    VPrototype.addClass = function(className) {\n        this.node.classList.add(...getTokenList(className));\n        return this;\n    };\n\n    VPrototype.removeClass = function(className) {\n        this.node.classList.remove(...getTokenList(className));\n        return this;\n    };\n\n    VPrototype.toggleClass = function(className, toAdd) {\n        const tokens = getTokenList(className);\n        for (let i = 0; i < tokens.length; i++) {\n            this.node.classList.toggle(tokens[i], toAdd);\n        }\n        return this;\n    };\n\n    // Interpolate path by discrete points. The precision of the sampling\n    // is controlled by `interval`. In other words, `sample()` will generate\n    // a point on the path starting at the beginning of the path going to the end\n    // every `interval` pixels.\n    // The sampler can be very useful for e.g. finding intersection between two\n    // paths (finding the two closest points from two samples).\n    VPrototype.sample = function(interval) {\n\n        interval = interval || 1;\n        var node = this.node;\n        var length = node.getTotalLength();\n        var samples = [];\n        var distance = 0;\n        var sample;\n        while (distance < length) {\n            sample = node.getPointAtLength(distance);\n            samples.push({ x: sample.x, y: sample.y, distance: distance });\n            distance += interval;\n        }\n        return samples;\n    };\n\n    VPrototype.convertToPath = function() {\n\n        var path = V('path');\n        path.attr(this.attr());\n        var d = this.convertToPathData();\n        if (d) {\n            path.attr('d', d);\n        }\n        return path;\n    };\n\n    VPrototype.convertToPathData = function() {\n\n        var tagName = this.tagName();\n\n        switch (tagName) {\n            case 'PATH':\n                return this.attr('d');\n            case 'LINE':\n                return V.convertLineToPathData(this.node);\n            case 'POLYGON':\n                return V.convertPolygonToPathData(this.node);\n            case 'POLYLINE':\n                return V.convertPolylineToPathData(this.node);\n            case 'ELLIPSE':\n                return V.convertEllipseToPathData(this.node);\n            case 'CIRCLE':\n                return V.convertCircleToPathData(this.node);\n            case 'RECT':\n                return V.convertRectToPathData(this.node);\n        }\n\n        throw new Error(tagName + ' cannot be converted to PATH.');\n    };\n\n    V.prototype.toGeometryShape = function() {\n        var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;\n        switch (this.tagName()) {\n\n            case 'RECT':\n                x = parseFloat(this.attr('x')) || 0;\n                y = parseFloat(this.attr('y')) || 0;\n                width = parseFloat(this.attr('width')) || 0;\n                height = parseFloat(this.attr('height')) || 0;\n                return new g.Rect(x, y, width, height);\n\n            case 'CIRCLE':\n                cx = parseFloat(this.attr('cx')) || 0;\n                cy = parseFloat(this.attr('cy')) || 0;\n                r = parseFloat(this.attr('r')) || 0;\n                return new g.Ellipse({ x: cx, y: cy }, r, r);\n\n            case 'ELLIPSE':\n                cx = parseFloat(this.attr('cx')) || 0;\n                cy = parseFloat(this.attr('cy')) || 0;\n                rx = parseFloat(this.attr('rx')) || 0;\n                ry = parseFloat(this.attr('ry')) || 0;\n                return new g.Ellipse({ x: cx, y: cy }, rx, ry);\n\n            case 'POLYLINE':\n                points = V.getPointsFromSvgNode(this);\n                return new g.Polyline(points);\n\n            case 'POLYGON':\n                points = V.getPointsFromSvgNode(this);\n                if (points.length > 1) points.push(points[0]);\n                return new g.Polyline(points);\n\n            case 'PATH':\n                d = this.attr('d');\n                if (!g.Path.isDataSupported(d)) d = V.normalizePathData(d);\n                return new g.Path(d);\n\n            case 'LINE':\n                x1 = parseFloat(this.attr('x1')) || 0;\n                y1 = parseFloat(this.attr('y1')) || 0;\n                x2 = parseFloat(this.attr('x2')) || 0;\n                y2 = parseFloat(this.attr('y2')) || 0;\n                return new g.Line({ x: x1, y: y1 }, { x: x2, y: y2 });\n        }\n\n        // Anything else is a rectangle\n        return this.getBBox();\n    };\n\n    // Find the intersection of a line starting in the center\n    // of the SVG `node` ending in the point `ref`.\n    // `target` is an SVG element to which `node`s transformations are relative to.\n    // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.\n    // Returns a point in the `target` coordinate system (the same system as `ref` is in) if\n    // an intersection is found. Returns `undefined` otherwise.\n    VPrototype.findIntersection = function(ref, target) {\n\n        var svg = this.svg().node;\n        target = target || svg;\n        var bbox = this.getBBox({ target: target });\n        var center = bbox.center();\n\n        if (!bbox.intersectionWithLineFromCenterToPoint(ref)) return undefined;\n\n        var spot;\n        var tagName = this.tagName();\n\n        // Little speed up optimization for `<rect>` element. We do not do conversion\n        // to path element and sampling but directly calculate the intersection through\n        // a transformed geometrical rectangle.\n        if (tagName === 'RECT') {\n\n            var gRect = new g.Rect(\n                parseFloat(this.attr('x') || 0),\n                parseFloat(this.attr('y') || 0),\n                parseFloat(this.attr('width')),\n                parseFloat(this.attr('height'))\n            );\n            // Get the rect transformation matrix with regards to the SVG document.\n            var rectMatrix = this.getTransformToElement(target);\n            // Decompose the matrix to find the rotation angle.\n            var rectMatrixComponents = V.decomposeMatrix(rectMatrix);\n            // Now we want to rotate the rectangle back so that we\n            // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.\n            var resetRotation = svg.createSVGTransform();\n            resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n            var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));\n            spot = (new g.Rect(rect)).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n\n        } else if (tagName === 'PATH' || tagName === 'POLYGON' || tagName === 'POLYLINE' || tagName === 'CIRCLE' || tagName === 'ELLIPSE') {\n\n            var pathNode = (tagName === 'PATH') ? this : this.convertToPath();\n            var samples = pathNode.sample();\n            var minDistance = Infinity;\n            var closestSamples = [];\n\n            var i, sample, gp, centerDistance, refDistance, distance;\n\n            for (i = 0; i < samples.length; i++) {\n\n                sample = samples[i];\n                // Convert the sample point in the local coordinate system to the global coordinate system.\n                gp = V.createSVGPoint(sample.x, sample.y);\n                gp = gp.matrixTransform(this.getTransformToElement(target));\n                sample = new g.Point(gp);\n                centerDistance = sample.distance(center);\n                // Penalize a higher distance to the reference point by 10%.\n                // This gives better results. This is due to\n                // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n                refDistance = sample.distance(ref) * 1.1;\n                distance = centerDistance + refDistance;\n\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    closestSamples = [{ sample: sample, refDistance: refDistance }];\n                } else if (distance < minDistance + 1) {\n                    closestSamples.push({ sample: sample, refDistance: refDistance });\n                }\n            }\n\n            closestSamples.sort(function(a, b) {\n                return a.refDistance - b.refDistance;\n            });\n\n            if (closestSamples[0]) {\n                spot = closestSamples[0].sample;\n            }\n        }\n\n        return spot;\n    };\n\n    /**\n     * @private\n     * @param {string} name\n     * @param {string} value\n     * @returns {Vectorizer}\n     */\n    VPrototype.setAttribute = function(name, value) {\n\n        const el = this.node;\n\n        if (value === null) {\n            this.removeAttr(name);\n            return this;\n        }\n\n        const trueName = attributeNames[name];\n\n        const { ns } = V.qualifyAttr(trueName);\n        if (ns) {\n            // Attribute names can be namespaced. E.g. `image` elements\n            // have a `xlink:href` attribute to set the source of the image.\n            el.setAttributeNS(ns, trueName, value);\n        } else if (trueName === 'id') {\n            el.id = value;\n        } else {\n            el.setAttribute(trueName, value);\n        }\n\n        return this;\n    };\n\n    // Create an SVG document element.\n    // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.\n    V.createSvgDocument = function(content) {\n\n        if (content) {\n            const XMLString = `<svg xmlns=\"${ns.svg}\" xmlns:xlink=\"${ns.xlink}\" version=\"${SVGVersion}\">${content}</svg>`;\n            const { documentElement } = V.parseXML(XMLString, { async: false });\n            return documentElement;\n        }\n\n        const svg = document.createElementNS(ns.svg, 'svg');\n        svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);\n        svg.setAttribute('version', SVGVersion);\n        return svg;\n    };\n\n    V.createSVGStyle = function(stylesheet) {\n        const { node } = V('style', { type: 'text/css' }, [\n            V.createCDATASection(stylesheet)\n        ]);\n        return node;\n    },\n\n    V.createCDATASection = function(data = '') {\n        const xml = document.implementation.createDocument(null, 'xml', null);\n        return xml.createCDATASection(data);\n    };\n\n    V.idCounter = 0;\n\n    // A function returning a unique identifier for this client session with every call.\n    V.uniqueId = function() {\n\n        return 'v-' + (++V.idCounter);\n    };\n\n    V.toNode = function(el) {\n\n        return V.isV(el) ? el.node : (el.nodeName && el || el[0]);\n    };\n\n    V.ensureId = function(node) {\n\n        node = V.toNode(node);\n        return node.id || (node.id = V.uniqueId());\n    };\n\n    // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n    // IE would otherwise collapse all spaces into one. This is used in the text() method but it is\n    // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests\n    // when you want to compare the actual DOM text content without having to add the unicode character in\n    // the place of all spaces.\n    V.sanitizeText = function(text) {\n\n        return (text || '').replace(/ /g, '\\u00A0');\n    };\n\n    V.isUndefined = function(value) {\n\n        return typeof value === 'undefined';\n    };\n\n    V.isString = function(value) {\n\n        return typeof value === 'string';\n    };\n\n    V.isObject = function(value) {\n\n        return value && (typeof value === 'object');\n    };\n\n    V.isArray = Array.isArray;\n\n    V.parseXML = function(data, opt) {\n\n        opt = opt || {};\n\n        var xml;\n\n        try {\n            var parser = new DOMParser();\n\n            if (!V.isUndefined(opt.async)) {\n                parser.async = opt.async;\n            }\n\n            xml = parser.parseFromString(data, 'text/xml');\n        } catch (error) {\n            xml = undefined;\n        }\n\n        if (!xml || xml.getElementsByTagName('parsererror').length) {\n            throw new Error('Invalid XML: ' + data);\n        }\n\n        return xml;\n    };\n\n    // Create an empty object which does not inherit any properties from `Object.prototype`.\n    // This is useful when we want to use an object as a dictionary without having to\n    // worry about inherited properties such as `toString`, `valueOf` etc.\n    const _attributeNames = Object.create(null);\n\n    // List of attributes for which not to split camel case words.\n    // It contains known SVG attribute names and may be extended with user-defined attribute names.\n    [\n        'baseFrequency',\n        'baseProfile',\n        'clipPathUnits',\n        'contentScriptType',\n        'contentStyleType',\n        'diffuseConstant',\n        'edgeMode',\n        'externalResourcesRequired',\n        'filterRes', // deprecated\n        'filterUnits',\n        'gradientTransform',\n        'gradientUnits',\n        'kernelMatrix',\n        'kernelUnitLength',\n        'keyPoints',\n        'lengthAdjust',\n        'limitingConeAngle',\n        'markerHeight',\n        'markerUnits',\n        'markerWidth',\n        'maskContentUnits',\n        'maskUnits',\n        'numOctaves',\n        'pathLength',\n        'patternContentUnits',\n        'patternTransform',\n        'patternUnits',\n        'pointsAtX',\n        'pointsAtY',\n        'pointsAtZ',\n        'preserveAlpha',\n        'preserveAspectRatio',\n        'primitiveUnits',\n        'refX',\n        'refY',\n        'requiredExtensions',\n        'requiredFeatures',\n        'specularConstant',\n        'specularExponent',\n        'spreadMethod',\n        'startOffset',\n        'stdDeviation',\n        'stitchTiles',\n        'surfaceScale',\n        'systemLanguage',\n        'tableValues',\n        'targetX',\n        'targetY',\n        'textLength',\n        'viewBox',\n        'viewTarget', // deprecated\n        'xChannelSelector',\n        'yChannelSelector',\n        'zoomAndPan' // deprecated\n    ].forEach((name) => _attributeNames[name] = name);\n\n    _attributeNames['xlinkShow'] = 'xlink:show';\n    _attributeNames['xlinkRole'] = 'xlink:role';\n    _attributeNames['xlinkActuate'] = 'xlink:actuate';\n    _attributeNames['xlinkHref'] = 'xlink:href';\n    _attributeNames['xlinkType'] = 'xlink:type';\n    _attributeNames['xlinkTitle'] = 'xlink:title';\n    _attributeNames['xmlBase'] = 'xml:base';\n    _attributeNames['xmlLang'] = 'xml:lang';\n    _attributeNames['xmlSpace'] = 'xml:space';\n\n    const attributeNames = new Proxy(_attributeNames, {\n        get(cache, name) {\n            // The cache is a dictionary of attribute names. See `_attributeNames` above.\n            // If the attribute name is not in the cache, it means that it is not\n            // a camel-case attribute name. In that case, we need to convert\n            // the attribute name to dash-separated words.\n            if (!V.supportCamelCaseAttributes) return name;\n            if (name in cache) {\n                return cache[name];\n            }\n            // Convert camel case to dash-separated words.\n            return (cache[name] = name.replace(/[A-Z]/g, '-$&').toLowerCase());\n        }\n    });\n\n    // Dictionary of attribute names\n    Object.defineProperty(V, 'attributeNames', {\n        enumerable: true,\n        value: attributeNames,\n        writable: false,\n    });\n\n    // Should camel case attributes be supported?\n    Object.defineProperty(V, 'supportCamelCaseAttributes', {\n        enumerable: true,\n        value: true,\n        writable: true,\n    });\n\n    /**\n     * @param {string} name\n     * @returns {{ns: string|null, local: string}} namespace and attribute name\n     */\n    V.qualifyAttr = function(name) {\n\n        if (name.indexOf(':') !== -1) {\n            var combinedKey = name.split(':');\n            return {\n                ns: ns[combinedKey[0]],\n                local: combinedKey[1]\n            };\n        }\n\n        return {\n            ns: null,\n            local: name\n        };\n    };\n\n    // Note: This regex allows multiple commas as separator which is incorrect in SVG\n    // This regex is used by `split()`, so it doesn't need to use /g\n    V.transformSeparatorRegex = /[ ,]+/;\n    // Note: All following regexes are more restrictive than SVG specification\n    // ReDoS mitigation: Use an anchor at the beginning of the match\n    // ReDoS mitigation: Avoid backtracking (uses `[^()]+` instead of `.*?`)\n    // ReDoS mitigation: Don't match initial `(` inside repeated part\n    // The following regex needs to use /g (= cannot use capturing groups)\n    V.transformRegex = /\\b\\w+\\([^()]+\\)/g;\n    // The following regexes need to use capturing groups (= cannot use /g)\n    V.transformFunctionRegex = /\\b(\\w+)\\(([^()]+)\\)/;\n    V.transformTranslateRegex = /\\btranslate\\(([^()]+)\\)/;\n    V.transformRotateRegex = /\\brotate\\(([^()]+)\\)/;\n    V.transformScaleRegex = /\\bscale\\(([^()]+)\\)/;\n\n    V.transformStringToMatrix = function(transform) {\n\n        // Initialize result matrix as identity matrix\n        let transformationMatrix = V.createSVGMatrix();\n\n        // Note: Multiple transform functions are allowed in `transform` string\n        // `match()` returns `null` if none found\n        const transformMatches = transform && transform.match(V.transformRegex);\n        if (!transformMatches) {\n            // Return identity matrix\n            return transformationMatrix;\n        }\n\n        const numMatches = transformMatches.length;\n        for (let i = 0; i < numMatches; i++) {\n\n            const transformMatch = transformMatches[i];\n            // Use same regex as above, but with capturing groups\n            // `match()` returns values of capturing groups as `[1]`, `[2]`\n            const transformFunctionMatch = transformMatch.match(V.transformFunctionRegex);\n            if (transformFunctionMatch) {\n\n                let sx, sy, tx, ty, angle;\n                let ctm = V.createSVGMatrix();\n                const transformFunction = transformFunctionMatch[1].toLowerCase();\n                const args = transformFunctionMatch[2].split(V.transformSeparatorRegex);\n                switch (transformFunction) {\n\n                    case 'scale':\n                        sx = parseFloat(args[0]);\n                        sy = (args[1] === undefined) ? sx : parseFloat(args[1]);\n                        ctm = ctm.scaleNonUniform(sx, sy);\n                        break;\n\n                    case 'translate':\n                        tx = parseFloat(args[0]);\n                        ty = parseFloat(args[1]);\n                        ctm = ctm.translate(tx, ty);\n                        break;\n\n                    case 'rotate':\n                        angle = parseFloat(args[0]);\n                        tx = parseFloat(args[1]) || 0;\n                        ty = parseFloat(args[2]) || 0;\n                        if (tx !== 0 || ty !== 0) {\n                            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\n                        } else {\n                            ctm = ctm.rotate(angle);\n                        }\n                        break;\n\n                    case 'skewx':\n                        angle = parseFloat(args[0]);\n                        ctm = ctm.skewX(angle);\n                        break;\n\n                    case 'skewy':\n                        angle = parseFloat(args[0]);\n                        ctm = ctm.skewY(angle);\n                        break;\n\n                    case 'matrix':\n                        ctm.a = parseFloat(args[0]);\n                        ctm.b = parseFloat(args[1]);\n                        ctm.c = parseFloat(args[2]);\n                        ctm.d = parseFloat(args[3]);\n                        ctm.e = parseFloat(args[4]);\n                        ctm.f = parseFloat(args[5]);\n                        break;\n\n                    default:\n                        continue;\n                }\n\n                // Multiply current transformation into result matrix\n                transformationMatrix = transformationMatrix.multiply(ctm);\n            }\n\n        }\n        return transformationMatrix;\n    };\n\n    V.matrixToTransformString = function(matrix) {\n        matrix || (matrix = true);\n\n        return 'matrix(' +\n            (matrix.a !== undefined ? matrix.a : 1) + ',' +\n            (matrix.b !== undefined ? matrix.b : 0) + ',' +\n            (matrix.c !== undefined ? matrix.c : 0) + ',' +\n            (matrix.d !== undefined ? matrix.d : 1) + ',' +\n            (matrix.e !== undefined ? matrix.e : 0) + ',' +\n            (matrix.f !== undefined ? matrix.f : 0) +\n            ')';\n    };\n\n    V.parseTransformString = function(transform) {\n\n        var translate, rotate, scale;\n\n        if (transform) {\n\n            var separator = V.transformSeparatorRegex;\n\n            // Special handling for `transform` with one or more matrix functions\n            if (transform.trim().indexOf('matrix') >= 0) {\n\n                // Convert EVERYTHING in `transform` string to a matrix\n                // Will combine ALL matrixes * ALL translates * ALL scales * ALL rotates\n                // Note: In non-matrix case, we only take first one of each (if any)\n                var matrix = V.transformStringToMatrix(transform);\n                var decomposedMatrix = V.decomposeMatrix(matrix);\n\n                // Extract `translate`, `scale`, `rotate` from matrix\n                translate = [decomposedMatrix.translateX, decomposedMatrix.translateY];\n                scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\n                rotate = [decomposedMatrix.rotation];\n\n                // Rewrite `transform` string in `translate scale rotate` format\n                var transformations = [];\n                if (translate[0] !== 0 || translate[1] !== 0) {\n                    transformations.push('translate(' + translate + ')');\n                }\n                if (scale[0] !== 1 || scale[1] !== 1) {\n                    transformations.push('scale(' + scale + ')');\n                }\n                if (rotate[0] !== 0) {\n                    transformations.push('rotate(' + rotate + ')');\n                }\n                transform = transformations.join(' ');\n\n            } else {\n\n                // Extract `translate`, `rotate`, `scale` functions from `transform` string\n                // Note: We only detect the first match of each (if any)\n                // `match()` returns value of capturing group as `[1]`\n                const translateMatch = transform.match(V.transformTranslateRegex);\n                if (translateMatch) {\n                    translate = translateMatch[1].split(separator);\n                }\n                const rotateMatch = transform.match(V.transformRotateRegex);\n                if (rotateMatch) {\n                    rotate = rotateMatch[1].split(separator);\n                }\n                const scaleMatch = transform.match(V.transformScaleRegex);\n                if (scaleMatch) {\n                    scale = scaleMatch[1].split(separator);\n                }\n            }\n        }\n\n        var sx = (scale && scale[0]) ? parseFloat(scale[0]) : 1;\n\n        return {\n            value: transform,\n            translate: {\n                tx: (translate && translate[0]) ? parseInt(translate[0], 10) : 0,\n                ty: (translate && translate[1]) ? parseInt(translate[1], 10) : 0\n            },\n            rotate: {\n                angle: (rotate && rotate[0]) ? parseInt(rotate[0], 10) : 0,\n                cx: (rotate && rotate[1]) ? parseInt(rotate[1], 10) : undefined,\n                cy: (rotate && rotate[2]) ? parseInt(rotate[2], 10) : undefined\n            },\n            scale: {\n                sx: sx,\n                sy: (scale && scale[1]) ? parseFloat(scale[1]) : sx\n            }\n        };\n    };\n\n    V.deltaTransformPoint = function(matrix, point) {\n\n        var dx = point.x * matrix.a + point.y * matrix.c + 0;\n        var dy = point.x * matrix.b + point.y * matrix.d + 0;\n        return { x: dx, y: dy };\n    };\n\n    V.decomposeMatrix = function(matrix) {\n\n        // @see https://gist.github.com/2052247\n\n        // calculate delta transform point\n        var px = V.deltaTransformPoint(matrix, { x: 0, y: 1 });\n        var py = V.deltaTransformPoint(matrix, { x: 1, y: 0 });\n\n        // calculate skew\n        var skewX = ((180 / PI) * atan2(px.y, px.x) - 90);\n        var skewY = ((180 / PI) * atan2(py.y, py.x));\n\n        return {\n\n            translateX: matrix.e,\n            translateY: matrix.f,\n            scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n            scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n            skewX: skewX,\n            skewY: skewY,\n            rotation: skewX // rotation is the same as skew x\n        };\n    };\n\n    // Return the `scale` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToScale = function(matrix) {\n\n        var a, b, c, d;\n        if (matrix) {\n            a = V.isUndefined(matrix.a) ? 1 : matrix.a;\n            d = V.isUndefined(matrix.d) ? 1 : matrix.d;\n            b = matrix.b;\n            c = matrix.c;\n        } else {\n            a = d = 1;\n        }\n        return {\n            sx: b ? sqrt(a * a + b * b) : a,\n            sy: c ? sqrt(c * c + d * d) : d\n        };\n    };\n\n    // Return the `rotate` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToRotate = function(matrix) {\n\n        var p = { x: 0, y: 1 };\n        if (matrix) {\n            p = V.deltaTransformPoint(matrix, p);\n        }\n\n        return {\n            angle: g.normalizeAngle(g.toDeg(atan2(p.y, p.x)) - 90)\n        };\n    };\n\n    // Return the `translate` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToTranslate = function(matrix) {\n\n        return {\n            tx: (matrix && matrix.e) || 0,\n            ty: (matrix && matrix.f) || 0\n        };\n    };\n\n    V.isV = function(object) {\n\n        return object instanceof V;\n    };\n\n    // For backwards compatibility:\n    V.isVElement = V.isV;\n\n    // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`\n    // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n    V.isSVGGraphicsElement = function(node) {\n        if (!node) return false;\n        node = V.toNode(node);\n        // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below\n        return node instanceof SVGElement && typeof node.getScreenCTM === 'function';\n    };\n\n    var svgDocument = V('svg').node;\n\n    V.createSVGMatrix = function(matrix) {\n\n        var svgMatrix = svgDocument.createSVGMatrix();\n        for (var component in matrix) {\n            svgMatrix[component] = matrix[component];\n        }\n\n        return svgMatrix;\n    };\n\n    V.createSVGTransform = function(matrix) {\n\n        if (!V.isUndefined(matrix)) {\n\n            if (!(matrix instanceof SVGMatrix)) {\n                matrix = V.createSVGMatrix(matrix);\n            }\n\n            return svgDocument.createSVGTransformFromMatrix(matrix);\n        }\n\n        return svgDocument.createSVGTransform();\n    };\n\n    V.createSVGPoint = function(x, y) {\n\n        var p = svgDocument.createSVGPoint();\n        p.x = x;\n        p.y = y;\n        return p;\n    };\n\n    V.transformRect = function(r, matrix) {\n\n        var p = svgDocument.createSVGPoint();\n\n        p.x = r.x;\n        p.y = r.y;\n        var corner1 = p.matrixTransform(matrix);\n\n        p.x = r.x + r.width;\n        p.y = r.y;\n        var corner2 = p.matrixTransform(matrix);\n\n        p.x = r.x + r.width;\n        p.y = r.y + r.height;\n        var corner3 = p.matrixTransform(matrix);\n\n        p.x = r.x;\n        p.y = r.y + r.height;\n        var corner4 = p.matrixTransform(matrix);\n\n        var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);\n        var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);\n        var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);\n        var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);\n\n        return new g.Rect(minX, minY, maxX - minX, maxY - minY);\n    };\n\n    V.transformPoint = function(p, matrix) {\n\n        return new g.Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));\n    };\n\n    V.transformLine = function(l, matrix) {\n\n        return new g.Line(\n            V.transformPoint(l.start, matrix),\n            V.transformPoint(l.end, matrix)\n        );\n    };\n\n    V.transformPolyline = function(p, matrix) {\n\n        var inPoints = (p instanceof g.Polyline) ? p.points : p;\n        if (!V.isArray(inPoints)) inPoints = [];\n        var outPoints = [];\n        for (var i = 0, n = inPoints.length; i < n; i++) outPoints[i] = V.transformPoint(inPoints[i], matrix);\n        return new g.Polyline(outPoints);\n    };\n\n    // Convert a style represented as string (e.g. `'fill=\"blue\"; stroke=\"red\"'`) to\n    // an object (`{ fill: 'blue', stroke: 'red' }`).\n    V.styleToObject = function(styleString) {\n        var ret = {};\n        var styles = styleString.split(';');\n        for (var i = 0; i < styles.length; i++) {\n            var style = styles[i];\n            var pair = style.split('=');\n            ret[pair[0].trim()] = pair[1].trim();\n        }\n        return ret;\n    };\n\n    // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\n    V.createSlicePathData = function(innerRadius, outerRadius, startAngle, endAngle) {\n\n        var svgArcMax = 2 * PI - 1e-6;\n        var r0 = innerRadius;\n        var r1 = outerRadius;\n        var a0 = startAngle;\n        var a1 = endAngle;\n        var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);\n        var df = da < PI ? '0' : '1';\n        var c0 = cos(a0);\n        var s0 = sin(a0);\n        var c1 = cos(a1);\n        var s1 = sin(a1);\n\n        return (da >= svgArcMax)\n            ? (r0\n                ? 'M0,' + r1\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\n                + 'M0,' + r0\n                + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + (-r0)\n                + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + r0\n                + 'Z'\n                : 'M0,' + r1\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\n                + 'Z')\n            : (r0\n                ? 'M' + r1 * c0 + ',' + r1 * s0\n                + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\n                + 'L' + r0 * c1 + ',' + r0 * s1\n                + 'A' + r0 + ',' + r0 + ' 0 ' + df + ',0 ' + r0 * c0 + ',' + r0 * s0\n                + 'Z'\n                : 'M' + r1 * c0 + ',' + r1 * s0\n                + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\n                + 'L0,0'\n                + 'Z');\n    };\n\n    // Merge attributes from object `b` with attributes in object `a`.\n    // Note that this modifies the object `a`.\n    // Also important to note that attributes are merged but CSS classes are concatenated.\n    V.mergeAttrs = function(a, b) {\n\n        for (var attr in b) {\n\n            if (attr === 'class') {\n                // Concatenate classes.\n                a[attr] = a[attr] ? a[attr] + ' ' + b[attr] : b[attr];\n            } else if (attr === 'style') {\n                // `style` attribute can be an object.\n                if (V.isObject(a[attr]) && V.isObject(b[attr])) {\n                    // `style` stored in `a` is an object.\n                    a[attr] = V.mergeAttrs(a[attr], b[attr]);\n                } else if (V.isObject(a[attr])) {\n                    // `style` in `a` is an object but it's a string in `b`.\n                    // Convert the style represented as a string to an object in `b`.\n                    a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));\n                } else if (V.isObject(b[attr])) {\n                    // `style` in `a` is a string, in `b` it's an object.\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);\n                } else {\n                    // Both styles are strings.\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));\n                }\n            } else {\n                a[attr] = b[attr];\n            }\n        }\n\n        return a;\n    };\n\n    V.annotateString = function(t, annotations, opt) {\n\n        annotations = annotations || [];\n        opt = opt || {};\n\n        var offset = opt.offset || 0;\n        var compacted = [];\n        var batch;\n        var ret = [];\n        var item;\n        var prev;\n\n        for (var i = 0; i < t.length; i++) {\n\n            item = ret[i] = t[i];\n\n            for (var j = 0; j < annotations.length; j++) {\n\n                var annotation = annotations[j];\n                var start = annotation.start + offset;\n                var end = annotation.end + offset;\n\n                if (i >= start && i < end) {\n                    // Annotation applies.\n                    if (V.isObject(item)) {\n                        // There is more than one annotation to be applied => Merge attributes.\n                        item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);\n                    } else {\n                        item = ret[i] = { t: t[i], attrs: annotation.attrs };\n                    }\n                    if (opt.includeAnnotationIndices) {\n                        (item.annotations || (item.annotations = [])).push(j);\n                    }\n                }\n            }\n\n            prev = ret[i - 1];\n\n            if (!prev) {\n\n                batch = item;\n\n            } else if (V.isObject(item) && V.isObject(prev)) {\n                // Both previous item and the current one are annotations. If the attributes\n                // didn't change, merge the text.\n                if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {\n                    batch.t += item.t;\n                } else {\n                    compacted.push(batch);\n                    batch = item;\n                }\n\n            } else if (V.isObject(item)) {\n                // Previous item was a string, current item is an annotation.\n                compacted.push(batch);\n                batch = item;\n\n            } else if (V.isObject(prev)) {\n                // Previous item was an annotation, current item is a string.\n                compacted.push(batch);\n                batch = item;\n\n            } else {\n                // Both previous and current item are strings.\n                batch = (batch || '') + item;\n            }\n        }\n\n        if (batch) {\n            compacted.push(batch);\n        }\n\n        return compacted;\n    };\n\n    V.findAnnotationsAtIndex = function(annotations, index) {\n\n        var found = [];\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if (annotation.start < index && index <= annotation.end) {\n                    found.push(annotation);\n                }\n            });\n        }\n\n        return found;\n    };\n\n    V.findAnnotationsBetweenIndexes = function(annotations, start, end) {\n\n        var found = [];\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if ((start >= annotation.start && start < annotation.end) || (end > annotation.start && end <= annotation.end) || (annotation.start >= start && annotation.end < end)) {\n                    found.push(annotation);\n                }\n            });\n        }\n\n        return found;\n    };\n\n    // Shift all the text annotations after character `index` by `offset` positions.\n    V.shiftAnnotations = function(annotations, index, offset) {\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if (annotation.start < index && annotation.end >= index) {\n                    annotation.end += offset;\n                } else if (annotation.start >= index) {\n                    annotation.start += offset;\n                    annotation.end += offset;\n                }\n            });\n        }\n\n        return annotations;\n    };\n\n    V.convertLineToPathData = function(line) {\n\n        line = V(line);\n        var d = [\n            'M', line.attr('x1'), line.attr('y1'),\n            'L', line.attr('x2'), line.attr('y2')\n        ].join(' ');\n        return d;\n    };\n\n    V.convertPolygonToPathData = function(polygon) {\n\n        var points = V.getPointsFromSvgNode(polygon);\n        if (points.length === 0) return null;\n\n        return V.svgPointsToPath(points) + ' Z';\n    };\n\n    V.convertPolylineToPathData = function(polyline) {\n\n        var points = V.getPointsFromSvgNode(polyline);\n        if (points.length === 0) return null;\n\n        return V.svgPointsToPath(points);\n    };\n\n    V.svgPointsToPath = function(points) {\n\n        for (var i = 0, n = points.length; i < n; i++) {\n            points[i] = points[i].x + ' ' + points[i].y;\n        }\n\n        return 'M ' + points.join(' L');\n    };\n\n    V.getPointsFromSvgNode = function(node) {\n\n        node = V.toNode(node);\n        var points = [];\n        var nodePoints = node.points;\n        if (nodePoints) {\n            for (var i = 0, n = nodePoints.numberOfItems; i < n; i++) {\n                points.push(nodePoints.getItem(i));\n            }\n        }\n\n        return points;\n    };\n\n    V.KAPPA = 0.551784;\n\n    V.convertCircleToPathData = function(circle) {\n\n        circle = V(circle);\n        var cx = parseFloat(circle.attr('cx')) || 0;\n        var cy = parseFloat(circle.attr('cy')) || 0;\n        var r = parseFloat(circle.attr('r'));\n        var cd = r * V.KAPPA; // Control distance.\n\n        var d = [\n            'M', cx, cy - r,    // Move to the first point.\n            'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy, // I. Quadrant.\n            'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r, // II. Quadrant.\n            'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy, // III. Quadrant.\n            'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r, // IV. Quadrant.\n            'Z'\n        ].join(' ');\n        return d;\n    };\n\n    V.convertEllipseToPathData = function(ellipse) {\n\n        ellipse = V(ellipse);\n        var cx = parseFloat(ellipse.attr('cx')) || 0;\n        var cy = parseFloat(ellipse.attr('cy')) || 0;\n        var rx = parseFloat(ellipse.attr('rx'));\n        var ry = parseFloat(ellipse.attr('ry')) || rx;\n        var cdx = rx * V.KAPPA; // Control distance x.\n        var cdy = ry * V.KAPPA; // Control distance y.\n\n        var d = [\n            'M', cx, cy - ry,    // Move to the first point.\n            'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy, // I. Quadrant.\n            'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry, // II. Quadrant.\n            'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy, // III. Quadrant.\n            'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry, // IV. Quadrant.\n            'Z'\n        ].join(' ');\n        return d;\n    };\n\n    V.convertRectToPathData = function(rect) {\n\n        rect = V(rect);\n\n        return V.rectToPath({\n            x: parseFloat(rect.attr('x')) || 0,\n            y: parseFloat(rect.attr('y')) || 0,\n            width: parseFloat(rect.attr('width')) || 0,\n            height: parseFloat(rect.attr('height')) || 0,\n            rx: parseFloat(rect.attr('rx')) || 0,\n            ry: parseFloat(rect.attr('ry')) || 0\n        });\n    };\n\n    // Convert a rectangle to SVG path commands. `r` is an object of the form:\n    // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,\n    // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for\n    // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle\n    // that has only `rx` and `ry` attributes).\n    V.rectToPath = function(r) {\n\n        var d;\n        var x = r.x;\n        var y = r.y;\n        var width = r.width;\n        var height = r.height;\n        var topRx = min(r.rx || r['top-rx'] || 0, width / 2);\n        var bottomRx = min(r.rx || r['bottom-rx'] || 0, width / 2);\n        var topRy = min(r.ry || r['top-ry'] || 0, height / 2);\n        var bottomRy = min(r.ry || r['bottom-ry'] || 0, height / 2);\n\n        if (topRx || bottomRx || topRy || bottomRy) {\n            d = [\n                'M', x, y + topRy,\n                'v', height - topRy - bottomRy,\n                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy,\n                'h', width - 2 * bottomRx,\n                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy,\n                'v', -(height - bottomRy - topRy),\n                'a', topRx, topRy, 0, 0, 0, -topRx, -topRy,\n                'h', -(width - 2 * topRx),\n                'a', topRx, topRy, 0, 0, 0, -topRx, topRy,\n                'Z'\n            ];\n        } else {\n            d = [\n                'M', x, y,\n                'H', x + width,\n                'V', y + height,\n                'H', x,\n                'V', y,\n                'Z'\n            ];\n        }\n\n        return d.join(' ');\n    };\n\n    // Take a path data string\n    // Return a normalized path data string\n    // If data cannot be parsed, return 'M 0 0'\n    // Highly inspired by Raphael Library (www.raphael.com)\n    V.normalizePathData = (function() {\n\n        var spaces = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\n        var pathCommand = new RegExp('([a-z])[' + spaces + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + spaces + ']*,?[' + spaces + ']*)+)', 'ig');\n        var pathValues = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + spaces + ']*,?[' + spaces + ']*', 'ig');\n\n        var math = Math;\n        var PI = math.PI;\n        var sin = math.sin;\n        var cos = math.cos;\n        var tan = math.tan;\n        var asin = math.asin;\n        var sqrt = math.sqrt;\n        var abs = math.abs;\n\n        function q2c(x1, y1, ax, ay, x2, y2) {\n\n            var _13 = 1 / 3;\n            var _23 = 2 / 3;\n            return [(_13 * x1) + (_23 * ax), (_13 * y1) + (_23 * ay), (_13 * x2) + (_23 * ax), (_13 * y2) + (_23 * ay), x2, y2];\n        }\n\n        function rotate(x, y, rad) {\n\n            var X = (x * cos(rad)) - (y * sin(rad));\n            var Y = (x * sin(rad)) + (y * cos(rad));\n            return { x: X, y: Y };\n        }\n\n        function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n            // for more information of where this math came from visit:\n            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n            var _120 = (PI * 120) / 180;\n            var rad = (PI / 180) * (+angle || 0);\n            var res = [];\n            var xy;\n\n            if (!recursive) {\n                xy = rotate(x1, y1, -rad);\n                x1 = xy.x;\n                y1 = xy.y;\n\n                xy = rotate(x2, y2, -rad);\n                x2 = xy.x;\n                y2 = xy.y;\n\n                var x = (x1 - x2) / 2;\n                var y = (y1 - y2) / 2;\n                var h = ((x * x) / (rx * rx)) + ((y * y) / (ry * ry));\n\n                if (h > 1) {\n                    h = sqrt(h);\n                    rx = h * rx;\n                    ry = h * ry;\n                }\n\n                var rx2 = rx * rx;\n                var ry2 = ry * ry;\n\n                var k = ((large_arc_flag == sweep_flag) ? -1 : 1) * sqrt(abs(((rx2 * ry2) - (rx2 * y * y) - (ry2 * x * x)) / ((rx2 * y * y) + (ry2 * x * x))));\n                if (!Number.isFinite(k)) {\n                    // Arc is a single point\n                    return [x1, y1, x2, y2, x2, y2];\n                }\n\n                var cx = ((k * rx * y) / ry) + ((x1 + x2) / 2);\n                var cy = ((k * -ry * x) / rx) + ((y1 + y2) / 2);\n\n                var f1 = asin(((y1 - cy) / ry).toFixed(9));\n                var f2 = asin(((y2 - cy) / ry).toFixed(9));\n\n                f1 = ((x1 < cx) ? (PI - f1) : f1);\n                f2 = ((x2 < cx) ? (PI - f2) : f2);\n\n                if (f1 < 0) f1 = (PI * 2) + f1;\n                if (f2 < 0) f2 = (PI * 2) + f2;\n\n                if (sweep_flag && (f1 > f2)) f1 = f1 - (PI * 2);\n                if (!sweep_flag && (f2 > f1)) f2 = f2 - (PI * 2);\n\n            } else {\n                f1 = recursive[0];\n                f2 = recursive[1];\n                cx = recursive[2];\n                cy = recursive[3];\n            }\n\n            var df = f2 - f1;\n            if (abs(df) > _120) {\n                var f2old = f2;\n                var x2old = x2;\n                var y2old = y2;\n                f2 = f1 + (_120 * ((sweep_flag && (f2 > f1)) ? 1 : -1));\n                x2 = cx + (rx * cos(f2));\n                y2 = cy + (ry * sin(f2));\n                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n            }\n\n            df = f2 - f1;\n\n            var c1 = cos(f1);\n            var s1 = sin(f1);\n            var c2 = cos(f2);\n            var s2 = sin(f2);\n            var t = tan(df / 4);\n            var hx = (4 / 3) * (rx * t);\n            var hy = (4 / 3) * (ry * t);\n            var m1 = [x1, y1];\n            var m2 = [x1 + (hx * s1), y1 - (hy * c1)];\n            var m3 = [x2 + (hx * s2), y2 - (hy * c2)];\n            var m4 = [x2, y2];\n\n            m2[0] = (2 * m1[0]) - m2[0];\n            m2[1] = (2 * m1[1]) - m2[1];\n\n            if (recursive) {\n                return [m2, m3, m4].concat(res);\n            } else {\n                res = [m2, m3, m4].concat(res).join().split(',');\n                var newres = [];\n                var ii = res.length;\n                for (var i = 0; i < ii; i++) {\n                    newres[i] = (i % 2) ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n                }\n                return newres;\n            }\n        }\n\n        function parsePathString(pathString) {\n\n            if (!pathString) return null;\n\n            var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };\n            var data = [];\n\n            String(pathString).replace(pathCommand, function(a, b, c) {\n\n                var params = [];\n                var name = b.toLowerCase();\n                c.replace(pathValues, function(a, b) {\n                    if (b) params.push(+b);\n                });\n\n                if ((name === 'm') && (params.length > 2)) {\n                    data.push([b].concat(params.splice(0, 2)));\n                    name = 'l';\n                    b = ((b === 'm') ? 'l' : 'L');\n                }\n\n                while (params.length >= paramCounts[name]) {\n                    data.push([b].concat(params.splice(0, paramCounts[name])));\n                    if (!paramCounts[name]) break;\n                }\n            });\n\n            return data;\n        }\n\n        function pathToAbsolute(pathArray) {\n\n            if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) { // rough assumption\n                pathArray = parsePathString(pathArray);\n            }\n\n            // if invalid string, return 'M 0 0'\n            if (!pathArray || !pathArray.length) return [['M', 0, 0]];\n\n            var res = [];\n            var x = 0;\n            var y = 0;\n            var mx = 0;\n            var my = 0;\n            var start = 0;\n            var pa0;\n\n            var ii = pathArray.length;\n            for (var i = start; i < ii; i++) {\n\n                var r = [];\n                res.push(r);\n\n                var pa = pathArray[i];\n                pa0 = pa[0];\n\n                if (pa0 != pa0.toUpperCase()) {\n                    r[0] = pa0.toUpperCase();\n\n                    var jj;\n                    var j;\n                    switch (r[0]) {\n                        case 'A':\n                            r[1] = pa[1];\n                            r[2] = pa[2];\n                            r[3] = pa[3];\n                            r[4] = pa[4];\n                            r[5] = pa[5];\n                            r[6] = +pa[6] + x;\n                            r[7] = +pa[7] + y;\n                            break;\n\n                        case 'V':\n                            r[1] = +pa[1] + y;\n                            break;\n\n                        case 'H':\n                            r[1] = +pa[1] + x;\n                            break;\n\n                        case 'M':\n                            mx = +pa[1] + x;\n                            my = +pa[2] + y;\n\n                            jj = pa.length;\n                            for (j = 1; j < jj; j++) {\n                                r[j] = +pa[j] + ((j % 2) ? x : y);\n                            }\n                            break;\n\n                        default:\n                            jj = pa.length;\n                            for (j = 1; j < jj; j++) {\n                                r[j] = +pa[j] + ((j % 2) ? x : y);\n                            }\n                            break;\n                    }\n                } else {\n                    var kk = pa.length;\n                    for (var k = 0; k < kk; k++) {\n                        r[k] = pa[k];\n                    }\n                }\n\n                switch (r[0]) {\n                    case 'Z':\n                        x = +mx;\n                        y = +my;\n                        break;\n\n                    case 'H':\n                        x = r[1];\n                        break;\n\n                    case 'V':\n                        y = r[1];\n                        break;\n\n                    case 'M':\n                        mx = r[r.length - 2];\n                        my = r[r.length - 1];\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                        break;\n\n                    default:\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                        break;\n                }\n            }\n\n            return res;\n        }\n\n        function normalize(path) {\n\n            var p = pathToAbsolute(path);\n            var attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };\n\n            function processPath(path, d, pcom) {\n\n                var nx, ny;\n\n                if (!path) return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\n\n                if (!(path[0] in { T: 1, Q: 1 })) {\n                    d.qx = null;\n                    d.qy = null;\n                }\n\n                switch (path[0]) {\n                    case 'M':\n                        d.X = path[1];\n                        d.Y = path[2];\n                        break;\n\n                    case 'A':\n                        if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {\n                            // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters\n                            // \"If either rx or ry is 0, then this arc is treated as a\n                            // straight line segment (a \"lineto\") joining the endpoints.\"\n                            path = ['L', path[6], path[7]];\n                        } else {\n                            path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n                        }\n                        break;\n\n                    case 'S':\n                        if (pcom === 'C' || pcom === 'S') { // In 'S' case we have to take into account, if the previous command is C/S.\n                            nx = (d.x * 2) - d.bx;          // And reflect the previous\n                            ny = (d.y * 2) - d.by;          // command's control point relative to the current point.\n                        } else {                            // or some else or nothing\n                            nx = d.x;\n                            ny = d.y;\n                        }\n                        path = ['C', nx, ny].concat(path.slice(1));\n                        break;\n\n                    case 'T':\n                        if (pcom === 'Q' || pcom === 'T') { // In 'T' case we have to take into account, if the previous command is Q/T.\n                            d.qx = (d.x * 2) - d.qx;        // And make a reflection similar\n                            d.qy = (d.y * 2) - d.qy;        // to case 'S'.\n                        } else {                            // or something else or nothing\n                            d.qx = d.x;\n                            d.qy = d.y;\n                        }\n                        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                        break;\n\n                    case 'Q':\n                        d.qx = path[1];\n                        d.qy = path[2];\n                        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                        break;\n\n                    case 'H':\n                        path = ['L'].concat(path[1], d.y);\n                        break;\n\n                    case 'V':\n                        path = ['L'].concat(d.x, path[1]);\n                        break;\n\n                    case 'L':\n                        break;\n\n                    case 'Z':\n                        break;\n                }\n\n                return path;\n            }\n\n            function fixArc(pp, i) {\n\n                if (pp[i].length > 7) {\n\n                    pp[i].shift();\n                    var pi = pp[i];\n\n                    while (pi.length) {\n                        pcoms[i] = 'A'; // if created multiple 'C's, their original seg is saved\n                        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n                    }\n\n                    pp.splice(i, 1);\n                    ii = p.length;\n                }\n            }\n\n            var pcoms = []; // path commands of original path p\n            var pfirst = ''; // temporary holder for original path command\n            var pcom = ''; // holder for previous path command of original path\n\n            var ii = p.length;\n            for (var i = 0; i < ii; i++) {\n                if (p[i]) pfirst = p[i][0]; // save current path command\n\n                if (pfirst !== 'C') { // C is not saved yet, because it may be result of conversion\n                    pcoms[i] = pfirst; // Save current path command\n                    if (i > 0) pcom = pcoms[i - 1]; // Get previous path command pcom\n                }\n\n                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n                if (pcoms[i] !== 'A' && pfirst === 'C') pcoms[i] = 'C'; // 'A' is the only command\n                // which may produce multiple 'C's\n                // so we have to make sure that 'C' is also 'C' in original path\n\n                fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms\n\n                var seg = p[i];\n                var seglen = seg.length;\n\n                attrs.x = seg[seglen - 2];\n                attrs.y = seg[seglen - 1];\n\n                attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n                attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n            }\n\n            // make sure normalized path data string starts with an M segment\n            if (!p[0][0] || p[0][0] !== 'M') {\n                p.unshift(['M', 0, 0]);\n            }\n\n            return p;\n        }\n\n        return function(pathData) {\n            return normalize(pathData).join(',').split(',').join(' ');\n        };\n    })();\n\n    V.namespace = ns;\n\n    V.g = g;\n\n    return V;\n\n})();\n\nexport default V;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2396, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2402, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/layout/ports/port.mjs"],"sourcesContent":["import * as g from '../../g/index.mjs';\nimport * as util from '../../util/index.mjs';\n\nfunction portTransformAttrs(point, angle, opt) {\n\n    var trans = point.toJSON();\n\n    trans.angle = angle || 0;\n\n    return util.defaults({}, opt, trans);\n}\n\nfunction lineLayout(ports, p1, p2, elBBox) {\n    return ports.map(function(port, index, ports) {\n        var p = this.pointAt(((index + 0.5) / ports.length));\n        // `dx`,`dy` per port offset option\n        if (port.dx || port.dy) {\n            p.offset(port.dx || 0, port.dy || 0);\n        }\n        return portTransformAttrs(p.round(), 0, argTransform(elBBox, port));\n    }, g.line(p1, p2));\n}\n\nfunction ellipseLayout(ports, elBBox, startAngle, stepFn) {\n\n    var center = elBBox.center();\n    var ratio = elBBox.width / elBBox.height;\n    var p1 = elBBox.topMiddle();\n\n    var ellipse = g.Ellipse.fromRect(elBBox);\n\n    return ports.map(function(port, index, ports) {\n\n        var angle = startAngle + stepFn(index, ports.length);\n        var p2 = p1.clone()\n            .rotate(center, -angle)\n            .scale(ratio, 1, center);\n\n        var theta = port.compensateRotation ? -ellipse.tangentTheta(p2) : 0;\n\n        // `dx`,`dy` per port offset option\n        if (port.dx || port.dy) {\n            p2.offset(port.dx || 0, port.dy || 0);\n        }\n\n        // `dr` delta radius option\n        if (port.dr) {\n            p2.move(center, port.dr);\n        }\n\n        return portTransformAttrs(p2.round(), theta, argTransform(elBBox, port));\n    });\n}\n\n\nfunction argTransform(bbox, args) {\n    let { x, y, angle } = args;\n    if (util.isPercentage(x)) {\n        x = parseFloat(x) / 100 * bbox.width;\n    } else if (util.isCalcExpression(x)) {\n        x = Number(util.evalCalcExpression(x, bbox));\n    }\n    if (util.isPercentage(y)) {\n        y = parseFloat(y) / 100 * bbox.height;\n    } else if (util.isCalcExpression(y)) {\n        y = Number(util.evalCalcExpression(y, bbox));\n    }\n    return { x, y, angle };\n}\n\n// Creates a point stored in arguments\nfunction argPoint(bbox, args) {\n    const { x, y } = argTransform(bbox, args);\n    return new g.Point(x || 0, y || 0);\n}\n\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const absolute = function(ports, elBBox) {\n    return ports.map(port => {\n        const transformation = argPoint(elBBox, port).round().toJSON();\n        transformation.angle = port.angle || 0;\n        return transformation;\n    });\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const fn = function(ports, elBBox, opt) {\n    return opt.fn(ports, elBBox, opt);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const line = function(ports, elBBox, opt) {\n\n    var start = argPoint(elBBox, opt.start || elBBox.origin());\n    var end = argPoint(elBBox, opt.end || elBBox.corner());\n\n    return lineLayout(ports, start, end, elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const left = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const right = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.topRight(), elBBox.corner(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const top = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.origin(), elBBox.topRight(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const bottom = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt Group options\n * @returns {Array<g.Point>}\n */\nexport const ellipseSpread = function(ports, elBBox, opt) {\n\n    var startAngle = opt.startAngle || 0;\n    var stepAngle = opt.step || 360 / ports.length;\n\n    return ellipseLayout(ports, elBBox, startAngle, function(index) {\n        return index * stepAngle;\n    });\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt Group options\n * @returns {Array<g.Point>}\n */\nexport const ellipse = function(ports, elBBox, opt) {\n\n    var startAngle = opt.startAngle || 0;\n    var stepAngle = opt.step || 20;\n\n    return ellipseLayout(ports, elBBox, startAngle, function(index, count) {\n        return (index + 0.5 - count / 2) * stepAngle;\n    });\n};\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2516, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2522, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/layout/ports/portLabel.mjs"],"sourcesContent":["import * as g from '../../g/index.mjs';\nimport * as util from '../../util/index.mjs';\n\nfunction labelAttributes(opt1, opt2) {\n\n    // use value from `opt2` if it is missing in `opt1`\n    // use value from this object if it is missing in `opt2` as well\n    return util.defaultsDeep({}, opt1, opt2, {\n        x: 0,\n        y: 0,\n        angle: 0,\n        attrs: {}\n    });\n}\n\nfunction getBBoxAngles(elBBox) {\n\n    var center = elBBox.center();\n\n    var tl = center.theta(elBBox.origin());\n    var bl = center.theta(elBBox.bottomLeft());\n    var br = center.theta(elBBox.corner());\n    var tr = center.theta(elBBox.topRight());\n\n    return [tl, tr, br, bl];\n}\n\nfunction outsideLayout(portPosition, elBBox, autoOrient, opt) {\n\n    opt = util.defaults({}, opt, { offset: 15 });\n    var angle = elBBox.center().theta(portPosition);\n\n    var tx, ty, y, textAnchor;\n    var offset = opt.offset;\n    var orientAngle = 0;\n\n    const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);\n    if ((angle < bottomLeftAngle) || (angle > bottomRightAngle)) {\n        y = '.3em';\n        tx = offset;\n        ty = 0;\n        textAnchor = 'start';\n    } else if (angle < topLeftAngle) {\n        tx = 0;\n        ty = -offset;\n        if (autoOrient) {\n            orientAngle = -90;\n            textAnchor = 'start';\n            y = '.3em';\n        } else {\n            textAnchor = 'middle';\n            y = '0';\n        }\n    } else if (angle < topRightAngle) {\n        y = '.3em';\n        tx = -offset;\n        ty = 0;\n        textAnchor = 'end';\n    } else {\n        tx = 0;\n        ty = offset;\n        if (autoOrient) {\n            orientAngle = 90;\n            textAnchor = 'start';\n            y = '.3em';\n        } else {\n            textAnchor = 'middle';\n            y = '.6em';\n        }\n    }\n\n    var round = Math.round;\n    return labelAttributes(opt, {\n        x: round(tx),\n        y: round(ty),\n        angle: orientAngle,\n        attrs: { labelText: { y, textAnchor }}\n    });\n}\n\nfunction insideLayout(portPosition, elBBox, autoOrient, opt) {\n\n    opt = util.defaults({}, opt, { offset: 15 });\n    var angle = elBBox.center().theta(portPosition);\n\n    var tx, ty, y, textAnchor;\n    var offset = opt.offset;\n    var orientAngle = 0;\n\n    const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);\n    if ((angle < bottomLeftAngle) || (angle > bottomRightAngle)) {\n        y = '.3em';\n        tx = -offset;\n        ty = 0;\n        textAnchor = 'end';\n    } else if (angle < topLeftAngle) {\n        tx = 0;\n        ty = offset;\n        if (autoOrient) {\n            orientAngle = 90;\n            textAnchor = 'start';\n            y = '.3em';\n        } else {\n            textAnchor = 'middle';\n            y = '.6em';\n        }\n    } else if (angle < topRightAngle) {\n        y = '.3em';\n        tx = offset;\n        ty = 0;\n        textAnchor = 'start';\n    } else {\n        tx = 0;\n        ty = -offset;\n        if (autoOrient) {\n            orientAngle = -90;\n            textAnchor = 'start';\n            y = '.3em';\n        } else {\n            textAnchor = 'middle';\n            y = '0';\n        }\n    }\n\n    var round = Math.round;\n    return labelAttributes(opt, {\n        x: round(tx),\n        y: round(ty),\n        angle: orientAngle,\n        attrs: { labelText: { y, textAnchor }}\n    });\n}\n\nfunction radialLayout(portCenterOffset, autoOrient, opt) {\n\n    opt = util.defaults({}, opt, { offset: 20 });\n\n    var origin = g.point(0, 0);\n    var angle = -portCenterOffset.theta(origin);\n    var orientAngle = angle;\n    var offset = portCenterOffset.clone()\n        .move(origin, opt.offset)\n        .difference(portCenterOffset)\n        .round();\n\n    var y = '.3em';\n    var textAnchor;\n\n    if ((angle + 90) % 180 === 0) {\n        textAnchor = autoOrient ? 'end' : 'middle';\n        if (!autoOrient && angle === -270) {\n            y = '0em';\n        }\n    } else if (angle > -270 && angle < -90) {\n        textAnchor = 'start';\n        orientAngle = angle - 180;\n    } else {\n        textAnchor = 'end';\n    }\n\n    var round = Math.round;\n    return labelAttributes(opt, {\n        x: round(offset.x),\n        y: round(offset.y),\n        angle: ((autoOrient) ? orientAngle : 0),\n        attrs: { labelText: { y, textAnchor }}\n    });\n}\n\nexport const manual = function(_portPosition, _elBBox, opt) {\n    return labelAttributes(opt);\n};\n\nexport const left = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        x: -15,\n        attrs: { labelText: { y: '.3em', textAnchor: 'end' }},\n    });\n};\n\nexport const right = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        x: 15,\n        attrs: { labelText: { y: '.3em', textAnchor: 'start' }},\n    });\n};\n\nexport const top = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        y: -15,\n        attrs: { labelText: { y: '0', textAnchor: 'middle' }},\n    });\n};\n\nexport const bottom = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        y: 15,\n        attrs: { labelText: { y: '.6em', textAnchor: 'middle' }},\n    });\n};\n\nexport const outsideOriented = function(portPosition, elBBox, opt) {\n    return outsideLayout(portPosition, elBBox, true, opt);\n};\n\nexport const outside = function(portPosition, elBBox, opt) {\n    return outsideLayout(portPosition, elBBox, false, opt);\n};\n\nexport const insideOriented = function(portPosition, elBBox, opt) {\n    return insideLayout(portPosition, elBBox, true, opt);\n};\n\nexport const inside = function(portPosition, elBBox, opt) {\n    return insideLayout(portPosition, elBBox, false, opt);\n};\n\nexport const radial = function(portPosition, elBBox, opt) {\n    return radialLayout(portPosition.difference(elBBox.center()), false, opt);\n};\n\nexport const radialOriented = function(portPosition, elBBox, opt) {\n    return radialLayout(portPosition.difference(elBBox.center()), true, opt);\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2771, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2777, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/env/index.mjs"],"sourcesContent":["export const env = {\n\n    _results: {},\n\n    _tests: {\n\n        svgforeignobject: function() {\n            return !!document.createElementNS &&\n                /SVGForeignObject/.test(({}).toString.call(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')));\n        },\n\n        // works for iOS browsers too\n        isSafari: function() {\n            return /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);\n        }\n    },\n\n    addTest: function(name, fn) {\n\n        return this._tests[name] = fn;\n    },\n\n    test: function(name) {\n\n        var fn = this._tests[name];\n\n        if (!fn) {\n            throw new Error('Test not defined (\"' + name + '\"). Use `joint.env.addTest(name, fn) to add a new test.`');\n        }\n\n        var result = this._results[name];\n\n        if (typeof result !== 'undefined') {\n            return result;\n        }\n\n        try {\n            result = fn();\n        } catch (error) {\n            result = false;\n        }\n\n        // Cache the test result.\n        this._results[name] = result;\n\n        return result;\n    }\n};\n"],"names":[],"mappings":";;;AAAO,MAAM,MAAM;IAEf,UAAU,CAAC;IAEX,QAAQ;QAEJ,kBAAkB;YACd,OAAO,CAAC,CAAC,SAAS,eAAe,IAC7B,mBAAmB,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,IAAI,CAAC,SAAS,eAAe,CAAC,8BAA8B;QAC1G;QAEA,6BAA6B;QAC7B,UAAU;YACN,OAAO,SAAS,IAAI,CAAC,UAAU,SAAS,KAAK,iBAAiB,IAAI,CAAC,UAAU,MAAM;QACvF;IACJ;IAEA,SAAS,SAAS,IAAI,EAAE,EAAE;QAEtB,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG;IAC/B;IAEA,MAAM,SAAS,IAAI;QAEf,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,KAAK;QAE1B,IAAI,CAAC,IAAI;YACL,MAAM,IAAI,MAAM,wBAAwB,OAAO;QACnD;QAEA,IAAI,SAAS,IAAI,CAAC,QAAQ,CAAC,KAAK;QAEhC,IAAI,OAAO,WAAW,aAAa;YAC/B,OAAO;QACX;QAEA,IAAI;YACA,SAAS;QACb,EAAE,OAAO,OAAO;YACZ,SAAS;QACb;QAEA,yBAAyB;QACzB,IAAI,CAAC,QAAQ,CAAC,KAAK,GAAG;QAEtB,OAAO;IACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2813, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2819, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 2826, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2840, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/connectors/straight.mjs"],"sourcesContent":["import * as g from '../g/index.mjs';\n\nconst CornerTypes = {\n    POINT: 'point',\n    CUBIC: 'cubic',\n    LINE: 'line',\n    GAP: 'gap'\n};\n\nconst DEFINED_CORNER_TYPES = Object.values(CornerTypes);\n\nconst CORNER_RADIUS = 10;\nconst PRECISION = 1;\n\nexport const straight = function(sourcePoint, targetPoint, routePoints = [], opt = {}) {\n\n    const {\n        cornerType = CornerTypes.POINT,\n        cornerRadius = CORNER_RADIUS,\n        cornerPreserveAspectRatio = false,\n        precision = PRECISION,\n        raw = false\n    } = opt;\n\n    if (DEFINED_CORNER_TYPES.indexOf(cornerType) === -1) {\n        // unknown `cornerType` provided => error\n        throw new Error('Invalid `cornerType` provided to `straight` connector.');\n    }\n\n    let path;\n\n    if ((cornerType === CornerTypes.POINT) || !cornerRadius) {\n        // default option => normal connector\n        // simply connect all points with straight lines\n        const points = [sourcePoint].concat(routePoints).concat([targetPoint]);\n        const polyline = new g.Polyline(points);\n        path = new g.Path(polyline);\n\n    } else {\n        // `cornerType` is not unknown and not 'point' (default) => must be one of other valid types\n        path = new g.Path();\n\n        // add initial gap segment = to source point\n        path.appendSegment(g.Path.createSegment('M', sourcePoint));\n\n        let nextDistance;\n        const routePointsLength = routePoints.length;\n        for (let i = 0; i < routePointsLength; i++) {\n\n            const curr = new g.Point(routePoints[i]);\n            const prev = (routePoints[i - 1] || sourcePoint);\n            const next = (routePoints[i + 1] || targetPoint);\n            const prevDistance = (nextDistance || (curr.distance(prev) / 2)); // try to re-use previously-computed `nextDistance`\n            nextDistance = (curr.distance(next) / 2);\n\n            let startMove, endMove;\n            if (!cornerPreserveAspectRatio) {\n                // `startMove` and `endMove` may be different\n                // (this happens when next or previous path point is closer than `2 * cornerRadius`)\n                startMove = -Math.min(cornerRadius, prevDistance);\n                endMove = -Math.min(cornerRadius, nextDistance);\n            } else {\n                // force `startMove` and `endMove` to be the same\n                startMove = endMove = -Math.min(cornerRadius, prevDistance, nextDistance);\n            }\n\n            // to find `cornerStart` and `cornerEnd`, the logic is as follows (using `cornerStart` as example):\n            // - find a point lying on the line `prev - startMove` such that...\n            // - ...the point lies `abs(startMove)` distance away from `curr`...\n            // - ...and its coordinates are rounded to whole numbers\n            const cornerStart = curr.clone().move(prev, startMove).round(precision);\n            const cornerEnd = curr.clone().move(next, endMove).round(precision);\n\n            // add in-between straight segment = from previous route point to corner start point\n            // (may have zero length)\n            path.appendSegment(g.Path.createSegment('L', cornerStart));\n\n            // add corner segment = from corner start point to corner end point\n            switch (cornerType) {\n                case CornerTypes.CUBIC: {\n                    // corner is rounded\n                    const _13 = (1 / 3);\n                    const _23 = (2 / 3);\n                    const control1 = new g.Point((_13 * cornerStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * cornerStart.y));\n                    const control2 = new g.Point((_13 * cornerEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * cornerEnd.y));\n                    path.appendSegment(g.Path.createSegment('C', control1, control2, cornerEnd));\n                    break;\n                }\n                case CornerTypes.LINE: {\n                    // corner has bevel\n                    path.appendSegment(g.Path.createSegment('L', cornerEnd));\n                    break;\n                }\n                case CornerTypes.GAP: {\n                    // corner has empty space\n                    path.appendSegment(g.Path.createSegment('M', cornerEnd));\n                    break;\n                }\n                // default: no segment is created\n            }\n        }\n\n        // add final straight segment = from last corner end point to target point\n        // (= or from start point to end point, if there are no route points)\n        // (may have zero length)\n        path.appendSegment(g.Path.createSegment('L', targetPoint));\n    }\n\n    return ((raw) ? path : path.serialize());\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2936, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2942, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/connectors/jumpover.mjs"],"sourcesContent":["import * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\n// default size of jump if not specified in options\nvar JUMP_SIZE = 5;\n\n// available jump types\n// first one taken as default\nvar JUMP_TYPES = ['arc', 'gap', 'cubic'];\n\n// default radius\nvar RADIUS = 0;\n\n// takes care of math. error for case when jump is too close to end of line\nvar CLOSE_PROXIMITY_PADDING = 1;\n\n// list of connector types not to jump over.\nvar IGNORED_CONNECTORS = ['smooth'];\n\n// internal constants for round segment\nvar _13 = 1 / 3;\nvar _23 = 2 / 3;\n\nfunction sortPointsAscending(p1, p2) {\n\n    let { x: x1, y: y1 } = p1;\n    let { x: x2, y: y2 } = p2;\n\n    if (x1 > x2) {\n\n        let swap = x1;\n        x1 = x2;\n        x2 = swap;\n\n        swap = y1;\n        y1 = y2;\n        y2 = swap;\n    }\n\n    if (y1 > y2) {\n        let swap = x1;\n        x1 = x2;\n        x2 = swap;\n\n        swap = y1;\n        y1 = y2;\n        y2 = swap;\n    }\n\n    return [new g.Point(x1, y1), new g.Point(x2, y2)];\n}\n\nfunction overlapExists(line1, line2) {\n\n    const [{ x: x1, y: y1 }, { x: x2, y: y2 }] = sortPointsAscending(line1.start, line1.end);\n    const [{ x: x3, y: y3 }, { x: x4, y: y4 }] = sortPointsAscending(line2.start, line2.end);\n\n    const xMatch = x1 <= x4 && x3 <= x2;\n    const yMatch = y1 <= y4 && y3 <= y2;\n\n    return xMatch && yMatch;\n}\n\n/**\n * Transform start/end and route into series of lines\n * @param {g.point} sourcePoint start point\n * @param {g.point} targetPoint end point\n * @param {g.point[]} route optional list of route\n * @return {g.line[]} [description]\n */\nfunction createLines(sourcePoint, targetPoint, route) {\n    // make a flattened array of all points\n    var points = [].concat(sourcePoint, route, targetPoint);\n    return points.reduce(function(resultLines, point, idx) {\n        // if there is a next point, make a line with it\n        var nextPoint = points[idx + 1];\n        if (nextPoint != null) {\n            resultLines[idx] = g.line(point, nextPoint);\n        }\n        return resultLines;\n    }, []);\n}\n\nfunction setupUpdating(jumpOverLinkView) {\n    var paper = jumpOverLinkView.paper;\n    var updateList = paper._jumpOverUpdateList;\n\n    // first time setup for this paper\n    if (updateList == null) {\n        updateList = paper._jumpOverUpdateList = [];\n        var graph = paper.model;\n        graph.on('batch:stop', function() {\n            if (this.hasActiveBatch()) return;\n            updateJumpOver(paper);\n        });\n        graph.on('reset', function() {\n            updateList = paper._jumpOverUpdateList = [];\n        });\n    }\n\n    // add this link to a list so it can be updated when some other link is updated\n    if (updateList.indexOf(jumpOverLinkView) < 0) {\n        updateList.push(jumpOverLinkView);\n\n        // watch for change of connector type or removal of link itself\n        // to remove the link from a list of jump over connectors\n        jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function() {\n            updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n        });\n    }\n}\n\n/**\n * Handler for a batch:stop event to force\n * update of all registered links with jump over connector\n * @param {object} batchEvent optional object with info about batch\n */\nfunction updateJumpOver(paper) {\n    var updateList = paper._jumpOverUpdateList;\n    for (var i = 0; i < updateList.length; i++) {\n        const linkView = updateList[i];\n        const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);\n        linkView.requestUpdate(updateFlag);\n    }\n}\n\n/**\n * Utility function to collect all intersection points of a single\n * line against group of other lines.\n * @param {g.line} line where to find points\n * @param {g.line[]} crossCheckLines lines to cross\n * @return {g.point[]} list of intersection points\n */\nfunction findLineIntersections(line, crossCheckLines) {\n    return util.toArray(crossCheckLines).reduce(function(res, crossCheckLine) {\n        var intersection = line.intersection(crossCheckLine);\n        if (intersection) {\n            res.push(intersection);\n        }\n        return res;\n    }, []);\n}\n\n/**\n * Sorting function for list of points by their distance.\n * @param {g.point} p1 first point\n * @param {g.point} p2 second point\n * @return {number} squared distance between points\n */\nfunction sortPoints(p1, p2) {\n    return g.line(p1, p2).squaredLength();\n}\n\n/**\n * Split input line into multiple based on intersection points.\n * @param {g.line} line input line to split\n * @param {g.point[]} intersections points where to split the line\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @return {g.line[]} list of lines being split\n */\nfunction createJumps(line, intersections, jumpSize) {\n    return intersections.reduce(function(resultLines, point, idx) {\n        // skipping points that were merged with the previous line\n        // to make bigger arc over multiple lines that are close to each other\n        if (point.skip === true) {\n            return resultLines;\n        }\n\n        // always grab the last line from buffer and modify it\n        var lastLine = resultLines.pop() || line;\n\n        // calculate start and end of jump by moving by a given size of jump\n        var jumpStart = g.point(point).move(lastLine.start, -(jumpSize));\n        var jumpEnd = g.point(point).move(lastLine.start, +(jumpSize));\n\n        // now try to look at the next intersection point\n        var nextPoint = intersections[idx + 1];\n        if (nextPoint != null) {\n            var distance = jumpEnd.distance(nextPoint);\n            if (distance <= jumpSize) {\n                // next point is close enough, move the jump end by this\n                // difference and mark the next point to be skipped\n                jumpEnd = nextPoint.move(lastLine.start, distance);\n                nextPoint.skip = true;\n            }\n        } else {\n            // this block is inside of `else` as an optimization so the distance is\n            // not calculated when we know there are no other intersection points\n            var endDistance = jumpStart.distance(lastLine.end);\n            // if the end is too close to possible jump, draw remaining line instead of a jump\n            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n                resultLines.push(lastLine);\n                return resultLines;\n            }\n        }\n\n        var startDistance = jumpEnd.distance(lastLine.start);\n        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n            // if the start of line is too close to jump, draw that line instead of a jump\n            resultLines.push(lastLine);\n            return resultLines;\n        }\n\n        // finally create a jump line\n        var jumpLine = g.line(jumpStart, jumpEnd);\n        // it's just simple line but with a `isJump` property\n        jumpLine.isJump = true;\n\n        resultLines.push(\n            g.line(lastLine.start, jumpStart),\n            jumpLine,\n            g.line(jumpEnd, lastLine.end)\n        );\n        return resultLines;\n    }, []);\n}\n\n/**\n * Assemble `D` attribute of a SVG path by iterating given lines.\n * @param {g.line[]} lines source lines to use\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @param {number} radius the radius\n * @return {string}\n */\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n\n    var path = new g.Path();\n    var segment;\n\n    // first move to the start of a first line\n    segment = g.Path.createSegment('M', lines[0].start);\n    path.appendSegment(segment);\n\n    // make a paths from lines\n    util.toArray(lines).forEach(function(line, index) {\n\n        if (line.isJump) {\n            var angle, diff;\n\n            var control1, control2;\n\n            if (jumpType === 'arc') { // approximates semicircle with 2 curves\n                angle = -90;\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                var xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n                if (xAxisRotate) angle += 180;\n\n                var midpoint = line.midpoint();\n                var centerLine = new g.Line(midpoint, line.end).rotate(midpoint, angle);\n\n                var halfLine;\n\n                // first half\n                halfLine = new g.Line(line.start, midpoint);\n\n                control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n                control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n\n                segment = g.Path.createSegment('C', control1, control2, centerLine.end);\n                path.appendSegment(segment);\n\n                // second half\n                halfLine = new g.Line(midpoint, line.end);\n\n                control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n                control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n\n                segment = g.Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n\n            } else if (jumpType === 'gap') {\n                segment = g.Path.createSegment('M', line.end);\n                path.appendSegment(segment);\n\n            } else if (jumpType === 'cubic') { // approximates semicircle with 1 curve\n                angle = line.start.theta(line.end);\n\n                var xOffset = jumpSize * 0.6;\n                var yOffset = jumpSize * 1.35;\n\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n                if (xAxisRotate) yOffset *= -1;\n\n                control1 = g.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n                control2 = g.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n\n                segment = g.Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n            }\n\n        } else {\n            var nextLine = lines[index + 1];\n            if (radius == 0 || !nextLine || nextLine.isJump) {\n                segment = g.Path.createSegment('L', line.end);\n                path.appendSegment(segment);\n            } else {\n                buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n            }\n        }\n    });\n\n    return path;\n}\n\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n    var prevDistance = curr.distance(prev) / 2;\n    var nextDistance = curr.distance(next) / 2;\n\n    var startMove = -Math.min(offset, prevDistance);\n    var endMove = -Math.min(offset, nextDistance);\n\n    var roundedStart = curr.clone().move(prev, startMove).round();\n    var roundedEnd = curr.clone().move(next, endMove).round();\n\n    var control1 = new g.Point((_13 * roundedStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedStart.y));\n    var control2 = new g.Point((_13 * roundedEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedEnd.y));\n\n    var segment;\n    segment = g.Path.createSegment('L', roundedStart);\n    path.appendSegment(segment);\n\n    segment = g.Path.createSegment('C', control1, control2, roundedEnd);\n    path.appendSegment(segment);\n}\n\n/**\n * Actual connector function that will be run on every update.\n * @param {g.point} sourcePoint start point of this link\n * @param {g.point} targetPoint end point of this link\n * @param {g.point[]} route of this link\n * @param {object} opt options\n * @property {number} size optional size of a jump arc\n * @return {string} created `D` attribute of SVG path\n */\nexport const jumpover = function(sourcePoint, targetPoint, route, opt) { // eslint-disable-line max-params\n\n    setupUpdating(this);\n\n    var raw = opt.raw;\n    var jumpSize = opt.size || JUMP_SIZE;\n    var jumpType = opt.jump && ('' + opt.jump).toLowerCase();\n    var radius = opt.radius || RADIUS;\n    var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;\n\n    // grab the first jump type as a default if specified one is invalid\n    if (JUMP_TYPES.indexOf(jumpType) === -1) {\n        jumpType = JUMP_TYPES[0];\n    }\n\n    var paper = this.paper;\n    var graph = paper.model;\n    var allLinks = graph.getLinks();\n\n    // there is just one link, draw it directly\n    if (allLinks.length === 1) {\n        return buildPath(\n            createLines(sourcePoint, targetPoint, route),\n            jumpSize, jumpType, radius\n        );\n    }\n\n    var thisModel = this.model;\n    var thisIndex = allLinks.indexOf(thisModel);\n    var defaultConnector = paper.options.defaultConnector || {};\n\n    // not all links are meant to be jumped over.\n    var links = allLinks.filter(function(link, idx) {\n\n        var connector = link.get('connector') || defaultConnector;\n\n        // avoid jumping over links with connector type listed in `ignored connectors`.\n        if (util.toArray(ignoreConnectors).includes(connector.name)) {\n            return false;\n        }\n        // filter out links that are above this one and  have the same connector type\n        // otherwise there would double hoops for each intersection\n        if (idx > thisIndex) {\n            return connector.name !== 'jumpover';\n        }\n        return true;\n    });\n\n    // find views for all links\n    var linkViews = links.map(function(link) {\n        return paper.findViewByModel(link);\n    });\n\n    // create lines for this link\n    var thisLines = createLines(\n        sourcePoint,\n        targetPoint,\n        route\n    );\n\n    // create lines for all other links\n    var linkLines = linkViews.map(function(linkView) {\n        if (linkView == null) {\n            return [];\n        }\n        if (linkView === this) {\n            return thisLines;\n        }\n        return createLines(\n            linkView.sourcePoint,\n            linkView.targetPoint,\n            linkView.route\n        );\n    }, this);\n\n    // transform lines for this link by splitting with jump lines at\n    // points of intersection with other links\n    var jumpingLines = thisLines.reduce(function(resultLines, thisLine) {\n        // iterate all links and grab the intersections with this line\n        // these are then sorted by distance so the line can be split more easily\n        var intersections = links.reduce(function(res, link, i) {\n            // don't intersection with itself\n            if (link !== thisModel) {\n\n                const linkLinesToTest = linkLines[i].slice();\n                const overlapIndex = linkLinesToTest.findIndex((line) => overlapExists(thisLine, line));\n\n                // Overlap occurs and the end point of one segment lies on thisLine\n                if (overlapIndex > -1 && thisLine.containsPoint(linkLinesToTest[overlapIndex].end)) {\n                    // Remove the next segment because there will never be a jump\n                    linkLinesToTest.splice(overlapIndex + 1, 1);\n                }\n                const lineIntersections = findLineIntersections(thisLine, linkLinesToTest);\n                res.push.apply(res, lineIntersections);\n            }\n            return res;\n        }, []).sort(function(a, b) {\n            return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n        });\n\n        if (intersections.length > 0) {\n            // split the line based on found intersection points\n            resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n        } else {\n            // without any intersection the line goes uninterrupted\n            resultLines.push(thisLine);\n        }\n        return resultLines;\n    }, []);\n\n    var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n    return (raw) ? path : path.serialize();\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3298, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3304, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/connectors/normal.mjs"],"sourcesContent":["import { straight } from './straight.mjs';\n\nexport const normal = function(sourcePoint, targetPoint, route = [], opt = {}) {\n\n    const { raw } = opt;\n    const localOpt = {\n        cornerType: 'point',\n        raw\n    };\n\n    return straight(sourcePoint, targetPoint, route, localOpt);\n};\n"],"names":[],"mappings":";;;AAAA;;AAEO,MAAM,SAAS,SAAS,WAAW,EAAE,WAAW,EAAE,QAAQ,EAAE,EAAE,MAAM,CAAC,CAAC;IAEzE,MAAM,EAAE,GAAG,EAAE,GAAG;IAChB,MAAM,WAAW;QACb,YAAY;QACZ;IACJ;IAEA,OAAO,CAAA,GAAA,iKAAA,CAAA,WAAQ,AAAD,EAAE,aAAa,aAAa,OAAO;AACrD","ignoreList":[0]}},
    {"offset": {"line": 3317, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3323, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/connectors/rounded.mjs"],"sourcesContent":["import { straight } from './straight.mjs';\n\nconst CORNER_RADIUS = 10;\nconst PRECISION = 0;\n\nexport const rounded = function(sourcePoint, targetPoint, route = [], opt = {}) {\n\n    const { radius = CORNER_RADIUS, raw } = opt;\n    const localOpt = {\n        cornerType: 'cubic',\n        cornerRadius: radius,\n        precision: PRECISION,\n        raw\n    };\n\n    return straight(sourcePoint, targetPoint, route, localOpt);\n};\n"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,gBAAgB;AACtB,MAAM,YAAY;AAEX,MAAM,UAAU,SAAS,WAAW,EAAE,WAAW,EAAE,QAAQ,EAAE,EAAE,MAAM,CAAC,CAAC;IAE1E,MAAM,EAAE,SAAS,aAAa,EAAE,GAAG,EAAE,GAAG;IACxC,MAAM,WAAW;QACb,YAAY;QACZ,cAAc;QACd,WAAW;QACX;IACJ;IAEA,OAAO,CAAA,GAAA,iKAAA,CAAA,WAAQ,AAAD,EAAE,aAAa,aAAa,OAAO;AACrD","ignoreList":[0]}},
    {"offset": {"line": 3340, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3346, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/connectors/smooth.mjs"],"sourcesContent":["import * as g from '../g/index.mjs';\n\nexport const smooth = function(sourcePoint, targetPoint, route, opt) {\n\n    var raw = opt && opt.raw;\n    var path;\n\n    if (route && route.length !== 0) {\n\n        var points = [sourcePoint].concat(route).concat([targetPoint]);\n        var curves = g.Curve.throughPoints(points);\n\n        path = new g.Path(curves);\n\n    } else {\n        // if we have no route, use a default cubic bezier curve\n        // cubic bezier requires two control points\n        // the control points have `x` midway between source and target\n        // this produces an S-like curve\n\n        path = new g.Path();\n\n        var segment;\n\n        segment = g.Path.createSegment('M', sourcePoint);\n        path.appendSegment(segment);\n\n        if ((Math.abs(sourcePoint.x - targetPoint.x)) >= (Math.abs(sourcePoint.y - targetPoint.y))) {\n            var controlPointX = (sourcePoint.x + targetPoint.x) / 2;\n\n            segment = g.Path.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y);\n            path.appendSegment(segment);\n\n        } else {\n            var controlPointY = (sourcePoint.y + targetPoint.y) / 2;\n\n            segment = g.Path.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y);\n            path.appendSegment(segment);\n\n        }\n    }\n\n    return (raw) ? path : path.serialize();\n};\n"],"names":[],"mappings":";;;AAAA;;AAEO,MAAM,SAAS,SAAS,WAAW,EAAE,WAAW,EAAE,KAAK,EAAE,GAAG;IAE/D,IAAI,MAAM,OAAO,IAAI,GAAG;IACxB,IAAI;IAEJ,IAAI,SAAS,MAAM,MAAM,KAAK,GAAG;QAE7B,IAAI,SAAS;YAAC;SAAY,CAAC,MAAM,CAAC,OAAO,MAAM,CAAC;YAAC;SAAY;QAC7D,IAAI,SAAS,sJAAE,KAAK,CAAC,aAAa,CAAC;QAEnC,OAAO,IAAI,sJAAE,IAAI,CAAC;IAEtB,OAAO;QACH,wDAAwD;QACxD,2CAA2C;QAC3C,+DAA+D;QAC/D,gCAAgC;QAEhC,OAAO,IAAI,sJAAE,IAAI;QAEjB,IAAI;QAEJ,UAAU,sJAAE,IAAI,CAAC,aAAa,CAAC,KAAK;QACpC,KAAK,aAAa,CAAC;QAEnB,IAAI,AAAC,KAAK,GAAG,CAAC,YAAY,CAAC,GAAG,YAAY,CAAC,KAAO,KAAK,GAAG,CAAC,YAAY,CAAC,GAAG,YAAY,CAAC,GAAI;YACxF,IAAI,gBAAgB,CAAC,YAAY,CAAC,GAAG,YAAY,CAAC,IAAI;YAEtD,UAAU,sJAAE,IAAI,CAAC,aAAa,CAAC,KAAK,eAAe,YAAY,CAAC,EAAE,eAAe,YAAY,CAAC,EAAE,YAAY,CAAC,EAAE,YAAY,CAAC;YAC5H,KAAK,aAAa,CAAC;QAEvB,OAAO;YACH,IAAI,gBAAgB,CAAC,YAAY,CAAC,GAAG,YAAY,CAAC,IAAI;YAEtD,UAAU,sJAAE,IAAI,CAAC,aAAa,CAAC,KAAK,YAAY,CAAC,EAAE,eAAe,YAAY,CAAC,EAAE,eAAe,YAAY,CAAC,EAAE,YAAY,CAAC;YAC5H,KAAK,aAAa,CAAC;QAEvB;IACJ;IAEA,OAAO,AAAC,MAAO,OAAO,KAAK,SAAS;AACxC","ignoreList":[0]}},
    {"offset": {"line": 3383, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3389, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/connectors/curve.mjs"],"sourcesContent":["import { Path, Point, Curve } from '../g/index.mjs';\n\nconst Directions = {\n    AUTO: 'auto',\n    HORIZONTAL: 'horizontal',\n    VERTICAL: 'vertical',\n    CLOSEST_POINT: 'closest-point',\n    OUTWARDS: 'outwards'\n};\n\nconst TangentDirections = {\n    UP: 'up',\n    DOWN: 'down',\n    LEFT: 'left',\n    RIGHT: 'right',\n    AUTO: 'auto',\n    CLOSEST_POINT: 'closest-point',\n    OUTWARDS: 'outwards'\n};\n\nexport const curve = function(sourcePoint, targetPoint, route = [], opt = {}, linkView) {\n    const raw = Boolean(opt.raw);\n    // distanceCoefficient - a coefficient of the tangent vector length relative to the distance between points.\n    // angleTangentCoefficient - a coefficient of the end tangents length in the case of angles larger than 45 degrees.\n    // tension - a Catmull-Rom curve tension parameter.\n    // sourceTangent - a tangent vector along the curve at the sourcePoint.\n    // sourceDirection - a unit direction vector along the curve at the sourcePoint.\n    // targetTangent - a tangent vector along the curve at the targetPoint.\n    // targetDirection - a unit direction vector along the curve at the targetPoint.\n    // precision - a rounding precision for path values.\n    const { direction = Directions.AUTO, precision = 3 } = opt;\n    const options = {\n        coeff: opt.distanceCoefficient || 0.6,\n        angleTangentCoefficient: opt.angleTangentCoefficient || 80,\n        tau: opt.tension || 0.5,\n        sourceTangent: opt.sourceTangent ? new Point(opt.sourceTangent) : null,\n        targetTangent: opt.targetTangent ? new Point(opt.targetTangent) : null,\n        rotate: Boolean(opt.rotate)\n    };\n    if (typeof opt.sourceDirection === 'string')\n        options.sourceDirection = opt.sourceDirection;\n    else if (typeof opt.sourceDirection === 'number')\n        options.sourceDirection = new Point(1, 0).rotate(null, opt.sourceDirection);\n    else\n        options.sourceDirection = opt.sourceDirection ? new Point(opt.sourceDirection).normalize() : null;\n\n    if (typeof opt.targetDirection === 'string')\n        options.targetDirection = opt.targetDirection;\n    else if (typeof opt.targetDirection === 'number')\n        options.targetDirection = new Point(1, 0).rotate(null, opt.targetDirection);\n    else\n        options.targetDirection = opt.targetDirection ? new Point(opt.targetDirection).normalize() : null;\n\n    const completeRoute = [sourcePoint, ...route, targetPoint].map(p => new Point(p));\n\n    // The calculation of a sourceTangent\n    let sourceTangent;\n    if (options.sourceTangent) {\n        sourceTangent = options.sourceTangent;\n    } else {\n        const sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);\n        const tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;\n        const pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();\n        const angle = angleBetweenVectors(sourceDirection, pointsVector);\n        if (angle > Math.PI / 4) {\n            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n            sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);\n        } else {\n            sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);\n        }\n    }\n\n    // The calculation of a targetTangent\n    let targetTangent;\n    if (options.targetTangent) {\n        targetTangent = options.targetTangent;\n    } else {\n        const targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);\n        const last = completeRoute.length - 1;\n        const tangentLength = completeRoute[last - 1].distance(completeRoute[last]) * options.coeff;\n        const pointsVector = completeRoute[last - 1].difference(completeRoute[last]).normalize();\n        const angle = angleBetweenVectors(targetDirection, pointsVector);\n        if (angle > Math.PI / 4) {\n            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n            targetTangent = targetDirection.clone().scale(updatedLength, updatedLength);\n        } else {\n            targetTangent = targetDirection.clone().scale(tangentLength, tangentLength);\n        }\n    }\n\n    const catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);\n    const bezierCurves = catmullRomCurves.map(curve => catmullRomToBezier(curve, options));\n    const path = new Path(bezierCurves).round(precision);\n\n    return (raw) ? path : path.serialize();\n};\ncurve.Directions = Directions;\ncurve.TangentDirections = TangentDirections;\n\nfunction getHorizontalSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        if (sourceBBox.x > route[1].x)\n            sourceSide = 'right';\n        else\n            sourceSide = 'left';\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n\n    let direction;\n    switch (sourceSide) {\n        case 'left':\n            direction = new Point(-1, 0);\n            break;\n        case 'right':\n        default:\n            direction = new Point(1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getHorizontalTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        if (targetBBox.x > route[route.length - 2].x)\n            targetSide = 'left';\n        else\n            targetSide = 'right';\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n\n    let direction;\n    switch (targetSide) {\n        case 'left':\n            direction = new Point(-1, 0);\n            break;\n        case 'right':\n        default:\n            direction = new Point(1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getVerticalSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        if (sourceBBox.y > route[1].y)\n            sourceSide = 'bottom';\n        else\n            sourceSide = 'top';\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n\n    let direction;\n    switch (sourceSide) {\n        case 'top':\n            direction = new Point(0, -1);\n            break;\n        case 'bottom':\n        default:\n            direction = new Point(0, 1);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getVerticalTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        if (targetBBox.y > route[route.length - 2].y)\n            targetSide = 'top';\n        else\n            targetSide = 'bottom';\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n\n\n    let direction;\n    switch (targetSide) {\n        case 'top':\n            direction = new Point(0, -1);\n            break;\n        case 'bottom':\n        default:\n            direction = new Point(0, 1);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getAutoSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        sourceSide = sourceBBox.sideNearestToPoint(route[1]);\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n\n    let direction;\n    switch (sourceSide) {\n        case 'top':\n            direction = new Point(0, -1);\n            break;\n        case 'bottom':\n            direction = new Point(0, 1);\n            break;\n        case 'right':\n            direction = new Point(1, 0);\n            break;\n        case 'left':\n            direction = new Point(-1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getAutoTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n\n    let direction;\n    switch (targetSide) {\n        case 'top':\n            direction = new Point(0, -1);\n            break;\n        case 'bottom':\n            direction = new Point(0, 1);\n            break;\n        case 'right':\n            direction = new Point(1, 0);\n            break;\n        case 'left':\n            direction = new Point(-1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getClosestPointSourceDirection(linkView, route, options) {\n    return route[1].difference(route[0]).normalize();\n}\n\nfunction getClosestPointTargetDirection(linkView, route, options) {\n    const last = route.length - 1;\n    return route[last - 1].difference(route[last]).normalize();\n}\n\nfunction getOutwardsSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n    const sourceCenter = sourceBBox.center();\n    return route[0].difference(sourceCenter).normalize();\n}\n\nfunction getOutwardsTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n    const targetCenter = targetBBox.center();\n    return route[route.length - 1].difference(targetCenter).normalize();\n}\n\nfunction getSourceTangentDirection(linkView, route, direction, options) {\n    if (options.sourceDirection) {\n        switch (options.sourceDirection) {\n            case TangentDirections.UP:\n                return new Point(0, -1);\n            case TangentDirections.DOWN:\n                return new Point(0, 1);\n            case TangentDirections.LEFT:\n                return new Point(-1, 0);\n            case TangentDirections.RIGHT:\n                return new Point(1, 0);\n            case TangentDirections.AUTO:\n                return getAutoSourceDirection(linkView, route, options);\n            case TangentDirections.CLOSEST_POINT:\n                return getClosestPointSourceDirection(linkView, route, options);\n            case TangentDirections.OUTWARDS:\n                return getOutwardsSourceDirection(linkView, route, options);\n            default:\n                return options.sourceDirection;\n        }\n    }\n\n    switch (direction) {\n        case Directions.HORIZONTAL:\n            return getHorizontalSourceDirection(linkView, route, options);\n        case Directions.VERTICAL:\n            return getVerticalSourceDirection(linkView, route, options);\n        case Directions.CLOSEST_POINT:\n            return getClosestPointSourceDirection(linkView, route, options);\n        case Directions.OUTWARDS:\n            return getOutwardsSourceDirection(linkView, route, options);\n        case Directions.AUTO:\n        default:\n            return getAutoSourceDirection(linkView, route, options);\n    }\n}\n\nfunction getTargetTangentDirection(linkView, route, direction, options) {\n    if (options.targetDirection) {\n        switch (options.targetDirection) {\n            case TangentDirections.UP:\n                return new Point(0, -1);\n            case TangentDirections.DOWN:\n                return new Point(0, 1);\n            case TangentDirections.LEFT:\n                return new Point(-1, 0);\n            case TangentDirections.RIGHT:\n                return new Point(1, 0);\n            case TangentDirections.AUTO:\n                return getAutoTargetDirection(linkView, route, options);\n            case TangentDirections.CLOSEST_POINT:\n                return getClosestPointTargetDirection(linkView, route, options);\n            case TangentDirections.OUTWARDS:\n                return getOutwardsTargetDirection(linkView, route, options);\n            default:\n                return options.targetDirection;\n        }\n    }\n\n    switch (direction) {\n        case Directions.HORIZONTAL:\n            return getHorizontalTargetDirection(linkView, route, options);\n        case Directions.VERTICAL:\n            return getVerticalTargetDirection(linkView, route, options);\n        case Directions.CLOSEST_POINT:\n            return getClosestPointTargetDirection(linkView, route, options);\n        case Directions.OUTWARDS:\n            return getOutwardsTargetDirection(linkView, route, options);\n        case Directions.AUTO:\n        default:\n            return getAutoTargetDirection(linkView, route, options);\n    }\n}\n\nfunction rotateVector(vector, angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = cos * vector.x - sin * vector.y;\n    const y = sin * vector.x + cos * vector.y;\n    vector.x = x;\n    vector.y = y;\n}\n\nfunction angleBetweenVectors(v1, v2) {\n    let cos = v1.dot(v2) / (v1.magnitude() * v2.magnitude());\n    if (cos < -1) cos = -1;\n    if (cos > 1) cos = 1;\n    return Math.acos(cos);\n}\n\nfunction determinant(v1, v2) {\n    return v1.x * v2.y - v1.y * v2.x;\n}\n\nfunction createCatmullRomCurves(points, sourceTangent, targetTangent, options) {\n    const { tau, coeff } = options;\n    const distances = [];\n    const tangents = [];\n    const catmullRomCurves = [];\n    const n = points.length - 1;\n\n    for (let i = 0; i < n; i++) {\n        distances[i] = points[i].distance(points[i + 1]);\n    }\n\n    tangents[0] = sourceTangent;\n    tangents[n] = targetTangent;\n\n    // The calculation of tangents of vertices\n    for (let i = 1; i < n; i++) {\n        let tpPrev;\n        let tpNext;\n        if (i === 1) {\n            tpPrev = points[i - 1].clone().offset(tangents[i - 1].x, tangents[i - 1].y);\n        } else {\n            tpPrev = points[i - 1].clone();\n        }\n        if (i === n - 1) {\n            tpNext = points[i + 1].clone().offset(tangents[i + 1].x, tangents[i + 1].y);\n        } else {\n            tpNext = points[i + 1].clone();\n        }\n        const v1 = tpPrev.difference(points[i]).normalize();\n        const v2 = tpNext.difference(points[i]).normalize();\n        const vAngle = angleBetweenVectors(v1, v2);\n\n        let rot = (Math.PI - vAngle) / 2;\n        let t;\n        const vectorDeterminant = determinant(v1, v2);\n        let pointsDeterminant;\n        pointsDeterminant = determinant(points[i].difference(points[i + 1]), points[i].difference(points[i - 1]));\n        if (vectorDeterminant < 0) {\n            rot = -rot;\n        }\n        if ((vAngle < Math.PI / 2) && ((rot < 0 && pointsDeterminant < 0) || (rot > 0 && pointsDeterminant > 0))) {\n            rot = rot - Math.PI;\n        }\n        t = v2.clone();\n        rotateVector(t, rot);\n\n        const t1 = t.clone();\n        const t2 = t.clone();\n        const scaleFactor1 = distances[i - 1] * coeff;\n        const scaleFactor2 = distances[i] * coeff;\n        t1.scale(scaleFactor1, scaleFactor1);\n        t2.scale(scaleFactor2, scaleFactor2);\n\n        tangents[i] = [t1, t2];\n    }\n\n    // The building of a Catmull-Rom curve based of tangents of points\n    for (let i = 0; i < n; i++) {\n        let p0;\n        let p3;\n        if (i === 0) {\n            p0 = points[i + 1].difference(tangents[i].x / tau, tangents[i].y / tau);\n        } else {\n            p0 = points[i + 1].difference(tangents[i][1].x / tau, tangents[i][1].y / tau);\n        }\n        if (i === n - 1) {\n            p3 = points[i].clone().offset(tangents[i + 1].x / tau, tangents[i + 1].y / tau);\n        } else {\n            p3 = points[i].difference(tangents[i + 1][0].x / tau, tangents[i + 1][0].y / tau);\n        }\n\n        catmullRomCurves[i] = [p0, points[i], points[i + 1], p3];\n    }\n    return catmullRomCurves;\n}\n\n// The function to convert Catmull-Rom curve to Bezier curve using the tension (tau)\nfunction catmullRomToBezier(points, options) {\n    const { tau } = options;\n\n    const bcp1 = new Point();\n    bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);\n    bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);\n\n    const bcp2 = new Point();\n    bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);\n    bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);\n    return new Curve(\n        points[1],\n        bcp1,\n        bcp2,\n        points[2]\n    );\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3878, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3921, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 3927, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3941, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/highlighters/stroke.mjs"],"sourcesContent":["import { assign } from '../util/index.mjs';\nimport V from '../V/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\n\nexport const stroke = HighlighterView.extend({\n\n    tagName: 'path',\n    className: 'highlight-stroke',\n    attributes: {\n        'pointer-events': 'none',\n        'fill': 'none'\n    },\n\n    options: {\n        padding: 3,\n        rx: 0,\n        ry: 0,\n        useFirstSubpath: false,\n        attrs: {\n            'stroke-width': 3,\n            'stroke': '#FEB663'\n        }\n    },\n\n    getPathData(cellView, node) {\n        const { options } = this;\n        const { useFirstSubpath } = options;\n        let d;\n        try {\n            const vNode = V(node);\n            d = vNode.convertToPathData().trim();\n            if (vNode.tagName() === 'PATH' && useFirstSubpath) {\n                const secondSubpathIndex = d.search(/.M/i) + 1;\n                if (secondSubpathIndex > 0) {\n                    d = d.substr(0, secondSubpathIndex);\n                }\n            }\n        } catch (error) {\n            // Failed to get path data from magnet element.\n            // Draw a rectangle around the node instead.\n            const nodeBBox = cellView.getNodeBoundingRect(node);\n            d = V.rectToPath(assign({}, options, nodeBBox.toJSON()));\n        }\n        return d;\n    },\n\n    highlightConnection(cellView) {\n        this.vel.attr('d', cellView.getSerializedConnection());\n    },\n\n    highlightNode(cellView, node) {\n        const { vel, options } = this;\n        const { padding, layer } = options;\n        let highlightMatrix = this.getNodeMatrix(cellView, node);\n        // Add padding to the highlight element.\n        if (padding) {\n            if (!layer && node === cellView.el) {\n                // If the highlighter is appended to the cellView\n                // and we measure the size of the cellView wrapping group\n                // it's necessary to remove the highlighter first\n                vel.remove();\n            }\n            let nodeBBox = cellView.getNodeBoundingRect(node);\n            const cx = nodeBBox.x + (nodeBBox.width / 2);\n            const cy = nodeBBox.y + (nodeBBox.height / 2);\n            nodeBBox = V.transformRect(nodeBBox, highlightMatrix);\n            const width = Math.max(nodeBBox.width, 1);\n            const height = Math.max(nodeBBox.height, 1);\n            const sx = (width + padding) / width;\n            const sy = (height + padding) / height;\n            const paddingMatrix = V.createSVGMatrix({\n                a: sx,\n                b: 0,\n                c: 0,\n                d: sy,\n                e: cx - sx * cx,\n                f: cy - sy * cy\n            });\n            highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n        }\n        vel.attr({\n            'd': this.getPathData(cellView, node),\n            'transform': V.matrixToTransformString(highlightMatrix)\n        });\n    },\n\n    highlight(cellView, node) {\n        const { vel, options } = this;\n        vel.attr(options.attrs);\n        if (options.nonScalingStroke) {\n            vel.attr('vector-effect', 'non-scaling-stroke');\n        }\n        if (cellView.isNodeConnection(node)) {\n            this.highlightConnection(cellView);\n        } else {\n            this.highlightNode(cellView, node);\n        }\n    }\n\n});\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4039, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4045, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/highlighters/mask.mjs"],"sourcesContent":["import V from '../V/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\n\nconst MASK_CLIP = 20;\n\nfunction forEachDescendant(vel, fn) {\n    const descendants = vel.children();\n    while (descendants.length > 0) {\n        const descendant = descendants.shift();\n        if (fn(descendant)) {\n            descendants.push(...descendant.children());\n        }\n    }\n}\n\nexport const mask = HighlighterView.extend({\n\n    tagName: 'rect',\n    className: 'highlight-mask',\n    attributes: {\n        'pointer-events': 'none'\n    },\n\n    options: {\n        padding: 3,\n        maskClip: MASK_CLIP,\n        deep: false,\n        attrs: {\n            'stroke': '#FEB663',\n            'stroke-width': 3,\n            'stroke-linecap': 'butt',\n            'stroke-linejoin': 'miter',\n        }\n    },\n\n    VISIBLE: 'white',\n    INVISIBLE: 'black',\n\n    MASK_ROOT_ATTRIBUTE_BLACKLIST: [\n        'marker-start',\n        'marker-end',\n        'marker-mid',\n        'transform',\n        'stroke-dasharray',\n        'class',\n    ],\n\n    MASK_CHILD_ATTRIBUTE_BLACKLIST: [\n        'stroke',\n        'fill',\n        'stroke-width',\n        'stroke-opacity',\n        'stroke-dasharray',\n        'fill-opacity',\n        'marker-start',\n        'marker-end',\n        'marker-mid',\n        'class',\n    ],\n\n    // TODO: change the list to a function callback\n    MASK_REPLACE_TAGS: [\n        'FOREIGNOBJECT',\n        'IMAGE',\n        'USE',\n        'TEXT',\n        'TSPAN',\n        'TEXTPATH'\n    ],\n\n    // TODO: change the list to a function callback\n    MASK_REMOVE_TAGS: [\n        'TEXT',\n        'TSPAN',\n        'TEXTPATH'\n    ],\n\n    transformMaskChild(cellView, childEl) {\n        const {\n            MASK_CHILD_ATTRIBUTE_BLACKLIST,\n            MASK_REPLACE_TAGS,\n            MASK_REMOVE_TAGS\n        } = this;\n        const childTagName = childEl.tagName();\n        // Do not include the element in the mask's image\n        if (!V.isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {\n            childEl.remove();\n            return false;\n        }\n        // Replace the element with a rectangle\n        if (MASK_REPLACE_TAGS.includes(childTagName)) {\n            // Note: clone() method does not change the children ids\n            const originalChild = cellView.vel.findOne(`#${childEl.id}`);\n            if (originalChild) {\n                const { node: originalNode } = originalChild;\n                let childBBox = cellView.getNodeBoundingRect(originalNode);\n                if (cellView.model.isElement()) {\n                    childBBox = V.transformRect(childBBox, cellView.getNodeMatrix(originalNode));\n                }\n                const replacement = V('rect', childBBox.toJSON());\n                const { x: ox, y: oy } = childBBox.center();\n                const { angle, cx = ox, cy = oy } = originalChild.rotate();\n                if (angle) replacement.rotate(angle, cx, cy);\n                // Note: it's not important to keep the same sibling index since all subnodes are filled\n                childEl.parent().append(replacement);\n            }\n            childEl.remove();\n            return false;\n        }\n        // Keep the element, but clean it from certain attributes\n        MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n            if (attrName === 'fill' && childEl.attr('fill') === 'none') return;\n            childEl.removeAttr(attrName);\n        });\n        return true;\n    },\n\n    transformMaskRoot(_cellView, rootEl) {\n        const { MASK_ROOT_ATTRIBUTE_BLACKLIST } = this;\n        MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n            rootEl.removeAttr(attrName);\n        });\n    },\n\n    getMaskShape(cellView, vel) {\n        const { options, MASK_REPLACE_TAGS } = this;\n        const { deep } = options;\n        const tagName = vel.tagName();\n        let maskRoot;\n        if (tagName === 'G') {\n            if (!deep) return null;\n            maskRoot = vel.clone();\n            forEachDescendant(maskRoot, maskChild => this.transformMaskChild(cellView, maskChild));\n        } else {\n            if (MASK_REPLACE_TAGS.includes(tagName)) return null;\n            maskRoot = vel.clone();\n        }\n        this.transformMaskRoot(cellView, maskRoot);\n        return maskRoot;\n    },\n\n    getMaskId() {\n        return `highlight-mask-${this.cid}`;\n    },\n\n    getMask(cellView, vNode) {\n\n        const { VISIBLE, INVISIBLE, options } = this;\n        const { padding, attrs } = options;\n        // support both `strokeWidth` and `stroke-width` attribute names\n        const strokeWidth = parseFloat(V('g').attr(attrs).attr('stroke-width'));\n        const hasNodeFill = vNode.attr('fill') !== 'none';\n        let magnetStrokeWidth = parseFloat(vNode.attr('stroke-width'));\n        if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1;\n        // stroke of the invisible shape\n        const minStrokeWidth = magnetStrokeWidth + padding * 2;\n        // stroke of the visible shape\n        const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;\n        let maskEl = this.getMaskShape(cellView, vNode);\n        if (!maskEl) {\n            const nodeBBox = cellView.getNodeBoundingRect(vNode.node);\n            // Make sure the rect is visible\n            nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);\n            maskEl =  V('rect', nodeBBox.toJSON());\n        }\n        maskEl.attr(attrs);\n        return V('mask', {\n            'id': this.getMaskId()\n        }).append([\n            maskEl.clone().attr({\n                'fill': hasNodeFill ? VISIBLE : 'none',\n                'stroke': VISIBLE,\n                'stroke-width': maxStrokeWidth\n            }),\n            maskEl.clone().attr({\n                'fill': hasNodeFill ? INVISIBLE : 'none',\n                'stroke': INVISIBLE,\n                'stroke-width': minStrokeWidth\n            })\n        ]);\n    },\n\n    removeMask(paper) {\n        const maskNode = paper.svg.getElementById(this.getMaskId());\n        if (maskNode) {\n            paper.defs.removeChild(maskNode);\n        }\n    },\n\n    addMask(paper, maskEl) {\n        paper.defs.appendChild(maskEl.node);\n    },\n\n    highlight(cellView, node) {\n        const { options, vel } = this;\n        const { padding, attrs, maskClip = MASK_CLIP, layer } = options;\n        const color = ('stroke' in attrs) ? attrs['stroke'] : '#000000';\n        if (!layer && node === cellView.el) {\n            // If the highlighter is appended to the cellView\n            // and we measure the size of the cellView wrapping group\n            // it's necessary to remove the highlighter first\n            vel.remove();\n        }\n        const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);\n        const highlightMatrix = this.getNodeMatrix(cellView, node);\n        const maskEl = this.getMask(cellView, V(node));\n        this.addMask(cellView.paper, maskEl);\n        vel.attr(highlighterBBox.toJSON());\n        vel.attr({\n            'transform': V.matrixToTransformString(highlightMatrix),\n            'mask': `url(#${maskEl.id})`,\n            'fill': color\n        });\n    },\n\n    unhighlight(cellView) {\n        this.removeMask(cellView.paper);\n    }\n\n});\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4245, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4251, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/highlighters/opacity.mjs"],"sourcesContent":["import { HighlighterView } from '../dia/HighlighterView.mjs';\n\nexport const opacity = HighlighterView.extend({\n\n    UPDATABLE: false,\n    MOUNTABLE: false,\n\n    highlight: function(_cellView, node) {\n        const { alphaValue = 0.3 } = this.options;\n        node.style.opacity = alphaValue;\n    },\n\n    unhighlight: function(_cellView, node) {\n        node.style.opacity = '';\n    }\n\n});\n"],"names":[],"mappings":";;;AAAA;;AAEO,MAAM,UAAU,iKAAA,CAAA,kBAAe,CAAC,MAAM,CAAC;IAE1C,WAAW;IACX,WAAW;IAEX,WAAW,SAAS,SAAS,EAAE,IAAI;QAC/B,MAAM,EAAE,aAAa,GAAG,EAAE,GAAG,IAAI,CAAC,OAAO;QACzC,KAAK,KAAK,CAAC,OAAO,GAAG;IACzB;IAEA,aAAa,SAAS,SAAS,EAAE,IAAI;QACjC,KAAK,KAAK,CAAC,OAAO,GAAG;IACzB;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 4267, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4273, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/highlighters/addClass.mjs"],"sourcesContent":["import * as util from '../util/index.mjs';\nimport V from '../V/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\n\nconst className = util.addClassNamePrefix('highlighted');\n\nexport const addClass = HighlighterView.extend({\n\n    UPDATABLE: false,\n    MOUNTABLE: false,\n\n    options: {\n        className\n    },\n\n    highlight: function(_cellView, node) {\n        V(node).addClass(this.options.className);\n    },\n\n    unhighlight: function(_cellView, node) {\n        V(node).removeClass(this.options.className);\n    }\n\n}, {\n    // Backwards Compatibility\n    className\n});\n"],"names":[],"mappings":";;;AAAA;AAEA;AADA;;;;AAGA,MAAM,YAAY,yJAAK,kBAAkB,CAAC;AAEnC,MAAM,WAAW,iKAAA,CAAA,kBAAe,CAAC,MAAM,CAAC;IAE3C,WAAW;IACX,WAAW;IAEX,SAAS;QACL;IACJ;IAEA,WAAW,SAAS,SAAS,EAAE,IAAI;QAC/B,CAAA,GAAA,qJAAA,CAAA,UAAC,AAAD,EAAE,MAAM,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS;IAC3C;IAEA,aAAa,SAAS,SAAS,EAAE,IAAI;QACjC,CAAA,GAAA,qJAAA,CAAA,UAAC,AAAD,EAAE,MAAM,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS;IAC9C;AAEJ,GAAG;IACC,0BAA0B;IAC1B;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4299, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4305, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/highlighters/list.mjs"],"sourcesContent":["import { Rect } from '../g/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\nimport {\n    normalizeSides,\n    isEqual,\n} from '../util/index.mjs';\nimport {\n    Positions,\n    getRectPoint,\n} from '../util/getRectPoint.mjs';\n\nconst Directions = {\n    ROW: 'row',\n    COLUMN: 'column'\n};\n\nexport const list = HighlighterView.extend({\n\n    tagName: 'g',\n    MOUNTABLE: true,\n    UPDATE_ATTRIBUTES: function() {\n        return [this.options.attribute];\n    },\n\n    _prevItems: null,\n\n    highlight(elementView, node) {\n        const element = elementView.model;\n        const { attribute, size = 20, gap = 5, direction = Directions.ROW } = this.options;\n        if (!attribute) throw new Error('List: attribute is required');\n        const normalizedSize = (typeof size === 'number') ? { width: size, height: size } : size;\n        const isRowDirection = (direction === Directions.ROW);\n        const itemWidth = isRowDirection ? normalizedSize.width : normalizedSize.height;\n        let items = element.get(attribute);\n        if (!Array.isArray(items)) items = [];\n        const prevItems = this._prevItems || [];\n        const comparison = items.map((item, index) => isEqual(prevItems[index], items[index]));\n        if (prevItems.length !== items.length || comparison.some(unchanged => !unchanged)) {\n            const prevEls = this.vel.children();\n            const itemsEls = items.map((item, index) => {\n                const prevEl = (index in prevEls) ? prevEls[index].node : null;\n                if (comparison[index]) return prevEl;\n                const itemEl = this.createListItem(item, normalizedSize, prevEl);\n                if (!itemEl) return null;\n                if (!(itemEl instanceof SVGElement)) throw new Error('List: item must be an SVGElement');\n                itemEl.dataset.index = index;\n                itemEl.dataset.attribute = attribute;\n                const offset = index * (itemWidth + gap);\n                itemEl.setAttribute('transform', (isRowDirection)\n                    ? `translate(${offset}, 0)`\n                    : `translate(0, ${offset})`\n                );\n                return itemEl;\n            });\n            this.vel.empty().append(itemsEls);\n            this._prevItems = items;\n        }\n        const itemsCount = items.length;\n        const length = (itemsCount === 0)\n            ? 0\n            : (itemsCount * itemWidth + (itemsCount - 1) * gap);\n        const listSize = (isRowDirection)\n            ? { width: length, height: normalizedSize.height }\n            : { width: normalizedSize.width, height: length };\n\n        this.position(element, listSize);\n    },\n\n    position(element, listSize) {\n        const { vel, options } = this;\n        const { margin = 5, position = 'top-left' } = options;\n        const { width, height } = element.size();\n        const { left, right, top, bottom } = normalizeSides(margin);\n        const bbox = new Rect(left, top, width - (left + right), height - (top + bottom));\n        let { x, y } = getRectPoint(bbox, position);\n        // x\n        switch (position) {\n            case Positions.CENTER:\n            case Positions.TOP:\n            case Positions.BOTTOM: {\n                x -= listSize.width / 2;\n                break;\n            }\n            case Positions.RIGHT:\n            case Positions.BOTTOM_RIGHT:\n            case Positions.TOP_RIGHT: {\n                x -= listSize.width;\n                break;\n            }\n        }\n        // y\n        switch (position) {\n            case Positions.CENTER:\n            case Positions.RIGHT:\n            case Positions.LEFT: {\n                y -= listSize.height / 2;\n                break;\n            }\n            case Positions.BOTTOM:\n            case Positions.BOTTOM_RIGHT:\n            case Positions.BOTTOM_LEFT: {\n                y -= listSize.height;\n                break;\n            }\n        }\n        vel.attr('transform', `translate(${x}, ${y})`);\n    }\n}, {\n    Directions,\n    Positions\n});\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4419, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4459, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/linkAnchors/index.mjs"],"sourcesContent":["import { Line, Point } from '../g/index.mjs';\nimport { isPercentage } from '../util/index.mjs';\n\nfunction connectionRatio(view, _magnet, _refPoint, opt) {\n\n    var ratio = ('ratio' in opt) ? opt.ratio : 0.5;\n    return view.getPointAtRatio(ratio);\n}\n\nfunction connectionLength(view, _magnet, _refPoint, opt) {\n\n    var length = ('length' in opt) ? opt.length : 20;\n    return view.getPointAtLength(length);\n}\n\nfunction _connectionPerpendicular(view, _magnet, refPoint, opt) {\n\n    var OFFSET = 1e6;\n    var path = view.getConnection();\n    var segmentSubdivisions = view.getConnectionSubdivisions();\n    var verticalLine = new Line(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));\n    var horizontalLine = new Line(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));\n    var verticalIntersections = verticalLine.intersect(path, { segmentSubdivisions: segmentSubdivisions });\n    var horizontalIntersections = horizontalLine.intersect(path, { segmentSubdivisions: segmentSubdivisions });\n    var intersections = [];\n    if (verticalIntersections) Array.prototype.push.apply(intersections, verticalIntersections);\n    if (horizontalIntersections) Array.prototype.push.apply(intersections, horizontalIntersections);\n    if (intersections.length > 0) return refPoint.chooseClosest(intersections);\n    if ('fallbackAt' in opt) {\n        return getPointAtLink(view, opt.fallbackAt);\n    }\n    return connectionClosest(view, _magnet, refPoint, opt);\n}\n\nfunction _connectionClosest(view, _magnet, refPoint, _opt) {\n\n    var closestPoint = view.getClosestPoint(refPoint);\n    if (!closestPoint) return new Point();\n    return closestPoint;\n}\n\nexport function resolveRef(fn) {\n    return function(view, magnet, ref, opt) {\n        if (ref instanceof Element) {\n            var refView = this.paper.findView(ref);\n            var refPoint;\n            if (refView) {\n                if (refView.isNodeConnection(ref)) {\n                    var distance = ('fixedAt' in opt) ? opt.fixedAt : '50%';\n                    refPoint = getPointAtLink(refView, distance);\n                } else {\n                    refPoint = refView.getNodeBBox(ref).center();\n                }\n            } else {\n                // Something went wrong\n                refPoint = new Point();\n            }\n            return fn.call(this, view, magnet, refPoint, opt);\n        }\n        return fn.apply(this, arguments);\n    };\n}\n\nfunction getPointAtLink(view, value) {\n    var parsedValue = parseFloat(value);\n    if (isPercentage(value)) {\n        return view.getPointAtRatio(parsedValue / 100);\n    } else {\n        return view.getPointAtLength(parsedValue);\n    }\n}\n\n// joint.linkAnchors\nexport { connectionRatio, connectionLength };\nexport const connectionPerpendicular = resolveRef(_connectionPerpendicular);\nexport const connectionClosest = resolveRef(_connectionClosest);\n"],"names":[],"mappings":";;;;;;;AAAA;AAAA;AACA;;;AAEA,SAAS,gBAAgB,IAAI,EAAE,OAAO,EAAE,SAAS,EAAE,GAAG;IAElD,IAAI,QAAQ,AAAC,WAAW,MAAO,IAAI,KAAK,GAAG;IAC3C,OAAO,KAAK,eAAe,CAAC;AAChC;AAEA,SAAS,iBAAiB,IAAI,EAAE,OAAO,EAAE,SAAS,EAAE,GAAG;IAEnD,IAAI,SAAS,AAAC,YAAY,MAAO,IAAI,MAAM,GAAG;IAC9C,OAAO,KAAK,gBAAgB,CAAC;AACjC;AAEA,SAAS,yBAAyB,IAAI,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAG;IAE1D,IAAI,SAAS;IACb,IAAI,OAAO,KAAK,aAAa;IAC7B,IAAI,sBAAsB,KAAK,yBAAyB;IACxD,IAAI,eAAe,IAAI,oJAAA,CAAA,OAAI,CAAC,SAAS,KAAK,GAAG,MAAM,CAAC,GAAG,SAAS,SAAS,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC;IAC5F,IAAI,iBAAiB,IAAI,oJAAA,CAAA,OAAI,CAAC,SAAS,KAAK,GAAG,MAAM,CAAC,QAAQ,IAAI,SAAS,KAAK,GAAG,MAAM,CAAC,CAAC,QAAQ;IACnG,IAAI,wBAAwB,aAAa,SAAS,CAAC,MAAM;QAAE,qBAAqB;IAAoB;IACpG,IAAI,0BAA0B,eAAe,SAAS,CAAC,MAAM;QAAE,qBAAqB;IAAoB;IACxG,IAAI,gBAAgB,EAAE;IACtB,IAAI,uBAAuB,MAAM,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe;IACrE,IAAI,yBAAyB,MAAM,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe;IACvE,IAAI,cAAc,MAAM,GAAG,GAAG,OAAO,SAAS,aAAa,CAAC;IAC5D,IAAI,gBAAgB,KAAK;QACrB,OAAO,eAAe,MAAM,IAAI,UAAU;IAC9C;IACA,OAAO,kBAAkB,MAAM,SAAS,UAAU;AACtD;AAEA,SAAS,mBAAmB,IAAI,EAAE,OAAO,EAAE,QAAQ,EAAE,IAAI;IAErD,IAAI,eAAe,KAAK,eAAe,CAAC;IACxC,IAAI,CAAC,cAAc,OAAO,IAAI,qJAAA,CAAA,QAAK;IACnC,OAAO;AACX;AAEO,SAAS,WAAW,EAAE;IACzB,OAAO,SAAS,IAAI,EAAE,MAAM,EAAE,GAAG,EAAE,GAAG;QAClC,IAAI,eAAe,SAAS;YACxB,IAAI,UAAU,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;YAClC,IAAI;YACJ,IAAI,SAAS;gBACT,IAAI,QAAQ,gBAAgB,CAAC,MAAM;oBAC/B,IAAI,WAAW,AAAC,aAAa,MAAO,IAAI,OAAO,GAAG;oBAClD,WAAW,eAAe,SAAS;gBACvC,OAAO;oBACH,WAAW,QAAQ,WAAW,CAAC,KAAK,MAAM;gBAC9C;YACJ,OAAO;gBACH,uBAAuB;gBACvB,WAAW,IAAI,qJAAA,CAAA,QAAK;YACxB;YACA,OAAO,GAAG,IAAI,CAAC,IAAI,EAAE,MAAM,QAAQ,UAAU;QACjD;QACA,OAAO,GAAG,KAAK,CAAC,IAAI,EAAE;IAC1B;AACJ;AAEA,SAAS,eAAe,IAAI,EAAE,KAAK;IAC/B,IAAI,cAAc,WAAW;IAC7B,IAAI,CAAA,GAAA,uKAAA,CAAA,eAAY,AAAD,EAAE,QAAQ;QACrB,OAAO,KAAK,eAAe,CAAC,cAAc;IAC9C,OAAO;QACH,OAAO,KAAK,gBAAgB,CAAC;IACjC;AACJ;;AAIO,MAAM,0BAA0B,WAAW;AAC3C,MAAM,oBAAoB,WAAW","ignoreList":[0]}},
    {"offset": {"line": 4537, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4543, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/anchors/index.mjs"],"sourcesContent":["import * as util from '../util/index.mjs';\nimport { toRad } from '../g/index.mjs';\nimport { resolveRef } from '../linkAnchors/index.mjs';\n\nfunction bboxWrapper(method) {\n\n    return function(view, magnet, ref, opt) {\n\n        var rotate = !!opt.rotate;\n        var bbox = (rotate) ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);\n        var anchor = bbox[method]();\n\n        var dx = opt.dx;\n        if (dx) {\n            var dxPercentage = util.isPercentage(dx);\n            dx = parseFloat(dx);\n            if (isFinite(dx)) {\n                if (dxPercentage) {\n                    dx /= 100;\n                    dx *= bbox.width;\n                }\n                anchor.x += dx;\n            }\n        }\n\n        var dy = opt.dy;\n        if (dy) {\n            var dyPercentage = util.isPercentage(dy);\n            dy = parseFloat(dy);\n            if (isFinite(dy)) {\n                if (dyPercentage) {\n                    dy /= 100;\n                    dy *= bbox.height;\n                }\n                anchor.y += dy;\n            }\n        }\n\n        return (rotate) ? anchor.rotate(view.model.getBBox().center(), -view.model.angle()) : anchor;\n    };\n}\n\nfunction _perpendicular(view, magnet, refPoint, opt) {\n\n    var angle = view.model.angle();\n    var bbox = view.getNodeBBox(magnet);\n    var anchor = bbox.center();\n    var topLeft = bbox.origin();\n    var bottomRight = bbox.corner();\n\n    var padding = opt.padding;\n    if (!isFinite(padding)) padding = 0;\n\n    if ((topLeft.y + padding) <= refPoint.y && refPoint.y <= (bottomRight.y - padding)) {\n        var dy = (refPoint.y - anchor.y);\n        anchor.x += (angle === 0 || angle === 180) ? 0 : dy * 1 / Math.tan(toRad(angle));\n        anchor.y += dy;\n    } else if ((topLeft.x + padding) <= refPoint.x && refPoint.x <= (bottomRight.x - padding)) {\n        var dx = (refPoint.x - anchor.x);\n        anchor.y += (angle === 90 || angle === 270) ? 0 : dx * Math.tan(toRad(angle));\n        anchor.x += dx;\n    }\n\n    return anchor;\n}\n\nfunction _midSide(view, magnet, refPoint, opt) {\n\n    var rotate = !!opt.rotate;\n    var bbox, angle, center;\n    if (rotate) {\n        bbox = view.getNodeUnrotatedBBox(magnet);\n        center = view.model.getBBox().center();\n        angle = view.model.angle();\n    } else {\n        bbox = view.getNodeBBox(magnet);\n    }\n\n    var padding = opt.padding;\n    if (isFinite(padding)) bbox.inflate(padding);\n\n    if (rotate) refPoint.rotate(center, angle);\n\n    var side = bbox.sideNearestToPoint(refPoint);\n    var anchor;\n    switch (side) {\n        case 'left':\n            anchor = bbox.leftMiddle();\n            break;\n        case 'right':\n            anchor = bbox.rightMiddle();\n            break;\n        case 'top':\n            anchor = bbox.topMiddle();\n            break;\n        case 'bottom':\n            anchor = bbox.bottomMiddle();\n            break;\n    }\n\n    return (rotate) ? anchor.rotate(center, -angle) : anchor;\n}\n\n// Can find anchor from model, when there is no selector or the link end\n// is connected to a port\nfunction _modelCenter(view, _magnet, _refPoint, opt, endType) {\n    return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);\n}\n\n//joint.anchors\nexport const center = bboxWrapper('center');\nexport const top = bboxWrapper('topMiddle');\nexport const bottom = bboxWrapper('bottomMiddle');\nexport const left = bboxWrapper('leftMiddle');\nexport const right = bboxWrapper('rightMiddle');\nexport const topLeft = bboxWrapper('origin');\nexport const topRight = bboxWrapper('topRight');\nexport const bottomLeft = bboxWrapper('bottomLeft');\nexport const bottomRight = bboxWrapper('corner');\nexport const perpendicular = resolveRef(_perpendicular);\nexport const midSide = resolveRef(_midSide);\nexport const modelCenter = _modelCenter;\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4662, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4668, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/connectionPoints/index.mjs"],"sourcesContent":["import * as g from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport * as util from '../util/index.mjs';\n\nfunction offsetPoint(p1, p2, offset) {\n    if (util.isPlainObject(offset)) {\n        const { x, y } = offset;\n        if (isFinite(y)) {\n            const line =  new g.Line(p2, p1);\n            const { start, end } = line.parallel(y);\n            p2 = start;\n            p1 = end;\n        }\n        offset = x;\n    }\n    if (!isFinite(offset)) return p1;\n    var length = p1.distance(p2);\n    if (offset === 0 && length > 0) return p1;\n    return p1.move(p2, -Math.min(offset, length - 1));\n}\n\nfunction stroke(magnet) {\n\n    var stroke = magnet.getAttribute('stroke-width');\n    if (stroke === null) return 0;\n    return parseFloat(stroke) || 0;\n}\n\nfunction alignLine(line, type, offset = 0) {\n    let coordinate, a, b, direction;\n    const { start, end } = line;\n    switch (type) {\n        case 'left':\n            coordinate = 'x';\n            a = end;\n            b = start;\n            direction = -1;\n            break;\n        case 'right':\n            coordinate = 'x';\n            a = start;\n            b = end;\n            direction = 1;\n            break;\n        case 'top':\n            coordinate = 'y';\n            a = end;\n            b = start;\n            direction = -1;\n            break;\n        case 'bottom':\n            coordinate = 'y';\n            a = start;\n            b = end;\n            direction = 1;\n            break;\n        default:\n            return;\n    }\n    if (start[coordinate] < end[coordinate]) {\n        a[coordinate] = b[coordinate];\n    } else {\n        b[coordinate] = a[coordinate];\n    }\n    if (isFinite(offset)) {\n        a[coordinate] += direction * offset;\n        b[coordinate] += direction * offset;\n    }\n}\n\n// Connection Points\n\nfunction anchorConnectionPoint(line, _view, _magnet, opt) {\n    let { offset, alignOffset, align } = opt;\n    if (align) alignLine(line, align, alignOffset);\n    return offsetPoint(line.end, line.start, offset);\n}\n\nfunction bboxIntersection(line, view, magnet, opt) {\n\n    var bbox = view.getNodeBBox(magnet);\n    if (opt.stroke) bbox.inflate(stroke(magnet) / 2);\n    var intersections = line.intersect(bbox);\n    var cp = (intersections)\n        ? line.start.chooseClosest(intersections)\n        : line.end;\n    return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction rectangleIntersection(line, view, magnet, opt) {\n\n    var angle = view.model.angle();\n    if (angle === 0) {\n        return bboxIntersection(line, view, magnet, opt);\n    }\n\n    var bboxWORotation = view.getNodeUnrotatedBBox(magnet);\n    if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);\n    var center = bboxWORotation.center();\n    var lineWORotation = line.clone().rotate(center, angle);\n    var intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);\n    var cp = (intersections)\n        ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle)\n        : line.end;\n    return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction findShapeNode(magnet) {\n    if (!magnet) return null;\n    var node = magnet;\n    do {\n        var tagName = node.tagName;\n        if (typeof tagName !== 'string') return null;\n        tagName = tagName.toUpperCase();\n        if (tagName === 'G') {\n            node = node.firstElementChild;\n        } else if (tagName === 'TITLE') {\n            node = node.nextElementSibling;\n        } else break;\n    } while (node);\n    return node;\n}\n\nvar BNDR_SUBDIVISIONS = 'segmentSubdivisons';\nvar BNDR_SHAPE_BBOX = 'shapeBBox';\n\nfunction boundaryIntersection(line, view, magnet, opt) {\n\n    var node, intersection;\n    var selector = opt.selector;\n    var anchor = line.end;\n\n    if (typeof selector === 'string') {\n        node = view.findNode(selector);\n    } else if (selector === false) {\n        node = magnet;\n    } else if (Array.isArray(selector)) {\n        node = util.getByPath(magnet, selector);\n    } else {\n        node = findShapeNode(magnet);\n    }\n\n    if (!V.isSVGGraphicsElement(node)) {\n        if (node === magnet || !V.isSVGGraphicsElement(magnet)) return anchor;\n        node = magnet;\n    }\n\n    var localShape = view.getNodeShape(node);\n    var magnetMatrix = view.getNodeMatrix(node);\n    var translateMatrix = view.getRootTranslateMatrix();\n    var rotateMatrix = view.getRootRotateMatrix();\n    var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n    var localMatrix = targetMatrix.inverse();\n    var localLine = V.transformLine(line, localMatrix);\n    var localRef = localLine.start.clone();\n    var data = view.getNodeData(node);\n\n    if (opt.insideout === false) {\n        if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();\n        var localBBox = data[BNDR_SHAPE_BBOX];\n        if (localBBox.containsPoint(localRef)) return anchor;\n    }\n\n    // Caching segment subdivisions for paths\n    var pathOpt;\n    if (localShape instanceof g.Path) {\n        var precision = opt.precision || 2;\n        if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({ precision: precision });\n        pathOpt = {\n            precision: precision,\n            segmentSubdivisions: data[BNDR_SUBDIVISIONS]\n        };\n    }\n\n    if (opt.extrapolate === true) localLine.setLength(1e6);\n\n    intersection = localLine.intersect(localShape, pathOpt);\n    if (intersection) {\n        // More than one intersection\n        if (V.isArray(intersection)) intersection = localRef.chooseClosest(intersection);\n    } else if (opt.sticky === true) {\n        // No intersection, find the closest point instead\n        if (localShape instanceof g.Rect) {\n            intersection = localShape.pointNearestToPoint(localRef);\n        } else if (localShape instanceof g.Ellipse) {\n            intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);\n        } else {\n            intersection = localShape.closestPoint(localRef, pathOpt);\n        }\n    }\n\n    var cp = (intersection) ? V.transformPoint(intersection, targetMatrix) : anchor;\n    var cpOffset = opt.offset || 0;\n    if (opt.stroke) cpOffset += stroke(node) / 2;\n\n    return offsetPoint(cp, line.start, cpOffset);\n}\n\nexport const anchor = anchorConnectionPoint;\nexport const bbox = bboxIntersection;\nexport const rectangle = rectangleIntersection;\nexport const boundary = boundaryIntersection;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4852, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4858, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 4861, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4875, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/shapes/standard.mjs"],"sourcesContent":["import V from '../V/index.mjs';\nimport { Element } from '../dia/Element.mjs';\nimport { Link as LinkBase } from '../dia/Link.mjs';\nimport { isPercentage, assign } from '../util/index.mjs';\nimport { attributes } from '../dia/attributes/index.mjs';\nimport { env } from '../env/index.mjs';\n\n\n// ELEMENTS\n\nexport const Rectangle = Element.define('standard.Rectangle', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            strokeWidth: 2,\n            stroke: '#000000',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'body',\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const Circle = Element.define('standard.Circle', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            cx: 'calc(s/2)',\n            cy: 'calc(s/2)',\n            r: 'calc(s/2)',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'circle',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const Ellipse = Element.define('standard.Ellipse', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            cx: 'calc(w/2)',\n            cy: 'calc(h/2)',\n            rx: 'calc(w/2)',\n            ry: 'calc(h/2)',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'ellipse',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const Path = Element.define('standard.Path', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            d: 'M 0 0 H calc(w) V calc(h) H 0 Z',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const Polygon = Element.define('standard.Polygon', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            points: '0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'polygon',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const Polyline = Element.define('standard.Polyline', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            points: '0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'polyline',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const Image = Element.define('standard.Image', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        image: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            // xlinkHref: '[URL]'\n        },\n        label: {\n            textVerticalAnchor: 'top',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h+10)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'image',\n        selector: 'image'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const BorderedImage = Element.define('standard.BorderedImage', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        border: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            stroke: '#333333',\n            strokeWidth: 2\n        },\n        background: {\n            width: 'calc(w-1)',\n            height: 'calc(h-1)',\n            x: 0.5,\n            y: 0.5,\n            fill: '#FFFFFF'\n        },\n        image: {\n            // xlinkHref: '[URL]'\n            width: 'calc(w-1)',\n            height: 'calc(h-1)',\n            x: 0.5,\n            y: 0.5\n        },\n        label: {\n            textVerticalAnchor: 'top',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h+10)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'background',\n        attributes: {\n            'stroke': 'none'\n        }\n    }, {\n        tagName: 'image',\n        selector: 'image'\n    }, {\n        tagName: 'rect',\n        selector: 'border',\n        attributes: {\n            'fill': 'none'\n        }\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const EmbeddedImage = Element.define('standard.EmbeddedImage', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            stroke: '#333333',\n            fill: '#FFFFFF',\n            strokeWidth: 2\n        },\n        image: {\n            // xlinkHref: '[URL]'\n            width: 'calc(0.3*w)',\n            height: 'calc(h-20)',\n            x: 10,\n            y: 10,\n            preserveAspectRatio: 'xMidYMin'\n        },\n        label: {\n            textVerticalAnchor: 'top',\n            textAnchor: 'left',\n            x: 'calc(0.3*w+20)', // 10 + 10\n            y: 10,\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'body'\n    }, {\n        tagName: 'image',\n        selector: 'image'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const InscribedImage = Element.define('standard.InscribedImage', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        border: {\n            rx: 'calc(w/2)',\n            ry: 'calc(h/2)',\n            cx: 'calc(w/2)',\n            cy: 'calc(h/2)',\n            stroke: '#333333',\n            strokeWidth: 2\n        },\n        background: {\n            rx: 'calc(w/2)',\n            ry: 'calc(h/2)',\n            cx: 'calc(w/2)',\n            cy: 'calc(h/2)',\n            fill: '#FFFFFF'\n        },\n        image: {\n            // The image corners touch the border when its size is Math.sqrt(2) / 2 = 0.707.. ~= 70%\n            width: 'calc(0.68*w)',\n            height: 'calc(0.68*h)',\n            // The image offset is calculated as (100% - 68%) / 2\n            x: 'calc(0.16*w)',\n            y: 'calc(0.16*h)',\n            preserveAspectRatio: 'xMidYMid'\n            // xlinkHref: '[URL]'\n        },\n        label: {\n            textVerticalAnchor: 'top',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h+10)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'ellipse',\n        selector: 'background'\n    }, {\n        tagName: 'image',\n        selector: 'image'\n    }, {\n        tagName: 'ellipse',\n        selector: 'border',\n        attributes: {\n            'fill': 'none'\n        }\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const HeaderedRectangle = Element.define('standard.HeaderedRectangle', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            strokeWidth: 2,\n            stroke: '#000000',\n            fill: '#FFFFFF'\n        },\n        header: {\n            width: 'calc(w)',\n            height: 30,\n            strokeWidth: 2,\n            stroke: '#000000',\n            fill: '#FFFFFF'\n        },\n        headerText: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 15,\n            fontSize: 16,\n            fill: '#333333'\n        },\n        bodyText: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2+15)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'body'\n    }, {\n        tagName: 'rect',\n        selector: 'header'\n    }, {\n        tagName: 'text',\n        selector: 'headerText'\n    }, {\n        tagName: 'text',\n        selector: 'bodyText'\n    }]\n});\n\nvar CYLINDER_TILT = 10;\n\nexport const Cylinder = Element.define('standard.Cylinder', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            lateralArea: CYLINDER_TILT,\n            fill: '#FFFFFF',\n            stroke: '#333333',\n            strokeWidth: 2\n        },\n        top: {\n            cx: 'calc(w/2)',\n            cy: CYLINDER_TILT,\n            rx: 'calc(w/2)',\n            ry: CYLINDER_TILT,\n            fill: '#FFFFFF',\n            stroke: '#333333',\n            strokeWidth: 2\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h+15)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'body'\n    }, {\n        tagName: 'ellipse',\n        selector: 'top'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }],\n\n    topRy: function(t, opt) {\n        // getter\n        if (t === undefined) return this.attr('body/lateralArea');\n\n        // setter\n        var bodyAttrs = { lateralArea: t };\n\n        var isPercentageSetter = isPercentage(t);\n        var ty = (isPercentageSetter) ? `calc(${parseFloat(t) / 100}*h)` : t;\n        var topAttrs = { cy: ty, ry: ty };\n\n        return this.attr({ body: bodyAttrs, top: topAttrs }, opt);\n    }\n\n}, {\n    attributes: {\n        'lateral-area': {\n            set: function(t, refBBox) {\n                var isPercentageSetter = isPercentage(t);\n                if (isPercentageSetter) t = parseFloat(t) / 100;\n\n                var x = refBBox.x;\n                var y = refBBox.y;\n                var w = refBBox.width;\n                var h = refBBox.height;\n\n                // curve control point variables\n                var rx = w / 2;\n                var ry = isPercentageSetter ? (h * t) : t;\n\n                var kappa = V.KAPPA;\n                var cx = kappa * rx;\n                var cy = kappa * (isPercentageSetter ? (h * t) : t);\n\n                // shape variables\n                var xLeft = x;\n                var xCenter = x + (w / 2);\n                var xRight = x + w;\n\n                var ySideTop = y + ry;\n                var yCurveTop = ySideTop - ry;\n                var ySideBottom = y + h - ry;\n                var yCurveBottom = y + h;\n\n                // return calculated shape\n                var data = [\n                    'M', xLeft, ySideTop,\n                    'L', xLeft, ySideBottom,\n                    'C', x, (ySideBottom + cy), (xCenter - cx), yCurveBottom, xCenter, yCurveBottom,\n                    'C', (xCenter + cx), yCurveBottom, xRight, (ySideBottom + cy), xRight, ySideBottom,\n                    'L', xRight, ySideTop,\n                    'C', xRight, (ySideTop - cy), (xCenter + cx), yCurveTop, xCenter, yCurveTop,\n                    'C', (xCenter - cx), yCurveTop, xLeft, (ySideTop - cy), xLeft, ySideTop,\n                    'Z'\n                ];\n                return { d: data.join(' ') };\n            },\n            unset: 'd'\n        }\n    }\n});\n\nvar foLabelMarkup = {\n    tagName: 'foreignObject',\n    selector: 'foreignObject',\n    attributes: {\n        'overflow': 'hidden'\n    },\n    children: [{\n        tagName: 'div',\n        namespaceURI: 'http://www.w3.org/1999/xhtml',\n        selector: 'label',\n        style: {\n            width: '100%',\n            height: '100%',\n            position: 'static',\n            backgroundColor: 'transparent',\n            textAlign: 'center',\n            margin: 0,\n            padding: '0px 5px',\n            boxSizing: 'border-box',\n            display: 'flex',\n            alignItems: 'center',\n            justifyContent: 'center'\n        }\n    }]\n};\n\nvar svgLabelMarkup = {\n    tagName: 'text',\n    selector: 'label',\n    attributes: {\n        'text-anchor': 'middle'\n    }\n};\n\nvar labelMarkup = (env.test('svgforeignobject')) ? foLabelMarkup : svgLabelMarkup;\n\nexport const TextBlock = Element.define('standard.TextBlock', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            stroke: '#333333',\n            fill: '#ffffff',\n            strokeWidth: 2\n        },\n        foreignObject: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n        },\n        label: {\n            style: {\n                fontSize: 14\n            }\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'body'\n    }, labelMarkup]\n}, {\n    attributes: {\n        text: {\n            set: function(text, refBBox, node, attrs) {\n                if (node instanceof HTMLElement) {\n                    node.textContent = text;\n                } else {\n                    // No foreign object\n                    var style = attrs['style'] || {};\n                    var wrapValue = { text, width: -5, height: '100%' };\n                    var wrapAttrs = assign({ 'text-vertical-anchor': 'middle' }, style);\n                    attributes['text-wrap'].set.call(this, wrapValue, refBBox, node, wrapAttrs);\n                    return { fill: style.color || null };\n                }\n            },\n            unset: function(node) {\n                node.textContent = '';\n                if (node instanceof SVGElement) {\n                    return 'fill';\n                }\n            },\n            position: function(text, refBBox, node) {\n                // No foreign object\n                if (node instanceof SVGElement) return refBBox.center();\n            }\n        }\n    }\n});\n\n// LINKS\n\nexport const Link = LinkBase.define('standard.Link', {\n    attrs: {\n        line: {\n            connection: true,\n            stroke: '#333333',\n            strokeWidth: 2,\n            strokeLinejoin: 'round',\n            targetMarker: {\n                'type': 'path',\n                'd': 'M 10 -5 0 0 10 5 z'\n            }\n        },\n        wrapper: {\n            connection: true,\n            strokeWidth: 10,\n            strokeLinejoin: 'round'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'wrapper',\n        attributes: {\n            'fill': 'none',\n            'cursor': 'pointer',\n            'stroke': 'transparent',\n            'stroke-linecap': 'round'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'line',\n        attributes: {\n            'fill': 'none',\n            'pointer-events': 'none'\n        }\n    }]\n});\n\nexport const DoubleLink = LinkBase.define('standard.DoubleLink', {\n    attrs: {\n        line: {\n            connection: true,\n            stroke: '#DDDDDD',\n            strokeWidth: 4,\n            strokeLinejoin: 'round',\n            targetMarker: {\n                type: 'path',\n                stroke: '#000000',\n                d: 'M 10 -3 10 -10 -2 0 10 10 10 3'\n            }\n        },\n        outline: {\n            connection: true,\n            stroke: '#000000',\n            strokeWidth: 6,\n            strokeLinejoin: 'round'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'outline',\n        attributes: {\n            'fill': 'none',\n            'cursor': 'pointer'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'line',\n        attributes: {\n            'fill': 'none',\n            'pointer-events': 'none'\n        }\n    }]\n});\n\nexport const ShadowLink = LinkBase.define('standard.ShadowLink', {\n    attrs: {\n        line: {\n            connection: true,\n            stroke: '#FF0000',\n            strokeWidth: 20,\n            strokeLinejoin: 'round',\n            targetMarker: {\n                'type': 'path',\n                'stroke': 'none',\n                'd': 'M 0 -10 -10 0 0 10 z'\n            },\n            sourceMarker: {\n                'type': 'path',\n                'stroke': 'none',\n                'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'\n            }\n        },\n        shadow: {\n            connection: true,\n            transform: 'translate(3,6)',\n            stroke: '#000000',\n            strokeOpacity: 0.2,\n            strokeWidth: 20,\n            strokeLinejoin: 'round',\n            targetMarker: {\n                'type': 'path',\n                'd': 'M 0 -10 -10 0 0 10 z',\n                'stroke': 'none'\n            },\n            sourceMarker: {\n                'type': 'path',\n                'stroke': 'none',\n                'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'\n            }\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'shadow',\n        attributes: {\n            'fill': 'none',\n            'pointer-events': 'none'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'line',\n        attributes: {\n            'fill': 'none',\n            'cursor': 'pointer'\n        }\n    }]\n});\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5730, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}