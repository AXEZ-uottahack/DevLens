{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/edge/EntityRelation.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellState from '../../cell/CellState';\nimport Point from '../../geometry/Point';\nimport { DIRECTION_MASK, ENTITY_SEGMENT } from '../../../util/Constants';\nimport { getPortConstraints } from '../../../util/mathUtils';\nimport { getValue } from '../../../util/Utils';\nexport const EntityRelation = (state, source, target, _points, result) => {\n    const { view } = state;\n    const segment = getValue(state.style, 'segment', ENTITY_SEGMENT) * view.scale;\n    const pts = state.absolutePoints;\n    const p0 = pts[0];\n    const pe = pts[pts.length - 1];\n    let isSourceLeft = false;\n    if (source != null) {\n        const sourceGeometry = source.cell.getGeometry();\n        if (sourceGeometry.relative) {\n            isSourceLeft = sourceGeometry.x <= 0.5;\n        }\n        else if (target != null) {\n            isSourceLeft =\n                (pe != null ? pe.x : target.x + target.width) < (p0 != null ? p0.x : source.x);\n        }\n    }\n    if (p0 != null) {\n        source = new CellState();\n        source.x = p0.x;\n        source.y = p0.y;\n    }\n    else if (source != null) {\n        const constraint = getPortConstraints(source, state, true, DIRECTION_MASK.NONE);\n        if (constraint !== DIRECTION_MASK.NONE &&\n            constraint !== DIRECTION_MASK.WEST + DIRECTION_MASK.EAST) {\n            isSourceLeft = constraint === DIRECTION_MASK.WEST;\n        }\n    }\n    else {\n        return;\n    }\n    let isTargetLeft = true;\n    if (target != null) {\n        const targetGeometry = target.cell.getGeometry();\n        if (targetGeometry.relative) {\n            isTargetLeft = targetGeometry.x <= 0.5;\n        }\n        else if (source != null) {\n            isTargetLeft =\n                (p0 != null ? p0.x : source.x + source.width) < (pe != null ? pe.x : target.x);\n        }\n    }\n    if (pe != null) {\n        target = new CellState();\n        target.x = pe.x;\n        target.y = pe.y;\n    }\n    else if (target != null) {\n        const constraint = getPortConstraints(target, state, false, DIRECTION_MASK.NONE);\n        if (constraint !== DIRECTION_MASK.NONE &&\n            constraint != DIRECTION_MASK.WEST + DIRECTION_MASK.EAST) {\n            isTargetLeft = constraint === DIRECTION_MASK.WEST;\n        }\n    }\n    if (source != null && target != null) {\n        const x0 = isSourceLeft ? source.x : source.x + source.width;\n        const y0 = view.getRoutingCenterY(source);\n        const xe = isTargetLeft ? target.x : target.x + target.width;\n        const ye = view.getRoutingCenterY(target);\n        const seg = segment;\n        let dx = isSourceLeft ? -seg : seg;\n        const dep = new Point(x0 + dx, y0);\n        dx = isTargetLeft ? -seg : seg;\n        const arr = new Point(xe + dx, ye);\n        // Adds intermediate points if both go out on same side\n        if (isSourceLeft === isTargetLeft) {\n            const x = isSourceLeft ? Math.min(x0, xe) - segment : Math.max(x0, xe) + segment;\n            result.push(new Point(x, y0));\n            result.push(new Point(x, ye));\n        }\n        else if (dep.x < arr.x === isSourceLeft) {\n            const midY = y0 + (ye - y0) / 2;\n            result.push(dep);\n            result.push(new Point(dep.x, midY));\n            result.push(new Point(arr.x, midY));\n            result.push(arr);\n        }\n        else {\n            result.push(dep);\n            result.push(arr);\n        }\n    }\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/edge/Loop.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\nimport { DIRECTION } from '../../../util/Constants';\nimport { contains } from '../../../util/mathUtils';\nimport { getValue } from '../../../util/Utils';\nexport const Loop = (state, source, _target, points, result) => {\n    const pts = state.absolutePoints;\n    const p0 = pts[0];\n    const pe = pts[pts.length - 1];\n    if (p0 != null && pe != null) {\n        if (points != null && points.length > 0) {\n            for (let i = 0; i < points.length; i += 1) {\n                let pt = points[i];\n                pt = state.view.transformControlPoint(state, pt);\n                result.push(new Point(pt.x, pt.y));\n            }\n        }\n        return;\n    }\n    if (source != null) {\n        const { view } = state;\n        const { graph } = view;\n        let pt = points != null && points.length > 0 ? points[0] : null;\n        if (pt != null) {\n            pt = view.transformControlPoint(state, pt);\n            if (contains(source, pt.x, pt.y)) {\n                pt = null;\n            }\n        }\n        let x = 0;\n        let dx = 0;\n        let y = 0;\n        let dy = 0;\n        const seg = getValue(state.style, 'segment', graph.gridSize) * view.scale;\n        const dir = getValue(state.style, 'direction', DIRECTION.WEST);\n        if (dir === DIRECTION.NORTH || dir === DIRECTION.SOUTH) {\n            x = view.getRoutingCenterX(source);\n            dx = seg;\n        }\n        else {\n            y = view.getRoutingCenterY(source);\n            dy = seg;\n        }\n        if (pt == null || pt.x < source.x || pt.x > source.x + source.width) {\n            if (pt != null) {\n                x = pt.x;\n                dy = Math.max(Math.abs(y - pt.y), dy);\n            }\n            else if (dir === DIRECTION.NORTH) {\n                y = source.y - 2 * dx;\n            }\n            else if (dir === DIRECTION.SOUTH) {\n                y = source.y + source.height + 2 * dx;\n            }\n            else if (dir === DIRECTION.EAST) {\n                x = source.x - 2 * dy;\n            }\n            else {\n                x = source.x + source.width + 2 * dy;\n            }\n        }\n        else if (pt !== null) {\n            x = view.getRoutingCenterX(source);\n            dx = Math.max(Math.abs(x - pt.x), dy);\n            y = pt.y;\n            dy = 0;\n        }\n        result.push(new Point(x - dx, y - dy));\n        result.push(new Point(x + dx, y + dy));\n    }\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 208, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/edge/SideToSide.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellState from '../../cell/CellState';\nimport Point from '../../geometry/Point';\nimport { contains } from '../../../util/mathUtils';\nexport const SideToSide = (state, source, target, points, result) => {\n    const { view } = state;\n    let pt = points != null && points.length > 0 ? points[0] : null;\n    const pts = state.absolutePoints;\n    const p0 = pts[0];\n    const pe = pts[pts.length - 1];\n    if (pt != null) {\n        pt = view.transformControlPoint(state, pt);\n    }\n    if (p0 != null) {\n        source = new CellState();\n        source.x = p0.x;\n        source.y = p0.y;\n    }\n    if (pe != null) {\n        target = new CellState();\n        target.x = pe.x;\n        target.y = pe.y;\n    }\n    if (source != null && target != null) {\n        const l = Math.max(source.x, target.x);\n        const r = Math.min(source.x + source.width, target.x + target.width);\n        const x = pt != null ? pt.x : Math.round(r + (l - r) / 2);\n        let y1 = view.getRoutingCenterY(source);\n        let y2 = view.getRoutingCenterY(target);\n        if (pt != null) {\n            if (pt.y >= source.y && pt.y <= source.y + source.height) {\n                y1 = pt.y;\n            }\n            if (pt.y >= target.y && pt.y <= target.y + target.height) {\n                y2 = pt.y;\n            }\n        }\n        if (!contains(target, x, y1) && !contains(source, x, y1)) {\n            result.push(new Point(x, y1));\n        }\n        if (!contains(target, x, y2) && !contains(source, x, y2)) {\n            result.push(new Point(x, y2));\n        }\n        if (result.length === 1) {\n            if (pt != null) {\n                if (!contains(target, x, pt.y) && !contains(source, x, pt.y)) {\n                    result.push(new Point(x, pt.y));\n                }\n            }\n            else {\n                const t = Math.max(source.y, target.y);\n                const b = Math.min(source.y + source.height, target.y + target.height);\n                result.push(new Point(x, t + (b - t) / 2));\n            }\n        }\n    }\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 285, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 291, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/edge/TopToBottom.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellState from '../../cell/CellState';\nimport Point from '../../geometry/Point';\nimport { contains } from '../../../util/mathUtils';\nexport const TopToBottom = (state, source, target, points, result) => {\n    const { view } = state;\n    let pt = points != null && points.length > 0 ? points[0] : null;\n    const pts = state.absolutePoints;\n    const p0 = pts[0];\n    const pe = pts[pts.length - 1];\n    if (pt != null) {\n        pt = view.transformControlPoint(state, pt);\n    }\n    if (p0 != null) {\n        source = new CellState();\n        source.x = p0.x;\n        source.y = p0.y;\n    }\n    if (pe != null) {\n        target = new CellState();\n        target.x = pe.x;\n        target.y = pe.y;\n    }\n    if (source != null && target != null) {\n        const t = Math.max(source.y, target.y);\n        const b = Math.min(source.y + source.height, target.y + target.height);\n        let x = view.getRoutingCenterX(source);\n        if (pt != null && pt.x >= source.x && pt.x <= source.x + source.width) {\n            x = pt.x;\n        }\n        const y = pt != null ? pt.y : Math.round(b + (t - b) / 2);\n        if (!contains(target, x, y) && !contains(source, x, y)) {\n            result.push(new Point(x, y));\n        }\n        if (pt != null && pt.x >= target.x && pt.x <= target.x + target.width) {\n            x = pt.x;\n        }\n        else {\n            x = view.getRoutingCenterX(target);\n        }\n        if (!contains(target, x, y) && !contains(source, x, y)) {\n            result.push(new Point(x, y));\n        }\n        if (result.length === 1) {\n            if (pt != null && result.length === 1) {\n                if (!contains(target, pt.x, y) && !contains(source, pt.x, y)) {\n                    result.push(new Point(pt.x, y));\n                }\n            }\n            else {\n                const l = Math.max(source.x, target.x);\n                const r = Math.min(source.x + source.width, target.x + target.width);\n                result.push(new Point(l + (r - l) / 2, y));\n            }\n        }\n    }\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AACA;AAEA;AADA;;;;AAEO,MAAM,cAAc,CAAC,OAAO,QAAQ,QAAQ,QAAQ;IACvD,MAAM,EAAE,IAAI,EAAE,GAAG;IACjB,IAAI,KAAK,UAAU,QAAQ,OAAO,MAAM,GAAG,IAAI,MAAM,CAAC,EAAE,GAAG;IAC3D,MAAM,MAAM,MAAM,cAAc;IAChC,MAAM,KAAK,GAAG,CAAC,EAAE;IACjB,MAAM,KAAK,GAAG,CAAC,IAAI,MAAM,GAAG,EAAE;IAC9B,IAAI,MAAM,MAAM;QACZ,KAAK,KAAK,qBAAqB,CAAC,OAAO;IAC3C;IACA,IAAI,MAAM,MAAM;QACZ,SAAS,IAAI,sKAAA,CAAA,UAAS;QACtB,OAAO,CAAC,GAAG,GAAG,CAAC;QACf,OAAO,CAAC,GAAG,GAAG,CAAC;IACnB;IACA,IAAI,MAAM,MAAM;QACZ,SAAS,IAAI,sKAAA,CAAA,UAAS;QACtB,OAAO,CAAC,GAAG,GAAG,CAAC;QACf,OAAO,CAAC,GAAG,GAAG,CAAC;IACnB;IACA,IAAI,UAAU,QAAQ,UAAU,MAAM;QAClC,MAAM,IAAI,KAAK,GAAG,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC;QACrC,MAAM,IAAI,KAAK,GAAG,CAAC,OAAO,CAAC,GAAG,OAAO,MAAM,EAAE,OAAO,CAAC,GAAG,OAAO,MAAM;QACrE,IAAI,IAAI,KAAK,iBAAiB,CAAC;QAC/B,IAAI,MAAM,QAAQ,GAAG,CAAC,IAAI,OAAO,CAAC,IAAI,GAAG,CAAC,IAAI,OAAO,CAAC,GAAG,OAAO,KAAK,EAAE;YACnE,IAAI,GAAG,CAAC;QACZ;QACA,MAAM,IAAI,MAAM,OAAO,GAAG,CAAC,GAAG,KAAK,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;QACvD,IAAI,CAAC,CAAA,GAAA,8JAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,GAAG,MAAM,CAAC,CAAA,GAAA,8JAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,GAAG,IAAI;YACpD,OAAO,IAAI,CAAC,IAAI,sKAAA,CAAA,UAAK,CAAC,GAAG;QAC7B;QACA,IAAI,MAAM,QAAQ,GAAG,CAAC,IAAI,OAAO,CAAC,IAAI,GAAG,CAAC,IAAI,OAAO,CAAC,GAAG,OAAO,KAAK,EAAE;YACnE,IAAI,GAAG,CAAC;QACZ,OACK;YACD,IAAI,KAAK,iBAAiB,CAAC;QAC/B;QACA,IAAI,CAAC,CAAA,GAAA,8JAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,GAAG,MAAM,CAAC,CAAA,GAAA,8JAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,GAAG,IAAI;YACpD,OAAO,IAAI,CAAC,IAAI,sKAAA,CAAA,UAAK,CAAC,GAAG;QAC7B;QACA,IAAI,OAAO,MAAM,KAAK,GAAG;YACrB,IAAI,MAAM,QAAQ,OAAO,MAAM,KAAK,GAAG;gBACnC,IAAI,CAAC,CAAA,GAAA,8JAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,GAAG,CAAC,EAAE,MAAM,CAAC,CAAA,GAAA,8JAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,GAAG,CAAC,EAAE,IAAI;oBAC1D,OAAO,IAAI,CAAC,IAAI,sKAAA,CAAA,UAAK,CAAC,GAAG,CAAC,EAAE;gBAChC;YACJ,OACK;gBACD,MAAM,IAAI,KAAK,GAAG,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC;gBACrC,MAAM,IAAI,KAAK,GAAG,CAAC,OAAO,CAAC,GAAG,OAAO,KAAK,EAAE,OAAO,CAAC,GAAG,OAAO,KAAK;gBACnE,OAAO,IAAI,CAAC,IAAI,sKAAA,CAAA,UAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG;YAC3C;QACJ;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 367, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 373, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/edge/Elbow.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { SideToSide } from './SideToSide';\nimport { TopToBottom } from './TopToBottom';\nimport { ELBOW } from '../../../util/Constants';\nexport const ElbowConnector = (state, source, target, points, result) => {\n    let pt = points != null && points.length > 0 ? points[0] : null;\n    let vertical = false;\n    let horizontal = false;\n    if (source != null && target != null) {\n        if (pt != null) {\n            const left = Math.min(source.x, target.x);\n            const right = Math.max(source.x + source.width, target.x + target.width);\n            const top = Math.min(source.y, target.y);\n            const bottom = Math.max(source.y + source.height, target.y + target.height);\n            pt = state.view.transformControlPoint(state, pt);\n            vertical = pt.y < top || pt.y > bottom;\n            horizontal = pt.x < left || pt.x > right;\n        }\n        else {\n            const left = Math.max(source.x, target.x);\n            const right = Math.min(source.x + source.width, target.x + target.width);\n            vertical = left === right;\n            if (!vertical) {\n                const top = Math.max(source.y, target.y);\n                const bottom = Math.min(source.y + source.height, target.y + target.height);\n                horizontal = top === bottom;\n            }\n        }\n    }\n    if (!horizontal && (vertical || state.style.elbow === ELBOW.VERTICAL)) {\n        TopToBottom(state, source, target, points, result);\n    }\n    else {\n        SideToSide(state, source, target, points, result);\n    }\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AAGA;AAFA;AACA;;;;AAEO,MAAM,iBAAiB,CAAC,OAAO,QAAQ,QAAQ,QAAQ;IAC1D,IAAI,KAAK,UAAU,QAAQ,OAAO,MAAM,GAAG,IAAI,MAAM,CAAC,EAAE,GAAG;IAC3D,IAAI,WAAW;IACf,IAAI,aAAa;IACjB,IAAI,UAAU,QAAQ,UAAU,MAAM;QAClC,IAAI,MAAM,MAAM;YACZ,MAAM,OAAO,KAAK,GAAG,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC;YACxC,MAAM,QAAQ,KAAK,GAAG,CAAC,OAAO,CAAC,GAAG,OAAO,KAAK,EAAE,OAAO,CAAC,GAAG,OAAO,KAAK;YACvE,MAAM,MAAM,KAAK,GAAG,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC;YACvC,MAAM,SAAS,KAAK,GAAG,CAAC,OAAO,CAAC,GAAG,OAAO,MAAM,EAAE,OAAO,CAAC,GAAG,OAAO,MAAM;YAC1E,KAAK,MAAM,IAAI,CAAC,qBAAqB,CAAC,OAAO;YAC7C,WAAW,GAAG,CAAC,GAAG,OAAO,GAAG,CAAC,GAAG;YAChC,aAAa,GAAG,CAAC,GAAG,QAAQ,GAAG,CAAC,GAAG;QACvC,OACK;YACD,MAAM,OAAO,KAAK,GAAG,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC;YACxC,MAAM,QAAQ,KAAK,GAAG,CAAC,OAAO,CAAC,GAAG,OAAO,KAAK,EAAE,OAAO,CAAC,GAAG,OAAO,KAAK;YACvE,WAAW,SAAS;YACpB,IAAI,CAAC,UAAU;gBACX,MAAM,MAAM,KAAK,GAAG,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC;gBACvC,MAAM,SAAS,KAAK,GAAG,CAAC,OAAO,CAAC,GAAG,OAAO,MAAM,EAAE,OAAO,CAAC,GAAG,OAAO,MAAM;gBAC1E,aAAa,QAAQ;YACzB;QACJ;IACJ;IACA,IAAI,CAAC,cAAc,CAAC,YAAY,MAAM,KAAK,CAAC,KAAK,KAAK,8JAAA,CAAA,QAAK,CAAC,QAAQ,GAAG;QACnE,CAAA,GAAA,iLAAA,CAAA,cAAW,AAAD,EAAE,OAAO,QAAQ,QAAQ,QAAQ;IAC/C,OACK;QACD,CAAA,GAAA,gLAAA,CAAA,aAAU,AAAD,EAAE,OAAO,QAAQ,QAAQ,QAAQ;IAC9C;AACJ","ignoreList":[0]}},
    {"offset": {"line": 428, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 434, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/edge/shared.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\n/**\n * Scales an array of {@link Point}\n *\n * @param points array of {@link Point} to scale\n * @param scale the scaling to divide by\n */\nexport function scalePointArray(points, scale) {\n    let result = [];\n    if (points != null) {\n        for (let i = 0; i < points.length; i += 1) {\n            if (points[i] != null) {\n                result[i] = new Point(Math.round((points[i].x / scale) * 10) / 10, Math.round((points[i].y / scale) * 10) / 10);\n            }\n            else {\n                result[i] = null;\n            }\n        }\n    }\n    else {\n        result = null;\n    }\n    return result;\n}\n/**\n * Scales an {@link CellState}.\n *\n * @param state {@link CellState} to scale\n * @param scale the scaling to divide by\n */\nexport function scaleCellState(state, scale) {\n    let result = null;\n    if (state != null) {\n        result = state.clone();\n        result.setRect(Math.round((state.x / scale) * 10) / 10, Math.round((state.y / scale) * 10) / 10, Math.round((state.width / scale) * 10) / 10, Math.round((state.height / scale) * 10) / 10);\n    }\n    return result;\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;;AACA;;AAOO,SAAS,gBAAgB,MAAM,EAAE,KAAK;IACzC,IAAI,SAAS,EAAE;IACf,IAAI,UAAU,MAAM;QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,KAAK,EAAG;YACvC,IAAI,MAAM,CAAC,EAAE,IAAI,MAAM;gBACnB,MAAM,CAAC,EAAE,GAAG,IAAI,sKAAA,CAAA,UAAK,CAAC,KAAK,KAAK,CAAC,AAAC,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG,QAAS,MAAM,IAAI,KAAK,KAAK,CAAC,AAAC,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG,QAAS,MAAM;YAChH,OACK;gBACD,MAAM,CAAC,EAAE,GAAG;YAChB;QACJ;IACJ,OACK;QACD,SAAS;IACb;IACA,OAAO;AACX;AAOO,SAAS,eAAe,KAAK,EAAE,KAAK;IACvC,IAAI,SAAS;IACb,IAAI,SAAS,MAAM;QACf,SAAS,MAAM,KAAK;QACpB,OAAO,OAAO,CAAC,KAAK,KAAK,CAAC,AAAC,MAAM,CAAC,GAAG,QAAS,MAAM,IAAI,KAAK,KAAK,CAAC,AAAC,MAAM,CAAC,GAAG,QAAS,MAAM,IAAI,KAAK,KAAK,CAAC,AAAC,MAAM,KAAK,GAAG,QAAS,MAAM,IAAI,KAAK,KAAK,CAAC,AAAC,MAAM,MAAM,GAAG,QAAS,MAAM;IAC5L;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 479, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 485, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/edge/Segment.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\nimport { contains } from '../../../util/mathUtils';\nimport { scaleCellState, scalePointArray } from './shared';\nexport const SegmentConnector = (state, sourceScaled, targetScaled, controlHints, result) => {\n    // Creates array of all way- and terminal points\n    // TODO: Figure out what to do when there are nulls in `pts`!\n    const pts = scalePointArray(state.absolutePoints, state.view.scale);\n    const source = scaleCellState(sourceScaled, state.view.scale);\n    const target = scaleCellState(targetScaled, state.view.scale);\n    const tol = 1;\n    // Whether the first segment outgoing from the source end is horizontal\n    let lastPushed = result.length > 0 ? result[0] : null;\n    let horizontal = true;\n    let hint = null;\n    // Adds waypoints only if outside of tolerance\n    function pushPoint(pt) {\n        pt.x = Math.round(pt.x * state.view.scale * 10) / 10;\n        pt.y = Math.round(pt.y * state.view.scale * 10) / 10;\n        if (lastPushed == null ||\n            Math.abs(lastPushed.x - pt.x) >= tol ||\n            Math.abs(lastPushed.y - pt.y) >= Math.max(1, state.view.scale)) {\n            result.push(pt);\n            lastPushed = pt;\n        }\n        return lastPushed;\n    }\n    // Adds the first point\n    let pt = pts[0];\n    if (pt == null && source != null) {\n        pt = new Point(state.view.getRoutingCenterX(source), state.view.getRoutingCenterY(source));\n    }\n    else if (pt != null) {\n        pt = pt.clone();\n    }\n    const lastInx = pts.length - 1;\n    let pe = null;\n    // Adds the waypoints\n    if (controlHints != null && controlHints.length > 0) {\n        // Converts all hints and removes nulls\n        let hints = [];\n        for (let i = 0; i < controlHints.length; i += 1) {\n            const tmp = state.view.transformControlPoint(state, controlHints[i], true);\n            if (tmp != null) {\n                hints.push(tmp);\n            }\n        }\n        if (hints.length === 0) {\n            return;\n        }\n        // Aligns source and target hint to fixed points\n        if (pt != null && hints[0] != null) {\n            if (Math.abs(hints[0].x - pt.x) < tol) {\n                hints[0].x = pt.x;\n            }\n            if (Math.abs(hints[0].y - pt.y) < tol) {\n                hints[0].y = pt.y;\n            }\n        }\n        pe = pts[lastInx];\n        if (pe != null && hints[hints.length - 1] != null) {\n            if (Math.abs(hints[hints.length - 1].x - pe.x) < tol) {\n                hints[hints.length - 1].x = pe.x;\n            }\n            if (Math.abs(hints[hints.length - 1].y - pe.y) < tol) {\n                hints[hints.length - 1].y = pe.y;\n            }\n        }\n        hint = hints[0];\n        let currentTerm = source;\n        let currentPt = pts[0];\n        let hozChan = false;\n        let vertChan = false;\n        let currentHint = hint;\n        if (currentPt != null) {\n            currentTerm = null;\n        }\n        // Check for alignment with fixed points and with channels\n        // at source and target segments only\n        for (let i = 0; i < 2; i += 1) {\n            const fixedVertAlign = currentPt != null && currentPt.x === currentHint.x;\n            const fixedHozAlign = currentPt != null && currentPt.y === currentHint.y;\n            const inHozChan = currentTerm != null &&\n                currentHint.y >= currentTerm.y &&\n                currentHint.y <= currentTerm.y + currentTerm.height;\n            const inVertChan = currentTerm != null &&\n                currentHint.x >= currentTerm.x &&\n                currentHint.x <= currentTerm.x + currentTerm.width;\n            hozChan = fixedHozAlign || (currentPt == null && inHozChan);\n            vertChan = fixedVertAlign || (currentPt == null && inVertChan);\n            // If the current hint falls in both the hor and vert channels in the case\n            // of a floating port, or if the hint is exactly co-incident with a\n            // fixed point, ignore the source and try to work out the orientation\n            // from the target end\n            if (!(i == 0 && ((hozChan && vertChan) || (fixedVertAlign && fixedHozAlign)))) {\n                if (currentPt != null &&\n                    !fixedHozAlign &&\n                    !fixedVertAlign &&\n                    (inHozChan || inVertChan)) {\n                    horizontal = !inHozChan;\n                    break;\n                }\n                if (vertChan || hozChan) {\n                    horizontal = hozChan;\n                    if (i === 1) {\n                        // Work back from target end\n                        horizontal = hints.length % 2 === 0 ? hozChan : vertChan;\n                    }\n                    break;\n                }\n            }\n            currentTerm = target;\n            currentPt = pts[lastInx];\n            if (currentPt != null) {\n                currentTerm = null;\n            }\n            currentHint = hints[hints.length - 1];\n            if (fixedVertAlign && fixedHozAlign) {\n                hints = hints.slice(1);\n            }\n        }\n        if (horizontal &&\n            ((pts[0] != null && pts[0].y !== hint.y) ||\n                (pts[0] == null &&\n                    source != null &&\n                    (hint.y < source.y || hint.y > source.y + source.height)))) {\n            pushPoint(new Point(pt.x, hint.y));\n        }\n        else if (!horizontal &&\n            ((pts[0] != null && pts[0].x !== hint.x) ||\n                (pts[0] == null &&\n                    source != null &&\n                    (hint.x < source.x || hint.x > source.x + source.width)))) {\n            pushPoint(new Point(hint.x, pt.y));\n        }\n        if (horizontal) {\n            pt.y = hint.y;\n        }\n        else {\n            pt.x = hint.x;\n        }\n        for (let i = 0; i < hints.length; i += 1) {\n            horizontal = !horizontal;\n            hint = hints[i];\n            if (horizontal) {\n                pt.y = hint.y;\n            }\n            else {\n                pt.x = hint.x;\n            }\n            pushPoint(pt.clone());\n        }\n    }\n    else {\n        hint = pt;\n        // FIXME: First click in connect preview toggles orientation\n        horizontal = true;\n    }\n    // Adds the last point\n    pt = pts[lastInx];\n    if (pt == null && target != null) {\n        pt = new Point(state.view.getRoutingCenterX(target), state.view.getRoutingCenterY(target));\n    }\n    if (pt != null) {\n        if (hint != null) {\n            if (horizontal &&\n                ((pts[lastInx] != null && pts[lastInx].y !== hint.y) ||\n                    (pts[lastInx] == null &&\n                        target != null &&\n                        (hint.y < target.y || hint.y > target.y + target.height)))) {\n                pushPoint(new Point(pt.x, hint.y));\n            }\n            else if (!horizontal &&\n                ((pts[lastInx] != null && pts[lastInx].x !== hint.x) ||\n                    (pts[lastInx] == null &&\n                        target != null &&\n                        (hint.x < target.x || hint.x > target.x + target.width)))) {\n                pushPoint(new Point(hint.x, pt.y));\n            }\n        }\n    }\n    // Removes bends inside the source terminal for floating ports\n    if (pts[0] == null && source != null) {\n        while (result.length > 1 &&\n            result[1] != null &&\n            contains(source, result[1].x, result[1].y)) {\n            result.splice(1, 1);\n        }\n    }\n    // Removes bends inside the target terminal\n    if (pts[lastInx] == null && target != null) {\n        while (result.length > 1 &&\n            result[result.length - 1] != null &&\n            contains(target, result[result.length - 1].x, result[result.length - 1].y)) {\n            result.splice(result.length - 1, 1);\n        }\n    }\n    // Removes last point if inside tolerance with end point\n    if (pe != null &&\n        result[result.length - 1] != null &&\n        Math.abs(pe.x - result[result.length - 1].x) <= tol &&\n        Math.abs(pe.y - result[result.length - 1].y) <= tol) {\n        result.splice(result.length - 1, 1);\n        // Lines up second last point in result with end point\n        if (result[result.length - 1] != null) {\n            if (Math.abs(result[result.length - 1].x - pe.x) < tol) {\n                result[result.length - 1].x = pe.x;\n            }\n            if (Math.abs(result[result.length - 1].y - pe.y) < tol) {\n                result[result.length - 1].y = pe.y;\n            }\n        }\n    }\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 682, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 688, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/EdgeStyle.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nvar _a;\nimport { getValue } from '../../util/Utils';\nimport { getNumber } from '../../util/StringUtils';\nimport { getBoundingBox, getPortConstraints, reversePortConstraints, } from '../../util/mathUtils';\nimport Point from '../geometry/Point';\nimport { DEFAULT_MARKERSIZE, DIRECTION, DIRECTION_MASK, NONE, } from '../../util/Constants';\nimport Rectangle from '../geometry/Rectangle';\nimport Geometry from '../geometry/Geometry';\nimport { scaleCellState, scalePointArray } from './edge/shared';\nimport { ElbowConnector as ElbowConnectorFunction } from './edge/Elbow';\nimport { EntityRelation as EntityRelationFunction } from './edge/EntityRelation';\nimport { Loop as LoopFunction } from './edge/Loop';\nimport { SegmentConnector as SegmentConnectorFunction } from './edge/Segment';\nimport { SideToSide as SideToSideFunction } from './edge/SideToSide';\nimport { TopToBottom as TopToBottomFunction } from './edge/TopToBottom';\n/**\n * Provides various edge styles to be used as the values for `edgeStyle` in a cell style.\n *\n * The following example sets the default edge style to `ElbowConnector`:\n *\n * ```javascript\n * const style = stylesheet.getDefaultEdgeStyle();\n * style.edgeStyle = EdgeStyle.ElbowConnector;\n * ```\n *\n * To write a custom edge style, a function can be added to the `EdgeStyle` object as follows.\n * In the example below, a right angle is created using a point on the horizontal center of the target vertex and the vertical center of the source vertex.\n * The code checks if that point intersects the source vertex and makes the edge straight if it does.\n * The point is then added into the result array, which acts as the return value of the function.\n *\n * ```javascript\n * EdgeStyle.MyStyle = (state, source, target, points, result) => {\n *   if (source && target) {\n *     const pt = new Point(target.getCenterX(), source.getCenterY());\n *\n *     if (mathUtils.contains(source, pt.x, pt.y)) {\n *       pt.y = source.y + source.height;\n *     }\n *\n *     result.push(pt);\n *   }\n * };\n * ```\n *\n * The new edge style can then be registered in the {@link StyleRegistry} as follows:\n * ```javascript\n * StyleRegistry.putValue('myEdgeStyle', EdgeStyle.MyStyle);\n * ```\n *\n * The custom edge style above can now be used in a specific edge as follows:\n * ```javascript\n * style.edgeStyle = 'myEdgeStyle';\n * ```\n *\n * The key of the {@link StyleRegistry} entry for the function should be used in the {@link CellState.edgeStyle} values, unless {@link GraphView#allowEval} is `true.\n * In this case, you can also use the `'EdgeStyle.MyStyle'` string for the value in the cell style above.\n *\n * The custom EdgeStyle can be used for all edges in the graph as follows:\n *\n * ```javascript\n * let style = graph.getStylesheet().getDefaultEdgeStyle();\n * style.edgeStyle = EdgeStyle.MyStyle;\n * ```\n *\n * It can also be used directly when setting the value of the `edgeStyle` key in a style of a specific edge as follows:\n * ```javascript\n * style.edgeStyle = EdgeStyle.MyStyle;\n * ```\n */\nclass EdgeStyle {\n    // mxEdgeStyle.SOURCE_MASK | mxEdgeStyle.TARGET_MASK,\n    static getJettySize(state, isSource) {\n        let value = getValue(state.style, isSource ? 'sourceJettySize' : 'targetJettySize', getValue(state.style, 'jettySize', _a.orthBuffer));\n        if (value === 'auto') {\n            // Computes the automatic jetty size\n            const type = getValue(state.style, isSource ? 'startArrow' : 'endArrow', NONE);\n            if (type !== NONE) {\n                const size = getNumber(state.style, isSource ? 'startSize' : 'endSize', DEFAULT_MARKERSIZE);\n                value =\n                    Math.max(2, Math.ceil((size + _a.orthBuffer) / _a.orthBuffer)) *\n                        _a.orthBuffer;\n            }\n            else {\n                value = 2 * _a.orthBuffer;\n            }\n        }\n        return value;\n    }\n    static getRoutePattern(dir, quad, dx, dy) {\n        let sourceIndex = dir[0] === DIRECTION_MASK.EAST ? 3 : dir[0];\n        let targetIndex = dir[1] === DIRECTION_MASK.EAST ? 3 : dir[1];\n        sourceIndex -= quad;\n        targetIndex -= quad;\n        if (sourceIndex < 1) {\n            sourceIndex += 4;\n        }\n        if (targetIndex < 1) {\n            targetIndex += 4;\n        }\n        let result = _a.routePatterns[sourceIndex - 1][targetIndex - 1];\n        if (dx === 0 || dy === 0) {\n            if (_a.inlineRoutePatterns[sourceIndex - 1][targetIndex - 1] != null) {\n                result = _a.inlineRoutePatterns[sourceIndex - 1][targetIndex - 1];\n            }\n        }\n        return result;\n    }\n}\n_a = EdgeStyle;\n/**\n * Implements an entity relation style for edges (as used in database\n * schema diagrams). At the time the function is called, the result\n * array contains a placeholder (null) for the first absolute point,\n * that is, the point where the edge and source terminal are connected.\n * The implementation of the style then adds all intermediate waypoints\n * except for the last point, that is, the connection point between the\n * edge and the target terminal. The first ant the last point in the\n * result array are then replaced with Point that take into account\n * the terminal's perimeter and next point on the edge.\n *\n * @param state {@link CellState} that represents the edge to be updated.\n * @param source {@link CellState} that represents the source terminal.\n * @param target {@link CellState} that represents the target terminal.\n * @param points List of relative control points.\n * @param result Array of {@link Point} that represent the actual points of the edge.\n */\nEdgeStyle.EntityRelation = EntityRelationFunction;\n/**\n * Implements a self-reference, aka. loop.\n */\nEdgeStyle.Loop = LoopFunction;\n/**\n * Uses either {@link SideToSide} or {@link TopToBottom} depending on the horizontal flag in the cell style.\n * {@link SideToSide} is used if horizontal is `true` or unspecified.\n */\nEdgeStyle.ElbowConnector = ElbowConnectorFunction;\n/**\n * Implements a vertical elbow edge.\n */\nEdgeStyle.SideToSide = SideToSideFunction;\n/**\n * Implements a horizontal elbow edge.\n */\nEdgeStyle.TopToBottom = TopToBottomFunction;\n/**\n * Implements an orthogonal edge style. Use {@link EdgeSegmentHandler}\n * as an interactive handler for this style.\n *\n * @param state {@link CellState} that represents the edge to be updated.\n * @param sourceScaled {@link CellState} that represents the source terminal.\n * @param targetScaled {@link CellState} that represents the target terminal.\n * @param controlHints List of relative control points.\n * @param result Array of {@link Point} that represent the actual points of the edge.\n */\nEdgeStyle.SegmentConnector = SegmentConnectorFunction;\nEdgeStyle.orthBuffer = 10;\nEdgeStyle.orthPointsFallback = true;\nEdgeStyle.dirVectors = [\n    [-1, 0],\n    [0, -1],\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n    [1, 0],\n];\nEdgeStyle.wayPoints1 = [\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n];\nEdgeStyle.routePatterns = [\n    [\n        [513, 2308, 2081, 2562],\n        [513, 1090, 514, 2184, 2114, 2561],\n        [513, 1090, 514, 2564, 2184, 2562],\n        [513, 2308, 2561, 1090, 514, 2568, 2308],\n    ],\n    [\n        [514, 1057, 513, 2308, 2081, 2562],\n        [514, 2184, 2114, 2561],\n        [514, 2184, 2562, 1057, 513, 2564, 2184],\n        [514, 1057, 513, 2568, 2308, 2561],\n    ],\n    [\n        [1090, 514, 1057, 513, 2308, 2081, 2562],\n        [2114, 2561],\n        [1090, 2562, 1057, 513, 2564, 2184],\n        [1090, 514, 1057, 513, 2308, 2561, 2568],\n    ],\n    [\n        [2081, 2562],\n        [1057, 513, 1090, 514, 2184, 2114, 2561],\n        [1057, 513, 1090, 514, 2184, 2562, 2564],\n        [1057, 2561, 1090, 514, 2568, 2308],\n    ],\n];\nEdgeStyle.inlineRoutePatterns = [\n    [null, [2114, 2568], null, null],\n    [null, [514, 2081, 2114, 2568], null, null],\n    [null, [2114, 2561], null, null],\n    [[2081, 2562], [1057, 2114, 2568], [2184, 2562], null],\n];\nEdgeStyle.vertexSeperations = [];\nEdgeStyle.limits = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n];\nEdgeStyle.LEFT_MASK = 32;\nEdgeStyle.TOP_MASK = 64;\nEdgeStyle.RIGHT_MASK = 128;\nEdgeStyle.BOTTOM_MASK = 256;\nEdgeStyle.LEFT = 1;\nEdgeStyle.TOP = 2;\nEdgeStyle.RIGHT = 4;\nEdgeStyle.BOTTOM = 8;\n// TODO remove magic numbers\nEdgeStyle.SIDE_MASK = 480;\n// mxEdgeStyle.LEFT_MASK | mxEdgeStyle.TOP_MASK | mxEdgeStyle.RIGHT_MASK\n// | mxEdgeStyle.BOTTOM_MASK,\nEdgeStyle.CENTER_MASK = 512;\nEdgeStyle.SOURCE_MASK = 1024;\nEdgeStyle.TARGET_MASK = 2048;\nEdgeStyle.VERTEX_MASK = 3072;\n/**\n * Implements a local orthogonal router between the given cells.\n *\n * @param state {@link CellState} that represents the edge to be updated.\n * @param sourceScaled {@link CellState} that represents the source terminal.\n * @param targetScaled {@link CellState} that represents the target terminal.\n * @param controlHints List of relative control {@link Point}s.\n * @param result Array of {@link Point}s that represent the actual points of the\n * edge.\n */\nEdgeStyle.OrthConnector = (state, sourceScaled, targetScaled, controlHints, result) => {\n    // TODO: Figure out what to do when there are nulls in `pts`!\n    const pts = scalePointArray(state.absolutePoints, state.view.scale);\n    const source = scaleCellState(sourceScaled, state.view.scale);\n    const target = scaleCellState(targetScaled, state.view.scale);\n    const sourceEdge = source == null ? false : source.cell.isEdge();\n    const targetEdge = target == null ? false : target.cell.isEdge();\n    const p0 = pts[0];\n    const pe = pts[pts.length - 1];\n    let sourceX = source != null ? source.x : p0.x;\n    let sourceY = source != null ? source.y : p0.y;\n    let sourceWidth = source != null ? source.width : 0;\n    let sourceHeight = source != null ? source.height : 0;\n    let targetX = target != null ? target.x : pe.x;\n    let targetY = target != null ? target.y : pe.y;\n    let targetWidth = target != null ? target.width : 0;\n    let targetHeight = target != null ? target.height : 0;\n    let sourceBuffer = _a.getJettySize(state, true);\n    let targetBuffer = _a.getJettySize(state, false);\n    // Workaround for loop routing within buffer zone\n    if (source != null && target === source) {\n        targetBuffer = Math.max(sourceBuffer, targetBuffer);\n        sourceBuffer = targetBuffer;\n    }\n    const totalBuffer = targetBuffer + sourceBuffer;\n    let tooShort = false;\n    // Checks minimum distance for fixed points and falls back to segment connector\n    if (p0 != null && pe != null) {\n        const dx = pe.x - p0.x;\n        const dy = pe.y - p0.y;\n        tooShort = dx * dx + dy * dy < totalBuffer * totalBuffer;\n    }\n    if (tooShort ||\n        (_a.orthPointsFallback && controlHints != null && controlHints.length > 0) ||\n        sourceEdge ||\n        targetEdge) {\n        _a.SegmentConnector(state, sourceScaled, targetScaled, controlHints, result);\n        return;\n    }\n    // Determine the side(s) of the source and target vertices\n    // that the edge may connect to\n    // portConstraint [source, target]\n    const portConstraint = [DIRECTION_MASK.ALL, DIRECTION_MASK.ALL];\n    let rotation = 0;\n    if (source != null) {\n        portConstraint[0] = getPortConstraints(source, state, true, DIRECTION_MASK.ALL);\n        rotation = source.style.rotation ?? 0;\n        if (rotation !== 0) {\n            const newRect = (getBoundingBox(new Rectangle(sourceX, sourceY, sourceWidth, sourceHeight), rotation));\n            sourceX = newRect.x;\n            sourceY = newRect.y;\n            sourceWidth = newRect.width;\n            sourceHeight = newRect.height;\n        }\n    }\n    if (target != null) {\n        portConstraint[1] = getPortConstraints(target, state, false, DIRECTION_MASK.ALL);\n        rotation = target.style.rotation ?? 0;\n        if (rotation !== 0) {\n            const newRect = (getBoundingBox(new Rectangle(targetX, targetY, targetWidth, targetHeight), rotation));\n            targetX = newRect.x;\n            targetY = newRect.y;\n            targetWidth = newRect.width;\n            targetHeight = newRect.height;\n        }\n    }\n    const dir = [0, 0];\n    // Work out which faces of the vertices present against each other\n    // in a way that would allow a 3-segment connection if port constraints\n    // permitted.\n    // geo -> [source, target] [x, y, width, height]\n    const geo = [\n        [sourceX, sourceY, sourceWidth, sourceHeight],\n        [targetX, targetY, targetWidth, targetHeight],\n    ];\n    const buffer = [sourceBuffer, targetBuffer];\n    for (let i = 0; i < 2; i += 1) {\n        _a.limits[i][1] = geo[i][0] - buffer[i];\n        _a.limits[i][2] = geo[i][1] - buffer[i];\n        _a.limits[i][4] = geo[i][0] + geo[i][2] + buffer[i];\n        _a.limits[i][8] = geo[i][1] + geo[i][3] + buffer[i];\n    }\n    // Work out which quad the target is in\n    const sourceCenX = geo[0][0] + geo[0][2] / 2.0;\n    const sourceCenY = geo[0][1] + geo[0][3] / 2.0;\n    const targetCenX = geo[1][0] + geo[1][2] / 2.0;\n    const targetCenY = geo[1][1] + geo[1][3] / 2.0;\n    const dx = sourceCenX - targetCenX;\n    const dy = sourceCenY - targetCenY;\n    let quad = 0;\n    // 0 | 1\n    // -----\n    // 3 | 2\n    if (dx < 0) {\n        if (dy < 0) {\n            quad = 2;\n        }\n        else {\n            quad = 1;\n        }\n    }\n    else if (dy <= 0) {\n        quad = 3;\n        // Special case on x = 0 and negative y\n        if (dx === 0) {\n            quad = 2;\n        }\n    }\n    // Check for connection constraints\n    let currentTerm = null;\n    if (source != null) {\n        currentTerm = p0;\n    }\n    const constraint = [\n        [0.5, 0.5],\n        [0.5, 0.5],\n    ];\n    for (let i = 0; i < 2; i += 1) {\n        if (currentTerm != null) {\n            constraint[i][0] = (currentTerm.x - geo[i][0]) / geo[i][2];\n            if (Math.abs(currentTerm.x - geo[i][0]) <= 1) {\n                dir[i] = DIRECTION_MASK.WEST;\n            }\n            else if (Math.abs(currentTerm.x - geo[i][0] - geo[i][2]) <= 1) {\n                dir[i] = DIRECTION_MASK.EAST;\n            }\n            constraint[i][1] = (currentTerm.y - geo[i][1]) / geo[i][3];\n            if (Math.abs(currentTerm.y - geo[i][1]) <= 1) {\n                dir[i] = DIRECTION_MASK.NORTH;\n            }\n            else if (Math.abs(currentTerm.y - geo[i][1] - geo[i][3]) <= 1) {\n                dir[i] = DIRECTION_MASK.SOUTH;\n            }\n        }\n        currentTerm = null;\n        if (target != null) {\n            currentTerm = pe;\n        }\n    }\n    const sourceTopDist = geo[0][1] - (geo[1][1] + geo[1][3]);\n    const sourceLeftDist = geo[0][0] - (geo[1][0] + geo[1][2]);\n    const sourceBottomDist = geo[1][1] - (geo[0][1] + geo[0][3]);\n    const sourceRightDist = geo[1][0] - (geo[0][0] + geo[0][2]);\n    _a.vertexSeperations[1] = Math.max(sourceLeftDist - totalBuffer, 0);\n    _a.vertexSeperations[2] = Math.max(sourceTopDist - totalBuffer, 0);\n    _a.vertexSeperations[4] = Math.max(sourceBottomDist - totalBuffer, 0);\n    _a.vertexSeperations[3] = Math.max(sourceRightDist - totalBuffer, 0);\n    //= =============================================================\n    // Start of source and target direction determination\n    // Work through the preferred orientations by relative positioning\n    // of the vertices and list them in preferred and available order\n    const dirPref = [];\n    const horPref = [];\n    const vertPref = [];\n    horPref[0] =\n        sourceLeftDist >= sourceRightDist ? DIRECTION_MASK.WEST : DIRECTION_MASK.EAST;\n    vertPref[0] =\n        sourceTopDist >= sourceBottomDist ? DIRECTION_MASK.NORTH : DIRECTION_MASK.SOUTH;\n    horPref[1] = reversePortConstraints(horPref[0]);\n    vertPref[1] = reversePortConstraints(vertPref[0]);\n    const preferredHorizDist = sourceLeftDist >= sourceRightDist ? sourceLeftDist : sourceRightDist;\n    const preferredVertDist = sourceTopDist >= sourceBottomDist ? sourceTopDist : sourceBottomDist;\n    const prefOrdering = [\n        [0, 0],\n        [0, 0],\n    ];\n    let preferredOrderSet = false;\n    // If the preferred port isn't available, switch it\n    for (let i = 0; i < 2; i += 1) {\n        if (dir[i] !== 0x0) {\n            continue;\n        }\n        if ((horPref[i] & portConstraint[i]) === 0) {\n            horPref[i] = reversePortConstraints(horPref[i]);\n        }\n        if ((vertPref[i] & portConstraint[i]) === 0) {\n            vertPref[i] = reversePortConstraints(vertPref[i]);\n        }\n        prefOrdering[i][0] = vertPref[i];\n        prefOrdering[i][1] = horPref[i];\n    }\n    if (preferredVertDist > 0 && preferredHorizDist > 0) {\n        // Possibility of two segment edge connection\n        if ((horPref[0] & portConstraint[0]) > 0 && (vertPref[1] & portConstraint[1]) > 0) {\n            prefOrdering[0][0] = horPref[0];\n            prefOrdering[0][1] = vertPref[0];\n            prefOrdering[1][0] = vertPref[1];\n            prefOrdering[1][1] = horPref[1];\n            preferredOrderSet = true;\n        }\n        else if ((vertPref[0] & portConstraint[0]) > 0 &&\n            (horPref[1] & portConstraint[1]) > 0) {\n            prefOrdering[0][0] = vertPref[0];\n            prefOrdering[0][1] = horPref[0];\n            prefOrdering[1][0] = horPref[1];\n            prefOrdering[1][1] = vertPref[1];\n            preferredOrderSet = true;\n        }\n    }\n    if (preferredVertDist > 0 && !preferredOrderSet) {\n        prefOrdering[0][0] = vertPref[0];\n        prefOrdering[0][1] = horPref[0];\n        prefOrdering[1][0] = vertPref[1];\n        prefOrdering[1][1] = horPref[1];\n        preferredOrderSet = true;\n    }\n    if (preferredHorizDist > 0 && !preferredOrderSet) {\n        prefOrdering[0][0] = horPref[0];\n        prefOrdering[0][1] = vertPref[0];\n        prefOrdering[1][0] = horPref[1];\n        prefOrdering[1][1] = vertPref[1];\n        preferredOrderSet = true;\n    }\n    // The source and target prefs are now an ordered list of\n    // the preferred port selections\n    // If the list contains gaps, compact it\n    for (let i = 0; i < 2; i += 1) {\n        if (dir[i] !== 0x0) {\n            continue;\n        }\n        if ((prefOrdering[i][0] & portConstraint[i]) === 0) {\n            prefOrdering[i][0] = prefOrdering[i][1];\n        }\n        dirPref[i] = prefOrdering[i][0] & portConstraint[i];\n        dirPref[i] |= (prefOrdering[i][1] & portConstraint[i]) << 8;\n        dirPref[i] |= (prefOrdering[1 - i][i] & portConstraint[i]) << 16;\n        dirPref[i] |= (prefOrdering[1 - i][1 - i] & portConstraint[i]) << 24;\n        if ((dirPref[i] & 0xf) === 0) {\n            dirPref[i] = dirPref[i] << 8;\n        }\n        if ((dirPref[i] & 0xf00) === 0) {\n            dirPref[i] = (dirPref[i] & 0xf) | (dirPref[i] >> 8);\n        }\n        if ((dirPref[i] & 0xf0000) === 0) {\n            dirPref[i] = (dirPref[i] & 0xffff) | ((dirPref[i] & 0xf000000) >> 8);\n        }\n        dir[i] = dirPref[i] & 0xf;\n        if (portConstraint[i] === DIRECTION_MASK.WEST ||\n            portConstraint[i] === DIRECTION_MASK.NORTH ||\n            portConstraint[i] === DIRECTION_MASK.EAST ||\n            portConstraint[i] === DIRECTION_MASK.SOUTH) {\n            dir[i] = portConstraint[i];\n        }\n    }\n    //= =============================================================\n    // End of source and target direction determination\n    let sourceIndex = dir[0] === DIRECTION_MASK.EAST ? 3 : dir[0];\n    let targetIndex = dir[1] === DIRECTION_MASK.EAST ? 3 : dir[1];\n    sourceIndex -= quad;\n    targetIndex -= quad;\n    if (sourceIndex < 1) {\n        sourceIndex += 4;\n    }\n    if (targetIndex < 1) {\n        targetIndex += 4;\n    }\n    const routePattern = _a.routePatterns[sourceIndex - 1][targetIndex - 1];\n    _a.wayPoints1[0][0] = geo[0][0];\n    _a.wayPoints1[0][1] = geo[0][1];\n    switch (dir[0]) {\n        case DIRECTION_MASK.WEST:\n            _a.wayPoints1[0][0] -= sourceBuffer;\n            _a.wayPoints1[0][1] += constraint[0][1] * geo[0][3];\n            break;\n        case DIRECTION_MASK.SOUTH:\n            _a.wayPoints1[0][0] += constraint[0][0] * geo[0][2];\n            _a.wayPoints1[0][1] += geo[0][3] + sourceBuffer;\n            break;\n        case DIRECTION_MASK.EAST:\n            _a.wayPoints1[0][0] += geo[0][2] + sourceBuffer;\n            _a.wayPoints1[0][1] += constraint[0][1] * geo[0][3];\n            break;\n        case DIRECTION_MASK.NORTH:\n            _a.wayPoints1[0][0] += constraint[0][0] * geo[0][2];\n            _a.wayPoints1[0][1] -= sourceBuffer;\n            break;\n    }\n    let currentIndex = 0;\n    // Orientation, 0 horizontal, 1 vertical\n    let lastOrientation = (dir[0] & (DIRECTION_MASK.EAST | DIRECTION_MASK.WEST)) > 0 ? 0 : 1;\n    const initialOrientation = lastOrientation;\n    let currentOrientation = 0;\n    for (let i = 0; i < routePattern.length; i += 1) {\n        const nextDirection = routePattern[i] & 0xf;\n        // Rotate the index of this direction by the quad\n        // to get the real direction\n        let directionIndex = nextDirection === DIRECTION_MASK.EAST ? 3 : nextDirection;\n        directionIndex += quad;\n        if (directionIndex > 4) {\n            directionIndex -= 4;\n        }\n        const direction = _a.dirVectors[directionIndex - 1];\n        currentOrientation = directionIndex % 2 > 0 ? 0 : 1;\n        // Only update the current index if the point moved\n        // in the direction of the current segment move,\n        // otherwise the same point is moved until there is\n        // a segment direction change\n        if (currentOrientation !== lastOrientation) {\n            currentIndex++;\n            // Copy the previous way point into the new one\n            // We can't base the new position on index - 1\n            // because sometime elbows turn out not to exist,\n            // then we'd have to rewind.\n            _a.wayPoints1[currentIndex][0] = _a.wayPoints1[currentIndex - 1][0];\n            _a.wayPoints1[currentIndex][1] = _a.wayPoints1[currentIndex - 1][1];\n        }\n        const tar = (routePattern[i] & _a.TARGET_MASK) > 0;\n        const sou = (routePattern[i] & _a.SOURCE_MASK) > 0;\n        let side = (routePattern[i] & _a.SIDE_MASK) >> 5;\n        side <<= quad;\n        if (side > 0xf) {\n            side >>= 4;\n        }\n        const center = (routePattern[i] & _a.CENTER_MASK) > 0;\n        if ((sou || tar) && side < 9) {\n            let limit = 0;\n            const souTar = sou ? 0 : 1;\n            if (center && currentOrientation === 0) {\n                limit = geo[souTar][0] + constraint[souTar][0] * geo[souTar][2];\n            }\n            else if (center) {\n                limit = geo[souTar][1] + constraint[souTar][1] * geo[souTar][3];\n            }\n            else {\n                limit = _a.limits[souTar][side];\n            }\n            if (currentOrientation === 0) {\n                const lastX = _a.wayPoints1[currentIndex][0];\n                const deltaX = (limit - lastX) * direction[0];\n                if (deltaX > 0) {\n                    _a.wayPoints1[currentIndex][0] += direction[0] * deltaX;\n                }\n            }\n            else {\n                const lastY = _a.wayPoints1[currentIndex][1];\n                const deltaY = (limit - lastY) * direction[1];\n                if (deltaY > 0) {\n                    _a.wayPoints1[currentIndex][1] += direction[1] * deltaY;\n                }\n            }\n        }\n        else if (center) {\n            // Which center we're travelling to depend on the current direction\n            _a.wayPoints1[currentIndex][0] +=\n                direction[0] * Math.abs(_a.vertexSeperations[directionIndex] / 2);\n            _a.wayPoints1[currentIndex][1] +=\n                direction[1] * Math.abs(_a.vertexSeperations[directionIndex] / 2);\n        }\n        if (currentIndex > 0 &&\n            _a.wayPoints1[currentIndex][currentOrientation] ===\n                _a.wayPoints1[currentIndex - 1][currentOrientation]) {\n            currentIndex--;\n        }\n        else {\n            lastOrientation = currentOrientation;\n        }\n    }\n    for (let i = 0; i <= currentIndex; i += 1) {\n        if (i === currentIndex) {\n            // Last point can cause last segment to be in\n            // same direction as jetty/approach. If so,\n            // check the number of points is consistent\n            // with the relative orientation of source and target\n            // jx. Same orientation requires an even\n            // number of turns (points), different requires\n            // odd.\n            const targetOrientation = (dir[1] & (DIRECTION_MASK.EAST | DIRECTION_MASK.WEST)) > 0 ? 0 : 1;\n            const sameOrient = targetOrientation === initialOrientation ? 0 : 1;\n            // (currentIndex + 1) % 2 is 0 for even number of points,\n            // 1 for odd\n            if (sameOrient !== (currentIndex + 1) % 2) {\n                // The last point isn't required\n                break;\n            }\n        }\n        result.push(new Point(Math.round(_a.wayPoints1[i][0] * state.view.scale * 10) / 10, Math.round(_a.wayPoints1[i][1] * state.view.scale * 10) / 10));\n    }\n    // Removes duplicates\n    let index = 1;\n    while (index < result.length) {\n        if (result[index - 1] == null ||\n            result[index] == null ||\n            result[index - 1].x !== result[index].x ||\n            result[index - 1].y !== result[index].y) {\n            index++;\n        }\n        else {\n            result.splice(index, 1);\n        }\n    }\n};\n// Size of the step to find a route\nEdgeStyle.MANHATTAN_STEP = 12;\n// If number of route finding loops exceed the maximum, stops searching and returns\n// fallback route\nEdgeStyle.MANHATTAN_MAXIMUM_LOOPS = 2000;\n// Possible starting directions from an element\nEdgeStyle.MANHATTAN_START_DIRECTIONS = [\n    DIRECTION.NORTH,\n    DIRECTION.EAST,\n    DIRECTION.SOUTH,\n    DIRECTION.WEST,\n];\n// Possible ending directions to an element\nEdgeStyle.MANHATTAN_END_DIRECTIONS = [\n    DIRECTION.NORTH,\n    DIRECTION.EAST,\n    DIRECTION.SOUTH,\n    DIRECTION.WEST,\n];\n// Limit for directions change when searching route\nEdgeStyle.MANHATTAN_MAX_ALLOWED_DIRECTION_CHANGE = 90;\nEdgeStyle.MANHATTAN_PADDING_BOX = new Geometry(-_a.MANHATTAN_STEP, -_a.MANHATTAN_STEP, _a.MANHATTAN_STEP * 2, _a.MANHATTAN_STEP * 2);\n/**\n * ManhattanConnector code is based on code from https://github.com/mwangm/mxgraph-manhattan-connector\n *\n * Implements router to find the shortest route that avoids cells using manhattan distance as metric.\n */\nEdgeStyle.ManhattanConnector = (state, source, target, points, result) => {\n    /**\n     * Adds all values from source geometry to target.\n     * Used to create padding box around cell geometry.\n     * @param target\n     * @param source\n     * @returns\n     */\n    function moveAndExpand(target, source) {\n        target.x += source.x || 0;\n        target.y += source.y || 0;\n        target.width += source.width || 0;\n        target.height += source.height || 0;\n        return target;\n    }\n    function snapCoordinateToGrid(value, gridSize) {\n        return gridSize * Math.round(value / gridSize);\n    }\n    function snapPointToGrid(p, gx, gy) {\n        p.x = snapCoordinateToGrid(p.x, gx);\n        p.y = snapCoordinateToGrid(p.y, gy || gx);\n        return p;\n    }\n    function isPointInRectangle(rect, p) {\n        return (p.x >= rect.x &&\n            p.x <= rect.x + rect.width &&\n            p.y >= rect.y &&\n            p.y <= rect.y + rect.height);\n    }\n    function getRectangleCenter(rect) {\n        return new Point(rect.x + rect.width / 2, rect.y + rect.height / 2);\n    }\n    function getDifferencePoint(p1, p2) {\n        return new Point(p1.x - p2.x, p1.y - p2.y);\n    }\n    function movePoint(p, moveX, moveY) {\n        p.x += moveX || 0;\n        p.y += moveY || 0;\n        return p;\n    }\n    function getPointTheta(p1, p2) {\n        const p = p2.clone();\n        const y = -(p.y - p1.y);\n        const x = p.x - p1.x;\n        const PRECISION = 10;\n        const rad = y.toFixed(PRECISION) == '0' && x.toFixed(PRECISION) == '0' ? 0 : Math.atan2(y, x);\n        return (180 * rad) / Math.PI;\n    }\n    function normalizePoint(point) {\n        return new Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);\n    }\n    function getManhattanDistance(p1, p2) {\n        return Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y);\n    }\n    function toPointFromString(pointString) {\n        const xy = pointString.split(pointString.indexOf('@') === -1 ? ' ' : '@');\n        return new Point(parseInt(xy[0], 10), parseInt(xy[1], 10));\n    }\n    function pointToString(point) {\n        return `${point.x}@${point.y}`;\n    }\n    function getCellAbsoluteBounds(cellState) {\n        const graph = cellState.view.graph;\n        const cellBounds = graph.getCellBounds(cellState.cell, false, false)?.clone();\n        if (!cellBounds)\n            return undefined;\n        const view = graph.view;\n        const { scale, translate } = view;\n        const { x, y } = translate;\n        const round = (v) => Math.round(v * 10) / 10;\n        const res = new Rectangle(round(cellBounds.x / scale - x), round(cellBounds.y / scale - y), round(cellBounds.width / scale), round(cellBounds.height / scale));\n        return res;\n    }\n    const mStep = _a.MANHATTAN_STEP;\n    const config = {\n        // Padding applied on the element bounding boxes\n        paddingBox: _a.MANHATTAN_PADDING_BOX,\n        // An array of directions to find next points on the route\n        directions: [\n            {\n                offsetX: mStep,\n                offsetY: 0,\n                cost: mStep,\n                angle: normalizeAngle(getPointTheta(new Point(0, 0), new Point(mStep, 0))),\n            },\n            {\n                offsetX: 0,\n                offsetY: mStep,\n                cost: mStep,\n                angle: normalizeAngle(getPointTheta(new Point(0, 0), new Point(0, mStep))),\n            },\n            {\n                offsetX: -mStep,\n                offsetY: 0,\n                cost: mStep,\n                angle: normalizeAngle(getPointTheta(new Point(0, 0), new Point(-mStep, 0))),\n            },\n            {\n                offsetX: 0,\n                offsetY: -mStep,\n                cost: mStep,\n                angle: normalizeAngle(getPointTheta(new Point(0, 0), new Point(0, -mStep))),\n            },\n        ],\n        directionMap: {\n            east: { x: 1, y: 0 },\n            south: { x: 0, y: 1 },\n            west: { x: -1, y: 0 },\n            north: { x: 0, y: -1 },\n        },\n        // A penalty received for direction change\n        penaltiesGenerator: (angle) => {\n            if (angle == 45 || angle == 90 || angle == 180)\n                return _a.MANHATTAN_STEP / 2;\n            return 0;\n        },\n        // If a function is provided, it's used to route the link while dragging an end\n        // i.e. function(from, to, opts) { return []; }\n        draggingRoute: null,\n        previousDirAngle: 0,\n    };\n    /**\n     * Map of obstacles\n     * Helper structure to identify whether a point lies in an obstacle.\n     */\n    class ObstacleMap {\n        constructor(opt) {\n            this.options = opt;\n            this.mapGridSize = 100;\n            this.map = new Map();\n        }\n        // Builds a map of all elements for quicker obstacle queries\n        // The svg is divided to  cells, where each of them holds an information which\n        // elements belong to it. When we query whether a point is in an obstacle we don't need\n        // to go through all obstacles, we check only those in a particular cell.\n        build(source, target) {\n            const graph = source?.view.graph || target?.view.graph;\n            if (!graph)\n                return;\n            return Array.from(graph.getView().getCellStates())\n                .filter((s) => s.cell && s.cell.isVertex() && !s.cell.isEdge())\n                .map((s) => getCellAbsoluteBounds(s))\n                .map((bbox) => (bbox ? moveAndExpand(bbox, this.options.paddingBox) : null))\n                .forEach((bbox) => {\n                if (!bbox)\n                    return;\n                const origin = snapPointToGrid(new Point(bbox.x, bbox.y), this.mapGridSize);\n                const corner = snapPointToGrid(new Point(bbox.x + bbox.width, bbox.y + bbox.height), this.mapGridSize);\n                for (let x = origin.x; x <= corner.x; x += this.mapGridSize) {\n                    for (let y = origin.y; y <= corner.y; y += this.mapGridSize) {\n                        const gridKey = x + '@' + y;\n                        const rectArr = this.map.get(gridKey) || [];\n                        if (!this.map.has(gridKey))\n                            this.map.set(gridKey, rectArr);\n                        rectArr.push(bbox);\n                    }\n                }\n            });\n        }\n        isPointAccessible(point) {\n            const mapKey = pointToString(snapPointToGrid(point.clone(), this.mapGridSize));\n            const obstacles = this.map.get(mapKey);\n            if (obstacles) {\n                return obstacles.every((obstacle) => !isPointInRectangle(obstacle, point));\n            }\n            return true;\n        }\n    }\n    class SortedSet {\n        constructor() {\n            this.items = [];\n            this.hash = new Map();\n        }\n        add(key, value) {\n            const hashItem = this.hash.get(key);\n            if (hashItem) {\n                hashItem.value = value;\n                this.items.splice(this.items.indexOf(key), 1);\n            }\n            else {\n                this.hash.set(key, {\n                    value,\n                    open: true,\n                });\n            }\n            this.items.push(key);\n            this.items.sort((i1, i2) => {\n                const hashItem1 = this.hash.get(i1);\n                const hashItem2 = this.hash.get(i2);\n                if (!hashItem1 || !hashItem2)\n                    return 0;\n                return hashItem1.value - hashItem2.value;\n            });\n        }\n        remove(key) {\n            const hashItem = this.hash.get(key);\n            if (hashItem)\n                hashItem.open = false;\n        }\n        isOpen(key) {\n            const hashItem = this.hash.get(key);\n            return hashItem && hashItem.open == true;\n        }\n        isClose(key) {\n            const hashItem = this.hash.get(key);\n            return hashItem && hashItem.open == false;\n        }\n        isEmpty() {\n            return this.items.length == 0;\n        }\n        pop() {\n            const key = this.items.shift();\n            if (key)\n                this.remove(key);\n            return key;\n        }\n    }\n    function reconstructRoute(parents, endPoint, startCenter, endCenter) {\n        const route = [];\n        let previousDirection = normalizePoint(getDifferencePoint(endCenter, endPoint));\n        let current = endPoint;\n        let parent;\n        while (parents[pointToString(current)]) {\n            parent = parents[pointToString(current)];\n            if (!parent)\n                continue;\n            const direction = normalizePoint(getDifferencePoint(current, parent));\n            // Add point in when direction change\n            if (!direction.equals(previousDirection)) {\n                route.unshift(current);\n                previousDirection = direction;\n            }\n            current = parent;\n        }\n        const startDirection = normalizePoint(getDifferencePoint(current, startCenter));\n        if (!startDirection.equals(previousDirection)) {\n            route.unshift(current);\n        }\n        return route;\n    }\n    function getRectPoints(bbox, directionList, opt) {\n        const step = _a.MANHATTAN_STEP;\n        const center = getRectangleCenter(bbox);\n        const res = [];\n        for (const direction of directionList) {\n            const directionPoint = opt.directionMap[direction];\n            const x = (directionPoint.x * bbox.width) / 2;\n            const y = (directionPoint.y * bbox.height) / 2;\n            const point = movePoint(center.clone(), x, y);\n            if (isPointInRectangle(bbox, point)) {\n                movePoint(point, directionPoint.x * step, directionPoint.y * step);\n            }\n            res.push(snapPointToGrid(point, step));\n        }\n        return res;\n    }\n    function normalizeAngle(angle) {\n        return (angle % 360) + (angle < 0 ? 360 : 0);\n    }\n    function getDirectionAngle(start, end, directionLength) {\n        const q = 360 / directionLength;\n        return Math.floor(normalizeAngle(getPointTheta(start, end) + q / 2) / q) * q;\n    }\n    function getDirectionChange(angle1, angle2) {\n        const dirChange = Math.abs(angle1 - angle2);\n        return dirChange > 180 ? 360 - dirChange : dirChange;\n    }\n    function estimateCost(from, endPoints) {\n        let min = Infinity;\n        for (let i = 0, len = endPoints.length; i < len; i++) {\n            const cost = getManhattanDistance(from, endPoints[i]);\n            if (cost < min)\n                min = cost;\n        }\n        return min;\n    }\n    function alignPointToCell(point, edgeState, cellState, isSourceCell) {\n        const cellBounds = getCellAbsoluteBounds(cellState);\n        const y = isSourceCell ? edgeState.style.exitY : edgeState.style.entryY;\n        const onlyHorizontalDirections = isSourceCell\n            ? _a.MANHATTAN_START_DIRECTIONS.every((d) => d != DIRECTION.NORTH && d != DIRECTION.SOUTH)\n            : _a.MANHATTAN_END_DIRECTIONS.every((d) => d != DIRECTION.NORTH && d != DIRECTION.SOUTH);\n        if (y != undefined && onlyHorizontalDirections) {\n            const cellHeight = cellBounds?.height || 0;\n            point.y =\n                cellBounds?.y != undefined\n                    ? cellBounds?.y + cellHeight * y\n                    : point.y - cellHeight / 2 + cellHeight * y;\n        }\n        const x = isSourceCell ? edgeState.style.exitX : edgeState.style.entryX;\n        const onlyVerticalDirections = isSourceCell\n            ? _a.MANHATTAN_START_DIRECTIONS.every((d) => d != DIRECTION.WEST && d != DIRECTION.EAST)\n            : _a.MANHATTAN_END_DIRECTIONS.every((d) => d != DIRECTION.WEST && d != DIRECTION.EAST);\n        if (x != undefined && onlyVerticalDirections) {\n            const cellWidth = cellBounds?.width || 0;\n            point.x =\n                cellBounds?.x != undefined\n                    ? cellBounds?.x + cellWidth * x\n                    : point.x - cellWidth / 2 + cellWidth * (x || 0);\n        }\n    }\n    function findRoute(start, end, obstacleMap, opt) {\n        // Caculate start points and end points\n        const step = _a.MANHATTAN_STEP;\n        const startPoints = getRectPoints(start, _a.MANHATTAN_START_DIRECTIONS, opt).filter((p) => obstacleMap.isPointAccessible(p));\n        const startCenter = snapPointToGrid(getRectangleCenter(start), step);\n        const endPoints = getRectPoints(end, _a.MANHATTAN_END_DIRECTIONS, opt).filter((p) => obstacleMap.isPointAccessible(p));\n        const endCenter = snapPointToGrid(getRectangleCenter(end), step);\n        if (startPoints.length > 0 && endPoints.length > 0) {\n            // The set of possible  points to be evaluated, initially containing the start points.\n            const openSet = new SortedSet();\n            // Keeps predecessor of given element.\n            const parents = {};\n            // Cost from start to a point along best known path.\n            const costs = {};\n            startPoints.forEach((p) => {\n                const key = pointToString(p);\n                openSet.add(key, estimateCost(p, endPoints));\n                costs[key] = 0;\n            });\n            let loopsRemain = _a.MANHATTAN_MAXIMUM_LOOPS;\n            const endPointsKeys = endPoints.map((p) => pointToString(p));\n            let currentDirectionAngle;\n            let previousDirectionAngle;\n            // Main route finding loop\n            while (!openSet.isEmpty() && loopsRemain > 0) {\n                const currentKey = openSet.pop();\n                if (currentKey == undefined) {\n                    continue;\n                }\n                const currentPoint = toPointFromString(currentKey);\n                const currentCost = costs[currentKey];\n                previousDirectionAngle = currentDirectionAngle;\n                currentDirectionAngle = parents[currentKey]\n                    ? getDirectionAngle(parents[currentKey], currentPoint, opt.directions.length)\n                    : opt.previousDirAngle != 0\n                        ? opt.previousDirAngle\n                        : getDirectionAngle(startCenter, currentPoint, opt.directions.length);\n                // if get the endpoint\n                if (endPointsKeys.indexOf(currentKey) >= 0) {\n                    // stop route to enter the end point in opposite direction.\n                    const directionChangedAngle = getDirectionChange(currentDirectionAngle, getDirectionAngle(currentPoint, endCenter, opt.directions.length));\n                    if (currentPoint.equals(endCenter) || directionChangedAngle < 180) {\n                        opt.previousDirAngle = currentDirectionAngle;\n                        return reconstructRoute(parents, currentPoint, startCenter, endCenter);\n                    }\n                }\n                // Go over all possible directions and find neighbors.\n                for (let i = 0; i < opt.directions.length; i++) {\n                    const direction = opt.directions[i];\n                    const directionChangedAngle = getDirectionChange(currentDirectionAngle, direction.angle);\n                    if (previousDirectionAngle &&\n                        directionChangedAngle > _a.MANHATTAN_MAX_ALLOWED_DIRECTION_CHANGE) {\n                        continue;\n                    }\n                    const neighborPoint = movePoint(currentPoint.clone(), direction.offsetX, direction.offsetY);\n                    const neighborKey = pointToString(neighborPoint);\n                    if (openSet.isClose(neighborKey) ||\n                        !obstacleMap.isPointAccessible(neighborPoint)) {\n                        continue;\n                    }\n                    const costFromStart = currentCost +\n                        direction.cost +\n                        opt.penaltiesGenerator(directionChangedAngle);\n                    if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {\n                        // Neighbor point has not been processed yet or the cost of the path\n                        // from start is lesser than previously calcluated.\n                        parents[neighborKey] = currentPoint;\n                        costs[neighborKey] = costFromStart;\n                        openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n                    }\n                }\n                loopsRemain--;\n            }\n            return null;\n        }\n        return null;\n    }\n    function router(state, source, target, points, result, opt) {\n        // If edge is dragged after calculation, points will be filled, so fallback to SegmentConnector\n        if ((points != null && points.length > 0) || source == null || target == null) {\n            _a.SegmentConnector(state, source, target, points, result);\n            return;\n        }\n        let sourceBBox = getCellAbsoluteBounds(source);\n        sourceBBox = sourceBBox ? moveAndExpand(sourceBBox, opt.paddingBox) : undefined;\n        let targetBBox = getCellAbsoluteBounds(target);\n        targetBBox = targetBBox ? moveAndExpand(targetBBox, opt.paddingBox) : undefined;\n        const obstacleMap = new ObstacleMap(opt);\n        obstacleMap.build(source, target);\n        if (!sourceBBox || !targetBBox) {\n            // Fallback to OrthConnector\n            return _a.OrthConnector(state, source, target, points, result);\n        }\n        const routePoints = findRoute(sourceBBox, targetBBox, obstacleMap, opt);\n        if (routePoints == null || routePoints.length == 0) {\n            // Fallback to OrthConnector\n            return _a.OrthConnector(state, source, target, points, result);\n        }\n        if (state.style) {\n            if (state.visibleSourceState && routePoints.length > 0) {\n                // If there are at least one point, align it to source cell\n                alignPointToCell(routePoints[0], state, state.visibleSourceState, true);\n            }\n            if (state.visibleTargetState && routePoints.length > 1) {\n                // If there are more than one point, align last point to target cell\n                alignPointToCell(routePoints[routePoints.length - 1], state, state.visibleTargetState, false);\n            }\n        }\n        // Scaling and translating result points\n        const scale = state.view.scale;\n        routePoints.forEach((pt) => result.push(new Point(Math.round((pt.x + state.view.translate.x) * scale * 10) / 10, Math.round((pt.y + state.view.translate.y) * scale * 10) / 10)));\n    }\n    router(state, source, target, points, result, config);\n};\nexport default EdgeStyle;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1987, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1993, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/StyleRegistry.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Singleton class that acts as a global converter from string to object values\n * in a style. This is currently only used to perimeters and edge styles.\n */\nclass StyleRegistry {\n    /**\n     * Puts the given object into the registry under the given name.\n     */\n    static putValue(name, obj) {\n        StyleRegistry.values[name] = obj;\n    }\n    /**\n     * Returns the value associated with the given name.\n     */\n    static getValue(name) {\n        return StyleRegistry.values[name];\n    }\n    /**\n     * Returns the name for the given value.\n     */\n    static getName(value) {\n        for (const key in StyleRegistry.values) {\n            if (StyleRegistry.values[key] === value) {\n                return key;\n            }\n        }\n        return null;\n    }\n}\n/**\n * Maps from strings to objects.\n */\nStyleRegistry.values = {};\nexport default StyleRegistry;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA,GACA;;;CAGC;;;AACD,MAAM;IACF;;KAEC,GACD,OAAO,SAAS,IAAI,EAAE,GAAG,EAAE;QACvB,cAAc,MAAM,CAAC,KAAK,GAAG;IACjC;IACA;;KAEC,GACD,OAAO,SAAS,IAAI,EAAE;QAClB,OAAO,cAAc,MAAM,CAAC,KAAK;IACrC;IACA;;KAEC,GACD,OAAO,QAAQ,KAAK,EAAE;QAClB,IAAK,MAAM,OAAO,cAAc,MAAM,CAAE;YACpC,IAAI,cAAc,MAAM,CAAC,IAAI,KAAK,OAAO;gBACrC,OAAO;YACX;QACJ;QACA,OAAO;IACX;AACJ;AACA;;CAEC,GACD,cAAc,MAAM,GAAG,CAAC;uCACT","ignoreList":[0]}},
    {"offset": {"line": 2041, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2047, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/Stylesheet.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { ALIGN, ARROW, NONE, SHAPE } from '../../util/Constants';\n/**\n * Defines the appearance of the cells in a graph. See {@link putCellStyle} for an example\n * of creating a new cell style.\n *\n * Existing styles can be cloned using {@link clone} and turned into a string for debugging\n * using {@link toString}.\n *\n * ### Default Styles\n *\n * The stylesheet contains two built-in styles, which are used if no style is defined for\n * a cell:\n *\n * - `defaultVertex`: default style for vertices\n * - `defaultEdge`: default style for edges\n *\n * ### Example\n *\n * ```javascript\n * const defaultVertexStyle = stylesheet.getDefaultVertexStyle();\n * defaultVertexStyle.rounded = true;\n * const defaultEdgeStyle = stylesheet.getDefaultEdgeStyle();\n * defaultEdgeStyle.edgeStyle = EdgeStyle.EntityRelation;\n * ```\n */\nexport class Stylesheet {\n    constructor() {\n        this.styles = new Map();\n        this.putDefaultVertexStyle(this.createDefaultVertexStyle());\n        this.putDefaultEdgeStyle(this.createDefaultEdgeStyle());\n    }\n    /**\n     * Creates and returns the default vertex style.\n     */\n    createDefaultVertexStyle() {\n        const style = {};\n        style.shape = SHAPE.RECTANGLE;\n        style.perimeter = 'rectanglePerimeter';\n        style.verticalAlign = ALIGN.MIDDLE;\n        style.align = ALIGN.CENTER;\n        style.fillColor = '#C3D9FF';\n        style.strokeColor = '#6482B9';\n        style.fontColor = '#774400';\n        return style;\n    }\n    /**\n     * Creates and returns the default edge style.\n     */\n    createDefaultEdgeStyle() {\n        const style = {};\n        style.shape = SHAPE.CONNECTOR;\n        style.endArrow = ARROW.CLASSIC;\n        style.verticalAlign = ALIGN.MIDDLE;\n        style.align = ALIGN.CENTER;\n        style.strokeColor = '#6482B9';\n        style.fontColor = '#446299';\n        return style;\n    }\n    /**\n     * Sets the default style for vertices using `defaultVertex` as the style name.\n     * @param style The style to be stored.\n     */\n    putDefaultVertexStyle(style) {\n        this.putCellStyle('defaultVertex', style);\n    }\n    /**\n     * Sets the default style for edges using `defaultEdge` as the style name.\n     * @param style The style to be stored.\n     */\n    putDefaultEdgeStyle(style) {\n        this.putCellStyle('defaultEdge', style);\n    }\n    /**\n     * Returns the default style for vertices.\n     */\n    getDefaultVertexStyle() {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- the style is set in the constructor\n        return this.styles.get('defaultVertex');\n    }\n    /**\n     * Returns the default style for edges.\n     */\n    getDefaultEdgeStyle() {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- the style is set in the constructor\n        return this.styles.get('defaultEdge');\n    }\n    /**\n     * Stores the given {@link CellStateStyle} under the given name in {@link styles}.\n     *\n     * ### Example\n     *\n     * The following example adds a new style called `rounded` into an existing stylesheet:\n     *\n     * ```javascript\n     * const style = {} as CellStateStyle;\n     * style.shape = SHAPE.RECTANGLE;\n     * style.perimeter = PERIMETER.RECTANGLE;\n     * style.rounded = true;\n     * graph.getStylesheet().putCellStyle('rounded', style);\n     * ```\n     *\n     * ### Description\n     *\n     * Note that not all properties will be interpreted by all shapes. For example, the 'line' shape ignores the fill color.\n     * The final call to this method associates the style with a name in the stylesheet.\n     *\n     * The style is used in a cell with the following code:\n     * ```javascript\n     * // model is an instance of GraphDataModel\n     * // style is an instance of CellStyle\n     * model.setStyle(cell, { baseStyleNames: ['rounded'] });\n     * ```\n     *\n     * @param name Name for the style to be stored.\n     * @param style The instance of the style to be stored.\n     */\n    putCellStyle(name, style) {\n        this.styles.set(name, style);\n    }\n    /**\n     * Returns a {@link CellStateStyle} computed by merging the default style, styles referenced in the specified `baseStyleNames`\n     * and the properties of the `cellStyle` parameter.\n     *\n     * The properties are merged by taking the properties from various styles in the following order:\n     *   - default style (if {@link CellStyle.ignoreDefaultStyle} is not set to `true`, otherwise it is ignored)\n     *   - registered styles referenced in `baseStyleNames`, in the order of the array\n     *   - `cellStyle` parameter\n     *\n     * To fully unset a style property i.e. the property is not set even if a value is set in the default style or in the referenced styles,\n     * set the `cellStyle` property to `none`. For example. `cellStyle.fillColor = 'none'`\n     *\n     * @param cellStyle An object that represents the style.\n     * @param defaultStyle Default style used as reference to compute the returned style.\n     */\n    getCellStyle(cellStyle, defaultStyle) {\n        let style = cellStyle.ignoreDefaultStyle ? {} : { ...defaultStyle };\n        if (cellStyle.baseStyleNames) {\n            // creates style with the given baseStyleNames. (merges from left to right)\n            style = cellStyle.baseStyleNames.reduce((acc, styleName) => {\n                return {\n                    ...acc,\n                    ...this.styles.get(styleName),\n                };\n            }, style);\n        }\n        // Merges cellStyle into style\n        for (const key of Object.keys(cellStyle)) {\n            // @ts-ignore\n            if (cellStyle[key] !== undefined) {\n                // @ts-ignore\n                cellStyle[key] == NONE ? delete style[key] : (style[key] = cellStyle[key]);\n            }\n        }\n        // Remove the specific CellStyle properties that may have been copied from the cellStyle parameter to match the method signature\n        'baseStyleNames' in style && delete style.baseStyleNames;\n        'ignoreDefaultStyle' in style && delete style.ignoreDefaultStyle;\n        return style;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AACA;;AAyBO,MAAM;IACT,aAAc;QACV,IAAI,CAAC,MAAM,GAAG,IAAI;QAClB,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,wBAAwB;QACxD,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,sBAAsB;IACxD;IACA;;KAEC,GACD,2BAA2B;QACvB,MAAM,QAAQ,CAAC;QACf,MAAM,KAAK,GAAG,8JAAA,CAAA,QAAK,CAAC,SAAS;QAC7B,MAAM,SAAS,GAAG;QAClB,MAAM,aAAa,GAAG,8JAAA,CAAA,QAAK,CAAC,MAAM;QAClC,MAAM,KAAK,GAAG,8JAAA,CAAA,QAAK,CAAC,MAAM;QAC1B,MAAM,SAAS,GAAG;QAClB,MAAM,WAAW,GAAG;QACpB,MAAM,SAAS,GAAG;QAClB,OAAO;IACX;IACA;;KAEC,GACD,yBAAyB;QACrB,MAAM,QAAQ,CAAC;QACf,MAAM,KAAK,GAAG,8JAAA,CAAA,QAAK,CAAC,SAAS;QAC7B,MAAM,QAAQ,GAAG,8JAAA,CAAA,QAAK,CAAC,OAAO;QAC9B,MAAM,aAAa,GAAG,8JAAA,CAAA,QAAK,CAAC,MAAM;QAClC,MAAM,KAAK,GAAG,8JAAA,CAAA,QAAK,CAAC,MAAM;QAC1B,MAAM,WAAW,GAAG;QACpB,MAAM,SAAS,GAAG;QAClB,OAAO;IACX;IACA;;;KAGC,GACD,sBAAsB,KAAK,EAAE;QACzB,IAAI,CAAC,YAAY,CAAC,iBAAiB;IACvC;IACA;;;KAGC,GACD,oBAAoB,KAAK,EAAE;QACvB,IAAI,CAAC,YAAY,CAAC,eAAe;IACrC;IACA;;KAEC,GACD,wBAAwB;QACpB,2GAA2G;QAC3G,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC;IAC3B;IACA;;KAEC,GACD,sBAAsB;QAClB,2GAA2G;QAC3G,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC;IAC3B;IACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KA6BC,GACD,aAAa,IAAI,EAAE,KAAK,EAAE;QACtB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM;IAC1B;IACA;;;;;;;;;;;;;;KAcC,GACD,aAAa,SAAS,EAAE,YAAY,EAAE;QAClC,IAAI,QAAQ,UAAU,kBAAkB,GAAG,CAAC,IAAI;YAAE,GAAG,YAAY;QAAC;QAClE,IAAI,UAAU,cAAc,EAAE;YAC1B,2EAA2E;YAC3E,QAAQ,UAAU,cAAc,CAAC,MAAM,CAAC,CAAC,KAAK;gBAC1C,OAAO;oBACH,GAAG,GAAG;oBACN,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,UAAU;gBACjC;YACJ,GAAG;QACP;QACA,8BAA8B;QAC9B,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,WAAY;YACtC,aAAa;YACb,IAAI,SAAS,CAAC,IAAI,KAAK,WAAW;gBAC9B,aAAa;gBACb,SAAS,CAAC,IAAI,IAAI,8JAAA,CAAA,OAAI,GAAG,OAAO,KAAK,CAAC,IAAI,GAAI,KAAK,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI;YAC7E;QACJ;QACA,gIAAgI;QAChI,oBAAoB,SAAS,OAAO,MAAM,cAAc;QACxD,wBAAwB,SAAS,OAAO,MAAM,kBAAkB;QAChE,OAAO;IACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2196, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2202, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/perimeter/RectanglePerimeter.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\n/**\n * Describes a rectangular perimeter for the given bounds.\n *\n * @category Perimeter\n */\nexport const RectanglePerimeter = (bounds, _vertex, next, orthogonal = false) => {\n    const cx = bounds.getCenterX();\n    const cy = bounds.getCenterY();\n    const dx = next.x - cx;\n    const dy = next.y - cy;\n    const alpha = Math.atan2(dy, dx);\n    const p = new Point(0, 0);\n    const pi = Math.PI;\n    const pi2 = Math.PI / 2;\n    const beta = pi2 - alpha;\n    const t = Math.atan2(bounds.height, bounds.width);\n    if (alpha < -pi + t || alpha > pi - t) {\n        // Left edge\n        p.x = bounds.x;\n        p.y = cy - (bounds.width * Math.tan(alpha)) / 2;\n    }\n    else if (alpha < -t) {\n        // Top Edge\n        p.y = bounds.y;\n        p.x = cx - (bounds.height * Math.tan(beta)) / 2;\n    }\n    else if (alpha < t) {\n        // Right Edge\n        p.x = bounds.x + bounds.width;\n        p.y = cy + (bounds.width * Math.tan(alpha)) / 2;\n    }\n    else {\n        // Bottom Edge\n        p.y = bounds.y + bounds.height;\n        p.x = cx + (bounds.height * Math.tan(beta)) / 2;\n    }\n    if (orthogonal) {\n        if (next.x >= bounds.x && next.x <= bounds.x + bounds.width) {\n            p.x = next.x;\n        }\n        else if (next.y >= bounds.y && next.y <= bounds.y + bounds.height) {\n            p.y = next.y;\n        }\n        if (next.x < bounds.x) {\n            p.x = bounds.x;\n        }\n        else if (next.x > bounds.x + bounds.width) {\n            p.x = bounds.x + bounds.width;\n        }\n        if (next.y < bounds.y) {\n            p.y = bounds.y;\n        }\n        else if (next.y > bounds.y + bounds.height) {\n            p.y = bounds.y + bounds.height;\n        }\n    }\n    return p;\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AACA;;AAMO,MAAM,qBAAqB,CAAC,QAAQ,SAAS,MAAM,aAAa,KAAK;IACxE,MAAM,KAAK,OAAO,UAAU;IAC5B,MAAM,KAAK,OAAO,UAAU;IAC5B,MAAM,KAAK,KAAK,CAAC,GAAG;IACpB,MAAM,KAAK,KAAK,CAAC,GAAG;IACpB,MAAM,QAAQ,KAAK,KAAK,CAAC,IAAI;IAC7B,MAAM,IAAI,IAAI,sKAAA,CAAA,UAAK,CAAC,GAAG;IACvB,MAAM,KAAK,KAAK,EAAE;IAClB,MAAM,MAAM,KAAK,EAAE,GAAG;IACtB,MAAM,OAAO,MAAM;IACnB,MAAM,IAAI,KAAK,KAAK,CAAC,OAAO,MAAM,EAAE,OAAO,KAAK;IAChD,IAAI,QAAQ,CAAC,KAAK,KAAK,QAAQ,KAAK,GAAG;QACnC,YAAY;QACZ,EAAE,CAAC,GAAG,OAAO,CAAC;QACd,EAAE,CAAC,GAAG,KAAK,AAAC,OAAO,KAAK,GAAG,KAAK,GAAG,CAAC,SAAU;IAClD,OACK,IAAI,QAAQ,CAAC,GAAG;QACjB,WAAW;QACX,EAAE,CAAC,GAAG,OAAO,CAAC;QACd,EAAE,CAAC,GAAG,KAAK,AAAC,OAAO,MAAM,GAAG,KAAK,GAAG,CAAC,QAAS;IAClD,OACK,IAAI,QAAQ,GAAG;QAChB,aAAa;QACb,EAAE,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,KAAK;QAC7B,EAAE,CAAC,GAAG,KAAK,AAAC,OAAO,KAAK,GAAG,KAAK,GAAG,CAAC,SAAU;IAClD,OACK;QACD,cAAc;QACd,EAAE,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,MAAM;QAC9B,EAAE,CAAC,GAAG,KAAK,AAAC,OAAO,MAAM,GAAG,KAAK,GAAG,CAAC,QAAS;IAClD;IACA,IAAI,YAAY;QACZ,IAAI,KAAK,CAAC,IAAI,OAAO,CAAC,IAAI,KAAK,CAAC,IAAI,OAAO,CAAC,GAAG,OAAO,KAAK,EAAE;YACzD,EAAE,CAAC,GAAG,KAAK,CAAC;QAChB,OACK,IAAI,KAAK,CAAC,IAAI,OAAO,CAAC,IAAI,KAAK,CAAC,IAAI,OAAO,CAAC,GAAG,OAAO,MAAM,EAAE;YAC/D,EAAE,CAAC,GAAG,KAAK,CAAC;QAChB;QACA,IAAI,KAAK,CAAC,GAAG,OAAO,CAAC,EAAE;YACnB,EAAE,CAAC,GAAG,OAAO,CAAC;QAClB,OACK,IAAI,KAAK,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,KAAK,EAAE;YACvC,EAAE,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,KAAK;QACjC;QACA,IAAI,KAAK,CAAC,GAAG,OAAO,CAAC,EAAE;YACnB,EAAE,CAAC,GAAG,OAAO,CAAC;QAClB,OACK,IAAI,KAAK,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,MAAM,EAAE;YACxC,EAAE,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,MAAM;QAClC;IACJ;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 2270, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2276, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/perimeter/EllipsePerimeter.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\n/**\n * @category Perimeter\n */\nexport const EllipsePerimeter = (bounds, _vertex, next, orthogonal = false) => {\n    const { x } = bounds;\n    const { y } = bounds;\n    const a = bounds.width / 2;\n    const b = bounds.height / 2;\n    const cx = x + a;\n    const cy = y + b;\n    const px = next.x;\n    const py = next.y;\n    // Calculates straight line equation through\n    // point and ellipse center y = d * x + h\n    const dx = parseInt(String(px - cx));\n    const dy = parseInt(String(py - cy));\n    if (dx === 0 && dy !== 0) {\n        return new Point(cx, cy + (b * dy) / Math.abs(dy));\n    }\n    if (dx === 0 && dy === 0) {\n        return new Point(px, py);\n    }\n    if (orthogonal) {\n        if (py >= y && py <= y + bounds.height) {\n            const ty = py - cy;\n            let tx = Math.sqrt(a * a * (1 - (ty * ty) / (b * b))) || 0;\n            if (px <= x) {\n                tx = -tx;\n            }\n            return new Point(cx + tx, py);\n        }\n        if (px >= x && px <= x + bounds.width) {\n            const tx = px - cx;\n            let ty = Math.sqrt(b * b * (1 - (tx * tx) / (a * a))) || 0;\n            if (py <= y) {\n                ty = -ty;\n            }\n            return new Point(px, cy + ty);\n        }\n    }\n    // Calculates intersection\n    const d = dy / dx;\n    const h = cy - d * cx;\n    const e = a * a * d * d + b * b;\n    const f = -2 * cx * e;\n    const g = a * a * d * d * cx * cx + b * b * cx * cx - a * a * b * b;\n    const det = Math.sqrt(f * f - 4 * e * g);\n    // Two solutions (perimeter points)\n    const xout1 = (-f + det) / (2 * e);\n    const xout2 = (-f - det) / (2 * e);\n    const yout1 = d * xout1 + h;\n    const yout2 = d * xout2 + h;\n    const dist1 = Math.sqrt(Math.pow(xout1 - px, 2) + Math.pow(yout1 - py, 2));\n    const dist2 = Math.sqrt(Math.pow(xout2 - px, 2) + Math.pow(yout2 - py, 2));\n    // Correct solution\n    let xout = 0;\n    let yout = 0;\n    if (dist1 < dist2) {\n        xout = xout1;\n        yout = yout1;\n    }\n    else {\n        xout = xout2;\n        yout = yout2;\n    }\n    return new Point(xout, yout);\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AACA;;AAIO,MAAM,mBAAmB,CAAC,QAAQ,SAAS,MAAM,aAAa,KAAK;IACtE,MAAM,EAAE,CAAC,EAAE,GAAG;IACd,MAAM,EAAE,CAAC,EAAE,GAAG;IACd,MAAM,IAAI,OAAO,KAAK,GAAG;IACzB,MAAM,IAAI,OAAO,MAAM,GAAG;IAC1B,MAAM,KAAK,IAAI;IACf,MAAM,KAAK,IAAI;IACf,MAAM,KAAK,KAAK,CAAC;IACjB,MAAM,KAAK,KAAK,CAAC;IACjB,4CAA4C;IAC5C,yCAAyC;IACzC,MAAM,KAAK,SAAS,OAAO,KAAK;IAChC,MAAM,KAAK,SAAS,OAAO,KAAK;IAChC,IAAI,OAAO,KAAK,OAAO,GAAG;QACtB,OAAO,IAAI,sKAAA,CAAA,UAAK,CAAC,IAAI,KAAK,AAAC,IAAI,KAAM,KAAK,GAAG,CAAC;IAClD;IACA,IAAI,OAAO,KAAK,OAAO,GAAG;QACtB,OAAO,IAAI,sKAAA,CAAA,UAAK,CAAC,IAAI;IACzB;IACA,IAAI,YAAY;QACZ,IAAI,MAAM,KAAK,MAAM,IAAI,OAAO,MAAM,EAAE;YACpC,MAAM,KAAK,KAAK;YAChB,IAAI,KAAK,KAAK,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,AAAC,KAAK,KAAM,CAAC,IAAI,CAAC,CAAC,MAAM;YACzD,IAAI,MAAM,GAAG;gBACT,KAAK,CAAC;YACV;YACA,OAAO,IAAI,sKAAA,CAAA,UAAK,CAAC,KAAK,IAAI;QAC9B;QACA,IAAI,MAAM,KAAK,MAAM,IAAI,OAAO,KAAK,EAAE;YACnC,MAAM,KAAK,KAAK;YAChB,IAAI,KAAK,KAAK,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,AAAC,KAAK,KAAM,CAAC,IAAI,CAAC,CAAC,MAAM;YACzD,IAAI,MAAM,GAAG;gBACT,KAAK,CAAC;YACV;YACA,OAAO,IAAI,sKAAA,CAAA,UAAK,CAAC,IAAI,KAAK;QAC9B;IACJ;IACA,0BAA0B;IAC1B,MAAM,IAAI,KAAK;IACf,MAAM,IAAI,KAAK,IAAI;IACnB,MAAM,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;IAC9B,MAAM,IAAI,CAAC,IAAI,KAAK;IACpB,MAAM,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,IAAI,IAAI,IAAI;IAClE,MAAM,MAAM,KAAK,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI;IACtC,mCAAmC;IACnC,MAAM,QAAQ,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;IACjC,MAAM,QAAQ,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;IACjC,MAAM,QAAQ,IAAI,QAAQ;IAC1B,MAAM,QAAQ,IAAI,QAAQ;IAC1B,MAAM,QAAQ,KAAK,IAAI,CAAC,KAAK,GAAG,CAAC,QAAQ,IAAI,KAAK,KAAK,GAAG,CAAC,QAAQ,IAAI;IACvE,MAAM,QAAQ,KAAK,IAAI,CAAC,KAAK,GAAG,CAAC,QAAQ,IAAI,KAAK,KAAK,GAAG,CAAC,QAAQ,IAAI;IACvE,mBAAmB;IACnB,IAAI,OAAO;IACX,IAAI,OAAO;IACX,IAAI,QAAQ,OAAO;QACf,OAAO;QACP,OAAO;IACX,OACK;QACD,OAAO;QACP,OAAO;IACX;IACA,OAAO,IAAI,sKAAA,CAAA,UAAK,CAAC,MAAM;AAC3B","ignoreList":[0]}},
    {"offset": {"line": 2360, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2366, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/perimeter/RhombusPerimeter.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\nimport { intersection } from '../../../util/mathUtils';\n/**\n * @category Perimeter\n */\nexport const RhombusPerimeter = (bounds, _vertex, next, orthogonal = false) => {\n    const { x } = bounds;\n    const { y } = bounds;\n    const w = bounds.width;\n    const h = bounds.height;\n    const cx = x + w / 2;\n    const cy = y + h / 2;\n    const px = next.x;\n    const py = next.y;\n    // Special case for intersecting the diamond's corners\n    if (cx === px) {\n        if (cy > py) {\n            return new Point(cx, y); // top\n        }\n        return new Point(cx, y + h); // bottom\n    }\n    if (cy === py) {\n        if (cx > px) {\n            return new Point(x, cy); // left\n        }\n        return new Point(x + w, cy); // right\n    }\n    let tx = cx;\n    let ty = cy;\n    if (orthogonal) {\n        if (px >= x && px <= x + w) {\n            tx = px;\n        }\n        else if (py >= y && py <= y + h) {\n            ty = py;\n        }\n    }\n    // In which quadrant will the intersection be?\n    // set the slope and offset of the border line accordingly\n    if (px < cx) {\n        if (py < cy) {\n            return intersection(px, py, tx, ty, cx, y, x, cy);\n        }\n        return intersection(px, py, tx, ty, cx, y + h, x, cy);\n    }\n    if (py < cy) {\n        return intersection(px, py, tx, ty, cx, y, x + w, cy);\n    }\n    return intersection(px, py, tx, ty, cx, y + h, x + w, cy);\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AAEA;AADA;;;AAKO,MAAM,mBAAmB,CAAC,QAAQ,SAAS,MAAM,aAAa,KAAK;IACtE,MAAM,EAAE,CAAC,EAAE,GAAG;IACd,MAAM,EAAE,CAAC,EAAE,GAAG;IACd,MAAM,IAAI,OAAO,KAAK;IACtB,MAAM,IAAI,OAAO,MAAM;IACvB,MAAM,KAAK,IAAI,IAAI;IACnB,MAAM,KAAK,IAAI,IAAI;IACnB,MAAM,KAAK,KAAK,CAAC;IACjB,MAAM,KAAK,KAAK,CAAC;IACjB,sDAAsD;IACtD,IAAI,OAAO,IAAI;QACX,IAAI,KAAK,IAAI;YACT,OAAO,IAAI,sKAAA,CAAA,UAAK,CAAC,IAAI,IAAI,MAAM;QACnC;QACA,OAAO,IAAI,sKAAA,CAAA,UAAK,CAAC,IAAI,IAAI,IAAI,SAAS;IAC1C;IACA,IAAI,OAAO,IAAI;QACX,IAAI,KAAK,IAAI;YACT,OAAO,IAAI,sKAAA,CAAA,UAAK,CAAC,GAAG,KAAK,OAAO;QACpC;QACA,OAAO,IAAI,sKAAA,CAAA,UAAK,CAAC,IAAI,GAAG,KAAK,QAAQ;IACzC;IACA,IAAI,KAAK;IACT,IAAI,KAAK;IACT,IAAI,YAAY;QACZ,IAAI,MAAM,KAAK,MAAM,IAAI,GAAG;YACxB,KAAK;QACT,OACK,IAAI,MAAM,KAAK,MAAM,IAAI,GAAG;YAC7B,KAAK;QACT;IACJ;IACA,8CAA8C;IAC9C,0DAA0D;IAC1D,IAAI,KAAK,IAAI;QACT,IAAI,KAAK,IAAI;YACT,OAAO,CAAA,GAAA,8JAAA,CAAA,eAAY,AAAD,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG;QAClD;QACA,OAAO,CAAA,GAAA,8JAAA,CAAA,eAAY,AAAD,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG;IACtD;IACA,IAAI,KAAK,IAAI;QACT,OAAO,CAAA,GAAA,8JAAA,CAAA,eAAY,AAAD,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG;IACtD;IACA,OAAO,CAAA,GAAA,8JAAA,CAAA,eAAY,AAAD,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG;AAC1D","ignoreList":[0]}},
    {"offset": {"line": 2433, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2439, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/perimeter/TrianglePerimeter.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\nimport { DIRECTION } from '../../../util/Constants';\nimport { intersection } from '../../../util/mathUtils';\n/**\n * @category Perimeter\n */\nexport const TrianglePerimeter = (bounds, vertex, next, orthogonal = false) => {\n    const direction = vertex != null ? vertex.style.direction : null;\n    const vertical = direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH;\n    const { x } = bounds;\n    const { y } = bounds;\n    const w = bounds.width;\n    const h = bounds.height;\n    let cx = x + w / 2;\n    let cy = y + h / 2;\n    let start = new Point(x, y);\n    let corner = new Point(x + w, cy);\n    let end = new Point(x, y + h);\n    if (direction === DIRECTION.NORTH) {\n        start = end;\n        corner = new Point(cx, y);\n        end = new Point(x + w, y + h);\n    }\n    else if (direction === DIRECTION.SOUTH) {\n        corner = new Point(cx, y + h);\n        end = new Point(x + w, y);\n    }\n    else if (direction === DIRECTION.WEST) {\n        start = new Point(x + w, y);\n        corner = new Point(x, cy);\n        end = new Point(x + w, y + h);\n    }\n    let dx = next.x - cx;\n    let dy = next.y - cy;\n    const alpha = vertical ? Math.atan2(dx, dy) : Math.atan2(dy, dx);\n    const t = vertical ? Math.atan2(w, h) : Math.atan2(h, w);\n    let base = false;\n    if (direction === DIRECTION.NORTH || direction === DIRECTION.WEST) {\n        base = alpha > -t && alpha < t;\n    }\n    else {\n        base = alpha < -Math.PI + t || alpha > Math.PI - t;\n    }\n    let result = null;\n    if (base) {\n        if (orthogonal &&\n            ((vertical && next.x >= start.x && next.x <= end.x) ||\n                (!vertical && next.y >= start.y && next.y <= end.y))) {\n            if (vertical) {\n                result = new Point(next.x, start.y);\n            }\n            else {\n                result = new Point(start.x, next.y);\n            }\n        }\n        else if (direction === DIRECTION.NORTH) {\n            result = new Point(x + w / 2 + (h * Math.tan(alpha)) / 2, y + h);\n        }\n        else if (direction === DIRECTION.SOUTH) {\n            result = new Point(x + w / 2 - (h * Math.tan(alpha)) / 2, y);\n        }\n        else if (direction === DIRECTION.WEST) {\n            result = new Point(x + w, y + h / 2 + (w * Math.tan(alpha)) / 2);\n        }\n        else {\n            result = new Point(x, y + h / 2 - (w * Math.tan(alpha)) / 2);\n        }\n    }\n    else {\n        if (orthogonal) {\n            const pt = new Point(cx, cy);\n            if (next.y >= y && next.y <= y + h) {\n                pt.x = vertical ? cx : direction === DIRECTION.WEST ? x + w : x;\n                pt.y = next.y;\n            }\n            else if (next.x >= x && next.x <= x + w) {\n                pt.x = next.x;\n                pt.y = !vertical ? cy : direction === DIRECTION.NORTH ? y + h : y;\n            }\n            // Compute angle\n            dx = next.x - pt.x;\n            dy = next.y - pt.y;\n            cx = pt.x;\n            cy = pt.y;\n        }\n        if ((vertical && next.x <= x + w / 2) || (!vertical && next.y <= y + h / 2)) {\n            result = intersection(next.x, next.y, cx, cy, start.x, start.y, corner.x, corner.y);\n        }\n        else {\n            result = intersection(next.x, next.y, cx, cy, corner.x, corner.y, end.x, end.y);\n        }\n    }\n    if (result == null) {\n        result = new Point(cx, cy);\n    }\n    return result;\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2542, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2548, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/perimeter/HexagonPerimeter.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\nimport { DIRECTION } from '../../../util/Constants';\nimport { intersection } from '../../../util/mathUtils';\n/**\n * @category Perimeter\n */\nexport const HexagonPerimeter = (bounds, vertex, next, orthogonal = false) => {\n    const { x } = bounds;\n    const { y } = bounds;\n    const w = bounds.width;\n    const h = bounds.height;\n    const cx = bounds.getCenterX();\n    const cy = bounds.getCenterY();\n    const px = next.x;\n    const py = next.y;\n    const dx = px - cx;\n    const dy = py - cy;\n    const alpha = -Math.atan2(dy, dx);\n    const pi = Math.PI;\n    const pi2 = Math.PI / 2;\n    let result = new Point(cx, cy);\n    const direction = vertex?.style?.direction ?? DIRECTION.EAST;\n    const vertical = direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH;\n    let a = new Point();\n    let b = new Point();\n    // Only consider corrects quadrants for the orthogonal case.\n    if ((px < x && py < y) ||\n        (px < x && py > y + h) ||\n        (px > x + w && py < y) ||\n        (px > x + w && py > y + h)) {\n        orthogonal = false;\n    }\n    if (orthogonal) {\n        if (vertical) {\n            // Special cases where intersects with hexagon corners\n            if (px === cx) {\n                if (py <= y) {\n                    return new Point(cx, y);\n                }\n                if (py >= y + h) {\n                    return new Point(cx, y + h);\n                }\n            }\n            else if (px < x) {\n                if (py === y + h / 4) {\n                    return new Point(x, y + h / 4);\n                }\n                if (py === y + (3 * h) / 4) {\n                    return new Point(x, y + (3 * h) / 4);\n                }\n            }\n            else if (px > x + w) {\n                if (py === y + h / 4) {\n                    return new Point(x + w, y + h / 4);\n                }\n                if (py === y + (3 * h) / 4) {\n                    return new Point(x + w, y + (3 * h) / 4);\n                }\n            }\n            else if (px === x) {\n                if (py < cy) {\n                    return new Point(x, y + h / 4);\n                }\n                if (py > cy) {\n                    return new Point(x, y + (3 * h) / 4);\n                }\n            }\n            else if (px === x + w) {\n                if (py < cy) {\n                    return new Point(x + w, y + h / 4);\n                }\n                if (py > cy) {\n                    return new Point(x + w, y + (3 * h) / 4);\n                }\n            }\n            if (py === y) {\n                return new Point(cx, y);\n            }\n            if (py === y + h) {\n                return new Point(cx, y + h);\n            }\n            if (px < cx) {\n                if (py > y + h / 4 && py < y + (3 * h) / 4) {\n                    a = new Point(x, y);\n                    b = new Point(x, y + h);\n                }\n                else if (py < y + h / 4) {\n                    a = new Point(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));\n                    b = new Point(x + w, y - Math.floor(0.25 * h));\n                }\n                else if (py > y + (3 * h) / 4) {\n                    a = new Point(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));\n                    b = new Point(x + w, y + Math.floor(1.25 * h));\n                }\n            }\n            else if (px > cx) {\n                if (py > y + h / 4 && py < y + (3 * h) / 4) {\n                    a = new Point(x + w, y);\n                    b = new Point(x + w, y + h);\n                }\n                else if (py < y + h / 4) {\n                    a = new Point(x, y - Math.floor(0.25 * h));\n                    b = new Point(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));\n                }\n                else if (py > y + (3 * h) / 4) {\n                    a = new Point(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));\n                    b = new Point(x, y + Math.floor(1.25 * h));\n                }\n            }\n        }\n        else {\n            // Special cases where intersects with hexagon corners\n            if (py === cy) {\n                if (px <= x) {\n                    return new Point(x, y + h / 2);\n                }\n                if (px >= x + w) {\n                    return new Point(x + w, y + h / 2);\n                }\n            }\n            else if (py < y) {\n                if (px === x + w / 4) {\n                    return new Point(x + w / 4, y);\n                }\n                if (px === x + (3 * w) / 4) {\n                    return new Point(x + (3 * w) / 4, y);\n                }\n            }\n            else if (py > y + h) {\n                if (px === x + w / 4) {\n                    return new Point(x + w / 4, y + h);\n                }\n                if (px === x + (3 * w) / 4) {\n                    return new Point(x + (3 * w) / 4, y + h);\n                }\n            }\n            else if (py === y) {\n                if (px < cx) {\n                    return new Point(x + w / 4, y);\n                }\n                if (px > cx) {\n                    return new Point(x + (3 * w) / 4, y);\n                }\n            }\n            else if (py === y + h) {\n                if (px < cx) {\n                    return new Point(x + w / 4, y + h);\n                }\n                if (py > cy) {\n                    return new Point(x + (3 * w) / 4, y + h);\n                }\n            }\n            if (px === x) {\n                return new Point(x, cy);\n            }\n            if (px === x + w) {\n                return new Point(x + w, cy);\n            }\n            if (py < cy) {\n                if (px > x + w / 4 && px < x + (3 * w) / 4) {\n                    a = new Point(x, y);\n                    b = new Point(x + w, y);\n                }\n                else if (px < x + w / 4) {\n                    a = new Point(x - Math.floor(0.25 * w), y + h);\n                    b = new Point(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));\n                }\n                else if (px > x + (3 * w) / 4) {\n                    a = new Point(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));\n                    b = new Point(x + Math.floor(1.25 * w), y + h);\n                }\n            }\n            else if (py > cy) {\n                if (px > x + w / 4 && px < x + (3 * w) / 4) {\n                    a = new Point(x, y + h);\n                    b = new Point(x + w, y + h);\n                }\n                else if (px < x + w / 4) {\n                    a = new Point(x - Math.floor(0.25 * w), y);\n                    b = new Point(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));\n                }\n                else if (px > x + (3 * w) / 4) {\n                    a = new Point(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));\n                    b = new Point(x + Math.floor(1.25 * w), y);\n                }\n            }\n        }\n        let tx = cx;\n        let ty = cy;\n        if (px >= x && px <= x + w) {\n            tx = px;\n            if (py < cy) {\n                ty = y + h;\n            }\n            else {\n                ty = y;\n            }\n        }\n        else if (py >= y && py <= y + h) {\n            ty = py;\n            if (px < cx) {\n                tx = x + w;\n            }\n            else {\n                tx = x;\n            }\n        }\n        result = intersection(tx, ty, next.x, next.y, a.x, a.y, b.x, b.y);\n    }\n    else {\n        if (vertical) {\n            const beta = Math.atan2(h / 4, w / 2);\n            // Special cases where intersects with hexagon corners\n            if (alpha === beta) {\n                return new Point(x + w, y + Math.floor(0.25 * h));\n            }\n            if (alpha === pi2) {\n                return new Point(x + Math.floor(0.5 * w), y);\n            }\n            if (alpha === pi - beta) {\n                return new Point(x, y + Math.floor(0.25 * h));\n            }\n            if (alpha === -beta) {\n                return new Point(x + w, y + Math.floor(0.75 * h));\n            }\n            if (alpha === -pi2) {\n                return new Point(x + Math.floor(0.5 * w), y + h);\n            }\n            if (alpha === -pi + beta) {\n                return new Point(x, y + Math.floor(0.75 * h));\n            }\n            if (alpha < beta && alpha > -beta) {\n                a = new Point(x + w, y);\n                b = new Point(x + w, y + h);\n            }\n            else if (alpha > beta && alpha < pi2) {\n                a = new Point(x, y - Math.floor(0.25 * h));\n                b = new Point(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));\n            }\n            else if (alpha > pi2 && alpha < pi - beta) {\n                a = new Point(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));\n                b = new Point(x + w, y - Math.floor(0.25 * h));\n            }\n            else if ((alpha > pi - beta && alpha <= pi) ||\n                (alpha < -pi + beta && alpha >= -pi)) {\n                a = new Point(x, y);\n                b = new Point(x, y + h);\n            }\n            else if (alpha < -beta && alpha > -pi2) {\n                a = new Point(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));\n                b = new Point(x, y + Math.floor(1.25 * h));\n            }\n            else if (alpha < -pi2 && alpha > -pi + beta) {\n                a = new Point(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));\n                b = new Point(x + w, y + Math.floor(1.25 * h));\n            }\n        }\n        else {\n            const beta = Math.atan2(h / 2, w / 4);\n            // Special cases where intersects with hexagon corners\n            if (alpha === beta) {\n                return new Point(x + Math.floor(0.75 * w), y);\n            }\n            if (alpha === pi - beta) {\n                return new Point(x + Math.floor(0.25 * w), y);\n            }\n            if (alpha === pi || alpha === -pi) {\n                return new Point(x, y + Math.floor(0.5 * h));\n            }\n            if (alpha === 0) {\n                return new Point(x + w, y + Math.floor(0.5 * h));\n            }\n            if (alpha === -beta) {\n                return new Point(x + Math.floor(0.75 * w), y + h);\n            }\n            if (alpha === -pi + beta) {\n                return new Point(x + Math.floor(0.25 * w), y + h);\n            }\n            if (alpha > 0 && alpha < beta) {\n                a = new Point(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));\n                b = new Point(x + Math.floor(1.25 * w), y + h);\n            }\n            else if (alpha > beta && alpha < pi - beta) {\n                a = new Point(x, y);\n                b = new Point(x + w, y);\n            }\n            else if (alpha > pi - beta && alpha < pi) {\n                a = new Point(x - Math.floor(0.25 * w), y + h);\n                b = new Point(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));\n            }\n            else if (alpha < 0 && alpha > -beta) {\n                a = new Point(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));\n                b = new Point(x + Math.floor(1.25 * w), y);\n            }\n            else if (alpha < -beta && alpha > -pi + beta) {\n                a = new Point(x, y + h);\n                b = new Point(x + w, y + h);\n            }\n            else if (alpha < -pi + beta && alpha > -pi) {\n                a = new Point(x - Math.floor(0.25 * w), y);\n                b = new Point(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));\n            }\n        }\n        result = intersection(cx, cy, next.x, next.y, a.x, a.y, b.x, b.y);\n    }\n    if (result == null) {\n        return new Point(cx, cy);\n    }\n    return result;\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2839, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2845, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/Perimeter.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { EllipsePerimeter as EllipsePerimeterFunction } from './perimeter/EllipsePerimeter';\nimport { HexagonPerimeter as HexagonPerimeterFunction } from './perimeter/HexagonPerimeter';\nimport { RectanglePerimeter as RectanglePerimeterFunction } from './perimeter/RectanglePerimeter';\nimport { RhombusPerimeter as RhombusPerimeterFunction } from './perimeter/RhombusPerimeter';\nimport { TrianglePerimeter as TrianglePerimeterFunction } from './perimeter/TrianglePerimeter';\n/**\n * Provides various perimeter functions to be used in a style as the value of {@link CellStateStyle.perimeter}.\n *\n * @category Perimeter\n */\nconst Perimeter = {\n    /**\n     * Describes a rectangular perimeter.\n     */\n    RectanglePerimeter: RectanglePerimeterFunction,\n    /**\n     * Describes an elliptic perimeter.\n     */\n    EllipsePerimeter: EllipsePerimeterFunction,\n    /**\n     * Describes a rhombus (aka diamond) perimeter.\n     */\n    RhombusPerimeter: RhombusPerimeterFunction,\n    /**\n     * Describes a triangle perimeter.\n     */\n    TrianglePerimeter: TrianglePerimeterFunction,\n    /**\n     * Describes a hexagon perimeter.\n     */\n    HexagonPerimeter: HexagonPerimeterFunction,\n};\nexport default Perimeter;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AAGA;AAFA;AAGA;AACA;AAHA;;;;;;AAIA;;;;CAIC,GACD,MAAM,YAAY;IACd;;KAEC,GACD,oBAAoB,6LAAA,CAAA,qBAA0B;IAC9C;;KAEC,GACD,kBAAkB,2LAAA,CAAA,mBAAwB;IAC1C;;KAEC,GACD,kBAAkB,2LAAA,CAAA,mBAAwB;IAC1C;;KAEC,GACD,mBAAmB,4LAAA,CAAA,oBAAyB;IAC5C;;KAEC,GACD,kBAAkB,2LAAA,CAAA,mBAAwB;AAC9C;uCACe","ignoreList":[0]}},
    {"offset": {"line": 2896, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2902, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/style/register.js"],"sourcesContent":["/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { EDGESTYLE, PERIMETER } from '../../util/Constants';\nimport EdgeStyle from './EdgeStyle';\nimport Perimeter from './Perimeter';\nimport StyleRegistry from './StyleRegistry';\nlet isDefaultsRegistered = false;\n/**\n * Register style elements for \"EdgeStyle\" and \"Perimeters\".\n *\n * @category Configuration\n */\nexport const registerDefaultStyleElements = () => {\n    if (!isDefaultsRegistered) {\n        // Edge styles\n        StyleRegistry.putValue(EDGESTYLE.ELBOW, EdgeStyle.ElbowConnector);\n        StyleRegistry.putValue(EDGESTYLE.ENTITY_RELATION, EdgeStyle.EntityRelation);\n        StyleRegistry.putValue(EDGESTYLE.LOOP, EdgeStyle.Loop);\n        StyleRegistry.putValue(EDGESTYLE.MANHATTAN, EdgeStyle.ManhattanConnector);\n        StyleRegistry.putValue(EDGESTYLE.ORTHOGONAL, EdgeStyle.OrthConnector);\n        StyleRegistry.putValue(EDGESTYLE.SEGMENT, EdgeStyle.SegmentConnector);\n        StyleRegistry.putValue(EDGESTYLE.SIDETOSIDE, EdgeStyle.SideToSide);\n        StyleRegistry.putValue(EDGESTYLE.TOPTOBOTTOM, EdgeStyle.TopToBottom);\n        // Perimeters\n        StyleRegistry.putValue(PERIMETER.ELLIPSE, Perimeter.EllipsePerimeter);\n        StyleRegistry.putValue(PERIMETER.HEXAGON, Perimeter.HexagonPerimeter);\n        StyleRegistry.putValue(PERIMETER.RECTANGLE, Perimeter.RectanglePerimeter);\n        StyleRegistry.putValue(PERIMETER.RHOMBUS, Perimeter.RhombusPerimeter);\n        StyleRegistry.putValue(PERIMETER.TRIANGLE, Perimeter.TrianglePerimeter);\n        isDefaultsRegistered = true;\n    }\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcA;;;AAIA;AAHA;AACA;AACA;;;;;AAEA,IAAI,uBAAuB;AAMpB,MAAM,+BAA+B;IACxC,IAAI,CAAC,sBAAsB;QACvB,cAAc;QACd,2KAAA,CAAA,UAAa,CAAC,QAAQ,CAAC,8JAAA,CAAA,YAAS,CAAC,KAAK,EAAE,uKAAA,CAAA,UAAS,CAAC,cAAc;QAChE,2KAAA,CAAA,UAAa,CAAC,QAAQ,CAAC,8JAAA,CAAA,YAAS,CAAC,eAAe,EAAE,uKAAA,CAAA,UAAS,CAAC,cAAc;QAC1E,2KAAA,CAAA,UAAa,CAAC,QAAQ,CAAC,8JAAA,CAAA,YAAS,CAAC,IAAI,EAAE,uKAAA,CAAA,UAAS,CAAC,IAAI;QACrD,2KAAA,CAAA,UAAa,CAAC,QAAQ,CAAC,8JAAA,CAAA,YAAS,CAAC,SAAS,EAAE,uKAAA,CAAA,UAAS,CAAC,kBAAkB;QACxE,2KAAA,CAAA,UAAa,CAAC,QAAQ,CAAC,8JAAA,CAAA,YAAS,CAAC,UAAU,EAAE,uKAAA,CAAA,UAAS,CAAC,aAAa;QACpE,2KAAA,CAAA,UAAa,CAAC,QAAQ,CAAC,8JAAA,CAAA,YAAS,CAAC,OAAO,EAAE,uKAAA,CAAA,UAAS,CAAC,gBAAgB;QACpE,2KAAA,CAAA,UAAa,CAAC,QAAQ,CAAC,8JAAA,CAAA,YAAS,CAAC,UAAU,EAAE,uKAAA,CAAA,UAAS,CAAC,UAAU;QACjE,2KAAA,CAAA,UAAa,CAAC,QAAQ,CAAC,8JAAA,CAAA,YAAS,CAAC,WAAW,EAAE,uKAAA,CAAA,UAAS,CAAC,WAAW;QACnE,aAAa;QACb,2KAAA,CAAA,UAAa,CAAC,QAAQ,CAAC,8JAAA,CAAA,YAAS,CAAC,OAAO,EAAE,uKAAA,CAAA,UAAS,CAAC,gBAAgB;QACpE,2KAAA,CAAA,UAAa,CAAC,QAAQ,CAAC,8JAAA,CAAA,YAAS,CAAC,OAAO,EAAE,uKAAA,CAAA,UAAS,CAAC,gBAAgB;QACpE,2KAAA,CAAA,UAAa,CAAC,QAAQ,CAAC,8JAAA,CAAA,YAAS,CAAC,SAAS,EAAE,uKAAA,CAAA,UAAS,CAAC,kBAAkB;QACxE,2KAAA,CAAA,UAAa,CAAC,QAAQ,CAAC,8JAAA,CAAA,YAAS,CAAC,OAAO,EAAE,uKAAA,CAAA,UAAS,CAAC,gBAAgB;QACpE,2KAAA,CAAA,UAAa,CAAC,QAAQ,CAAC,8JAAA,CAAA,YAAS,CAAC,QAAQ,EAAE,uKAAA,CAAA,UAAS,CAAC,iBAAiB;QACtE,uBAAuB;IAC3B;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2948, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}