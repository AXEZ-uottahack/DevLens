module.exports = {

"[project]/node_modules/@maxgraph/core/lib/view/cell/CellPath.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ /**
 * Implements a mechanism for temporary cell Ids.
 * @class CellPath
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
class CellPath {
    constructor(){
        throw new Error("Static class can't be instantiated!");
    }
    /**
     * Creates the cell path for the given cell. The cell path is a
     * concatenation of the indices of all ancestors on the (finite) path to
     * the root, eg. "0.0.0.1".
     *
     * @param cell Cell whose path should be returned.
     */ static create(cell) {
        let result = '';
        let parent = cell.getParent();
        while(parent){
            const index = parent.getIndex(cell);
            result = index + CellPath.PATH_SEPARATOR + result;
            cell = parent;
            parent = cell.getParent();
        }
        // Remove trailing separator
        const n = result.length;
        if (n > 1) {
            result = result.substring(0, n - 1);
        }
        return result;
    }
    /**
     * Returns the path for the parent of the cell represented by the given
     * path. Returns null if the given path has no parent.
     *
     * @param path Path whose parent path should be returned.
     */ static getParentPath(path) {
        const index = path.lastIndexOf(CellPath.PATH_SEPARATOR);
        if (index >= 0) {
            return path.substring(0, index);
        }
        if (path.length > 0) {
            return '';
        }
        return null;
    }
    /**
     * Returns the cell for the specified cell path using the given root as the
     * root of the path.
     *
     * @param root Root cell of the path to be resolved.
     * @param path String that defines the path.
     */ static resolve(root, path) {
        let parent = root;
        const tokens = path.split(CellPath.PATH_SEPARATOR);
        for(let i = 0; i < tokens.length; i += 1){
            parent = parent.getChildAt(parseInt(tokens[i]));
        }
        return parent;
    }
    /**
     * Compares the given cell paths and returns -1 if p1 is smaller, 0 if
     * p1 is equal and 1 if p1 is greater than p2.
     */ static compare(p1, p2) {
        const min = Math.min(p1.length, p2.length);
        let comp = 0;
        for(let i = 0; i < min; i += 1){
            if (p1[i] !== p2[i]) {
                if (p1[i].length === 0 || p2[i].length === 0) {
                    comp = p1[i] === p2[i] ? 0 : p1[i] > p2[i] ? 1 : -1;
                } else {
                    const t1 = parseInt(p1[i]);
                    const t2 = parseInt(p2[i]);
                    comp = t1 === t2 ? 0 : t1 > t2 ? 1 : -1;
                }
                break;
            }
        }
        // Compares path length if both paths are equal to this point
        if (comp === 0) {
            const t1 = p1.length;
            const t2 = p2.length;
            if (t1 !== t2) {
                comp = t1 > t2 ? 1 : -1;
            }
        }
        return comp;
    }
}
/**
 * Defines the separator between the path components. Default is ".".
 */ CellPath.PATH_SEPARATOR = '.';
const __TURBOPACK__default__export__ = CellPath;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/cell/TemporaryCellStates.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2017, JGraph Ltd
Copyright (c) 2006-2017, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Dictionary.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-ssr] (ecmascript)");
;
;
/**
 * Creates a temporary set of cell states.
 */ class TemporaryCellStates {
    constructor(view, scale = 1, cells, isCellVisibleFn = null, getLinkForCellState = null){
        this.view = view;
        // Stores the previous state
        this.oldValidateCellState = view.validateCellState;
        this.oldBounds = view.getGraphBounds();
        this.oldStates = view.getStates();
        this.oldScale = view.getScale();
        this.oldDoRedrawShape = view.graph.cellRenderer.doRedrawShape;
        // Overrides doRedrawShape and paint shape to add links on shapes
        if (getLinkForCellState != null) {
            view.graph.cellRenderer.doRedrawShape = (state)=>{
                const shape = state?.shape;
                const oldPaint = shape.paint;
                shape.paint = (c)=>{
                    const link = getLinkForCellState(state);
                    if (link != null) {
                        c.setLink(link);
                    }
                    oldPaint.apply(shape, [
                        c
                    ]);
                    if (link != null) {
                        c.setLink(null);
                    }
                };
                this.oldDoRedrawShape.apply(view.graph.cellRenderer, [
                    state
                ]);
                shape.paint = oldPaint;
            };
        }
        // Overrides validateCellState to ignore invisible cells
        view.validateCellState = (cell, recurse)=>{
            if (cell == null || isCellVisibleFn == null || isCellVisibleFn(cell)) {
                return this.oldValidateCellState.apply(view, [
                    cell,
                    recurse
                ]);
            }
            return null;
        };
        // Creates space for new states
        view.setStates(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]());
        view.setScale(scale);
        view.resetValidationState();
        let bbox = null;
        // Validates the vertices and edges without adding them to
        // the model so that the original cells are not modified
        for (const cell of cells){
            const bounds = view.getBoundingBox(view.validateCellState(view.validateCell(cell)));
            if (bbox == null) {
                bbox = bounds;
            } else {
                bbox.add(bounds);
            }
        }
        view.setGraphBounds(bbox || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]());
    }
    destroy() {
        const view = this.view;
        view.setScale(this.oldScale);
        view.setStates(this.oldStates);
        view.setGraphBounds(this.oldBounds);
        view.validateCellState = this.oldValidateCellState;
        view.graph.cellRenderer.doRedrawShape = this.oldDoRedrawShape;
    }
}
const __TURBOPACK__default__export__ = TemporaryCellStates;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/cell/Cell.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "Cell": (()=>Cell),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cloneUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/cloneUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellPath$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/CellPath.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-ssr] (ecmascript)");
;
;
;
;
;
class Cell {
    constructor(value = null, geometry = null, style = {}){
        // TODO: Document me!
        // used by invalidate() of mxGraphView
        this.invalidating = false;
        this.onInit = null;
        // used by addCellOverlay() of mxGraph
        this.overlays = [];
        /**
         * Holds the Id. Default is null.
         */ this.id = null;
        /**
         * Holds the user object. Default is null.
         */ this.value = null;
        /**
         * Holds the {@link Geometry}. Default is null.
         */ this.geometry = null;
        /**
         * Holds the style as a string of the form [(stylename|key=value);]. Default is
         * null.
         */ this.style = {};
        /**
         * Specifies whether the cell is a vertex. Default is false.
         */ this.vertex = false;
        /**
         * Specifies whether the cell is an edge. Default is false.
         */ this.edge = false;
        /**
         * Specifies whether the cell is connectable. Default is true.
         */ this.connectable = true;
        /**
         * Specifies whether the cell is visible. Default is true.
         */ this.visible = true;
        /**
         * Specifies whether the cell is collapsed. Default is false.
         */ this.collapsed = false;
        /**
         * Reference to the parent cell.
         */ this.parent = null;
        /**
         * Reference to the source terminal.
         */ this.source = null;
        /**
         * Reference to the target terminal.
         */ this.target = null;
        /**
         * Holds the child cells.
         */ this.children = [];
        /**
         * Holds the edges.
         */ this.edges = [];
        /**
         * List of members that should not be cloned inside <clone>. This field is
         * passed to {@link Utils#clone} and is not made persistent in <CellCodec>.
         * This is not a convention for all classes, it is only used in this class
         * to mark transient fields since transient modifiers are not supported by
         * the language.
         */ this.mxTransient = [
            'id',
            'value',
            'parent',
            'source',
            'target',
            'children',
            'edges'
        ];
        this.value = value;
        this.setGeometry(geometry);
        this.setStyle(style);
        if (this.onInit) {
            this.onInit();
        }
    }
    // TODO: Document me!!!
    getChildren() {
        return this.children || [];
    }
    /**
     * Returns the Id of the cell as a string.
     */ getId() {
        return this.id;
    }
    /**
     * Sets the Id of the cell to the given string.
     */ setId(id) {
        this.id = id;
    }
    /**
     * Returns the user object of the cell. The user
     * object is stored in <value>.
     */ getValue() {
        return this.value;
    }
    /**
     * Sets the user object of the cell. The user object
     * is stored in <value>.
     */ setValue(value) {
        this.value = value;
    }
    /**
     * Changes the user object after an in-place edit
     * and returns the previous value. This implementation
     * replaces the user object with the given value and
     * returns the old user object.
     */ valueChanged(newValue) {
        const previous = this.getValue();
        this.setValue(newValue);
        return previous;
    }
    /**
     * Returns the {@link Geometry} that describes the <geometry>.
     */ getGeometry() {
        return this.geometry;
    }
    /**
     * Sets the {@link Geometry} to be used as the <geometry>.
     */ setGeometry(geometry) {
        this.geometry = geometry;
    }
    /**
     * Returns a string that describes the {@link style}.
     *
     * **IMPORTANT**: if you want to get the style object to later update it and propagate changes to the view, use {@link getClonedStyle} instead.
     */ getStyle() {
        return this.style;
    }
    /**
     * Use this method to get the style object to later update it and propagate changes to the view.
     *
     * See {@link GraphDataModel.setStyle} for more details.
     */ getClonedStyle() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cloneUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(this.getStyle());
    }
    /**
     * Sets the string to be used as the {@link style}.
     */ setStyle(style) {
        this.style = style;
    }
    /**
     * Returns true if the cell is a vertex.
     */ isVertex() {
        return this.vertex;
    }
    /**
     * Specifies if the cell is a vertex. This should only be assigned at
     * construction of the cell and not be changed during its lifecycle.
     *
     * @param vertex Boolean that specifies if the cell is a vertex.
     */ setVertex(vertex) {
        this.vertex = vertex;
    }
    /**
     * Returns true if the cell is an edge.
     */ isEdge() {
        return this.edge;
    }
    /**
     * Specifies if the cell is an edge. This should only be assigned at
     * construction of the cell and not be changed during its lifecycle.
     *
     * @param edge Boolean that specifies if the cell is an edge.
     */ setEdge(edge) {
        this.edge = edge;
    }
    /**
     * Returns true if the cell is connectable.
     */ isConnectable() {
        return this.connectable;
    }
    /**
     * Sets the connectable state.
     *
     * @param connectable Boolean that specifies the new connectable state.
     */ setConnectable(connectable) {
        this.connectable = connectable;
    }
    /**
     * Returns true if the cell is visibile.
     */ isVisible() {
        return this.visible;
    }
    /**
     * Specifies if the cell is visible.
     *
     * @param visible Boolean that specifies the new visible state.
     */ setVisible(visible) {
        this.visible = visible;
    }
    /**
     * Returns true if the cell is collapsed.
     */ isCollapsed() {
        return this.collapsed;
    }
    /**
     * Sets the collapsed state.
     *
     * @param collapsed Boolean that specifies the new collapsed state.
     */ setCollapsed(collapsed) {
        this.collapsed = collapsed;
    }
    /**
     * Returns the cell's parent.
     */ getParent() {
        return this.parent;
    }
    /**
     * Sets the parent cell.
     *
     * @param parent<Cell> that represents the new parent.
     */ setParent(parent) {
        this.parent = parent;
    }
    /**
     * Returns the source or target terminal.
     *
     * @param source Boolean that specifies if the source terminal should be
     * returned.
     */ getTerminal(source = false) {
        return source ? this.source : this.target;
    }
    /**
     * Sets the source or target terminal and returns the new terminal.
     *
     * @param terminal  Cell that represents the new source or target terminal.
     * @param isSource  boolean that specifies if the source or target terminal should be set.
     */ setTerminal(terminal, isSource) {
        if (isSource) {
            this.source = terminal;
        } else {
            this.target = terminal;
        }
        return terminal;
    }
    /**
     * Returns the number of child cells.
     */ getChildCount() {
        return this.children.length;
    }
    /**
     * Returns the index of the specified child in the child array.
     *
     * @param child Child whose index should be returned.
     */ getIndex(child) {
        if (child === null) return -1;
        return this.children.indexOf(child);
    }
    /**
     * Returns the child at the specified index.
     *
     * @param indexInteger that specifies the child to be returned.
     */ getChildAt(index) {
        return this.children[index];
    }
    /**
     * Inserts the specified child into the child array at the specified index
     * and updates the parent reference of the child. If not childIndex is
     * specified then the child is appended to the child array. Returns the
     * inserted child.
     *
     * @param child<Cell> to be inserted or appended to the child array.
     * @param indexOptional integer that specifies the index at which the child
     * should be inserted into the child array.
     */ insert(child, index) {
        if (index === undefined) {
            index = this.getChildCount();
            if (child.getParent() === this) {
                index--;
            }
        }
        child.removeFromParent();
        child.setParent(this);
        this.children.splice(index, 0, child);
        return child;
    }
    /**
     * Removes the child at the specified index from the child array and
     * returns the child that was removed. Will remove the parent reference of
     * the child.
     *
     * @param indexInteger that specifies the index of the child to be
     * removed.
     */ remove(index) {
        let child = null;
        if (index >= 0) {
            child = this.getChildAt(index);
            if (child) {
                this.children.splice(index, 1);
                child.setParent(null);
            }
        }
        return child;
    }
    /**
     * Removes the cell from its parent.
     */ removeFromParent() {
        if (this.parent) {
            const index = this.parent.getIndex(this);
            this.parent.remove(index);
        }
    }
    /**
     * Returns the number of edges in the edge array.
     */ getEdgeCount() {
        return this.edges.length;
    }
    /**
     * Returns the index of the specified edge in <edges>.
     *
     * @param edge<Cell> whose index in <edges> should be returned.
     */ getEdgeIndex(edge) {
        return this.edges.indexOf(edge);
    }
    /**
     * Returns the edge at the specified index in <edges>.
     *
     * @param indexInteger that specifies the index of the edge to be returned.
     */ getEdgeAt(index) {
        return this.edges[index];
    }
    /**
     * Inserts the specified edge into the edge array and returns the edge.
     * Will update the respective terminal reference of the edge.
     *
     * @param edge              <Cell> to be inserted into the edge array.
     * @param isOutgoing Boolean that specifies if the edge is outgoing.
     */ insertEdge(edge, isOutgoing = false) {
        edge.removeFromTerminal(isOutgoing);
        edge.setTerminal(this, isOutgoing);
        if (this.edges.length === 0 || edge.getTerminal(!isOutgoing) !== this || this.edges.indexOf(edge) < 0) {
            this.edges.push(edge);
        }
        return edge;
    }
    /**
     * Removes the specified edge from the edge array and returns the edge.
     * Will remove the respective terminal reference from the edge.
     *
     * @param edge<Cell> to be removed from the edge array.
     * @param isOutgoing Boolean that specifies if the edge is outgoing.
     */ removeEdge(edge, isOutgoing = false) {
        if (edge != null) {
            if (edge.getTerminal(!isOutgoing) !== this && this.edges != null) {
                const index = this.getEdgeIndex(edge);
                if (index >= 0) {
                    this.edges.splice(index, 1);
                }
            }
            edge.setTerminal(null, isOutgoing);
        }
        return edge;
    }
    /**
     * Removes the edge from its source or target terminal.
     *
     * @param isSource Boolean that specifies if the edge should be removed from its source or target terminal.
     */ removeFromTerminal(isSource) {
        const terminal = this.getTerminal(isSource);
        if (terminal) {
            terminal.removeEdge(this, isSource);
        }
    }
    /**
     * Returns true if the user object is an XML node that contains the given attribute.
     *
     * @param name Name nameName of the attribute.
     */ hasAttribute(name) {
        const userObject = this.getValue();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNotNullish"])(userObject) && (userObject.nodeType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NODETYPE"].ELEMENT && userObject.hasAttribute ? userObject.hasAttribute(name) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNotNullish"])(userObject.getAttribute?.(name)));
    }
    /**
     * Returns the specified attribute from the user object if it is an XML node.
     *
     * @param name Name of the attribute whose value should be returned.
     * @param defaultValue Optional default value to use if the attribute has no
     * value.
     */ getAttribute(name, defaultValue) {
        const userObject = this.getValue();
        const val = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNotNullish"])(userObject) && userObject.nodeType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NODETYPE"].ELEMENT ? userObject.getAttribute?.(name) : null;
        return val ?? defaultValue;
    }
    /**
     * Sets the specified attribute on the user object if it is an XML node.
     *
     * @param name Name of the attribute whose value should be set.
     * @param value New value of the attribute.
     */ setAttribute(name, value) {
        const userObject = this.getValue();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNotNullish"])(userObject) && userObject.nodeType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NODETYPE"].ELEMENT) {
            userObject.setAttribute?.(name, value);
        }
    }
    /**
     * Returns a clone of the cell.
     *
     * Uses {@link cloneValue} to clone the user object.
     *
     * All fields in {@link mxTransient} are ignored during the cloning.
     */ clone() {
        const c = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cloneUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(this, this.mxTransient);
        c.setValue(this.cloneValue());
        return c;
    }
    /**
     * Returns a clone of the cell's user object.
     */ cloneValue() {
        let value = this.getValue();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNotNullish"])(value)) {
            if (typeof value.clone === 'function') {
                value = value.clone();
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNotNullish"])(value.nodeType) && value.cloneNode) {
                value = value.cloneNode(true);
            }
        }
        return value;
    }
    /**
     * Returns the nearest common ancestor for the specified cells to `this`.
     *
     * @param {Cell} cell2  that specifies the second cell in the tree.
     */ getNearestCommonAncestor(cell2) {
        // Creates the cell path for the second cell
        let path = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellPath$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].create(cell2);
        if (path.length > 0) {
            // Bubbles through the ancestors of the first cell to find the nearest common ancestor.
            // eslint-disable-next-line @typescript-eslint/no-this-alias -- we need to use `this` to refer to the instance to start processing
            let cell = this;
            let current = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellPath$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].create(cell);
            // Inverts arguments
            if (path.length < current.length) {
                cell = cell2;
                const tmp = current;
                current = path;
                path = tmp;
            }
            while(cell && current){
                const parent = cell.getParent();
                // Checks if the cell path is equal to the beginning of the given cell path
                if (path.indexOf(current + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellPath$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PATH_SEPARATOR) === 0 && parent) {
                    return cell;
                }
                current = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellPath$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].getParentPath(current);
                cell = parent;
            }
        }
        return null;
    }
    /**
     * Returns true if the given parent is an ancestor of the given child. Note
     * returns true if child == parent.
     *
     * @param {Cell} child  that specifies the child.
     */ isAncestor(child) {
        while(child && child !== this){
            child = child.getParent();
        }
        return child === this;
    }
    /**
     * Returns the child vertices of the given parent.
     */ getChildVertices() {
        return this.getChildCells(true, false);
    }
    /**
     * Returns the child edges of the given parent.
     */ getChildEdges() {
        return this.getChildCells(false, true);
    }
    /**
     * Returns the children of the given cell that are vertices and/or edges
     * depending on the arguments.
     *
     * @param vertices  Boolean indicating if child vertices should be returned.
     * Default is false.
     * @param edges  Boolean indicating if child edges should be returned.
     * Default is false.
     */ getChildCells(vertices = false, edges = false) {
        const childCount = this.getChildCount();
        const result = [];
        for(let i = 0; i < childCount; i += 1){
            const child = this.getChildAt(i);
            if (!edges && !vertices || edges && child.isEdge() || vertices && child.isVertex()) {
                result.push(child);
            }
        }
        return result;
    }
    /**
     * Returns the number of incoming or outgoing edges, ignoring the given
     * edge.
     *
     * @param outgoing  Boolean that specifies if the number of outgoing or
     * incoming edges should be returned.
     * @param {Cell} ignoredEdge  that represents an edge to be ignored.
     */ getDirectedEdgeCount(outgoing, ignoredEdge = null) {
        let count = 0;
        const edgeCount = this.getEdgeCount();
        for(let i = 0; i < edgeCount; i += 1){
            const edge = this.getEdgeAt(i);
            if (edge !== ignoredEdge && edge && edge.getTerminal(outgoing) === this) {
                count += 1;
            }
        }
        return count;
    }
    /**
     * Returns all edges of the given cell without loops.
     */ getConnections() {
        return this.getEdges(true, true, false);
    }
    /**
     * Returns the incoming edges of the given cell without loops.
     */ getIncomingEdges() {
        return this.getEdges(true, false, false);
    }
    /**
     * Returns the outgoing edges of the given cell without loops.
     */ getOutgoingEdges() {
        return this.getEdges(false, true, false);
    }
    /**
     * Returns all distinct edges connected to this cell as a new array of
     * {@link Cell}. If at least one of incoming or outgoing is true, then loops
     * are ignored, otherwise if both are false, then all edges connected to
     * the given cell are returned including loops.
     *
     * @param incoming  Optional boolean that specifies if incoming edges should be
     * returned. Default is true.
     * @param outgoing  Optional boolean that specifies if outgoing edges should be
     * returned. Default is true.
     * @param includeLoops  Optional boolean that specifies if loops should be returned.
     * Default is true.
     */ getEdges(incoming = true, outgoing = true, includeLoops = true) {
        const edgeCount = this.getEdgeCount();
        const result = [];
        for(let i = 0; i < edgeCount; i += 1){
            const edge = this.getEdgeAt(i);
            const source = edge.getTerminal(true);
            const target = edge.getTerminal(false);
            if (includeLoops && source === target || source !== target && (incoming && target === this || outgoing && source === this)) {
                result.push(edge);
            }
        }
        return result;
    }
    /**
     * Returns the absolute, accumulated origin for the children inside the
     * given parent as an {@link Point}.
     */ getOrigin() {
        let result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
        const parent = this.getParent();
        if (parent) {
            result = parent.getOrigin();
            if (!this.isEdge()) {
                const geo = this.getGeometry();
                if (geo) {
                    result.x += geo.x;
                    result.y += geo.y;
                }
            }
        }
        return result;
    }
    /**
     * Returns all descendants of the given cell and the cell itself in an array.
     */ getDescendants() {
        return this.filterDescendants(null);
    }
    /**
     * Visits all cells recursively and applies the specified filter function
     * to each cell. If the function returns true then the cell is added
     * to the resulting array. The parent and result paramters are optional.
     * If parent is not specified then the recursion starts at {@link root}.
     *
     * Example:
     * The following example extracts all vertices from a given model:
     * ```javascript
     * var filter(cell)
     * {
     * 	return model.isVertex(cell);
     * }
     * var vertices = model.filterDescendants(filter);
     * ```
     *
     * @param filter  JavaScript function that takes an {@link Cell} as an argument
     * and returns a boolean.
     */ filterDescendants(filter) {
        // Creates a new array for storing the result
        let result = [];
        // Checks if the filter returns true for the cell
        // and adds it to the result array
        if (filter === null || filter(this)) {
            result.push(this);
        }
        // Visits the children of the cell
        const childCount = this.getChildCount();
        for(let i = 0; i < childCount; i += 1){
            const child = this.getChildAt(i);
            result = result.concat(child.filterDescendants(filter));
        }
        return result;
    }
    /**
     * Returns the root of the model or the topmost parent of the given cell.
     */ getRoot() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias -- we need to use `this` to refer to the instance to start processing
        let cell = this;
        let root = cell;
        while(cell){
            root = cell;
            cell = cell.getParent();
        }
        return root;
    }
}
const __TURBOPACK__default__export__ = Cell;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/cell/CellRenderer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2017, JGraph Ltd
Copyright (c) 2006-2017, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$ConnectorShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/ConnectorShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/RectangleShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$TextShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/TextShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$StencilShapeRegistry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/StencilShapeRegistry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Shape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/domUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalMouseEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Dictionary.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/ImageShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$arrayUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/arrayUtils.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const placeholderStyleValues = [
    'inherit',
    'swimlane',
    'indicated'
];
const placeholderStyleProperties = [
    'fillColor',
    'strokeColor',
    'gradientColor',
    'fontColor'
];
/**
 * Renders cells into a document object model. The <defaultShapes> is a global
 * map of shape names, constructor pairs that is used in all instances. You can
 * get a list of all available shape names using the following code.
 *
 * In general the cell renderer is in charge of creating, redrawing and
 * destroying the shape and label associated with a cell state, as well as
 * some other graphical objects, namely controls and overlays. The shape
 * hierarchy in the display (i.e. the hierarchy in which the DOM nodes
 * appear in the document) does not reflect the cell hierarchy. The shapes
 * are a (flat) sequence of shapes and labels inside the draw pane of the
 * graph view, with some exceptions, namely the HTML labels being placed
 * directly inside the graph container for certain browsers.
 *
 * ```javascript
 * GlobalConfig.logger.show();
 * for (var i in mxCellRenderer.defaultShapes)
 * {
 *   GlobalConfig.logger.debug(i);
 * }
 * ```
 */ class CellRenderer {
    constructor(){
        /**
         * Defines the default shape for edges.
         * @default {@link ConnectorShape}
         */ // @ts-expect-error The constructors for Shape and Connector are different.
        this.defaultEdgeShape = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$ConnectorShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"];
        /**
         * Defines the default shape for vertices.
         * @default {@link RectangleShape}.
         */ this.defaultVertexShape = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"];
        /**
         * Defines the default shape for labels.
         * @default {@link TextShape}.
         */ this.defaultTextShape = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$TextShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"];
        /**
         * Specifies if the folding icon should ignore the horizontal
         * orientation of a swimlane.
         * @default true.
         */ this.legacyControlPosition = true;
        /**
         * Specifies if spacing and label position should be ignored if overflow is
         * fill or width.
         * @default true for backwards compatibility.
         */ this.legacySpacing = true;
        /**
         * Antialiasing option for new shapes.
         * @default true.
         */ this.antiAlias = true;
        /**
         * Minimum stroke width for SVG output.
         */ this.minSvgStrokeWidth = 1;
        /**
         * Specifies if the enabled state of the graph should be ignored in the control
         * click handler (to allow folding in disabled graphs).
         * @default false.
         */ this.forceControlClickHandler = false;
    }
    /**
     * Registers the given constructor under the specified key in this instance of the renderer.
     * @example
     * ```
     * CellRenderer.registerShape(Constants.SHAPE_RECTANGLE, RectangleShape);
     * ```
     *
     * @param key the shape name.
     * @param shape constructor of the {@link Shape} subclass.
     */ static registerShape(key, shape) {
        CellRenderer.defaultShapes[key] = shape;
    }
    /**
     * Initializes the shape in the given state by calling its init method with
     * the correct container after configuring it using {@link configureShape}.
     *
     * @param state <CellState> for which the shape should be initialized.
     */ initializeShape(state) {
        if (state.shape) {
            state.shape.dialect = state.view.graph.dialect;
            this.configureShape(state);
            state.shape.init(state.view.getDrawPane());
        }
    }
    /**
     * Creates and returns the shape for the given cell state.
     *
     * @param state {@link CellState} for which the shape should be created.
     */ createShape(state) {
        let shape = null;
        // Checks if there is a stencil for the name and creates
        // a shape instance for the stencil if one exists
        const stencil = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$StencilShapeRegistry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].getStencil(state.style.shape);
        if (stencil) {
            shape = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](stencil);
        } else {
            const ctor = this.getShapeConstructor(state);
            shape = new ctor();
        }
        return shape;
    }
    /**
     * Creates the indicator shape for the given cell state.
     *
     * @param state {@link CellState} for which the indicator shape should be created.
     */ createIndicatorShape(state) {
        if (state.shape) {
            state.shape.indicatorShape = this.getShape(state.getIndicatorShape() || null);
        }
    }
    /**
     * Returns the shape for the given name from {@link defaultShapes}.
     */ getShape(name) {
        return name ? CellRenderer.defaultShapes[name] : null;
    }
    /**
     * Returns the constructor to be used for creating the shape.
     */ getShapeConstructor(state) {
        let ctor = this.getShape(state.style.shape || null);
        if (!ctor) {
            // @ts-expect-error The various Shape constructors are not compatible.
            ctor = state.cell.isEdge() ? this.defaultEdgeShape : this.defaultVertexShape;
        }
        return ctor;
    }
    /**
     * Configures the shape for the given cell state.
     *
     * @param state <CellState> for which the shape should be configured.
     */ configureShape(state) {
        const shape = state.shape;
        if (shape) {
            shape.apply(state);
            shape.imageSrc = state.getImageSrc() || null;
            shape.indicatorColor = state.getIndicatorColor() || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"];
            shape.indicatorStrokeColor = state.style.indicatorStrokeColor || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"];
            shape.indicatorGradientColor = state.getIndicatorGradientColor() || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"];
            if (state.style.indicatorDirection) {
                shape.indicatorDirection = state.style.indicatorDirection;
            }
            shape.indicatorImageSrc = state.getIndicatorImageSrc() || null;
            this.postConfigureShape(state);
        }
    }
    /**
     * Replaces any reserved words used for attributes, eg. inherit,
     * indicated or swimlane for colors in the shape for the given state.
     * This implementation resolves these keywords on the fill, stroke
     * and gradient color keys.
     */ postConfigureShape(state) {
        if (state.shape) {
            this.resolveColor(state, 'indicatorGradientColor', 'gradientColor');
            this.resolveColor(state, 'indicatorColor', 'fillColor');
            this.resolveColor(state, 'gradient', 'gradientColor');
            this.resolveColor(state, 'stroke', 'strokeColor');
            this.resolveColor(state, 'fill', 'fillColor');
        }
    }
    /**
     * Check if style properties supporting placeholders requires resolution.
     */ checkPlaceholderStyles(state) {
        // LATER: Check if the color has actually changed
        for (const property of placeholderStyleProperties){
            if (placeholderStyleValues.includes(state.style[property])) {
                return true;
            }
        }
        return false;
    }
    /**
     * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets
     * the respective color on the shape.
     */ resolveColor(state, field, key) {
        const shape = key === 'fontColor' ? state.text : state.shape;
        if (shape) {
            const graph = state.view.graph;
            // @ts-ignore
            const value = shape[field];
            let referenced = null;
            if (value === 'inherit') {
                referenced = state.cell.getParent();
            } else if (value === 'swimlane') {
                // @ts-ignore
                shape[field] = key === 'strokeColor' || key === 'fontColor' ? '#000000' : '#ffffff';
                if (state.cell.getTerminal(false)) {
                    referenced = state.cell.getTerminal(false);
                } else {
                    referenced = state.cell;
                }
                referenced = graph.getSwimlane(referenced);
                key = graph.swimlaneIndicatorColorAttribute;
            } else if (value === 'indicated' && state.shape) {
                // @ts-ignore
                shape[field] = state.shape.indicatorColor;
            } else if (key !== 'fillColor' && value === 'fillColor' && state.shape) {
                // @ts-ignore
                shape[field] = state.style.fillColor;
            } else if (key !== 'strokeColor' && value === 'strokeColor' && state.shape) {
                // @ts-ignore
                shape[field] = state.style.strokeColor;
            }
            if (referenced) {
                const rstate = graph.getView().getState(referenced);
                // @ts-ignore
                shape[field] = null;
                if (rstate) {
                    const rshape = key === 'fontColor' ? rstate.text : rstate.shape;
                    if (rshape && field !== 'indicatorColor') {
                        // @ts-ignore
                        shape[field] = rshape[field];
                    } else {
                        // @ts-ignore
                        shape[field] = rstate.style[key];
                    }
                }
            }
        }
    }
    /**
     * Returns the value to be used for the label.
     *
     * @param state <CellState> for which the label should be created.
     */ getLabelValue(state) {
        const graph = state.view.graph;
        return graph.getLabel(state.cell);
    }
    /**
     * Creates the label for the given cell state.
     *
     * @param state <CellState> for which the label should be created.
     */ createLabel(state, value) {
        const graph = state.view.graph;
        if ((state.style.fontSize || 0) > 0 || state.style.fontSize == null) {
            // Avoids using DOM node for empty labels
            const isForceHtml = graph.isHtmlLabel(state.cell) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNode"])(value);
            state.text = new this.defaultTextShape(value, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](), state.style.align ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].CENTER, state.getVerticalAlign(), state.style.fontColor, state.style.fontFamily, state.style.fontSize, state.style.fontStyle, state.style.spacing, state.style.spacingTop, state.style.spacingRight, state.style.spacingBottom, state.style.spacingLeft, state.style.horizontal, state.style.labelBackgroundColor, state.style.labelBorderColor, graph.isWrapping(state.cell) && graph.isHtmlLabel(state.cell), graph.isLabelClipped(state.cell), state.style.overflow, state.style.labelPadding, state.style.textDirection ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_TEXT_DIRECTION"]);
            state.text.opacity = state.style.textOpacity ?? 100;
            state.text.dialect = isForceHtml ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].STRICTHTML : graph.dialect;
            state.text.style = state.style;
            state.text.state = state;
            this.initializeLabel(state, state.text);
            // Workaround for touch devices routing all events for a mouse gesture
            // (down, move, up) via the initial DOM node. IE additionally redirects
            // the event via the initial DOM node but the event source is the node
            // under the mouse, so we need to check if this is the case and force
            // getCellAt for the subsequent mouseMoves and the final mouseUp.
            let forceGetCell = false;
            const getState = (evt)=>{
                let result = state;
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IS_TOUCH || forceGetCell) {
                    const x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientX"])(evt);
                    const y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientY"])(evt);
                    // Dispatches the drop event to the graph which
                    // consumes and executes the source function
                    const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertPoint"])(graph.container, x, y);
                    result = graph.view.getState(graph.getCellAt(pt.x, pt.y));
                }
                return result;
            };
            // TODO: Add handling for special touch device gestures
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addGestureListeners(state.text.node, (evt)=>{
                if (this.isLabelEvent(state, evt)) {
                    graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](evt, state));
                    const source = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSource"])(evt);
                    forceGetCell = // @ts-ignore nodeName should exist.
                    graph.dialect !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG && source.nodeName === 'IMG';
                }
            }, (evt)=>{
                if (this.isLabelEvent(state, evt)) {
                    graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOUSE_MOVE, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](evt, getState(evt)));
                }
            }, (evt)=>{
                if (this.isLabelEvent(state, evt)) {
                    graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOUSE_UP, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](evt, getState(evt)));
                    forceGetCell = false;
                }
            });
            // Uses double click timeout in mxGraph for quirks mode
            if (graph.isNativeDblClickEnabled()) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(state.text.node, 'dblclick', (evt)=>{
                    if (this.isLabelEvent(state, evt)) {
                        graph.dblClick(evt, state.cell);
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(evt);
                    }
                });
            }
        }
    }
    /**
     * Initiailzes the label with a suitable container.
     *
     * @param state <CellState> whose label should be initialized.
     */ initializeLabel(state, shape) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IS_SVG && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].NO_FO && shape.dialect !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG) {
            const graph = state.view.graph;
            shape.init(graph.container);
        } else {
            shape.init(state.view.getDrawPane());
        }
    }
    /**
     * Creates the actual shape for showing the overlay for the given cell state.
     *
     * @param state <CellState> for which the overlay should be created.
     */ createCellOverlays(state) {
        const graph = state.view.graph;
        const overlays = graph.getCellOverlays(state.cell);
        const dict = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
        for(let i = 0; i < overlays.length; i += 1){
            const shape = state.overlays.remove(overlays[i]);
            if (!shape) {
                const tmp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](), overlays[i].image.src);
                tmp.dialect = graph.dialect;
                tmp.preserveImageAspect = false;
                tmp.overlay = overlays[i];
                this.initializeOverlay(state, tmp);
                this.installCellOverlayListeners(state, overlays[i], tmp);
                if (overlays[i].cursor) {
                    tmp.node.style.cursor = overlays[i].cursor;
                }
                dict.put(overlays[i], tmp);
            } else {
                dict.put(overlays[i], shape);
            }
        }
        // Removes unused
        state.overlays.visit((id, shape)=>{
            shape.destroy();
        });
        state.overlays = dict;
    }
    /**
     * Initializes the given overlay.
     *
     * @param state <CellState> for which the overlay should be created.
     * @param overlay {@link ImageShape} that represents the overlay.
     */ initializeOverlay(state, overlay) {
        overlay.init(state.view.getOverlayPane());
    }
    /**
     * Installs the listeners for the given <CellState>, <CellOverlay> and
     * {@link Shape} that represents the overlay.
     */ installCellOverlayListeners(state, overlay, shape) {
        const graph = state.view.graph;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(shape.node, 'click', (evt)=>{
            if (graph.isEditing()) {
                graph.stopEditing(!graph.isInvokesStopCellEditing());
            }
            overlay.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CLICK, {
                event: evt,
                cell: state.cell
            }));
        });
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addGestureListeners(shape.node, (evt)=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(evt);
        }, (evt)=>{
            graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOUSE_MOVE, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](evt, state));
        });
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IS_TOUCH) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(shape.node, 'touchend', (evt)=>{
                overlay.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CLICK, {
                    event: evt,
                    cell: state.cell
                }));
            });
        }
    }
    /**
     * Creates the control for the given cell state.
     *
     * @param state <CellState> for which the control should be created.
     */ createControl(state) {
        const graph = state.view.graph;
        const image = graph.getFoldingImage(state);
        if (graph.isFoldingEnabled() && image) {
            if (!state.control) {
                const b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](0, 0, image.width, image.height);
                state.control = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](b, image.src);
                state.control.preserveImageAspect = false;
                state.control.dialect = graph.dialect;
                this.initControl(state, state.control, true, this.createControlClickHandler(state));
            }
        } else if (state.control) {
            state.control.destroy();
            state.control = null;
        }
    }
    /**
     * Hook for creating the click handler for the folding icon.
     *
     * @param state <CellState> whose control click handler should be returned.
     */ createControlClickHandler(state) {
        const graph = state.view.graph;
        return (evt)=>{
            if (this.forceControlClickHandler || graph.isEnabled()) {
                const collapse = !state.cell.isCollapsed();
                graph.foldCells(collapse, false, [
                    state.cell
                ], false, evt);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(evt);
            }
        };
    }
    /**
     * Initializes the given control and returns the corresponding DOM node.
     *
     * @param state <CellState> for which the control should be initialized.
     * @param control {@link Shape} to be initialized.
     * @param handleEvents Boolean indicating if mousedown and mousemove should fire events via the graph.
     * @param clickHandler Optional function to implement clicks on the control.
     */ initControl(state, control, handleEvents, clickHandler) {
        const graph = state.view.graph;
        // In the special case where the label is in HTML and the display is SVG the image
        // should go into the graph container directly in order to be clickable. Otherwise
        // it is obscured by the HTML label that overlaps the cell.
        const isForceHtml = graph.isHtmlLabel(state.cell) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].NO_FO && graph.dialect === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG;
        if (isForceHtml) {
            control.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].PREFERHTML;
            control.init(graph.container);
            control.node.style.zIndex = String(1);
        } else {
            control.init(state.view.getOverlayPane());
        }
        const node = control.node;
        // Workaround for missing click event on iOS is to check tolerance below
        if (clickHandler && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IS_IOS) {
            if (graph.isEnabled()) {
                node.style.cursor = 'pointer';
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(node, 'click', clickHandler);
        }
        if (handleEvents) {
            let first = null;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addGestureListeners(node, (evt)=>{
                first = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientX"])(evt), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientY"])(evt));
                graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](evt, state));
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(evt);
            }, (evt)=>{
                graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOUSE_MOVE, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](evt, state));
            }, (evt)=>{
                graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOUSE_UP, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](evt, state));
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(evt);
            });
            // Uses capture phase for event interception to stop bubble phase
            if (clickHandler && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IS_IOS) {
                node.addEventListener('touchend', (evt)=>{
                    if (first) {
                        const tol = graph.getEventTolerance();
                        if (Math.abs(first.x - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientX"])(evt)) < tol && Math.abs(first.y - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientY"])(evt)) < tol) {
                            clickHandler.call(clickHandler, evt);
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(evt);
                        }
                    }
                }, true);
            }
        }
        return node;
    }
    /**
     * Returns true if the event is for the shape of the given state. This
     * implementation always returns true.
     *
     * @param state <CellState> whose shape fired the event.
     * @param evt Mouse event which was fired.
     */ isShapeEvent(state, evt) {
        return true;
    }
    /**
     * Returns true if the event is for the label of the given state. This
     * implementation always returns true.
     *
     * @param state <CellState> whose label fired the event.
     * @param evt Mouse event which was fired.
     */ isLabelEvent(state, evt) {
        return true;
    }
    /**
     * Installs the event listeners for the given cell state.
     *
     * @param state <CellState> for which the event listeners should be isntalled.
     */ installListeners(state) {
        const graph = state.view.graph;
        // Workaround for touch devices routing all events for a mouse
        // gesture (down, move, up) via the initial DOM node. Same for
        // HTML images in all IE versions (VML images are working).
        const getState = (evt)=>{
            let result = state;
            const source = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSource"])(evt);
            if (source && graph.dialect !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG && // @ts-ignore nodeName should exist
            source.nodeName === 'IMG' || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IS_TOUCH) {
                const x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientX"])(evt);
                const y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientY"])(evt);
                // Dispatches the drop event to the graph which
                // consumes and executes the source function
                const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertPoint"])(graph.container, x, y);
                const cell = graph.getCellAt(pt.x, pt.y);
                result = cell ? graph.view.getState(cell) : null;
            }
            return result;
        };
        if (state.shape) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addGestureListeners(state.shape.node, (evt)=>{
                if (this.isShapeEvent(state, evt)) {
                    graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](evt, state));
                }
            }, (evt)=>{
                if (this.isShapeEvent(state, evt)) {
                    graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOUSE_MOVE, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](evt, getState(evt)));
                }
            }, (evt)=>{
                if (this.isShapeEvent(state, evt)) {
                    graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOUSE_UP, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](evt, getState(evt)));
                }
            });
            // Uses double click timeout in mxGraph for quirks mode
            if (graph.isNativeDblClickEnabled()) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(state.shape.node, 'dblclick', (evt)=>{
                    if (this.isShapeEvent(state, evt)) {
                        graph.dblClick(evt, state.cell);
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(evt);
                    }
                });
            }
        }
    }
    /**
     * Redraws the label for the given cell state.
     *
     * @param state <CellState> whose label should be redrawn.
     */ redrawLabel(state, forced) {
        const graph = state.view.graph;
        const value = this.getLabelValue(state);
        const wrapping = graph.isWrapping(state.cell);
        const clipping = graph.isLabelClipped(state.cell);
        const isForceHtml = graph.isHtmlLabel(state.cell) || value && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNode"])(value);
        const dialect = isForceHtml ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].STRICTHTML : graph.dialect;
        const overflow = state.style.overflow ?? 'visible';
        if (state.text && (state.text.wrap !== wrapping || state.text.clipped !== clipping || state.text.overflow !== overflow || state.text.dialect !== dialect)) {
            state.text.destroy();
            state.text = null;
        }
        if (state.text == null && value != null && ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNode"])(value) || value.length > 0)) {
            this.createLabel(state, value);
        } else if (state.text != null && (value == null || value.length == 0)) {
            state.text.destroy();
            state.text = null;
        }
        if (state.text != null) {
            // Forced is true if the style has changed, so to get the updated
            // result in getLabelBounds we apply the new style to the shape
            if (forced) {
                // Checks if a full repaint is needed
                if (state.text.lastValue != null && this.isTextShapeInvalid(state, state.text)) {
                    // Forces a full repaint
                    state.text.lastValue = null;
                }
                state.text.resetStyles();
                state.text.apply(state);
                // Special case where value is obtained via hook in graph
                state.text.valign = state.getVerticalAlign();
            }
            const bounds = this.getLabelBounds(state);
            const nextScale = this.getTextScale(state);
            this.resolveColor(state, 'color', 'fontColor');
            if (forced || state.text.value !== value || state.text.wrap !== wrapping || state.text.overflow !== overflow || state.text.clipped !== clipping || state.text.scale !== nextScale || state.text.dialect !== dialect || state.text.bounds == null || !state.text.bounds.equals(bounds)) {
                state.text.dialect = dialect;
                state.text.value = value;
                state.text.bounds = bounds;
                state.text.scale = nextScale;
                state.text.wrap = wrapping;
                state.text.clipped = clipping;
                state.text.overflow = overflow;
                // Preserves visible state
                // @ts-ignore
                const vis = state.text.node.style.visibility;
                this.redrawLabelShape(state.text);
                // @ts-ignore
                state.text.node.style.visibility = vis;
            }
        }
    }
    /**
     * Returns true if the style for the text shape has changed.
     *
     * @param state <CellState> whose label should be checked.
     * @param shape {@link Text} shape to be checked.
     */ isTextShapeInvalid(state, shape) {
        function check(property, stylename, defaultValue) {
            let result = false;
            // Workaround for spacing added to directional spacing
            if (stylename === 'spacingTop' || stylename === 'spacingRight' || stylename === 'spacingBottom' || stylename === 'spacingLeft') {
                result = // @ts-ignore
                parseFloat(String(shape[property])) - parseFloat(String(shape.spacing)) !== (state.style[stylename] || defaultValue);
            } else {
                // @ts-ignore
                result = shape[property] !== (state.style[stylename] || defaultValue);
            }
            return result;
        }
        return check('fontStyle', 'fontStyle', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_FONTSTYLE"]) || check('family', 'fontFamily', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_FONTFAMILY"]) || check('size', 'fontSize', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_FONTSIZE"]) || check('color', 'fontColor', 'black') || check('align', 'align', '') || check('valign', 'verticalAlign', '') || check('spacing', 'spacing', 2) || check('spacingTop', 'spacingTop', 0) || check('spacingRight', 'spacingRight', 0) || check('spacingBottom', 'spacingBottom', 0) || check('spacingLeft', 'spacingLeft', 0) || check('horizontal', 'horizontal', true) || check('background', 'labelBackgroundColor', null) || check('border', 'labelBorderColor', null) || check('opacity', 'textOpacity', 100) || check('textDirection', 'textDirection', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_TEXT_DIRECTION"]);
    }
    /**
     * Called to invoked redraw on the given text shape.
     *
     * @param shape {@link Text} shape to be redrawn.
     */ redrawLabelShape(shape) {
        shape.redraw();
    }
    /**
     * Returns the scaling used for the label of the given state
     *
     * @param state <CellState> whose label scale should be returned.
     */ getTextScale(state) {
        return state.view.scale;
    }
    /**
     * Returns the bounds to be used to draw the label of the given state.
     *
     * @param state <CellState> whose label bounds should be returned.
     */ getLabelBounds(state) {
        const { scale } = state.view;
        const isEdge = state.cell.isEdge();
        let bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](state.absoluteOffset.x, state.absoluteOffset.y);
        if (isEdge) {
            // @ts-ignore
            const spacing = state.text.getSpacing();
            bounds.x += spacing.x * scale;
            bounds.y += spacing.y * scale;
            const geo = state.cell.getGeometry();
            if (geo != null) {
                bounds.width = Math.max(0, geo.width * scale);
                bounds.height = Math.max(0, geo.height * scale);
            }
        } else {
            // Inverts label position
            // @ts-ignore
            if (state.text.isPaintBoundsInverted()) {
                const tmp = bounds.x;
                bounds.x = bounds.y;
                bounds.y = tmp;
            }
            bounds.x += state.x;
            bounds.y += state.y;
            // Minimum of 1 fixes alignment bug in HTML labels
            bounds.width = Math.max(1, state.width);
            bounds.height = Math.max(1, state.height);
        }
        // @ts-ignore
        if (state.text.isPaintBoundsInverted()) {
            // Rotates around center of state
            const t = (state.width - state.height) / 2;
            bounds.x += t;
            bounds.y -= t;
            const tmp = bounds.width;
            bounds.width = bounds.height;
            bounds.height = tmp;
        }
        // Shape can modify its label bounds
        if (state.shape != null) {
            const hpos = state.style.labelPosition ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].CENTER;
            const vpos = state.style.verticalLabelPosition ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE;
            if (hpos === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].CENTER && vpos === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE) {
                bounds = state.shape.getLabelBounds(bounds);
            }
        }
        // Label width style overrides actual label width
        const lw = state.style.labelWidth ?? null;
        if (lw != null) {
            bounds.width = lw * scale;
        }
        if (!isEdge) {
            this.rotateLabelBounds(state, bounds);
        }
        return bounds;
    }
    /**
     * Adds the shape rotation to the given label bounds and
     * applies the alignment and offsets.
     *
     * @param state <CellState> whose label bounds should be rotated.
     * @param bounds {@link Rectangle} the rectangle to be rotated.
     */ rotateLabelBounds(state, bounds) {
        bounds.y -= state.text.margin.y * bounds.height;
        bounds.x -= state.text.margin.x * bounds.width;
        if (!this.legacySpacing || state.style.overflow !== 'fill' && state.style.overflow !== 'width') {
            const s = state.view.scale;
            const spacing = state.text.getSpacing();
            bounds.x += spacing.x * s;
            bounds.y += spacing.y * s;
            const hpos = state.style.labelPosition ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].CENTER;
            const vpos = state.style.verticalLabelPosition ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE;
            const lw = state.style.labelWidth ?? null;
            bounds.width = Math.max(0, bounds.width - (hpos === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].CENTER && lw == null ? state.text.spacingLeft * s + state.text.spacingRight * s : 0));
            bounds.height = Math.max(0, bounds.height - (vpos === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE ? state.text.spacingTop * s + state.text.spacingBottom * s : 0));
        }
        // @ts-ignore
        const theta = state.text.getTextRotation();
        // Only needed if rotated around another center
        if (theta !== 0 && state != null && // @ts-ignore
        state.cell.isVertex()) {
            const cx = state.getCenterX();
            const cy = state.getCenterY();
            if (bounds.x !== cx || bounds.y !== cy) {
                const rad = theta * (Math.PI / 180);
                const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](bounds.x, bounds.y), Math.cos(rad), Math.sin(rad), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](cx, cy));
                bounds.x = pt.x;
                bounds.y = pt.y;
            }
        }
    }
    /**
     * Redraws the overlays for the given cell state.
     *
     * @param state <CellState> whose overlays should be redrawn.
     */ redrawCellOverlays(state, forced = false) {
        this.createCellOverlays(state);
        if (state.overlays != null) {
            const rot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mod"])(state.style.rotation ?? 0, 90);
            const rad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(rot);
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            state.overlays.visit((id, shape)=>{
                // @ts-ignore
                const bounds = shape.overlay.getBounds(state);
                if (!state.cell.isEdge()) {
                    if (state.shape != null && rot !== 0) {
                        let cx = bounds.getCenterX();
                        let cy = bounds.getCenterY();
                        const point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](cx, cy), cos, sin, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](state.getCenterX(), state.getCenterY()));
                        cx = point.x;
                        cy = point.y;
                        bounds.x = Math.round(cx - bounds.width / 2);
                        bounds.y = Math.round(cy - bounds.height / 2);
                    }
                }
                if (forced || shape.bounds == null || shape.scale !== state.view.scale || !shape.bounds.equals(bounds)) {
                    shape.bounds = bounds;
                    shape.scale = state.view.scale;
                    shape.redraw();
                }
            });
        }
    }
    /**
     * Redraws the control for the given cell state.
     *
     * @param state <CellState> whose control should be redrawn.
     */ redrawControl(state, forced = false) {
        const image = state.view.graph.getFoldingImage(state);
        if (state.control != null && image != null) {
            const bounds = this.getControlBounds(state, image.width, image.height);
            const r = this.legacyControlPosition ? state.style.rotation ?? 0 : state.shape.getTextRotation();
            const s = state.view.scale;
            if (forced || state.control.scale !== s || !state.control.bounds.equals(bounds) || state.control.rotation !== r) {
                state.control.rotation = r;
                state.control.bounds = bounds;
                state.control.scale = s;
                state.control.redraw();
            }
        }
    }
    /**
     * Returns the bounds to be used to draw the control (folding icon) of the
     * given state.
     */ getControlBounds(state, w, h) {
        if (state.control != null) {
            const s = state.view.scale;
            let cx = state.getCenterX();
            let cy = state.getCenterY();
            if (!state.cell.isEdge()) {
                cx = state.x + w * s;
                cy = state.y + h * s;
                if (state.shape != null) {
                    // TODO: Factor out common code
                    let rot = state.shape.getShapeRotation();
                    if (this.legacyControlPosition) {
                        rot = state.style.rotation ?? 0;
                    } else if (state.shape.isPaintBoundsInverted()) {
                        const t = (state.width - state.height) / 2;
                        cx += t;
                        cy -= t;
                    }
                    if (rot !== 0) {
                        const rad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(rot);
                        const cos = Math.cos(rad);
                        const sin = Math.sin(rad);
                        const point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](cx, cy), cos, sin, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](state.getCenterX(), state.getCenterY()));
                        cx = point.x;
                        cy = point.y;
                    }
                }
            }
            return state.cell.isEdge() ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.round(cx - w / 2 * s), Math.round(cy - h / 2 * s), Math.round(w * s), Math.round(h * s)) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.round(cx - w / 2 * s), Math.round(cy - h / 2 * s), Math.round(w * s), Math.round(h * s));
        }
        return null;
    }
    /**
     * Inserts the given array of {@link Shapes} after the given nodes in the DOM.
     *
     * @param shapes Array of {@link Shapes} to be inserted.
     * @param node Node in <drawPane> after which the shapes should be inserted.
     * @param htmlNode Node in the graph container after which the shapes should be inserted that
     * will not go into the <drawPane> (eg. HTML labels without foreignObjects).
     */ insertStateAfter(state, node, htmlNode) {
        const graph = state.view.graph;
        const shapes = this.getShapesForState(state);
        for(let i = 0; i < shapes.length; i += 1){
            // @ts-ignore
            if (shapes[i] != null && shapes[i].node != null) {
                const html = // @ts-ignore
                shapes[i].node.parentNode !== state.view.getDrawPane() && // @ts-ignore
                shapes[i].node.parentNode !== state.view.getOverlayPane();
                const temp = html ? htmlNode : node;
                // @ts-ignore
                if (temp != null && temp.nextSibling !== shapes[i].node) {
                    if (temp.nextSibling == null) {
                        // @ts-ignore
                        temp.parentNode.appendChild(shapes[i].node);
                    } else {
                        // @ts-ignore
                        temp.parentNode.insertBefore(shapes[i].node, temp.nextSibling);
                    }
                } else if (temp == null) {
                    // Special case: First HTML node should be first sibling after canvas
                    // @ts-ignore
                    const shapeNode = shapes[i].node;
                    if (shapeNode.parentNode === graph.container) {
                        let { canvas } = state.view;
                        while(canvas != null && canvas.parentNode !== graph.container){
                            // @ts-ignore
                            canvas = canvas.parentNode;
                        }
                        if (canvas != null && canvas.nextSibling != null) {
                            if (canvas.nextSibling !== shapeNode) {
                                // @ts-ignore
                                shapeNode.parentNode.insertBefore(shapeNode, canvas.nextSibling);
                            }
                        } else {
                            // @ts-ignore
                            shapeNode.parentNode.appendChild(shapeNode);
                        }
                    } else if (shapeNode.parentNode != null && shapeNode.parentNode.firstChild != null && shapeNode.parentNode.firstChild != shapeNode) {
                        // Inserts the node as the first child of the parent to implement the order
                        shapeNode.parentNode.insertBefore(shapeNode, shapeNode.parentNode.firstChild);
                    }
                }
                if (html) {
                    // @ts-ignore
                    htmlNode = shapes[i].node;
                } else {
                    // @ts-ignore
                    node = shapes[i].node;
                }
            }
        }
        return [
            node,
            htmlNode
        ];
    }
    /**
     * Returns the {@link Shapes} for the given cell state in the order in which they should
     * appear in the DOM.
     *
     * @param state <CellState> whose shapes should be returned.
     */ getShapesForState(state) {
        return [
            state.shape,
            state.text,
            state.control
        ];
    }
    /**
     * Updates the bounds or points and scale of the shapes for the given cell
     * state. This is called in mxGraphView.validatePoints as the last step of
     * updating all cells.
     *
     * @param state <CellState> for which the shapes should be updated.
     * @param force Optional boolean that specifies if the cell should be reconfiured
     * and redrawn without any additional checks.
     * @param rendering Optional boolean that specifies if the cell should actually
     * be drawn into the DOM. If this is false then redraw and/or reconfigure
     * will not be called on the shape.
     */ redraw(state, force = false, rendering = true) {
        const shapeChanged = this.redrawShape(state, force, rendering);
        if (state.shape != null && rendering) {
            this.redrawLabel(state, shapeChanged);
            this.redrawCellOverlays(state, shapeChanged);
            this.redrawControl(state, shapeChanged);
        }
    }
    /**
     * Redraws the shape for the given cell state.
     *
     * @param state <CellState> whose label should be redrawn.
     */ redrawShape(state, force = false, rendering = true) {
        let shapeChanged = false;
        const graph = state.view.graph;
        // Forces creation of new shape if shape style has changed
        if (state.shape != null && state.shape.style != null && state.style != null && state.shape.style.shape !== state.style.shape) {
            state.shape.destroy();
            state.shape = null;
        }
        if (state.shape == null && graph.container != null && state.cell !== state.view.currentRoot && (state.cell.isVertex() || state.cell.isEdge())) {
            state.shape = this.createShape(state);
            if (state.shape != null) {
                state.shape.minSvgStrokeWidth = this.minSvgStrokeWidth;
                state.shape.antiAlias = this.antiAlias;
                this.createIndicatorShape(state);
                this.initializeShape(state);
                this.createCellOverlays(state);
                this.installListeners(state);
                // Forces a refresh of the handler if one exists
                const selectionCellsHandler = graph.getPlugin('SelectionCellsHandler');
                selectionCellsHandler?.updateHandler(state);
            }
        } else if (!force && state.shape != null && (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$arrayUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["equalEntries"])(state.shape.style, state.style) || this.checkPlaceholderStyles(state))) {
            state.shape.resetStyles();
            this.configureShape(state);
            // LATER: Ignore update for realtime to fix reset of current gesture
            const selectionCellsHandler = graph.getPlugin('SelectionCellsHandler');
            selectionCellsHandler?.updateHandler(state);
            force = true;
        }
        // Updates indicator shape
        if (state.shape != null && state.shape.indicatorShape != this.getShape(state.getIndicatorShape())) {
            if (state.shape.indicator != null) {
                state.shape.indicator.destroy();
                state.shape.indicator = null;
            }
            this.createIndicatorShape(state);
            if (state.shape.indicatorShape != null) {
                state.shape.indicator = new state.shape.indicatorShape();
                state.shape.indicator.dialect = state.shape.dialect;
                state.shape.indicator.init(state.node);
                force = true;
            }
        }
        if (state.shape) {
            // Handles changes of the collapse icon
            this.createControl(state);
            // Redraws the cell if required, ignores changes to bounds if points are
            // defined as the bounds are updated for the given points inside the shape
            if (force || this.isShapeInvalid(state, state.shape)) {
                if (state.absolutePoints.length > 0) {
                    state.shape.points = state.absolutePoints.slice();
                    state.shape.bounds = null;
                } else {
                    state.shape.points = [];
                    state.shape.bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](state.x, state.y, state.width, state.height);
                }
                state.shape.scale = state.view.scale;
                if (rendering == null || rendering) {
                    this.doRedrawShape(state);
                } else {
                    state.shape.updateBoundingBox();
                }
                shapeChanged = true;
            }
        }
        return shapeChanged;
    }
    /**
     * Invokes redraw on the shape of the given state.
     */ doRedrawShape(state) {
        state.shape?.redraw();
    }
    /**
     * Returns true if the given shape must be repainted.
     */ isShapeInvalid(state, shape) {
        return shape.bounds == null || shape.scale !== state.view.scale || state.absolutePoints.length === 0 && !shape.bounds.equals(state) || state.absolutePoints.length > 0 && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$arrayUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["equalPoints"])(shape.points, state.absolutePoints);
    }
    /**
     * Destroys the shapes associated with the given cell state.
     *
     * @param state <CellState> for which the shapes should be destroyed.
     */ destroy(state) {
        if (state.shape) {
            if (state.text) {
                state.text.destroy();
                state.text = null;
            }
            state.overlays.visit((id, shape)=>{
                shape.destroy();
            });
            state.overlays = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
            if (state.control) {
                state.control.destroy();
                state.control = null;
            }
            state.shape.destroy();
            state.shape = null;
        }
    }
}
/**
 * Static array that contains the globally registered shapes which are
 * known to all instances of this class. For adding new shapes you should
 * use the static {@link CellRenderer#registerShape} function.
 *
 * Built-in shapes: arrow, rectangle, ellipse, rhombus, image, line, label, cylinder,
 * swimlane, connector, actor and cloud.
 */ CellRenderer.defaultShapes = {};
const __TURBOPACK__default__export__ = CellRenderer;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/cell/CellState.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Dictionary.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
;
;
;
;
/**
 * Represents the current state of a cell in a given {@link GraphView}.
 *
 * For edges, the edge label position is stored in <absoluteOffset>.
 *
 * The size for oversize labels can be retrieved using the boundingBox property
 * of the <text> field as shown below.
 *
 * ```javascript
 * let bbox = (state.text != null) ? state.text.boundingBox : null;
 * ```
 *
 */ class CellState extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
     * Constructs a new object that represents the current state of the given Cell in the specified view.
     *
     * @param view {@link GraphView} that contains the state.
     * @param cell {@link Cell} that this state represents.
     * @param style the style of the Cell.
     */ constructor(view = null, cell = null, style = null){
        super();
        // referenced in mxCellRenderer
        this.node = null;
        // TODO: Document me!!
        this.cellBounds = null;
        this.paintBounds = null;
        this.boundingBox = null;
        // Used by mxCellRenderer's createControl()
        this.control = null;
        // Used by mxCellRenderer's createCellOverlays()
        this.overlays = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
        /**
         * Specifies if the style is invalid. Default is false.
         */ this.invalidStyle = false;
        /**
         * Specifies if the state is invalid. Default is true.
         */ this.invalid = true;
        /**
         * Holds an array of <Point> that represent the absolute points of an
         * edge.
         */ this.absolutePoints = [];
        /**
         * Caches the visible source terminal state.
         */ this.visibleSourceState = null;
        /**
         * Caches the visible target terminal state.
         */ this.visibleTargetState = null;
        /**
         * Caches the distance between the end points for an edge.
         */ this.terminalDistance = 0;
        /**
         * Caches the length of an edge.
         */ this.length = 0;
        /**
         * Array of numbers that represent the cached length of each segment of the
         * edge.
         */ this.segments = [];
        /**
         * Holds the {@link Shape} that represents the cell graphically.
         */ this.shape = null;
        /**
         * Holds the {@link Text} that represents the label of the cell. Thi smay be
         * null if the cell has no label.
         */ this.text = null;
        /**
         * Holds the unscaled width of the state.
         */ this.unscaledWidth = 0;
        /**
         * Holds the unscaled height of the state.
         */ this.unscaledHeight = 0;
        this.parentHighlight = null;
        this.point = null;
        if (view) {
            this.view = view;
        }
        if (cell) {
            this.cell = cell;
        }
        this.style = style ?? {};
        this.origin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
        this.absoluteOffset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
    }
    /**
     * Returns the {@link Rectangle} that should be used as the perimeter of the
     * cell.
     *
     * @param border Optional border to be added around the perimeter bounds.
     * @param bounds Optional {@link Rectangle} to be used as the initial bounds.
     */ getPerimeterBounds(border = 0, bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.x, this.y, this.width, this.height)) {
        if (this.shape?.stencil?.aspect === 'fixed') {
            const aspect = this.shape.stencil.computeAspect(this.shape, bounds.x, bounds.y, bounds.width, bounds.height);
            bounds.x = aspect.x;
            bounds.y = aspect.y;
            bounds.width = this.shape.stencil.w0 * aspect.width;
            bounds.height = this.shape.stencil.h0 * aspect.height;
        }
        if (border !== 0) {
            bounds.grow(border);
        }
        return bounds;
    }
    /**
     * Sets the first or last point in <absolutePoints> depending on isSource.
     *
     * @param point {@link Point} that represents the terminal point.
     * @param isSource Boolean that specifies if the first or last point should
     * be assigned.
     */ setAbsoluteTerminalPoint(point, isSource = false) {
        if (isSource) {
            if (this.absolutePoints.length === 0) {
                this.absolutePoints.push(point);
            } else {
                this.absolutePoints[0] = point;
            }
        } else if (this.absolutePoints.length === 0) {
            this.absolutePoints.push(null);
            this.absolutePoints.push(point);
        } else if (this.absolutePoints.length === 1) {
            this.absolutePoints.push(point);
        } else {
            this.absolutePoints[this.absolutePoints.length - 1] = point;
        }
    }
    /**
     * Sets the given cursor on the shape and text shape.
     */ setCursor(cursor) {
        if (this.shape) {
            this.shape.setCursor(cursor);
        }
        if (this.text) {
            this.text.setCursor(cursor);
        }
    }
    /**
     * Returns the visible source or target terminal cell.
     *
     * @param source Boolean that specifies if the source or target cell should be
     * returned.
     */ getVisibleTerminal(source = false) {
        return this.getVisibleTerminalState(source)?.cell ?? null;
    }
    /**
     * Returns the visible source or target terminal state.
     *
     * @param source Boolean that specifies if the source or target state should be
     * returned.
     */ getVisibleTerminalState(source = false) {
        return source ? this.visibleSourceState : this.visibleTargetState;
    }
    /**
     * Sets the visible source or target terminal state.
     *
     * @param terminalState <CellState> that represents the terminal.
     * @param source Boolean that specifies if the source or target state should be set.
     */ setVisibleTerminalState(terminalState, source = false) {
        if (source) {
            this.visibleSourceState = terminalState;
        } else {
            this.visibleTargetState = terminalState;
        }
    }
    /**
     * Returns the unscaled, untranslated bounds.
     */ getCellBounds() {
        return this.cellBounds;
    }
    /**
     * Returns the unscaled, untranslated paint bounds. This is the same as
     * <getCellBounds> but with a 90 degree rotation if the shape's
     * isPaintBoundsInverted returns true.
     */ getPaintBounds() {
        return this.paintBounds;
    }
    /**
     * Updates the cellBounds and paintBounds.
     */ updateCachedBounds() {
        const view = this.view;
        const tr = view.translate;
        const s = view.scale;
        this.cellBounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.x / s - tr.x, this.y / s - tr.y, this.width / s, this.height / s);
        this.paintBounds = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].fromRectangle(this.cellBounds);
        if (this.shape && this.shape.isPaintBoundsInverted()) {
            this.paintBounds.rotate90();
        }
    }
    /**
     * Destructor: setState
     *
     * Copies all fields from the given state to this state.
     */ setState(state) {
        this.view = state.view;
        this.cell = state.cell;
        this.style = state.style;
        this.absolutePoints = state.absolutePoints;
        this.origin = state.origin;
        this.absoluteOffset = state.absoluteOffset;
        this.boundingBox = state.boundingBox;
        this.terminalDistance = state.terminalDistance;
        this.segments = state.segments;
        this.length = state.length;
        this.x = state.x;
        this.y = state.y;
        this.width = state.width;
        this.height = state.height;
        this.unscaledWidth = state.unscaledWidth;
        this.unscaledHeight = state.unscaledHeight;
    }
    /**
     * Returns a clone of this {@link Point}.
     */ clone() {
        const clone = new CellState(this.view, this.cell, this.style);
        // Clones the absolute points
        for(let i = 0; i < this.absolutePoints.length; i += 1){
            const p = this.absolutePoints[i];
            clone.absolutePoints[i] = p ? p.clone() : null;
        }
        if (this.origin) {
            clone.origin = this.origin.clone();
        }
        if (this.absoluteOffset) {
            clone.absoluteOffset = this.absoluteOffset.clone();
        }
        if (this.boundingBox) {
            clone.boundingBox = this.boundingBox.clone();
        }
        clone.terminalDistance = this.terminalDistance;
        clone.segments = this.segments;
        clone.length = this.length;
        clone.x = this.x;
        clone.y = this.y;
        clone.width = this.width;
        clone.height = this.height;
        clone.unscaledWidth = this.unscaledWidth;
        clone.unscaledHeight = this.unscaledHeight;
        return clone;
    }
    /**
     * Destructor: destroy
     *
     * Destroys the state and all associated resources.
     */ destroy() {
        this.view.graph.cellRenderer.destroy(this);
    }
    /**
     * Returns true if the given cell state is a loop.
     *
     * @param state {@link CellState} that represents a potential loop.
     */ isLoop(state) {
        const src = this.getVisibleTerminalState(true);
        return src && src === this.getVisibleTerminalState(false);
    }
    /*****************************************************************************
     * Group: Graph appearance
     *****************************************************************************/ /**
     * Returns the vertical alignment for the given cell state.
     * This implementation returns the value stored in the {@link CellStateStyle.verticalAlign}
     * property of {@link style}.
     */ getVerticalAlign() {
        return this.style.verticalAlign ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE;
    }
    /**
     * Returns `true` if the given state has no stroke, no fill color and no image.
     */ isTransparentState() {
        return (this.style.strokeColor ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"]) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"] && (this.style.fillColor ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"]) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"] && !this.getImageSrc();
    }
    /**
     * Returns the image URL for the given cell state.
     * This implementation returns the value stored in the {@link CellStateStyle.image} property
     * of {@link style}.
     */ getImageSrc() {
        return this.style.image || null;
    }
    /**
     * Returns the indicator color for the given cell state.
     * This implementation returns the value stored in the {@link CellStateStyle.indicatorColor}
     * property of {@link style}.
     */ getIndicatorColor() {
        return this.style.indicatorColor || null;
    }
    /**
     * Returns the indicator gradient color for the given cell state.
     * This implementation returns the value stored in the {@link CellStateStyle.gradientColor}
     * property of {@link style}.
     */ getIndicatorGradientColor() {
        return this.style.gradientColor || null;
    }
    /**
     * Returns the indicator shape for the given cell state.
     * This implementation returns the value stored in the {@link CellStateStyle.indicatorShape}
     * property of {@link style}.
     */ getIndicatorShape() {
        return this.style.indicatorShape || null;
    }
    /**
     * Returns the indicator image for the given cell state.
     * This implementation returns the value stored in the {@link CellStateStyle.indicatorImage}
     * property of {@link style}.
     */ getIndicatorImageSrc() {
        return this.style.indicatorImage || null;
    }
}
const __TURBOPACK__default__export__ = CellState;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/cell/CellHighlight.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-ssr] (ecmascript)");
;
;
;
/**
 * A helper class to highlight cells. Here is an example for a given cell.
 *
 * ```javascript
 * var highlight = new mxCellHighlight(graph, '#ff0000', 2);
 * highlight.highlight(graph.view.getState(cell)));
 * ```
 */ class CellHighlight {
    constructor(graph, highlightColor, strokeWidth, dashed){
        this.strokeWidth = 0;
        this.dashed = false;
        this.opacity = 100;
        this.shape = null;
        /**
         * Specifies if the highlights should appear on top of everything else in the overlay pane.
         * @default false
         */ this.keepOnTop = false;
        /**
         * Reference to the {@link CellState}.
         * @default null
         */ this.state = null;
        /**
         * Specifies the spacing between the highlight for vertices and the vertex.
         * @default 2
         */ this.spacing = 2;
        this.graph = graph;
        this.highlightColor = highlightColor ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_VALID_COLOR"];
        this.strokeWidth = strokeWidth ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HIGHLIGHT_STROKEWIDTH"];
        this.dashed = dashed ?? false;
        this.opacity = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HIGHLIGHT_OPACITY"];
        // Updates the marker if the graph changes
        this.repaintHandler = ()=>{
            // Updates reference to state
            if (this.state) {
                const tmp = this.graph.view.getState(this.state.cell);
                if (!tmp) {
                    this.hide();
                } else {
                    this.state = tmp;
                    this.repaint();
                }
            }
        };
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SCALE, this.repaintHandler);
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].TRANSLATE, this.repaintHandler);
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SCALE_AND_TRANSLATE, this.repaintHandler);
        this.graph.getDataModel().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, this.repaintHandler);
        // Hides the marker if the current root changes
        this.resetHandler = ()=>{
            this.hide();
        };
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].DOWN, this.resetHandler);
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].UP, this.resetHandler);
    }
    /**
     * Sets the color of the rectangle used to highlight drop targets.
     *
     * @param {string} color - String that represents the new highlight color.
     */ setHighlightColor(color) {
        this.highlightColor = color;
        if (this.shape) {
            this.shape.stroke = color;
        }
    }
    /**
     * Creates and returns the highlight shape for the given state.
     */ drawHighlight() {
        this.shape = this.createShape();
        this.repaint();
        if (this.shape) {
            const node = this.shape.node;
            if (!this.keepOnTop && node?.parentNode?.firstChild !== node && node.parentNode) {
                node.parentNode.insertBefore(node, node.parentNode.firstChild);
            }
        }
    }
    /**
     * Creates and returns the highlight shape for the given state.
     */ createShape() {
        if (!this.state) return null;
        const shape = this.graph.cellRenderer.createShape(this.state);
        shape.svgStrokeTolerance = this.graph.getEventTolerance();
        shape.points = this.state.absolutePoints;
        shape.apply(this.state);
        shape.stroke = this.highlightColor;
        shape.opacity = this.opacity;
        shape.isDashed = this.dashed;
        shape.isShadow = false;
        shape.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG;
        shape.init(this.graph.getView().getOverlayPane());
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].redirectMouseEvents(shape.node, this.graph, this.state);
        if (this.graph.dialect !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG) {
            shape.pointerEvents = false;
        } else {
            shape.svgPointerEvents = 'stroke';
        }
        return shape;
    }
    /**
     * Updates the highlight after a change of the model or view.
     */ getStrokeWidth(state = null) {
        return this.strokeWidth;
    }
    /**
     * Updates the highlight after a change of the model or view.
     */ repaint() {
        if (this.state && this.shape) {
            this.shape.scale = this.state.view.scale;
            if (this.state.cell.isEdge()) {
                this.shape.strokeWidth = this.getStrokeWidth();
                this.shape.points = this.state.absolutePoints;
                this.shape.outline = false;
            } else {
                this.shape.bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.state.x - this.spacing, this.state.y - this.spacing, this.state.width + 2 * this.spacing, this.state.height + 2 * this.spacing);
                this.shape.rotation = this.state.style.rotation ?? 0;
                this.shape.strokeWidth = this.getStrokeWidth() / this.state.view.scale;
                this.shape.outline = true;
            }
            // Uses cursor from shape in highlight
            if (this.state.shape) {
                this.shape.setCursor(this.state.shape.getCursor());
            }
            this.shape.redraw();
        }
    }
    /**
     * Resets the state of the cell marker.
     */ hide() {
        this.highlight(null);
    }
    /**
     * Marks the {@link arkedState} and fires a {@link ark} event.
     */ highlight(state = null) {
        if (this.state !== state) {
            if (this.shape) {
                this.shape.destroy();
                this.shape = null;
            }
            this.state = state;
            if (this.state) {
                this.drawHighlight();
            }
        }
    }
    /**
     * Returns true if this highlight is at the given position.
     */ isHighlightAt(x, y) {
        let hit = false;
        if (this.shape && document.elementFromPoint) {
            let elt = document.elementFromPoint(x, y);
            while(elt){
                if (elt === this.shape.node) {
                    hit = true;
                    break;
                }
                elt = elt.parentNode;
            }
        }
        return hit;
    }
    /**
     * Destroys the handler and all its resources and DOM nodes.
     */ destroy() {
        const graph = this.graph;
        graph.getView().removeListener(this.resetHandler);
        graph.getView().removeListener(this.repaintHandler);
        graph.getDataModel().removeListener(this.repaintHandler);
        if (this.shape) {
            this.shape.destroy();
            this.shape = null;
        }
    }
}
const __TURBOPACK__default__export__ = CellHighlight;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/cell/CellMarker.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellHighlight$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/CellHighlight.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventSource.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
/**
 * A helper class to process mouse locations and highlight cells.
 *
 * Helper class to highlight cells. To add a cell marker to an existing graph
 * for highlighting all cells, the following code is used:
 *
 * ```javascript
 * let marker = new mxCellMarker(graph);
 * graph.addMouseListener({
 *   mouseDown: ()=> {},
 *   mouseMove: (sender, me)=>
 *   {
 *     marker.process(me);
 *   },
 *   mouseUp: ()=> {}
 * });
 * ```
 *
 * Event: mxEvent.MARK
 *
 * Fires after a cell has been marked or unmarked. The <code>state</code>
 * property contains the marked <CellState> or null if no state is marked.
 *
 * Constructor: mxCellMarker
 *
 * Constructs a new cell marker.
 *
 * @param graph Reference to the enclosing {@link Graph}.
 * @param validColor Optional marker color for valid states. Default is
 * {@link Constants#DEFAULT_VALID_COLOR}.
 * @param invalidColor Optional marker color for invalid states. Default is
 * {@link Constants#DEFAULT_INVALID_COLOR}.
 * @param hotspot Portion of the width and hight where a state intersects a
 * given coordinate pair. A value of 0 means always highlight. Default is
 * {@link Constants#DEFAULT_HOTSPOT}.
 */ class CellMarker extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    constructor(graph, validColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_VALID_COLOR"], invalidColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_INVALID_COLOR"], hotspot = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_HOTSPOT"]){
        super();
        /**
         * Specifies if the marker is enabled. Default is true.
         */ this.enabled = true;
        /**
         * Specifies the portion of the width and height that should trigger
         * a highlight. The area around the center of the cell to be marked is used
         * as the hotspot. Possible values are between 0 and 1. Default is
         * mxConstants.DEFAULT_HOTSPOT.
         */ this.hotspot = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_HOTSPOT"];
        /**
         * Specifies if the hotspot is enabled. Default is false.
         */ this.hotspotEnabled = false;
        /**
         * Holds the current marker color.
         */ this.currentColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"];
        /**
         * Holds the marked <CellState> if it is valid.
         */ this.validState = null;
        /**
         * Holds the marked <CellState>.
         */ this.markedState = null;
        this.graph = graph;
        this.validColor = validColor;
        this.invalidColor = invalidColor;
        this.hotspot = hotspot;
        this.highlight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellHighlight$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](graph);
    }
    /**
     * Enables or disables event handling. This implementation
     * updates <enabled>.
     *
     * @param enabled Boolean that specifies the new enabled state.
     */ setEnabled(enabled) {
        this.enabled = enabled;
    }
    /**
     * Returns true if events are handled. This implementation
     * returns <enabled>.
     */ isEnabled() {
        return this.enabled;
    }
    /**
     * Sets the <hotspot>.
     */ setHotspot(hotspot) {
        this.hotspot = hotspot;
    }
    /**
     * Returns the <hotspot>.
     */ getHotspot() {
        return this.hotspot;
    }
    /**
     * Specifies whether the hotspot should be used in <intersects>.
     */ setHotspotEnabled(enabled) {
        this.hotspotEnabled = enabled;
    }
    /**
     * Returns true if hotspot is used in <intersects>.
     */ isHotspotEnabled() {
        return this.hotspotEnabled;
    }
    /**
     * Returns true if <validState> is not null.
     */ hasValidState() {
        return !!this.validState;
    }
    /**
     * Returns the <validState>.
     */ getValidState() {
        return this.validState;
    }
    /**
     * Returns the {@link arkedState}.
     */ getMarkedState() {
        return this.markedState;
    }
    /**
     * Resets the state of the cell marker.
     */ reset() {
        this.validState = null;
        if (this.markedState) {
            this.markedState = null;
            this.unmark();
        }
    }
    /**
     * Processes the given event and cell and marks the state returned by
     * <getState> with the color returned by <getMarkerColor>. If the
     * markerColor is not null, then the state is stored in {@link arkedState}. If
     * <isValidState> returns true, then the state is stored in <validState>
     * regardless of the marker color. The state is returned regardless of the
     * marker color and valid state.
     */ process(me) {
        let state = null;
        if (this.isEnabled()) {
            state = this.getState(me);
            this.setCurrentState(state, me);
        }
        return state;
    }
    /**
     * Sets and marks the current valid state.
     */ setCurrentState(state, me, color) {
        const isValid = state ? this.isValidState(state) : false;
        color = color ?? this.getMarkerColor(me.getEvent(), state, isValid);
        if (isValid) {
            this.validState = state;
        } else {
            this.validState = null;
        }
        if (state !== this.markedState || color !== this.currentColor) {
            this.currentColor = color;
            if (state && this.currentColor !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"]) {
                this.markedState = state;
                this.mark();
            } else if (this.markedState) {
                this.markedState = null;
                this.unmark();
            }
        }
    }
    /**
     * Marks the given cell using the given color, or <validColor> if no color is specified.
     */ markCell(cell, color) {
        const state = this.graph.getView().getState(cell);
        if (state) {
            this.currentColor = color ?? this.validColor;
            this.markedState = state;
            this.mark();
        }
    }
    /**
     * Marks the {@link arkedState} and fires a {@link ark} event.
     */ mark() {
        this.highlight.setHighlightColor(this.currentColor);
        this.highlight.highlight(this.markedState);
        this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MARK, 'state', this.markedState));
    }
    /**
     * Hides the marker and fires a {@link ark} event.
     */ unmark() {
        this.mark();
    }
    /**
     * Returns true if the given <CellState> is a valid state. If this
     * returns true, then the state is stored in <validState>. The return value
     * of this method is used as the argument for <getMarkerColor>.
     */ isValidState(state) {
        return true;
    }
    /**
     * Returns the valid- or invalidColor depending on the value of isValid.
     * The given <CellState> is ignored by this implementation.
     */ getMarkerColor(evt, state, isValid) {
        return isValid ? this.validColor : this.invalidColor;
    }
    /**
     * Uses <getCell>, <getStateToMark> and <intersects> to return the
     * <CellState> for the given {@link MouseEvent}.
     */ getState(me) {
        const view = this.graph.getView();
        const cell = this.getCell(me);
        if (!cell) return null;
        const state = this.getStateToMark(view.getState(cell));
        return state && this.intersects(state, me) ? state : null;
    }
    /**
     * Returns the <Cell> for the given event and cell. This returns the
     * given cell.
     */ getCell(me) {
        return me.getCell();
    }
    /**
     * Returns the <CellState> to be marked for the given <CellState> under
     * the mouse. This returns the given state.
     */ getStateToMark(state) {
        return state;
    }
    /**
     * Returns true if the given coordinate pair intersects the given state.
     * This returns true if the <hotspot> is 0 or the coordinates are inside
     * the hotspot for the given cell state.
     */ intersects(state, me) {
        const x = me.getGraphX();
        const y = me.getGraphY();
        if (this.hotspotEnabled) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersectsHotspot"])(state, x, y, this.hotspot, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MIN_HOTSPOT_SIZE"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MAX_HOTSPOT_SIZE"]);
        }
        return true;
    }
    /**
     * Destroys the handler and all its resources and DOM nodes.
     */ destroy() {
        this.highlight.destroy();
    }
}
const __TURBOPACK__default__export__ = CellMarker;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/cell/register-shapes.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2024-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "registerDefaultShapes": (()=>registerDefaultShapes)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$ActorShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/ActorShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$ArrowShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/ArrowShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$ArrowConnectorShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/ArrowConnectorShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$ConnectorShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/ConnectorShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$CloudShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/CloudShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$CylinderShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/CylinderShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$DoubleEllipseShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/DoubleEllipseShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$EllipseShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/EllipseShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$HexagonShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/HexagonShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/ImageShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$LabelShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/LabelShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$LineShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/LineShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/RectangleShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RhombusShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/RhombusShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$SwimlaneShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/SwimlaneShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$TriangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/TriangleShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellRenderer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/CellRenderer.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
let isDefaultElementsRegistered = false;
function registerDefaultShapes() {
    if (!isDefaultElementsRegistered) {
        const shapesToRegister = [
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SHAPE"].ACTOR,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$ActorShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SHAPE"].ARROW,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$ArrowShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SHAPE"].ARROW_CONNECTOR,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$ArrowConnectorShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SHAPE"].CONNECTOR,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$ConnectorShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SHAPE"].CLOUD,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$CloudShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SHAPE"].CYLINDER,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$CylinderShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SHAPE"].DOUBLE_ELLIPSE,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$DoubleEllipseShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SHAPE"].ELLIPSE,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$EllipseShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SHAPE"].HEXAGON,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$HexagonShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SHAPE"].IMAGE,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SHAPE"].LABEL,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$LabelShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SHAPE"].LINE,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$LineShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SHAPE"].RECTANGLE,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SHAPE"].RHOMBUS,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RhombusShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SHAPE"].SWIMLANE,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$SwimlaneShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SHAPE"].TRIANGLE,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$TriangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
            ]
        ];
        for (const [shapeName, shapeClass] of shapesToRegister){
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellRenderer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].registerShape(shapeName, shapeClass);
        }
        isDefaultElementsRegistered = true;
    }
}
}}),
"[project]/node_modules/@maxgraph/core/lib/view/cell/CellOverlay.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventSource.js [app-ssr] (ecmascript)");
;
;
;
/**
 * Extends {@link EventSource} to implement a graph overlay, represented by an icon
 * and a tooltip. Overlays can handle and fire <click> events and are added to
 * the graph using {@link Graph#addCellOverlay}, and removed using
 * {@link Graph#removeCellOverlay}, or {@link Graph#removeCellOverlays} to remove all overlays.
 * The {@link Graph#getCellOverlays} function returns the array of overlays for a given
 * cell in a graph. If multiple overlays exist for the same cell, then
 * <getBounds> should be overridden in at least one of the overlays.
 *
 * Overlays appear on top of all cells in a special layer. If this is not
 * desirable, then the image must be rendered as part of the shape or label of
 * the cell instead.
 *
 * Example:
 *
 * The following adds a new overlays for a given vertex and selects the cell
 * if the overlay is clicked.
 *
 * ```javascript
 * let overlay = new CellOverlay(img, html);
 * graph.addCellOverlay(vertex, overlay);
 * overlay.addListener(mxEvent.CLICK, (sender, evt)=>
 * {
 *   let cell = evt.getProperty('cell');
 *   graph.setSelectionCell(cell);
 * });
 * ```
 *
 * For cell overlays to be printed use {@link PrintPreview#printOverlays}.
 *
 * Event: mxEvent.CLICK
 *
 * Fires when the user clicks on the overlay. The <code>event</code> property
 * contains the corresponding mouse event and the <code>cell</code> property
 * contains the cell. For touch devices this is fired if the element receives
 * a touchend event.
 *
 * Constructor: CellOverlay
 *
 * Constructs a new overlay using the given image and tooltip.
 *
 * @param image {@link Image} that represents the icon to be displayed.
 * @param tooltip Optional string that specifies the tooltip.
 * @param align Optional horizontal alignment for the overlay. Possible
 * values are <ALIGN_LEFT>, <ALIGN_CENTER> and <ALIGN_RIGHT>
 * (default).
 * @param verticalAlign Vertical alignment for the overlay. Possible
 * values are <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>
 * (default).
 */ class CellOverlay extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    constructor(image, tooltip = null, align = 'right', verticalAlign = 'bottom', offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](), cursor = 'help'){
        super();
        /**
         * Holds the horizontal alignment for the overlay.
         *
         * For edges, the overlay always appears in the center of the edge.
         * @default 'right'
         */ this.align = 'right';
        /**
         * Holds the vertical alignment for the overlay.
         *
         * For edges, the overlay always appears in the center of the edge.
         * @default 'bottom'
         */ this.verticalAlign = 'bottom';
        /**
         * Holds the offset as an {@link Point}. The offset will be scaled according to the
         * current scale.
         */ this.offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
        /**
         * Holds the cursor for the overlay.
         * @default 'help'.
         */ this.cursor = 'help';
        /**
         * Defines the overlapping for the overlay, that is, the proportional distance
         * from the origin to the point defined by the alignment. Default is 0.5.
         */ this.defaultOverlap = 0.5;
        this.image = image;
        this.tooltip = tooltip;
        this.align = align;
        this.verticalAlign = verticalAlign;
        this.offset = offset;
        this.cursor = cursor;
    }
    /**
     * Returns the bounds of the overlay for the given <CellState> as an
     * {@link Rectangle}. This should be overridden when using multiple overlays
     * per cell so that the overlays do not overlap.
     *
     * The following example will place the overlay along an edge (where
     * x=[-1..1] from the start to the end of the edge and y is the
     * orthogonal offset in px).
     *
     * ```javascript
     * overlay.getBounds = function(state)
     * {
     *   var bounds = getBounds.apply(this, arguments);
     *
     *   if (state.view.graph.getDataModel().isEdge(state.cell))
     *   {
     *     var pt = state.view.getPoint(state, {x: 0, y: 0, relative: true});
     *
     *     bounds.x = pt.x - bounds.width / 2;
     *     bounds.y = pt.y - bounds.height / 2;
     *   }
     *
     *   return bounds;
     * };
     * ```
     *
     * @param state <CellState> that represents the current state of the
     * associated cell.
     */ getBounds(state) {
        const isEdge = state.cell.isEdge();
        const s = state.view.scale;
        let pt = null;
        const image = this.image;
        const w = image.width;
        const h = image.height;
        if (isEdge) {
            const pts = state.absolutePoints;
            if (pts.length % 2 === 1) {
                pt = pts[Math.floor(pts.length / 2)];
            } else {
                const idx = pts.length / 2;
                const p0 = pts[idx - 1];
                const p1 = pts[idx];
                pt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](p0.x + (p1.x - p0.x) / 2, p0.y + (p1.y - p0.y) / 2);
            }
        } else {
            pt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
            if (this.align === 'left') {
                pt.x = state.x;
            } else if (this.align === 'center') {
                pt.x = state.x + state.width / 2;
            } else if (this.align === 'right') {
                pt.x = state.x + state.width;
            } else {
                throw new Error();
            }
            if (this.verticalAlign === 'top') {
                pt.y = state.y;
            } else if (this.verticalAlign === 'middle') {
                pt.y = state.y + state.height / 2;
            } else if (this.verticalAlign === 'bottom') {
                pt.y = state.y + state.height;
            } else {
                throw new Error();
            }
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.round(pt.x - (w * this.defaultOverlap - this.offset.x) * s), Math.round(pt.y - (h * this.defaultOverlap - this.offset.y) * s), w * s, h * s);
    }
    /**
     * Returns the textual representation of the overlay to be used as the
     * tooltip. This implementation returns <tooltip>.
     */ toString() {
        return this.tooltip;
    }
}
const __TURBOPACK__default__export__ = CellOverlay;
}}),

};

//# sourceMappingURL=node_modules_%40maxgraph_core_lib_view_cell_3b5015._.js.map