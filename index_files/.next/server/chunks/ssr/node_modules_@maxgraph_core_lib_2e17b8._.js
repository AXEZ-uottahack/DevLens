module.exports = {

"[project]/node_modules/@maxgraph/core/lib/Client.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2017, JGraph Ltd
Copyright (c) 2006-2017, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
;
class Client {
}
/**
 * The version of the `maxGraph` library.
 */ Client.VERSION = '0.14.0';
/**
 * Base path for all URLs in the core without trailing slash.
 *
 * When using a relative path, the path is relative to the URL of the page that contains the assignment. Trailing slashes are automatically removed.
 * @default '.'
 */ Client.basePath = '.';
Client.setBasePath = (value)=>{
    if (typeof value !== 'undefined' && value.length > 0) {
        // Adds a trailing slash if required
        if (value.substring(value.length - 1) === '/') {
            value = value.substring(0, value.length - 1);
        }
        Client.basePath = value;
    } else {
        Client.basePath = '.';
    }
};
/**
 * Base path for all images URLs in the core without trailing slash.
 *
 * When using a relative path, the path is relative to the URL of the page that
 * contains the assignment. Trailing slashes are automatically removed.
 * @default '.'
 */ Client.imageBasePath = '.';
Client.setImageBasePath = (value)=>{
    if (typeof value !== 'undefined' && value.length > 0) {
        // Adds a trailing slash if required
        if (value.substring(value.length - 1) === '/') {
            value = value.substring(0, value.length - 1);
        }
        Client.imageBasePath = value;
    } else {
        Client.imageBasePath = `${Client.basePath}/images`;
    }
};
/**
 * Defines the language of the client, eg. `en` for english, `de` for german etc.
 * The special value `none` will disable all built-in internationalization and
 * resource loading. See {@link Resources#getSpecialBundle} for handling identifiers
 * with and without a dash.
 *
 * If internationalization is disabled, then the following variables should be
 * overridden to reflect the current language of the system. These variables are
 * cleared when i18n is disabled.
 * {@link Editor.askZoomResource}, {@link Editor.lastSavedResource},
 * {@link Editor.currentFileResource}, {@link Editor.propertiesResource},
 * {@link Editor.tasksResource}, {@link Editor.helpResource}, {@link Editor.outlineResource},
 * {@link ElbowEdgeHandler#doubleClickOrientationResource}, {@link Utils#errorResource},
 * {@link Utils#closeResource}, {@link GraphSelectionModel#doneResource},
 * {@link GraphSelectionModel#updatingSelectionResource}, {@link GraphView#doneResource},
 * {@link GraphView#updatingDocumentResource}, {@link CellRenderer#collapseExpandResource},
 * {@link Graph#containsValidationErrorsResource} and
 * {@link Graph#alreadyConnectedResource}.
 */ Client.language = typeof window !== 'undefined' ? navigator.language : 'en';
Client.setLanguage = (value)=>{
    if (typeof value !== 'undefined' && value != null) {
        Client.language = value;
    } else {
        Client.language = navigator.language;
    }
};
/**
 * Defines the default language which is used in the common resource files. Any
 * resources for this language will only load the common resource file, but not
 * the language-specific resource file.
 * @default 'en'
 */ Client.defaultLanguage = 'en';
Client.setDefaultLanguage = (value)=>{
    if (typeof value !== 'undefined' && value != null) {
        Client.defaultLanguage = value;
    } else {
        Client.defaultLanguage = 'en';
    }
};
/**
 * Defines the optional array of all supported language extensions. The default
 * language does not have to be part of this list. See
 * {@link Translations#isLanguageSupported}.
 *
 * This is used to avoid unnecessary requests to language files, ie. if a 404
 * will be returned.
 * @default null
 */ Client.languages = null;
Client.setLanguages = (value)=>{
    if (typeof value !== 'undefined' && value != null) {
        Client.languages = value;
    }
};
/**
 * True if the current browser is Microsoft Edge.
 */ Client.IS_EDGE = typeof window !== 'undefined' && navigator.userAgent != null && !!navigator.userAgent.match(/Edge\//);
/**
 * True if the current browser is Netscape (including Firefox).
 */ Client.IS_NS = typeof window !== 'undefined' && navigator.userAgent != null && navigator.userAgent.indexOf('Mozilla/') >= 0 && navigator.userAgent.indexOf('MSIE') < 0 && navigator.userAgent.indexOf('Edge/') < 0;
/**
 * True if the current browser is Safari.
 */ Client.IS_SF = typeof window !== 'undefined' && /Apple Computer, Inc/.test(navigator.vendor);
/**
 * Returns true if the user agent contains Android.
 */ Client.IS_ANDROID = typeof window !== 'undefined' && navigator.appVersion.indexOf('Android') >= 0;
/**
 * Returns true if the user agent is an iPad, iPhone or iPod.
 */ Client.IS_IOS = typeof window !== 'undefined' && /iP(hone|od|ad)/.test(navigator.platform);
/**
 * True if the current browser is Google Chrome.
 */ Client.IS_GC = typeof window !== 'undefined' && /Google Inc/.test(navigator.vendor);
/**
 * True if the this is running inside a Chrome App.
 */ Client.IS_CHROMEAPP = typeof window !== 'undefined' && // @ts-ignore
window.chrome != null && // @ts-ignore
chrome.app != null && // @ts-ignore
chrome.app.runtime != null;
/**
 * True if the current browser is Firefox.
 */ Client.IS_FF = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
/**
 * True if -moz-transform is available as a CSS style. This is the case
 * for all Firefox-based browsers newer than or equal 3, such as Camino,
 * Iceweasel, Seamonkey and Iceape.
 */ Client.IS_MT = typeof window !== 'undefined' && (navigator.userAgent.indexOf('Firefox/') >= 0 && navigator.userAgent.indexOf('Firefox/1.') < 0 && navigator.userAgent.indexOf('Firefox/2.') < 0 || navigator.userAgent.indexOf('Iceweasel/') >= 0 && navigator.userAgent.indexOf('Iceweasel/1.') < 0 && navigator.userAgent.indexOf('Iceweasel/2.') < 0 || navigator.userAgent.indexOf('SeaMonkey/') >= 0 && navigator.userAgent.indexOf('SeaMonkey/1.') < 0 || navigator.userAgent.indexOf('Iceape/') >= 0 && navigator.userAgent.indexOf('Iceape/1.') < 0);
/**
 * True if the browser supports SVG.
 */ Client.IS_SVG = typeof window !== 'undefined' && navigator.appName.toUpperCase() !== 'MICROSOFT INTERNET EXPLORER';
/**
 * True if foreignObject support is not available. This is the case for
 * Opera, older SVG-based browsers and all versions of IE.
 */ Client.NO_FO = typeof window !== 'undefined' && (!document.createElementNS || document.createElementNS(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NS_SVG"], 'foreignObject').toString() !== '[object SVGForeignObjectElement]' || navigator.userAgent.indexOf('Opera/') >= 0);
/**
 * True if the client is a Windows.
 */ Client.IS_WIN = typeof window !== 'undefined' && navigator.appVersion.indexOf('Win') > 0;
/**
 * True if the client is a Mac.
 */ Client.IS_MAC = typeof window !== 'undefined' && navigator.appVersion.indexOf('Mac') > 0;
/**
 * True if the client is a Chrome OS.
 */ Client.IS_CHROMEOS = typeof window !== 'undefined' && /\bCrOS\b/.test(navigator.appVersion);
/**
 * True if this device supports touchstart/-move/-end events (Apple iOS,
 * Android, Chromebook and Chrome Browser on touch-enabled devices).
 */ Client.IS_TOUCH = typeof window !== 'undefined' && 'ontouchstart' in document.documentElement;
/**
 * True if this device supports Microsoft pointer events (always false on Macs).
 */ Client.IS_POINTER = typeof window !== 'undefined' && window.PointerEvent != null && !(navigator.appVersion.indexOf('Mac') > 0);
/**
 * True if the documents location does not start with http:// or https://.
 */ Client.IS_LOCAL = typeof window !== 'undefined' && document.location.href.indexOf('http://') < 0 && document.location.href.indexOf('https://') < 0;
/**
 * Returns true if the current browser is supported, that is, if
 * <Client.IS_SVG> is true.
 *
 * Example:
 *
 * ```javascript
 * if (!Client.isBrowserSupported())
 * {
 *   mxUtils.error('Browser is not supported!', 200, false);
 * }
 * ```
 */ Client.isBrowserSupported = ()=>{
    return Client.IS_SVG;
};
const __TURBOPACK__default__export__ = Client;
}}),
"[project]/node_modules/@maxgraph/core/lib/serialization/ObjectCodec.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$ObjectIdentity$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/ObjectIdentity.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Geometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/domUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$MaxXmlRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/MaxXmlRequest.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
/**
 * Generic codec for JavaScript objects that implements a mapping between
 * JavaScript objects and XML nodes that maps each field or element to an
 * attribute or child node, and vice versa.
 *
 * ### Atomic Values
 *
 * Consider the following example.
 *
 * ```javascript
 * const obj = new Object();
 * obj.foo = "Foo";
 * obj.bar = "Bar";
 * ```
 *
 * This object is encoded into an XML node using the following.
 *
 * ```javascript
 * const enc = new Codec();
 * const node = enc.encode(obj);
 * ```
 *
 * The output of the encoding may be viewed using {@link GlobalConfig.logger} as follows.
 *
 * ```javascript
 * GlobalConfig.logger.show();
 * GlobalConfig.logger.debug(mxUtils.getPrettyXml(node));
 * ```
 *
 * Finally, the result of the encoding looks as follows.
 *
 * ```javascript
 * <Object foo="Foo" bar="Bar"/>
 * ```
 *
 * In the above output, the foo and bar fields have been mapped to attributes
 * with the same names, and the name of the constructor was used for the
 * node name.
 *
 * ### Booleans
 *
 * Since booleans are numbers in JavaScript, all boolean values are encoded
 * into 1 for true and 0 for false. The decoder also accepts the string true
 * and false for boolean values.
 *
 * ### Objects
 *
 * The above scheme is applied to all atomic fields, that is, to all non-object
 * fields of an object. For object fields, a child node is created with a
 * special attribute that contains the field name. This special attribute is
 * called "as" and hence, as is a reserved word that should not be used for a
 * field name.
 *
 * Consider the following example where foo is an object and bar is an atomic
 * property of foo.
 *
 * ```javascript
 * const obj = {foo: {bar: "Bar"}};
 * ```
 *
 * This will be mapped to the following XML structure by ObjectCodec.
 *
 * ```javascript
 * <Object>
 *   <Object bar="Bar" as="foo"/>
 * </Object>
 * ```
 *
 * In the above output, the inner Object node contains the as-attribute that
 * specifies the field name in the enclosing object. That is, the field foo was
 * mapped to a child node with an as-attribute that has the value foo.
 *
 * ### Arrays
 *
 * Arrays are special objects that are either associative, in which case each
 * key, value pair is treated like a field where the key is the field name, or
 * they are a sequence of atomic values and objects, which is mapped to a
 * sequence of child nodes. For object elements, the above scheme is applied
 * without the use of the special as-attribute for creating each child. For
 * atomic elements, a special add-node is created with the value stored in the
 * value-attribute.
 *
 * For example, the following array contains one atomic value and one object
 * with a field called bar. Furthermore it contains two associative entries
 * called bar with an atomic value, and foo with an object value.
 *
 * ```javascript
 * const obj = ["Bar", {bar: "Bar"}];
 * obj["bar"] = "Bar";
 * obj["foo"] = {bar: "Bar"};
 * ```
 *
 * This array is represented by the following XML nodes.
 *
 * ```javascript
 * <Array bar="Bar">
 *   <add value="Bar"/>
 *   <Object bar="Bar"/>
 *   <Object bar="Bar" as="foo"/>
 * </Array>
 * ```
 *
 * The Array node name is the name of the constructor. The additional
 * as-attribute in the last child contains the key of the associative entry,
 * whereas the second last child is part of the array sequence and does not
 * have an as-attribute.
 *
 * ### References
 *
 * Objects may be represented as child nodes or attributes with ID values,
 * which are used to lookup the object in a table within {@link Codec}. The
 * {@link isReference} function is in charge of deciding if a specific field should
 * be encoded as a reference or not. Its default implementation returns true if
 * the field name is in {@link idrefs}, an array of strings that is used to configure
 * the {@link ObjectCodec}.
 *
 * Using this approach, the mapping does not guarantee that the referenced
 * object itself exists in the document. The fields that are encoded as
 * references must be carefully chosen to make sure all referenced objects
 * exist in the document, or may be resolved by some other means if necessary.
 *
 * For example, in the case of the graph model all cells are stored in a tree
 * whose root is referenced by the model's root field. A tree is a structure
 * that is well suited for an XML representation, however, the additional edges
 * in the graph model have a reference to a source and target cell, which are
 * also contained in the tree. To handle this case, the source and target cell
 * of an edge are treated as references, whereas the children are treated as
 * objects. Since all cells are contained in the tree and no edge references a
 * source or target outside the tree, this setup makes sure all referenced
 * objects are contained in the document.
 *
 * In the case of a tree structure we must further avoid infinite recursion by
 * ignoring the parent reference of each child. This is done by returning true
 * in {@link isExcluded}, whose default implementation uses the array of excluded
 * fieldnames passed to the ObjectCodec constructor.
 *
 * References are only used for cells in mxGraph. For defining other
 * referencable object types, the codec must be able to work out the ID of an
 * object. This is done by implementing {@link Codec.reference}. For decoding a
 * reference, the XML node with the respective id-attribute is fetched from the
 * document, decoded, and stored in a lookup table for later reference. For
 * looking up external objects, {@link Codec.lookup} may be implemented.
 *
 * ### Expressions
 *
 * For decoding JavaScript expressions, the add-node may be used with a text
 * content that contains the JavaScript expression. For example, the following
 * creates a field called foo in the enclosing object and assigns it the value
 * of {@link Constants.ALIGN.LEFT}.
 *
 * ```javascript
 * <Object>
 *   <add as="foo">Constants.ALIGN.LEFT</add>
 * </Object>
 * ```
 *
 * The resulting object has a field called foo with the value "left". Its XML
 * representation looks as follows.
 *
 * ```javascript
 * <Object foo="left"/>
 * ```
 *
 * This means the expression is evaluated at decoding time and the result of
 * the evaluation is stored in the respective field. Valid expressions are all
 * JavaScript expressions, including function definitions, which are mapped to
 * functions on the resulting object.
 *
 * Expressions are only evaluated if {@link allowEval} is true.
 *
 * @category Serialization with Codecs
 */ class ObjectCodec {
    constructor(template, exclude = [], idrefs = [], mapping = {}){
        this.template = template;
        this.exclude = exclude;
        this.idrefs = idrefs;
        this.mapping = mapping;
        this.reverse = {};
        for(const i in this.mapping){
            this.reverse[this.mapping[i]] = i;
        }
    }
    /**
     * Returns the name used for the node names and lookup of the codec when
     * classes are encoded and nodes are decoded. For classes to work with
     * this the codec registry automatically adds an alias for the classname
     * if that is different from what this returns.
     *
     * The default implementation returns the classname of the template class if no name is set.
     */ getName() {
        return this.name ?? this.template.constructor.name;
    }
    setName(name) {
        this.name = name;
    }
    /**
     * Returns a new instance of the template for this codec.
     */ cloneTemplate() {
        return new this.template.constructor();
    }
    /**
     * Returns the field name for the given attribute name.
     * Looks up the value in the {@link reverse} mapping or returns
     * the input if there is no reverse mapping for the
     * given name.
     */ getFieldName(attributename) {
        if (attributename != null) {
            const mapped = this.reverse[attributename];
            if (mapped != null) {
                attributename = mapped;
            }
        }
        return attributename;
    }
    /**
     * Returns the attribute name for the given field name.
     * Looks up the value in the {@link mapping} or returns
     * the input if there is no mapping for the
     * given name.
     */ getAttributeName(fieldname) {
        if (fieldname != null) {
            const mapped = this.mapping[fieldname];
            if (mapped != null) {
                fieldname = mapped;
            }
        }
        return fieldname;
    }
    /**
     * Returns true if the given attribute is to be ignored by the codec. This
     * implementation returns true if the given field name is in {@link exclude} or
     * if the field name equals {@link ObjectIdentity.FIELD_NAME}.
     *
     * @param obj Object instance that contains the field.
     * @param attr Fieldname of the field.
     * @param value Value of the field.
     * @param write Boolean indicating if the field is being encoded or decoded.
     * Write is true if the field is being encoded, else it is being decoded.
     */ isExcluded(obj, attr, value, write) {
        return attr == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$ObjectIdentity$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].FIELD_NAME || this.exclude.indexOf(attr) >= 0;
    }
    /**
     * Returns true if the given field name is to be treated
     * as a textual reference (ID). This implementation returns
     * true if the given field name is in {@link idrefs}.
     *
     * @param obj Object instance that contains the field.
     * @param attr Field name of the field.
     * @param value Value of the field.
     * @param write Boolean indicating if the field is being encoded or decoded.
     * Write is true if the field is being encoded, else it is being decoded.
     */ isReference(obj, attr, value, write) {
        return this.idrefs.indexOf(attr) >= 0;
    }
    /**
     * Encodes the specified object and returns a node
     * representing then given object. Calls {@link beforeEncode}
     * after creating the node and {@link afterEncode} with the
     * resulting node after processing.
     *
     * Enc is a reference to the calling encoder. It is used
     * to encode complex objects and create references.
     *
     * This implementation encodes all variables of an
     * object according to the following rules:
     *
     * - If the variable name is in {@link exclude} then it is ignored.
     * - If the variable name is in {@link idrefs} then {@link Codec.getId}
     * is used to replace the object with its ID.
     * - The variable name is mapped using {@link mapping}.
     * - If obj is an array and the variable name is numeric
     * (ie. an index) then it is not encoded.
     * - If the value is an object, then the codec is used to
     * create a child node with the variable name encoded into
     * the "as" attribute.
     * - Else, if {@link encodeDefaults} is true or the value differs
     * from the template value, then ...
     * - ... if obj is not an array, then the value is mapped to
     * an attribute.
     * - ... else if obj is an array, the value is mapped to an
     * add child with a value attribute or a text child node,
     * if the value is a function.
     *
     * If no ID exists for a variable in {@link idrefs} or if an object
     * cannot be encoded, a warning is issued using {@link GlobalConfig.logger}.
     *
     * Returns the resulting XML node that represents the given
     * object.
     *
     * @param enc {@link Codec} that controls the encoding process.
     * @param obj Object to be encoded.
     */ encode(enc, obj) {
        const node = enc.document.createElement(this.getName());
        obj = this.beforeEncode(enc, obj, node);
        this.encodeObject(enc, obj, node);
        return this.afterEncode(enc, obj, node);
    }
    /**
     * Encodes the value of each member in then given obj into the given node using
     * {@link encodeValue}.
     *
     * @param enc {@link Codec} that controls the encoding process.
     * @param obj Object to be encoded.
     * @param node XML node that contains the encoded object.
     */ encodeObject(enc, obj, node) {
        enc.setAttribute(node, 'id', enc.getId(obj));
        for(const i in obj){
            let name = i;
            const value = obj[name];
            if (value != null && !this.isExcluded(obj, name, value, true)) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInteger"])(name)) {
                    name = null;
                }
                this.encodeValue(enc, obj, name, value, node);
            }
        }
    }
    /**
     * Converts the given value according to the mappings
     * and id-refs in this codec and uses {@link writeAttribute}
     * to write the attribute into the given node.
     *
     * @param enc {@link Codec} that controls the encoding process.
     * @param obj Object whose property is going to be encoded.
     * @param name XML node that contains the encoded object.
     * @param value Value of the property to be encoded.
     * @param node XML node that contains the encoded object.
     */ encodeValue(enc, obj, name, value, node) {
        if (value != null) {
            // TODO: What is the case where `name` can be `null`? =========================================================================
            if (name != null && this.isReference(obj, name, value, true)) {
                const tmp = enc.getId(value);
                if (tmp == null) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GlobalConfig"].logger.warn(`ObjectCodec.encode: No ID for ${this.getName()}.${name}=${value}`);
                    return; // exit
                }
                value = tmp;
            }
            // Checks if the value is a default value and
            // the name is correct
            if (name == null || enc.encodeDefaults || this.template[name] != value) {
                name = this.getAttributeName(name);
                this.writeAttribute(enc, obj, name, value, node);
            }
        }
    }
    /**
     * Writes the given value into node using {@link writePrimitiveAttribute}
     * or {@link writeComplexAttribute} depending on the type of the value.
     */ writeAttribute(enc, obj, name, value, node) {
        if (typeof value !== 'object' /* primitive type */ ) {
            this.writePrimitiveAttribute(enc, obj, name, value, node);
        } else {
            this.writeComplexAttribute(enc, obj, name, value, node);
        }
    }
    /**
     * Writes the given value as an attribute of the given node.
     */ writePrimitiveAttribute(enc, obj, name, value, node) {
        value = this.convertAttributeToXml(enc, obj, name, value, node); // TODO: params don't seem to match - is this a bug? ===================================
        if (name == null) {
            const child = enc.document.createElement('add');
            if (typeof value === 'function') {
                child.appendChild(enc.document.createTextNode(value));
            } else {
                enc.setAttribute(child, 'value', value);
            }
            node.appendChild(child);
        } else if (typeof value !== 'function') {
            enc.setAttribute(node, name, value);
        }
    }
    /**
     * Writes the given value as a child node of the given node.
     */ writeComplexAttribute(enc, obj, name, value, node) {
        const child = enc.encode(value);
        if (child != null) {
            if (name != null) {
                child.setAttribute('as', name);
            }
            node.appendChild(child);
        } else {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GlobalConfig"].logger.warn(`ObjectCodec.encode: No node for ${this.getName()}.${name}: ${value}`);
        }
    }
    /**
     * Converts true to "1" and false to "0" is {@link isBooleanAttribute} returns true.
     * All other values are not converted.
     *
     * @param enc {@link Codec} that controls the encoding process.
     * @param obj Objec to convert the attribute for.
     * @param name Name of the attribute to be converted.
     * @param value Value to be converted.
     */ convertAttributeToXml(enc, obj, name, value, node) {
        // Makes sure to encode boolean values as numeric values
        if (this.isBooleanAttribute(enc, obj, name, value)) {
            // Checks if the value is true (do not use the value as is, because
            // this would check if the value is not null, so 0 would be true)
            value = value == true ? '1' : '0';
        }
        return value;
    }
    /**
     * Returns true if the given object attribute is a boolean value.
     *
     * @param enc {@link Codec} that controls the encoding process.
     * @param obj Object to convert the attribute for.
     * @param name Name of the attribute to be converted.
     * @param value Value of the attribute to be converted.
     */ isBooleanAttribute(enc, obj, name, value) {
        return typeof value.length === 'undefined' && (value == true || value == false);
    }
    /**
     * Converts booleans and numeric values to the respective types. Values are
     * numeric if {@link isNumericAttribute} returns true.
     *
     * @param dec {@link Codec} that controls the decoding process.
     * @param attr XML attribute to be converted.
     * @param obj Objec to convert the attribute for.
     */ convertAttributeFromXml(dec, attr, obj) {
        let { value } = attr;
        if (this.isNumericAttribute(dec, attr, obj)) {
            value = parseFloat(value);
            if (Number.isNaN(value) || !Number.isFinite(value)) {
                value = 0;
            }
        }
        return value;
    }
    /**
     * Returns true if the given XML attribute is or should be a numeric value.
     *
     * @param dec {@link Codec} that controls the decoding process.
     * @param attr XML attribute to be converted.
     * @param obj Object to convert the attribute for.
     */ isNumericAttribute(dec, attr, obj) {
        // Handles known numeric attributes for generic objects
        return obj.constructor === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] && (attr.name === 'x' || attr.name === 'y' || attr.name === 'width' || attr.name === 'height') || obj.constructor === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] && (attr.name === 'x' || attr.name === 'y') || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumeric"])(attr.value);
    }
    /**
     * Hook for subclassers to pre-process the object before
     * encoding. This returns the input object. The return
     * value of this function is used in {@link encode} to perform
     * the default encoding into the given node.
     *
     * @param enc {@link Codec} that controls the encoding process.
     * @param obj Object to be encoded.
     * @param node XML node to encode the object into.
     */ beforeEncode(enc, obj, node) {
        return obj;
    }
    /**
     * Hook for subclassers to post-process the node
     * for the given object after encoding and return the
     * post-processed node. This implementation returns
     * the input node. The return value of this method
     * is returned to the encoder from {@link encode}.
     *
     * @param enc {@link Codec} that controls the encoding process.
     * @param obj Object to be encoded.
     * @param node XML node that represents the default encoding.
     */ afterEncode(enc, obj, node) {
        return node;
    }
    /**
     * Parses the given node into the object or returns a new object
     * representing the given node.
     *
     * Dec is a reference to the calling decoder. It is used to decode
     * complex objects and resolve references.
     *
     * If a node has an id attribute then the object cache is checked for the
     * object. If the object is not yet in the cache then it is constructed
     * using the constructor of {@link template} and cached in {@link Codec.objects}.
     *
     * This implementation decodes all attributes and childs of a node
     * according to the following rules:
     *
     * - If the variable name is in {@link exclude} or if the attribute name is "id"
     * or "as" then it is ignored.
     * - If the variable name is in {@link idrefs} then {@link Codec.getObject} is used
     * to replace the reference with an object.
     * - The variable name is mapped using a reverse {@link mapping}.
     * - If the value has a child node, then the codec is used to create a
     * child object with the variable name taken from the "as" attribute.
     * - If the object is an array and the variable name is empty then the
     * value or child object is appended to the array.
     * - If an add child has no value or the object is not an array then
     * the child text content is evaluated using {@link eval}.
     *
     * For add nodes where the object is not an array and the variable name
     * is defined, the default mechanism is used, allowing to override/add
     * methods as follows:
     *
     * ```javascript
     * <Object>
     *   <add as="hello"><![CDATA[
     *     function(arg1) {
     *       mxUtils.alert('Hello '+arg1);
     *     }
     *   ]]></add>
     * </Object>
     * ```
     *
     * If no object exists for an ID in {@link idrefs} a warning is issued
     * using {@link GlobalConfig.logger}.
     *
     * Returns the resulting object that represents the given XML node
     * or the object given to the method as the into parameter.
     *
     * @param dec {@link Codec} that controls the decoding process.
     * @param node XML node to be decoded.
     * @param into Optional object to encode the node into.
     */ decode(dec, node, into) {
        const id = node.getAttribute('id');
        let obj = dec.objects[id];
        if (obj == null) {
            obj = into || this.cloneTemplate();
            if (id != null) {
                dec.putObject(id, obj);
            }
        }
        const _node = this.beforeDecode(dec, node, obj);
        this.decodeNode(dec, _node, obj);
        return this.afterDecode(dec, _node, obj);
    }
    /**
     * Calls {@link decodeAttributes} and {@link decodeChildren} for the given node.
     *
     * @param dec {@link Codec} that controls the decoding process.
     * @param node XML node to be decoded.
     * @param obj Objec to encode the node into.
     */ decodeNode(dec, node, obj) {
        if (node != null) {
            this.decodeAttributes(dec, node, obj);
            this.decodeChildren(dec, node, obj);
        }
    }
    /**
     * Decodes all attributes of the given node using {@link decodeAttribute}.
     *
     * @param dec {@link Codec} that controls the decoding process.
     * @param node XML node to be decoded.
     * @param obj Object to encode the node into.
     */ decodeAttributes(dec, node, obj) {
        const attrs = node.attributes;
        if (attrs != null) {
            for(let i = 0; i < attrs.length; i += 1){
                this.decodeAttribute(dec, attrs[i], obj);
            }
        }
    }
    /**
     * Returns true if the given attribute should be ignored. This implementation
     * returns true if the attribute name is "as" or "id".
     *
     * @param dec {@link Codec} that controls the decoding process.
     * @param attr XML attribute to be decoded.
     * @param obj Objec to encode the attribute into.
     */ isIgnoredAttribute(dec, attr, obj) {
        return attr.nodeName === 'as' || attr.nodeName === 'id';
    }
    /**
     * Reads the given attribute into the specified object.
     *
     * @param dec {@link Codec} that controls the decoding process.
     * @param attr XML attribute to be decoded.
     * @param obj Objec to encode the attribute into.
     */ decodeAttribute(dec, attr, obj) {
        if (!this.isIgnoredAttribute(dec, attr, obj)) {
            const name = attr.nodeName;
            // Converts the string true and false to their boolean values.
            // This may require an additional check on the obj to see if
            // the existing field is a boolean value or uninitialized, in
            // which case we may want to convert true and false to a string.
            let value = this.convertAttributeFromXml(dec, attr, obj);
            const fieldname = this.getFieldName(name);
            if (this.isReference(obj, fieldname, value, false)) {
                const tmp = dec.getObject(value);
                if (tmp == null) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GlobalConfig"].logger.warn(`ObjectCodec.decode: No object for ${this.getName()}.${name}=${value}`);
                    return; // exit
                }
                value = tmp;
            }
            if (!this.isExcluded(obj, name, value, false)) {
                obj[name] = value;
            }
        }
    }
    /**
     * Decodes all children of the given node using {@link decodeChild}.
     *
     * @param dec {@link Codec} that controls the decoding process.
     * @param node XML node to be decoded.
     * @param obj Objec to encode the node into.
     */ decodeChildren(dec, node, obj) {
        let child = node.firstChild;
        while(child != null){
            const tmp = child.nextSibling;
            if (child.nodeType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NODETYPE"].ELEMENT && !this.processInclude(dec, child, obj)) {
                this.decodeChild(dec, child, obj);
            }
            child = tmp;
        }
    }
    /**
     * Reads the specified child into the given object.
     *
     * @param dec {@link Codec} that controls the decoding process.
     * @param child XML child element to be decoded.
     * @param obj Objec to encode the node into.
     */ decodeChild(dec, child, obj) {
        const fieldname = this.getFieldName(child.getAttribute('as'));
        if (fieldname == null || !this.isExcluded(obj, fieldname, child, false)) {
            const template = this.getFieldTemplate(obj, fieldname, child);
            let value = null;
            if (child.nodeName === 'add') {
                value = child.getAttribute('value');
                if (value == null && ObjectCodec.allowEval) {
                    value = eval((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getTextContent"])(child));
                }
            } else {
                value = dec.decode(child, template);
            }
            try {
                this.addObjectValue(obj, fieldname, value, template);
            } catch (e) {
                throw new Error(`${e.message} for ${child.nodeName}`);
            }
        }
    }
    /**
     * Returns the template instance for the given field. This returns the
     * value of the field, null if the value is an array or an empty collection
     * if the value is a collection. The value is then used to populate the
     * field for a new instance. For strongly typed languages it may be
     * required to override this to return the correct collection instance
     * based on the encoded child.
     */ getFieldTemplate(obj, fieldname, child) {
        let template = obj[fieldname];
        // Non-empty arrays are replaced completely
        if (template instanceof Array && template.length > 0) {
            template = null;
        }
        return template;
    }
    /**
     * Sets the decoded child node as a value of the given object. If the
     * object is a map, then the value is added with the given field name as a
     * key. If the field name is not empty, then setFieldValue is called or
     * else, if the object is a collection, the value is added to the
     * collection. For strongly typed languages it may be required to
     * override this with the correct code to add an entry to an object.
     */ addObjectValue(obj, fieldname, value, template) {
        if (value != null && value !== template) {
            if (fieldname != null && fieldname.length > 0) {
                obj[fieldname] = value;
            } else {
                obj.push(value);
            }
        }
    }
    /**
     * Returns true if the given node is an include directive and
     * executes the include by decoding the XML document. Returns
     * false if the given node is not an include directive.
     *
     * @param dec {@link Codec} that controls the encoding/decoding process.
     * @param node XML node to be checked.
     * @param into Optional object to pass-thru to the codec.
     */ processInclude(dec, node, into) {
        if (node.nodeName === 'include') {
            const name = node.getAttribute('name');
            if (name != null) {
                try {
                    const xml = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$MaxXmlRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["load"])(name).getDocumentElement();
                    if (xml != null) {
                        dec.decode(xml, into);
                    }
                } catch (e) {
                // ignore
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Hook for subclassers to pre-process the node for
     * the specified object and return the node to be
     * used for further processing by {@link decode}.
     * The object is created based on the template in the
     * calling method and is never null. This implementation
     * returns the input node. The return value of this
     * function is used in {@link decode} to perform
     * the default decoding into the given object.
     *
     * @param dec {@link Codec} that controls the decoding process.
     * @param node XML node to be decoded.
     * @param obj Object to encode the node into.
     */ beforeDecode(dec, node, obj) {
        return node;
    }
    /**
     * Hook for subclassers to post-process the object after
     * decoding. This implementation returns the given object
     * without any changes. The return value of this method
     * is returned to the decoder from {@link decode}.
     *
     * @param dec {@link Codec} that controls the encoding process.
     * @param node XML node to be decoded.
     * @param obj Object that represents the default decoding.
     */ afterDecode(dec, node, obj) {
        return obj;
    }
}
/**
 * Static global switch that specifies if expressions in arrays are allowed.
 *
 * **NOTE**: Enabling this carries a possible security risk.
 * @default false
 */ ObjectCodec.allowEval = false;
const __TURBOPACK__default__export__ = ObjectCodec;
}}),
"[project]/node_modules/@maxgraph/core/lib/serialization/CodecRegistry.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$serialization$2f$ObjectCodec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/serialization/ObjectCodec.js [app-ssr] (ecmascript)");
;
/**
 * Singleton class that acts as a global registry for codecs.
 *
 * ### Adding a Codec
 *
 * 1. Define a default codec with a new instance of the object to be handled.
 *
 *     ```javascript
 *     const codec = new ObjectCodec(new Transactions());
 *     ```
 *
 * 2. Define the functions required for encoding and decoding objects.
 *
 *     ```javascript
 *     codec.encode = function(enc, obj) { ... }
 *     codec.decode = function(dec: Codec, node: Element, into: any): any { ... }
 *     ```
 *
 * 3. Register the codec in the CodecRegistry.
 *
 *     ```javascript
 *     CodecRegistry.register(codec);
 *     ```
 *
 * {@link ObjectCodec.decode} may be used to either create a new instance of an object or to configure an existing instance,
 * in which case the into argument points to the existing object. In this case, we say the codec "configures" the object.
 *
 * @category Serialization with Codecs
 */ class CodecRegistry {
    /**
     * Registers a new codec and associates the name of the codec via {@link ObjectCodec.getName} with the codec object.
     *
     * @param codec ObjectCodec to be registered.
     * @param registerAlias if `true`, register an alias if the codec name doesn't match the name of the constructor of {@link ObjectCodec.template}.
     */ static register(codec, registerAlias = true) {
        if (codec != null) {
            const name = codec.getName();
            CodecRegistry.codecs[name] = codec;
            const classname = codec.template.constructor.name;
            if (registerAlias && classname !== name) {
                CodecRegistry.addAlias(classname, name);
            }
        }
        return codec;
    }
    /**
     * Adds an alias for mapping a classname to a codec name.
     */ static addAlias(classname, codecname) {
        CodecRegistry.aliases[classname] = codecname;
    }
    /**
     * Returns a codec that handles objects that are constructed using the given constructor or a codec registered under the provided name.
     *
     * When passing a name, the method first check if an alias exists for the name, and if so, it uses it to retrieve the codec.
     *
     * If there is no registered Codec, the method tries to register a new Codec using the provided constructor.
     *
     * @param constructorOrName JavaScript constructor function of the Codec or Codec name.
     */ static getCodec(constructorOrName) {
        if (constructorOrName == null) {
            return null;
        }
        let codec = null;
        // Equivalent of calling import { getFunctionName } from '../util/StringUtils';
        let name = typeof constructorOrName === 'string' ? constructorOrName : constructorOrName.name;
        const tmp = CodecRegistry.aliases[name];
        if (tmp != null) {
            name = tmp;
        }
        codec = CodecRegistry.codecs[name] ?? null;
        // Registers a new default codec for the given constructor if no codec has been previously defined.
        if (codec == null) {
            try {
                codec = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$serialization$2f$ObjectCodec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](new constructorOrName());
                CodecRegistry.register(codec);
            } catch (e) {
            // ignore
            }
        }
        return codec;
    }
    /**
     * First try to get the codec by the name it is registered with. If it doesn't exist, use the alias eventually declared
     * to get the codec.
     * @param name the name of the codec that is willing to be retrieved.
     */ static getCodecByName(name) {
        let codec = CodecRegistry.codecs[name];
        if (!codec) {
            const alias = CodecRegistry.aliases[name];
            if (alias) {
                codec = CodecRegistry.codecs[alias];
            }
        }
        return codec ?? null;
    }
}
CodecRegistry.codecs = {};
/**
 * Maps from classnames to codec names.
 */ CodecRegistry.aliases = {};
const __TURBOPACK__default__export__ = CodecRegistry;
}}),
"[project]/node_modules/@maxgraph/core/lib/serialization/Codec.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/Cell.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellPath$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/CellPath.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$serialization$2f$CodecRegistry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/serialization/CodecRegistry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/domUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/StringUtils.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
const createXmlDocument = ()=>{
    return document.implementation.createDocument('', '', null);
};
/**
 * XML codec for JavaScript object graphs. See {@link ObjectCodec} for a
 * description of the general encoding/decoding scheme. This class uses the
 * codecs registered in {@link CodecRegistry} for encoding/decoding each object.
 *
 * ### References
 *
 * In order to resolve references, especially forward references, the Codec
 * constructor must be given the document that contains the referenced
 * elements.
 *
 * ### Examples
 *
 * The following code is used to encode a graph model.
 *
 * ```javascript
 * const encoder = new Codec();
 * const result = encoder.encode(graph.getDataModel());
 * const xml = mxUtils.getXml(result);
 * ```
 *
 * **WARN**: as of version 0.6.0, the codecs provided by maxGraph are no longer registered by default, they **MUST** be registered before
 * performing `encode` or `decode`. For instance, you can use the {@link registerAllCodecs} function (or other related functions)
 * to register the codecs.
 *
 * #### Example
 *
 * Using the code below, an XML document is decoded into an existing model. The
 * document may be obtained using {@link parseXml} for parsing an XML string.
 *
 * ```javascript
 * const doc = xmlUtils.parseXml(xmlString);
 * const codec = new Codec(doc);
 * codec.decode(doc.documentElement, graph.getDataModel());
 * ```
 *
 * #### Example
 *
 * This example demonstrates parsing a list of isolated cells into an existing
 * graph model. Note that the cells do not have a parent reference so they can
 * be added anywhere in the cell hierarchy after parsing.
 *
 * ```javascript
 * const xml = '<root><mxCell id="2" value="Hello," vertex="1"><mxGeometry x="20" y="20" width="80" height="30" as="geometry"/></mxCell><mxCell id="3" value="World!" vertex="1"><mxGeometry x="200" y="150" width="80" height="30" as="geometry"/></mxCell><mxCell id="4" value="" edge="1" source="2" target="3"><mxGeometry relative="1" as="geometry"/></mxCell></root>';
 * const doc = mxUtils.parseXml(xml);
 * const codec = new Codec(doc);
 * let elt = doc.documentElement.firstChild;
 * const cells = [];
 *
 * while (elt != null)
 * {
 *   cells.push(codec.decode(elt));
 *   elt = elt.nextSibling;
 * }
 * graph.addCells(cells);
 * ```
 *
 * #### Example
 *
 * Using the following code, the selection cells of a graph are encoded and the
 * output is displayed in a dialog box.
 *
 * ```javascript
 * const enc = new Codec();
 * const cells = graph.getSelectionCells();
 * const xml = xmlUtils.getPrettyXml(enc.encode(cells));
 * ```
 *
 * Newlines in the XML can be converted to <br>, in which case a '<br>' argument
 * must be passed to {@link getXml} as the second argument.
 *
 * ### Debugging
 *
 * For debugging I/O you can use the following code to get the sequence of
 * encoded objects:
 *
 * ```javascript
 * const oldEncode = encode;
 * encode(obj)
 * {
 *   GlobalConfig.logger.show();
 *   GlobalConfig.logger.debug('Codec.encode: obj=' + StringUtils.getFunctionName(obj.constructor));
 *
 *   return oldEncode.apply(this, arguments);
 * };
 * ```
 *
 * Note that the I/O system adds object codecs for new object automatically. For
 * decoding those objects, the constructor should be written as follows:
 *
 * ```javascript
 * var MyObj(name)
 * {
 *   // ...
 * };
 * ```
 *
 * @category Serialization with Codecs
 */ class Codec {
    constructor(document1 = createXmlDocument()){
        /**
         * Lookup table for resolving IDs to elements.
         */ this.elements = null; // TODO why not { [key: string]: Element } | null
        /**
         * Specifies if default values should be encoded. Default is false.
         */ this.encodeDefaults = false;
        this.document = document1;
        this.objects = {};
    }
    /**
     * Associates the given object with the given ID and returns the given object.
     *
     * @param id ID for the object to be associated with.
     * @param obj Object to be associated with the ID.
     */ putObject(id, obj) {
        this.objects[id] = obj;
        return obj;
    }
    /**
     * Returns the decoded object for the element with the specified ID in
     * {@link document}. If the object is not known then {@link lookup} is used to find an
     * object. If no object is found, then the element with the respective ID
     * from the document is parsed using {@link decode}.
     */ getObject(id) {
        let obj = null;
        if (id != null) {
            obj = this.objects[id];
            if (obj == null) {
                obj = this.lookup(id);
                if (obj == null) {
                    const node = this.getElementById(id);
                    if (node != null) {
                        obj = this.decode(node);
                    }
                }
            }
        }
        return obj;
    }
    /**
     * Hook for subclassers to implement a custom lookup mechanism for cell IDs.
     * This implementation always returns null.
     *
     * Example:
     *
     * ```javascript
     * const codec = new Codec();
     * codec.lookup(id)
     * {
     *   return model.getCell(id);
     * };
     * ```
     *
     * @param id ID of the object to be returned.
     */ lookup(id) {
        return null;
    }
    /**
     * Returns the element with the given ID from {@link document}.
     *
     * @param id String that contains the ID.
     */ getElementById(id) {
        this.updateElements();
        return this.elements[id];
    }
    updateElements() {
        if (this.elements == null) {
            this.elements = {};
            if (this.document.documentElement != null) {
                this.addElement(this.document.documentElement);
            }
        }
    }
    /**
     * Adds the given element to {@link elements} if it has an ID.
     */ addElement(node) {
        if (node.nodeType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NODETYPE"].ELEMENT) {
            const id = node.getAttribute('id');
            if (id != null) {
                if (this.elements[id] == null) {
                    this.elements[id] = node;
                } else if (this.elements[id] !== node) {
                    throw new Error(`${id}: Duplicate ID`);
                }
            }
        }
        let nodeChild = node.firstChild;
        while(nodeChild != null){
            this.addElement(nodeChild);
            nodeChild = nodeChild.nextSibling;
        }
    }
    /**
     * Returns the ID of the specified object. This implementation
     * calls {@link reference} first and if that returns null handles
     * the object as an {@link Cell} by returning their IDs using
     * {@link Cell.getId}. If no ID exists for the given cell, then
     * an on-the-fly ID is generated using {@link CellPath.create}.
     *
     * @param obj Object to return the ID for.
     */ getId(obj) {
        let id = null;
        if (obj != null) {
            id = this.reference(obj);
            if (id == null && obj instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]) {
                id = obj.getId();
                if (id == null) {
                    // Uses an on-the-fly Id
                    id = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellPath$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].create(obj);
                    if (id.length === 0) {
                        id = 'root';
                    }
                }
            }
        }
        return id;
    }
    /**
     * Hook for subclassers to implement a custom method
     * for retrieving IDs from objects. This implementation
     * always returns null.
     *
     * Example:
     *
     * ```javascript
     * const codec = new Codec();
     * codec.reference(obj)
     * {
     *   return obj.getCustomId();
     * };
     * ```
     *
     * @param obj Object whose ID should be returned.
     */ reference(obj) {
        return null;
    }
    /**
     * Encodes the specified object and returns the resulting XML node.
     *
     * @param obj Object to be encoded.
     */ encode(obj) {
        let node = null;
        if (obj != null && obj.constructor != null) {
            const enc = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$serialization$2f$CodecRegistry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].getCodec(obj.constructor);
            if (enc != null) {
                node = enc.encode(this, obj);
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNode"])(obj)) {
                node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["importNode"])(this.document, obj, true);
            } else {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GlobalConfig"].logger.warn(`Codec.encode: No codec for ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getFunctionName"])(obj.constructor)}`);
            }
        }
        return node;
    }
    /**
     * Decodes the given XML node. The optional "into"
     * argument specifies an existing object to be
     * used. If no object is given, then a new instance
     * is created using the constructor from the codec.
     *
     * The function returns the passed in object or
     * the new instance if no object was given.
     *
     * @param node XML node to be decoded.
     * @param into Optional object to be decoded into.
     */ decode(node, into) {
        this.updateElements();
        let obj = null;
        if (node != null && node.nodeType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NODETYPE"].ELEMENT) {
            const dec = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$serialization$2f$CodecRegistry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].getCodecByName(node.nodeName);
            if (dec != null) {
                obj = dec.decode(this, node, into);
            } else {
                obj = node.cloneNode(true);
                obj.removeAttribute('as');
            }
        }
        return obj;
    }
    /**
     * Encoding of cell hierarchies is built-into the core, but
     * is a higher-level function that needs to be explicitely
     * used by the respective object encoders (eg. {@link ModelCodec},
     * {@link ChildChangeCodec} and {@link RootChangeCodec}). This
     * implementation writes the given cell and its children as a
     * (flat) sequence into the given node. The children are not
     * encoded if the optional includeChildren is false. The
     * function is in charge of adding the result into the
     * given node and has no return value.
     *
     * @param cell {@link mxCell} to be encoded.
     * @param node Parent XML node to add the encoded cell into.
     * @param includeChildren Optional boolean indicating if the
     * function should include all descendents. Default is true.
     */ encodeCell(cell, node, includeChildren) {
        const appendMe = this.encode(cell);
        if (appendMe) {
            node.appendChild(appendMe);
        }
        if (includeChildren == null || includeChildren) {
            const childCount = cell.getChildCount();
            for(let i = 0; i < childCount; i += 1){
                this.encodeCell(cell.getChildAt(i), node);
            }
        }
    }
    /**
     * Returns true if the given codec is a cell codec. This uses
     * {@link CellCodec.isCellCodec} to check if the codec is of the
     * given type.
     */ isCellCodec(codec) {
        if (codec != null && 'isCellCodec' in codec) {
            return codec.isCellCodec();
        }
        return false;
    }
    /**
     * Decodes cells that have been encoded using inversion, ie.
     * where the user object is the enclosing node in the XML,
     * and restores the group and graph structure in the cells.
     * Returns a new {@link Cell} instance that represents the
     * given node.
     *
     * @param node XML node that contains the cell data.
     * @param restoreStructures Optional boolean indicating whether
     * the graph structure should be restored by calling insert
     * and insertEdge on the parent and terminals, respectively.
     * Default is `true`.
     */ decodeCell(node, restoreStructures = true) {
        if (node?.nodeType !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NODETYPE"].ELEMENT) {
            return null;
        }
        // Tries to find a codec for the given node name. If that does
        // not return a codec then the node is the user object (an XML node
        // that contains the mxCell, aka inversion).
        let decoder = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$serialization$2f$CodecRegistry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].getCodec(node.nodeName);
        // Tries to find the codec for the cell inside the user object.
        // This assumes all node names inside the user object are either
        // not registered or they correspond to a class for cells.
        if (!this.isCellCodec(decoder)) {
            let child = node.firstChild;
            while(child != null && !this.isCellCodec(decoder)){
                decoder = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$serialization$2f$CodecRegistry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].getCodec(child.nodeName);
                child = child.nextSibling;
            }
        }
        if (!this.isCellCodec(decoder)) {
            decoder = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$serialization$2f$CodecRegistry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].getCodec(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
        }
        const cell = decoder?.decode(this, node);
        if (restoreStructures) {
            this.insertIntoGraph(cell);
        }
        return cell;
    }
    /**
     * Inserts the given cell into its parent and terminal cells.
     */ insertIntoGraph(cell) {
        const { parent } = cell;
        const source = cell.getTerminal(true);
        const target = cell.getTerminal(false);
        // Fixes possible inconsistencies during insert into graph
        cell.setTerminal(null, false);
        cell.setTerminal(null, true);
        cell.parent = null;
        if (parent != null) {
            if (parent === cell) {
                throw new Error(`${parent.id}: Self Reference`);
            } else {
                parent.insert(cell);
            }
        }
        if (source != null) {
            source.insertEdge(cell, true);
        }
        if (target != null) {
            target.insertEdge(cell, false);
        }
    }
    /**
     * Sets the attribute on the specified node to value. This is a
     * helper method that makes sure the attribute and value arguments
     * are not null.
     *
     * @param node XML node to set the attribute for.
     * @param attribute The name of the attribute to be set.
     * @param value New value of the attribute.
     */ setAttribute(node, attribute, value) {
        if (attribute != null && value != null) {
            node.setAttribute(attribute, value);
        }
    }
}
const __TURBOPACK__default__export__ = Codec;
}}),
"[project]/node_modules/@maxgraph/core/lib/gui/MaxPopupMenu.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/domUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventSource.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
/**
 * Basic popup menu.
 *
 * To add a vertical scrollbar to a given submenu, the following code can be used:
 *
 * ```javascript
 * const popupMenu = new MaxPopupMenu(...);
 * const popupMenuShowMenu = popupMenu.showMenu;
 * popupMenu.showMenu = function() {
 *   popupMenuShowMenu.apply(this, []);
 *
 *   this.div.style.overflowY = 'auto';
 *   this.div.style.overflowX = 'hidden';
 *   this.div.style.maxHeight = '160px';
 * };
 * ```
 *
 * ### `InternalEvent.SHOW`
 *
 * Fires after the menu has been shown in {@link popup}.
 */ class MaxPopupMenu extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    constructor(factoryMethod){
        super();
        this.activeRow = null;
        this.eventReceiver = null;
        /**
         * URL of the image to be used for the submenu icon.
         */ this.submenuImage = `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].imageBasePath}/submenu.gif`;
        /**
         * Specifies the zIndex for the popupmenu and its shadow. Default is 1006.
         */ this.zIndex = 10006;
        /**
         * Specifies if popupmenus should be activated by clicking the left mouse
         * button. Default is false.
         */ this.useLeftButtonForPopup = false;
        /**
         * Specifies if events are handled. Default is true.
         */ this.enabled = true;
        /**
         * Contains the number of times <addItem> has been called for a new menu.
         */ this.itemCount = 0;
        /**
         * Specifies if submenus should be expanded on mouseover. Default is false.
         */ this.autoExpand = false;
        /**
         * Specifies if separators should only be added if a menu item follows them.
         * Default is false.
         */ this.smartSeparators = false;
        /**
         * Specifies if any labels should be visible. Default is true.
         */ this.labels = true;
        this.willAddSeparator = false;
        this.containsItems = false;
        if (factoryMethod) {
            this.factoryMethod = factoryMethod;
        }
        // Adds the inner table
        this.table = document.createElement('table');
        this.table.className = 'mxPopupMenu';
        this.tbody = document.createElement('tbody');
        this.table.appendChild(this.tbody);
        // Adds the outer div
        this.div = document.createElement('div');
        this.div.className = 'mxPopupMenu';
        this.div.style.display = 'inline';
        this.div.style.zIndex = String(this.zIndex);
        this.div.appendChild(this.table);
        // Disables the context menu on the outer div
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].disableContextMenu(this.div);
    }
    /**
     * Returns true if events are handled. This implementation
     * returns <enabled>.
     */ isEnabled() {
        return this.enabled;
    }
    /**
     * Enables or disables event handling. This implementation
     * updates <enabled>.
     */ setEnabled(enabled) {
        this.enabled = enabled;
    }
    /**
     * Returns true if the given event is a popupmenu trigger for the optional
     * given cell.
     *
     * @param me {@link MouseEvent} that represents the mouse event.
     */ isPopupTrigger(me) {
        return me.isPopupTrigger() || this.useLeftButtonForPopup && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isLeftMouseButton"])(me.getEvent());
    }
    /**
     * Adds the given item to the given parent item. If no parent item is specified
     * then the item is added to the top-level menu. The return value may be used
     * as the parent argument, ie. as a submenu item. The return value is the table
     * row that represents the item.
     *
     * Paramters:
     *
     * title - String that represents the title of the menu item.
     * image - Optional URL for the image icon.
     * funct - Function associated that takes a mouseup or touchend event.
     * parent - Optional item returned by <addItem>.
     * iconCls - Optional string that represents the CSS class for the image icon.
     * IconsCls is ignored if image is given.
     * enabled - Optional boolean indicating if the item is enabled. Default is true.
     * active - Optional boolean indicating if the menu should implement any event handling.
     * Default is true.
     * noHover - Optional boolean to disable hover state.
     */ addItem(title, image, funct, parent = null, iconCls = null, enabled = true, active = true, noHover = false) {
        parent = parent ?? this;
        this.itemCount++;
        // Smart separators only added if element contains items
        if (parent.willAddSeparator) {
            if (parent.containsItems) {
                this.addSeparator(parent, true);
            }
            parent.willAddSeparator = false;
        }
        parent.containsItems = true;
        const tr = document.createElement('tr');
        tr.className = 'mxPopupMenuItem';
        const col1 = document.createElement('td');
        col1.className = 'mxPopupMenuIcon';
        // Adds the given image into the first column
        if (image) {
            const img = document.createElement('img');
            img.src = image;
            col1.appendChild(img);
        } else if (iconCls) {
            const div = document.createElement('div');
            div.className = iconCls;
            col1.appendChild(div);
        }
        tr.appendChild(col1);
        if (this.labels) {
            const col2 = document.createElement('td');
            col2.className = `mxPopupMenuItem${!enabled ? ' mxDisabled' : ''}`;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["write"])(col2, title);
            col2.align = 'left';
            tr.appendChild(col2);
            const col3 = document.createElement('td');
            col3.className = `mxPopupMenuItem${!enabled ? ' mxDisabled' : ''}`;
            col3.style.paddingRight = '6px';
            col3.style.textAlign = 'right';
            tr.appendChild(col3);
            if (parent.div == null) {
                this.createSubmenu(parent);
            }
        }
        parent.tbody?.appendChild(tr);
        if (active && enabled) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addGestureListeners(tr, (evt)=>{
                this.eventReceiver = tr;
                if (parent && parent.activeRow != tr && parent.activeRow != parent) {
                    if (parent.activeRow && parent.activeRow.div.parentNode) {
                        this.hideSubmenu(parent);
                    }
                    if (tr.div) {
                        this.showSubmenu(parent, tr);
                        parent.activeRow = tr;
                    }
                }
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(evt);
            }, (_evt)=>{
                if (parent && parent.activeRow != tr && parent.activeRow != parent) {
                    if (parent.activeRow && parent.activeRow.div.parentNode) {
                        this.hideSubmenu(parent);
                    }
                    if (this.autoExpand && tr.div) {
                        this.showSubmenu(parent, tr);
                        parent.activeRow = tr;
                    }
                }
                // Sets hover style because TR in IE doesn't have hover
                if (!noHover) {
                    tr.className = 'mxPopupMenuItemHover';
                }
            }, (evt)=>{
                // EventReceiver avoids clicks on a submenu item
                // which has just been shown in the mousedown
                if (this.eventReceiver == tr) {
                    if (parent && parent.activeRow != tr) {
                        this.hideMenu();
                    }
                    funct?.(evt);
                }
                this.eventReceiver = null;
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(evt);
            });
            // Resets hover style because TR in IE doesn't have hover
            if (!noHover) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(tr, 'mouseout', (_evt)=>{
                    tr.className = 'mxPopupMenuItem';
                });
            }
        }
        return tr;
    }
    /**
     * Adds a checkmark to the given menuitem.
     */ addCheckmark(item, img) {
        if (item.firstChild) {
            const td = item.firstChild.nextSibling;
            td.style.backgroundImage = `url('${img}')`;
            td.style.backgroundRepeat = 'no-repeat';
            td.style.backgroundPosition = '2px 50%';
        }
    }
    /**
     * Creates the nodes required to add submenu items inside the given parent
     * item. This is called in <addItem> if a parent item is used for the first
     * time. This adds various DOM nodes and a <submenuImage> to the parent.
     *
     * @param parent An item returned by <addItem>.
     */ createSubmenu(parent) {
        parent.table = document.createElement('table');
        parent.table.className = 'mxPopupMenu';
        parent.tbody = document.createElement('tbody');
        parent.table.appendChild(parent.tbody);
        parent.div = document.createElement('div');
        parent.div.className = 'mxPopupMenu';
        parent.div.style.position = 'absolute';
        parent.div.style.display = 'inline';
        parent.div.style.zIndex = String(this.zIndex);
        parent.div.appendChild(parent.table);
        const img = document.createElement('img');
        img.setAttribute('src', this.submenuImage);
        // Last column of the submenu item in the parent menu
        if (parent.firstChild?.nextSibling?.nextSibling) {
            const td = parent.firstChild.nextSibling.nextSibling;
            td.appendChild(img);
        }
    }
    /**
     * Shows the submenu inside the given parent row.
     */ showSubmenu(parent, row) {
        if (row.div) {
            row.div.style.left = `${parent.div.offsetLeft + row.offsetLeft + row.offsetWidth - 1}px`;
            row.div.style.top = `${parent.div.offsetTop + row.offsetTop}px`;
            document.body.appendChild(row.div);
            // Moves the submenu to the left side if there is no space
            const left = row.div.offsetLeft;
            const width = row.div.offsetWidth;
            const offset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getDocumentScrollOrigin"])(document);
            const b = document.body;
            const d = document.documentElement;
            const right = offset.x + (b.clientWidth || d.clientWidth);
            if (left + width > right) {
                row.div.style.left = `${Math.max(0, parent.div.offsetLeft - width - 6)}px`;
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fit"])(row.div);
        }
    }
    /**
     * Adds a horizontal separator in the given parent item or the top-level menu
     * if no parent is specified.
     *
     * @param parent Optional item returned by <addItem>.
     * @param force Optional boolean to ignore <smartSeparators>. Default is false.
     */ addSeparator(parent = null, force = false) {
        // Defaults to this instance if no parent (submenu) specified, but
        // all the necessary DOM elements are present as in PopupMenuItem
        parent = parent || this;
        if (this.smartSeparators && !force) {
            parent.willAddSeparator = true;
        } else if (parent.tbody) {
            parent.willAddSeparator = false;
            const tr = document.createElement('tr');
            const col1 = document.createElement('td');
            col1.className = 'mxPopupMenuIcon';
            col1.style.padding = '0 0 0 0px';
            tr.appendChild(col1);
            const col2 = document.createElement('td');
            col2.style.padding = '0 0 0 0px';
            col2.setAttribute('colSpan', '2');
            const hr = document.createElement('hr');
            hr.setAttribute('size', '1');
            col2.appendChild(hr);
            tr.appendChild(col2);
            parent.tbody.appendChild(tr);
        }
    }
    /**
     * Shows the popup menu for the given event and cell.
     *
     * Example:
     *
     * ```javascript
     * graph.getPlugin('PanningHandler').popup(x, y, cell, evt)
     * {
     *   mxUtils.alert('Hello, World!');
     * }
     * ```
     */ popup(x, y, cell, evt) {
        if (this.div && this.tbody && this.factoryMethod) {
            this.div.style.left = `${x}px`;
            this.div.style.top = `${y}px`;
            // Removes all child nodes from the existing menu
            while(this.tbody.firstChild){
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].release(this.tbody.firstChild);
                this.tbody.removeChild(this.tbody.firstChild);
            }
            this.itemCount = 0;
            this.factoryMethod(this, cell, evt);
            if (this.itemCount > 0) {
                this.showMenu();
                this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SHOW));
            }
        }
    }
    /**
     * Returns true if the menu is showing.
     */ isMenuShowing() {
        return this.div && this.div.parentNode == document.body;
    }
    /**
     * Shows the menu.
     */ showMenu() {
        // Fits the div inside the viewport
        document.body.appendChild(this.div);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fit"])(this.div);
    }
    /**
     * Removes the menu and all submenus.
     */ hideMenu() {
        if (this.div) {
            this.div.parentNode?.removeChild(this.div);
            this.hideSubmenu(this);
            this.containsItems = false;
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].HIDE));
        }
    }
    /**
     * Removes all submenus inside the given parent.
     *
     * @param parent An item returned by <addItem>.
     */ hideSubmenu(parent) {
        if (parent.activeRow) {
            this.hideSubmenu(parent.activeRow);
            parent.activeRow.div.parentNode?.removeChild(parent.activeRow.div);
            parent.activeRow = null;
        }
    }
    /**
     * Destroys the handler and all its resources and DOM nodes.
     */ destroy() {
        if (this.div) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].release(this.div);
            this.div.parentNode?.removeChild(this.div);
        }
    }
}
const __TURBOPACK__default__export__ = MaxPopupMenu;
}}),

};

//# sourceMappingURL=node_modules_%40maxgraph_core_lib_2e17b8._.js.map