{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/CellsMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { contains, getBoundingBox, getRotatedPoint, intersects, ptSegDistSq, toRadians, } from '../../util/mathUtils';\nimport { getSizeForString, setCellStyleFlags, setCellStyles, } from '../../util/styleUtils';\nimport { ALIGN, DEFAULT_FONTSIZE, DEFAULT_IMAGESIZE, DIRECTION, SHAPE, } from '../../util/Constants';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport Rectangle from '../geometry/Rectangle';\nimport Dictionary from '../../util/Dictionary';\nimport Point from '../geometry/Point';\nimport { htmlEntities } from '../../util/StringUtils';\nimport { cloneCells, getTopmostCells } from '../../util/cellArrayUtils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const CellsMixin = {\n    cellsResizable: true,\n    cellsBendable: true,\n    cellsSelectable: true,\n    cellsDisconnectable: true,\n    autoSizeCells: false,\n    autoSizeCellsOnAdd: false,\n    cellsLocked: false,\n    cellsCloneable: true,\n    cellsDeletable: true,\n    cellsMovable: true,\n    extendParents: true,\n    extendParentsOnAdd: true,\n    extendParentsOnMove: false,\n    getBoundingBox(cells) {\n        let result = null;\n        if (cells.length > 0) {\n            for (const cell of cells) {\n                if (cell.isVertex() || cell.isEdge()) {\n                    const bbox = this.getView().getBoundingBox(this.getView().getState(cell), true);\n                    if (bbox) {\n                        if (!result) {\n                            result = Rectangle.fromRectangle(bbox);\n                        }\n                        else {\n                            result.add(bbox);\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    },\n    removeStateForCell(cell) {\n        for (const child of cell.getChildren()) {\n            this.removeStateForCell(child);\n        }\n        this.getView().invalidate(cell, false, true);\n        this.getView().removeState(cell);\n    },\n    /*****************************************************************************\n     * Group: Cell styles\n     *****************************************************************************/\n    getCurrentCellStyle(cell, ignoreState = false) {\n        const state = ignoreState ? null : this.getView().getState(cell);\n        return state ? state.style : this.getCellStyle(cell);\n    },\n    getCellStyle(cell) {\n        const cellStyle = cell.getStyle();\n        const stylesheet = this.getStylesheet();\n        // Gets the default style for the cell\n        const defaultStyle = cell.isEdge()\n            ? stylesheet.getDefaultEdgeStyle()\n            : stylesheet.getDefaultVertexStyle();\n        // Resolves the stylename using the above as the default\n        const style = this.postProcessCellStyle(stylesheet.getCellStyle(cellStyle, defaultStyle ?? {}));\n        return style;\n    },\n    postProcessCellStyle(style) {\n        if (!style.image) {\n            return style;\n        }\n        const key = style.image;\n        let image = this.getImageFromBundles(key);\n        if (image) {\n            style.image = image;\n        }\n        else {\n            image = key;\n        }\n        // Converts short data uris to normal data uris\n        if (image && image.substring(0, 11) === 'data:image/') {\n            if (image.substring(0, 20) === 'data:image/svg+xml,<') {\n                // Required for FF and IE11\n                image = image.substring(0, 19) + encodeURIComponent(image.substring(19));\n            }\n            else if (image.substring(0, 22) !== 'data:image/svg+xml,%3C') {\n                const comma = image.indexOf(',');\n                // Adds base64 encoding prefix if needed\n                if (comma > 0 && image.substring(comma - 7, comma + 1) !== ';base64,') {\n                    image = `${image.substring(0, comma)};base64,${image.substring(comma + 1)}`;\n                }\n            }\n            style.image = image;\n        }\n        return style;\n    },\n    setCellStyle(style, cells) {\n        cells = cells ?? this.getSelectionCells();\n        this.batchUpdate(() => {\n            for (const cell of cells) {\n                this.getDataModel().setStyle(cell, style);\n            }\n        });\n    },\n    toggleCellStyle(key, defaultValue = false, cell) {\n        cell = cell ?? this.getSelectionCell();\n        return this.toggleCellStyles(key, defaultValue, [cell]);\n    },\n    toggleCellStyles(key, defaultValue = false, cells) {\n        let value = false;\n        cells = cells ?? this.getSelectionCells();\n        if (cells.length > 0) {\n            const style = this.getCurrentCellStyle(cells[0]);\n            value = style[key] ?? defaultValue ? false : true;\n            this.setCellStyles(key, value, cells);\n        }\n        return value;\n    },\n    setCellStyles(key, value, cells) {\n        cells = cells ?? this.getSelectionCells();\n        setCellStyles(this.getDataModel(), cells, key, value);\n    },\n    toggleCellStyleFlags(key, flag, cells) {\n        cells = cells ?? this.getSelectionCells();\n        this.setCellStyleFlags(key, flag, null, cells);\n    },\n    setCellStyleFlags(key, flag, value = null, cells) {\n        cells = cells ?? this.getSelectionCells();\n        if (cells.length > 0) {\n            if (value === null) {\n                const style = this.getCurrentCellStyle(cells[0]);\n                const current = style[key] || 0;\n                value = !((current & flag) === flag);\n            }\n            setCellStyleFlags(this.getDataModel(), cells, key, flag, value);\n        }\n    },\n    /*****************************************************************************\n     * Group: Cell alignment and orientation\n     *****************************************************************************/\n    alignCells(align, cells, param = null) {\n        cells = cells ?? this.getSelectionCells();\n        if (cells.length > 1) {\n            // Finds the required coordinate for the alignment\n            if (param === null) {\n                for (const cell of cells) {\n                    const state = this.getView().getState(cell);\n                    if (state && !cell.isEdge()) {\n                        if (param === null) {\n                            if (align === ALIGN.CENTER) {\n                                param = state.x + state.width / 2;\n                                break;\n                            }\n                            else if (align === ALIGN.RIGHT) {\n                                param = state.x + state.width;\n                            }\n                            else if (align === ALIGN.TOP) {\n                                param = state.y;\n                            }\n                            else if (align === ALIGN.MIDDLE) {\n                                param = state.y + state.height / 2;\n                                break;\n                            }\n                            else if (align === ALIGN.BOTTOM) {\n                                param = state.y + state.height;\n                            }\n                            else {\n                                param = state.x;\n                            }\n                        }\n                        else if (align === ALIGN.RIGHT) {\n                            param = Math.max(param, state.x + state.width);\n                        }\n                        else if (align === ALIGN.TOP) {\n                            param = Math.min(param, state.y);\n                        }\n                        else if (align === ALIGN.BOTTOM) {\n                            param = Math.max(param, state.y + state.height);\n                        }\n                        else {\n                            param = Math.min(param, state.x);\n                        }\n                    }\n                }\n            }\n            // Aligns the cells to the coordinate\n            if (param !== null) {\n                const s = this.getView().scale;\n                this.batchUpdate(() => {\n                    const p = param;\n                    for (const cell of cells) {\n                        const state = this.getView().getState(cell);\n                        if (state != null) {\n                            let geo = cell.getGeometry();\n                            if (geo != null && !cell.isEdge()) {\n                                geo = geo.clone();\n                                if (align === ALIGN.CENTER) {\n                                    geo.x += (p - state.x - state.width / 2) / s;\n                                }\n                                else if (align === ALIGN.RIGHT) {\n                                    geo.x += (p - state.x - state.width) / s;\n                                }\n                                else if (align === ALIGN.TOP) {\n                                    geo.y += (p - state.y) / s;\n                                }\n                                else if (align === ALIGN.MIDDLE) {\n                                    geo.y += (p - state.y - state.height / 2) / s;\n                                }\n                                else if (align === ALIGN.BOTTOM) {\n                                    geo.y += (p - state.y - state.height) / s;\n                                }\n                                else {\n                                    geo.x += (p - state.x) / s;\n                                }\n                                this.resizeCell(cell, geo);\n                            }\n                        }\n                    }\n                    this.fireEvent(new EventObject(InternalEvent.ALIGN_CELLS, { align, cells }));\n                });\n            }\n        }\n        return cells;\n    },\n    /*****************************************************************************\n     * Group: Cell cloning, insertion and removal\n     *****************************************************************************/\n    cloneCell(cell, allowInvalidEdges = false, mapping = {}, keepPosition = false) {\n        return this.cloneCells([cell], allowInvalidEdges, mapping, keepPosition)[0];\n    },\n    cloneCells(cells, allowInvalidEdges = true, mapping = {}, keepPosition = false) {\n        let clones;\n        // Creates a dictionary for fast lookups\n        const dict = new Dictionary();\n        const tmp = [];\n        for (const cell of cells) {\n            dict.put(cell, true);\n            tmp.push(cell);\n        }\n        if (tmp.length > 0) {\n            const { scale } = this.getView();\n            const trans = this.getView().translate;\n            const out = [];\n            clones = cloneCells(cells, true, mapping);\n            for (let i = 0; i < cells.length; i += 1) {\n                const cell = cells[i];\n                const clone = clones[i];\n                if (!allowInvalidEdges &&\n                    clone.isEdge() &&\n                    this.getEdgeValidationError(clone, clone.getTerminal(true), clone.getTerminal(false)) !== null) {\n                    //clones[i] = null;\n                }\n                else {\n                    out.push(clone);\n                    const g = clone.getGeometry();\n                    if (g) {\n                        const state = this.getView().getState(cell);\n                        const parent = cell.getParent();\n                        const pstate = parent ? this.getView().getState(parent) : null;\n                        if (state && pstate) {\n                            const dx = keepPosition ? 0 : pstate.origin.x;\n                            const dy = keepPosition ? 0 : pstate.origin.y;\n                            if (clone.isEdge()) {\n                                const pts = state.absolutePoints;\n                                // Checks if the source is cloned or sets the terminal point\n                                let src = cell.getTerminal(true);\n                                while (src && !dict.get(src)) {\n                                    src = src.getParent();\n                                }\n                                if (!src && pts[0]) {\n                                    g.setTerminalPoint(new Point(pts[0].x / scale - trans.x, pts[0].y / scale - trans.y), true);\n                                }\n                                // Checks if the target is cloned or sets the terminal point\n                                let trg = cell.getTerminal(false);\n                                while (trg && !dict.get(trg)) {\n                                    trg = trg.getParent();\n                                }\n                                const n = pts.length - 1;\n                                const p = pts[n];\n                                if (!trg && p) {\n                                    g.setTerminalPoint(new Point(p.x / scale - trans.x, p.y / scale - trans.y), false);\n                                }\n                                // Translates the control points\n                                const { points } = g;\n                                if (points) {\n                                    for (const point of points) {\n                                        point.x += dx;\n                                        point.y += dy;\n                                    }\n                                }\n                            }\n                            else {\n                                g.translate(dx, dy);\n                            }\n                        }\n                    }\n                }\n            }\n            clones = out;\n        }\n        else {\n            clones = [];\n        }\n        return clones;\n    },\n    addCell(cell, parent = null, index = null, source = null, target = null) {\n        return this.addCells([cell], parent, index, source, target)[0];\n    },\n    addCells(cells, parent = null, index = null, source = null, target = null, absolute = false) {\n        const p = parent ?? this.getDefaultParent();\n        const i = index ?? p.getChildCount();\n        this.batchUpdate(() => {\n            this.cellsAdded(cells, p, i, source, target, absolute, true);\n            this.fireEvent(new EventObject(InternalEvent.ADD_CELLS, { cells, p, i, source, target }));\n        });\n        return cells;\n    },\n    cellsAdded(cells, parent, index, source = null, target = null, absolute = false, constrain = false, extend = true) {\n        this.batchUpdate(() => {\n            const parentState = absolute ? this.getView().getState(parent) : null;\n            const o1 = parentState ? parentState.origin : null;\n            const zero = new Point(0, 0);\n            cells.forEach((cell, i) => {\n                /* Can cells include null values?\n                if (cell == null) {\n                  index--;\n                } else {\n                */\n                const previous = cell.getParent();\n                // Keeps the cell at its absolute location\n                if (o1 && cell !== parent && parent !== previous) {\n                    const oldState = previous ? this.getView().getState(previous) : null;\n                    const o2 = oldState ? oldState.origin : zero;\n                    let geo = cell.getGeometry();\n                    if (geo) {\n                        const dx = o2.x - o1.x;\n                        const dy = o2.y - o1.y;\n                        // FIXME: Cells should always be inserted first before any other edit\n                        // to avoid forward references in sessions.\n                        geo = geo.clone();\n                        geo.translate(dx, dy);\n                        if (!geo.relative && cell.isVertex() && !this.isAllowNegativeCoordinates()) {\n                            geo.x = Math.max(0, geo.x);\n                            geo.y = Math.max(0, geo.y);\n                        }\n                        this.getDataModel().setGeometry(cell, geo);\n                    }\n                }\n                // Decrements all following indices\n                // if cell is already in parent\n                if (parent === previous && index + i > parent.getChildCount()) {\n                    index--;\n                }\n                this.getDataModel().add(parent, cell, index + i);\n                if (this.autoSizeCellsOnAdd) {\n                    this.autoSizeCell(cell, true);\n                }\n                // Extends the parent or constrains the child\n                if ((!extend || extend) &&\n                    this.isExtendParentsOnAdd(cell) &&\n                    this.isExtendParent(cell)) {\n                    this.extendParent(cell);\n                }\n                // Additionally constrains the child after extending the parent\n                if (!constrain || constrain) {\n                    this.constrainChild(cell);\n                }\n                // Sets the source terminal\n                if (source) {\n                    this.cellConnected(cell, source, true);\n                }\n                // Sets the target terminal\n                if (target) {\n                    this.cellConnected(cell, target, false);\n                }\n                /*}*/\n            });\n            this.fireEvent(new EventObject(InternalEvent.CELLS_ADDED, {\n                cells,\n                parent,\n                index,\n                source,\n                target,\n                absolute,\n            }));\n        });\n    },\n    autoSizeCell(cell, recurse = true) {\n        if (recurse) {\n            for (const child of cell.getChildren()) {\n                this.autoSizeCell(child);\n            }\n        }\n        if (cell.isVertex() && this.isAutoSizeCell(cell)) {\n            this.updateCellSize(cell);\n        }\n    },\n    removeCells(cells = null, includeEdges = true) {\n        if (!cells) {\n            cells = this.getDeletableCells(this.getSelectionCells());\n        }\n        // Adds all edges to the cells\n        if (includeEdges) {\n            // FIXME: Remove duplicate cells in result or do not add if\n            // in cells or descendant of cells\n            cells = this.getDeletableCells(this.addAllEdges(cells));\n        }\n        else {\n            cells = cells.slice();\n            // Removes edges that are currently not\n            // visible as those cannot be updated\n            const edges = this.getDeletableCells(this.getAllEdges(cells));\n            const dict = new Dictionary();\n            for (const cell of cells) {\n                dict.put(cell, true);\n            }\n            for (const edge of edges) {\n                if (!this.getView().getState(edge) && !dict.get(edge)) {\n                    dict.put(edge, true);\n                    cells.push(edge);\n                }\n            }\n        }\n        this.batchUpdate(() => {\n            this.cellsRemoved(cells);\n            this.fireEvent(new EventObject(InternalEvent.REMOVE_CELLS, { cells, includeEdges }));\n        });\n        return cells ?? [];\n    },\n    cellsRemoved(cells) {\n        if (cells.length > 0) {\n            const { scale } = this.getView();\n            const tr = this.getView().translate;\n            this.batchUpdate(() => {\n                // Creates hashtable for faster lookup\n                const dict = new Dictionary();\n                for (const cell of cells) {\n                    dict.put(cell, true);\n                }\n                for (const cell of cells) {\n                    // Disconnects edges which are not being removed\n                    const edges = this.getAllEdges([cell]);\n                    const disconnectTerminal = (edge, source) => {\n                        let geo = edge.getGeometry();\n                        if (geo) {\n                            // Checks if terminal is being removed\n                            const terminal = edge.getTerminal(source);\n                            let connected = false;\n                            let tmp = terminal;\n                            while (tmp) {\n                                if (cell === tmp) {\n                                    connected = true;\n                                    break;\n                                }\n                                tmp = tmp.getParent();\n                            }\n                            if (connected) {\n                                geo = geo.clone();\n                                const state = this.getView().getState(edge);\n                                if (state) {\n                                    const pts = state.absolutePoints;\n                                    const n = source ? 0 : pts.length - 1;\n                                    const p = pts[n];\n                                    geo.setTerminalPoint(new Point(p.x / scale - tr.x - state.origin.x, p.y / scale - tr.y - state.origin.y), source);\n                                }\n                                else if (terminal) {\n                                    // Fallback to center of terminal if routing\n                                    // points are not available to add new point\n                                    // KNOWN: Should recurse to find parent offset\n                                    // of edge for nested groups but invisible edges\n                                    // should be removed in removeCells step\n                                    const tstate = this.getView().getState(terminal);\n                                    if (tstate) {\n                                        geo.setTerminalPoint(new Point(tstate.getCenterX() / scale - tr.x, tstate.getCenterY() / scale - tr.y), source);\n                                    }\n                                }\n                                this.getDataModel().setGeometry(edge, geo);\n                                this.getDataModel().setTerminal(edge, null, source);\n                            }\n                        }\n                    };\n                    for (const edge of edges) {\n                        if (!dict.get(edge)) {\n                            dict.put(edge, true);\n                            disconnectTerminal(edge, true);\n                            disconnectTerminal(edge, false);\n                        }\n                    }\n                    this.getDataModel().remove(cell);\n                }\n                this.fireEvent(new EventObject(InternalEvent.CELLS_REMOVED, { cells }));\n            });\n        }\n    },\n    /*****************************************************************************\n     * Group: Cell visibility\n     *****************************************************************************/\n    toggleCells(show = false, cells, includeEdges = true) {\n        cells = cells ?? this.getSelectionCells();\n        // Adds all connected edges recursively\n        if (includeEdges) {\n            cells = this.addAllEdges(cells);\n        }\n        this.batchUpdate(() => {\n            this.cellsToggled(cells, show);\n            this.fireEvent(new EventObject(InternalEvent.TOGGLE_CELLS, { show, cells, includeEdges }));\n        });\n        return cells;\n    },\n    cellsToggled(cells, show = false) {\n        if (cells.length > 0) {\n            this.batchUpdate(() => {\n                for (const cell of cells) {\n                    this.getDataModel().setVisible(cell, show);\n                }\n            });\n        }\n    },\n    /*****************************************************************************\n     * Group: Cell sizing\n     *****************************************************************************/\n    updateCellSize(cell, ignoreChildren = false) {\n        this.batchUpdate(() => {\n            this.cellSizeUpdated(cell, ignoreChildren);\n            this.fireEvent(new EventObject(InternalEvent.UPDATE_CELL_SIZE, { cell, ignoreChildren }));\n        });\n        return cell;\n    },\n    cellSizeUpdated(cell, ignoreChildren = false) {\n        this.batchUpdate(() => {\n            const size = this.getPreferredSizeForCell(cell);\n            let geo = cell.getGeometry();\n            if (size && geo) {\n                const collapsed = cell.isCollapsed();\n                geo = geo.clone();\n                if (this.isSwimlane(cell)) {\n                    const style = this.getCellStyle(cell);\n                    const cellStyle = cell.getStyle();\n                    if (style.horizontal ?? true) {\n                        cellStyle.startSize = size.height + 8;\n                        if (collapsed) {\n                            geo.height = size.height + 8;\n                        }\n                        geo.width = size.width;\n                    }\n                    else {\n                        cellStyle.startSize = size.width + 8;\n                        if (collapsed) {\n                            geo.width = size.width + 8;\n                        }\n                        geo.height = size.height;\n                    }\n                    this.getDataModel().setStyle(cell, cellStyle);\n                }\n                else {\n                    const state = this.getView().createState(cell);\n                    const align = state.style.align ?? ALIGN.CENTER;\n                    if (align === ALIGN.RIGHT) {\n                        geo.x += geo.width - size.width;\n                    }\n                    else if (align === ALIGN.CENTER) {\n                        geo.x += Math.round((geo.width - size.width) / 2);\n                    }\n                    const valign = state.getVerticalAlign();\n                    if (valign === ALIGN.BOTTOM) {\n                        geo.y += geo.height - size.height;\n                    }\n                    else if (valign === ALIGN.MIDDLE) {\n                        geo.y += Math.round((geo.height - size.height) / 2);\n                    }\n                    geo.width = size.width;\n                    geo.height = size.height;\n                }\n                if (!ignoreChildren && !collapsed) {\n                    const bounds = this.getView().getBounds(cell.getChildren());\n                    if (bounds != null) {\n                        const tr = this.getView().translate;\n                        const { scale } = this.getView();\n                        const width = (bounds.x + bounds.width) / scale - geo.x - tr.x;\n                        const height = (bounds.y + bounds.height) / scale - geo.y - tr.y;\n                        geo.width = Math.max(geo.width, width);\n                        geo.height = Math.max(geo.height, height);\n                    }\n                }\n                this.cellsResized([cell], [geo], false);\n            }\n        });\n    },\n    getPreferredSizeForCell(cell, textWidth = null) {\n        let result = null;\n        const state = this.getView().createState(cell);\n        const { style } = state;\n        if (!cell.isEdge()) {\n            const fontSize = style.fontSize || DEFAULT_FONTSIZE;\n            let dx = 0;\n            let dy = 0;\n            // Adds dimension of image if shape is a label\n            if (state.getImageSrc() || style.image) {\n                if (style.shape === SHAPE.LABEL) {\n                    if (style.verticalAlign === ALIGN.MIDDLE) {\n                        dx += style.imageWidth || DEFAULT_IMAGESIZE;\n                    }\n                    if (style.align !== ALIGN.CENTER) {\n                        dy += style.imageHeight || DEFAULT_IMAGESIZE;\n                    }\n                }\n            }\n            // Adds spacings\n            dx += 2 * (style.spacing || 0);\n            dx += style.spacingLeft || 0;\n            dx += style.spacingRight || 0;\n            dy += 2 * (style.spacing || 0);\n            dy += style.spacingTop || 0;\n            dy += style.spacingBottom || 0;\n            // Add spacing for collapse/expand icon\n            // LATER: Check alignment and use constants\n            // for image spacing\n            const image = this.getFoldingImage(state);\n            if (image) {\n                dx += image.width + 8;\n            }\n            // Adds space for label\n            let value = this.getCellRenderer().getLabelValue(state);\n            if (value && value.length > 0) {\n                if (!this.isHtmlLabel(state.cell)) {\n                    value = htmlEntities(value, false);\n                }\n                value = value.replace(/\\n/g, '<br>');\n                const size = getSizeForString(value, fontSize, style.fontFamily, textWidth, style.fontStyle);\n                let width = size.width + dx;\n                let height = size.height + dy;\n                if (!(style.horizontal ?? true)) {\n                    const tmp = height;\n                    height = width;\n                    width = tmp;\n                }\n                if (this.isGridEnabled()) {\n                    width = this.snap(width + this.getGridSize() / 2);\n                    height = this.snap(height + this.getGridSize() / 2);\n                }\n                result = new Rectangle(0, 0, width, height);\n            }\n            else {\n                const gs2 = 4 * this.getGridSize();\n                result = new Rectangle(0, 0, gs2, gs2);\n            }\n        }\n        return result;\n    },\n    resizeCell(cell, bounds, recurse = false) {\n        return this.resizeCells([cell], [bounds], recurse)[0];\n    },\n    resizeCells(cells, bounds, recurse) {\n        recurse = recurse ?? this.isRecursiveResize();\n        this.batchUpdate(() => {\n            const prev = this.cellsResized(cells, bounds, recurse);\n            this.fireEvent(new EventObject(InternalEvent.RESIZE_CELLS, { cells, bounds, prev }));\n        });\n        return cells;\n    },\n    cellsResized(cells, bounds, recurse = false) {\n        const prev = [];\n        if (cells.length === bounds.length) {\n            this.batchUpdate(() => {\n                cells.forEach((cell, i) => {\n                    prev.push(this.cellResized(cell, bounds[i], false, recurse));\n                    if (this.isExtendParent(cell)) {\n                        this.extendParent(cell);\n                    }\n                    this.constrainChild(cell);\n                });\n                if (this.isResetEdgesOnResize()) {\n                    this.resetEdges(cells);\n                }\n                this.fireEvent(new EventObject(InternalEvent.CELLS_RESIZED, { cells, bounds, prev }));\n            });\n        }\n        return prev;\n    },\n    cellResized(cell, bounds, ignoreRelative = false, recurse = false) {\n        const prev = cell.getGeometry();\n        if (prev &&\n            (prev.x !== bounds.x ||\n                prev.y !== bounds.y ||\n                prev.width !== bounds.width ||\n                prev.height !== bounds.height)) {\n            const geo = prev.clone();\n            if (!ignoreRelative && geo.relative) {\n                const { offset } = geo;\n                if (offset) {\n                    offset.x += bounds.x - geo.x;\n                    offset.y += bounds.y - geo.y;\n                }\n            }\n            else {\n                geo.x = bounds.x;\n                geo.y = bounds.y;\n            }\n            geo.width = bounds.width;\n            geo.height = bounds.height;\n            if (!geo.relative && cell.isVertex() && !this.isAllowNegativeCoordinates()) {\n                geo.x = Math.max(0, geo.x);\n                geo.y = Math.max(0, geo.y);\n            }\n            this.batchUpdate(() => {\n                if (recurse) {\n                    this.resizeChildCells(cell, geo);\n                }\n                this.getDataModel().setGeometry(cell, geo);\n                this.constrainChildCells(cell);\n            });\n        }\n        return prev;\n    },\n    resizeChildCells(cell, newGeo) {\n        const geo = cell.getGeometry();\n        if (geo) {\n            const dx = geo.width !== 0 ? newGeo.width / geo.width : 1;\n            const dy = geo.height !== 0 ? newGeo.height / geo.height : 1;\n            for (const child of cell.getChildren()) {\n                this.scaleCell(child, dx, dy, true);\n            }\n        }\n    },\n    constrainChildCells(cell) {\n        for (const child of cell.getChildren()) {\n            this.constrainChild(child);\n        }\n    },\n    scaleCell(cell, dx, dy, recurse = false) {\n        let geo = cell.getGeometry();\n        if (geo) {\n            const style = this.getCurrentCellStyle(cell);\n            geo = geo.clone();\n            // Stores values for restoring based on style\n            const { x } = geo;\n            const { y } = geo;\n            const w = geo.width;\n            const h = geo.height;\n            geo.scale(dx, dy, style.aspect === 'fixed');\n            if (style.resizeWidth) {\n                geo.width = w * dx;\n            }\n            else if (!style.resizeWidth) {\n                geo.width = w;\n            }\n            if (style.resizeHeight) {\n                geo.height = h * dy;\n            }\n            else if (!style.resizeHeight) {\n                geo.height = h;\n            }\n            if (!this.isCellMovable(cell)) {\n                geo.x = x;\n                geo.y = y;\n            }\n            if (!this.isCellResizable(cell)) {\n                geo.width = w;\n                geo.height = h;\n            }\n            if (cell.isVertex()) {\n                this.cellResized(cell, geo, true, recurse);\n            }\n            else {\n                this.getDataModel().setGeometry(cell, geo);\n            }\n        }\n    },\n    extendParent(cell) {\n        const parent = cell.getParent();\n        let p = parent ? parent.getGeometry() : null;\n        if (parent && p && !parent.isCollapsed()) {\n            const geo = cell.getGeometry();\n            if (geo &&\n                !geo.relative &&\n                (p.width < geo.x + geo.width || p.height < geo.y + geo.height)) {\n                p = p.clone();\n                p.width = Math.max(p.width, geo.x + geo.width);\n                p.height = Math.max(p.height, geo.y + geo.height);\n                this.cellsResized([parent], [p], false);\n            }\n        }\n    },\n    // *************************************************************************************\n    // Group: Cell moving\n    // *************************************************************************************\n    importCells(cells, dx, dy, target = null, evt = null, mapping = {}) {\n        return this.moveCells(cells, dx, dy, true, target, evt, mapping);\n    },\n    moveCells(cells, dx = 0, dy = 0, clone = false, target = null, evt = null, mapping = {}) {\n        if (dx !== 0 || dy !== 0 || clone || target) {\n            // Removes descendants with ancestors in cells to avoid multiple moving\n            cells = getTopmostCells(cells);\n            const origCells = cells;\n            this.batchUpdate(() => {\n                // Faster cell lookups to remove relative edge labels with selected\n                // terminals to avoid explicit and implicit move at same time\n                const dict = new Dictionary();\n                for (const cell of cells) {\n                    dict.put(cell, true);\n                }\n                const isSelected = (cell) => {\n                    while (cell) {\n                        if (dict.get(cell)) {\n                            return true;\n                        }\n                        cell = cell.getParent();\n                    }\n                    return false;\n                };\n                // Removes relative edge labels with selected terminals\n                const checked = [];\n                for (const cell of cells) {\n                    const geo = cell.getGeometry();\n                    const parent = cell.getParent();\n                    if (!geo ||\n                        !geo.relative ||\n                        (parent && !parent.isEdge()) ||\n                        (parent &&\n                            !isSelected(parent.getTerminal(true)) &&\n                            !isSelected(parent.getTerminal(false)))) {\n                        checked.push(cell);\n                    }\n                }\n                cells = checked;\n                if (clone) {\n                    cells = this.cloneCells(cells, this.isCloneInvalidEdges(), mapping);\n                    if (!target) {\n                        target = this.getDefaultParent();\n                    }\n                }\n                // FIXME: Cells should always be inserted first before any other edit\n                // to avoid forward references in sessions.\n                // Need to disable allowNegativeCoordinates if target not null to\n                // allow for temporary negative numbers until cellsAdded is called.\n                const previous = this.isAllowNegativeCoordinates();\n                if (target) {\n                    this.setAllowNegativeCoordinates(true);\n                }\n                this.cellsMoved(cells, dx, dy, !clone && this.isDisconnectOnMove() && this.isAllowDanglingEdges(), !target, this.isExtendParentsOnMove() && !target);\n                this.setAllowNegativeCoordinates(previous);\n                if (target) {\n                    const index = target.getChildCount();\n                    this.cellsAdded(cells, target, index, null, null, true);\n                    // Restores parent edge on cloned edge labels\n                    if (clone) {\n                        cells.forEach((cell, i) => {\n                            const geo = cell.getGeometry();\n                            const parent = origCells[i].getParent();\n                            if (geo &&\n                                geo.relative &&\n                                parent &&\n                                parent.isEdge() &&\n                                this.getDataModel().contains(parent)) {\n                                this.getDataModel().add(parent, cell);\n                            }\n                        });\n                    }\n                }\n                // Dispatches a move event\n                this.fireEvent(new EventObject(InternalEvent.MOVE_CELLS, {\n                    cells,\n                    dx,\n                    dy,\n                    clone,\n                    target,\n                    event: evt,\n                }));\n            });\n        }\n        return cells;\n    },\n    cellsMoved(cells, dx, dy, disconnect = false, constrain = false, extend = false) {\n        if (dx !== 0 || dy !== 0) {\n            this.batchUpdate(() => {\n                if (disconnect) {\n                    this.disconnectGraph(cells);\n                }\n                for (const cell of cells) {\n                    this.translateCell(cell, dx, dy);\n                    if (extend && this.isExtendParent(cell)) {\n                        this.extendParent(cell);\n                    }\n                    else if (constrain) {\n                        this.constrainChild(cell);\n                    }\n                }\n                if (this.isResetEdgesOnMove()) {\n                    this.resetEdges(cells);\n                }\n                this.fireEvent(new EventObject(InternalEvent.CELLS_MOVED, { cells, dx, dy, disconnect }));\n            });\n        }\n    },\n    translateCell(cell, dx, dy) {\n        let geometry = cell.getGeometry();\n        if (geometry) {\n            geometry = geometry.clone();\n            geometry.translate(dx, dy);\n            if (!geometry.relative && cell.isVertex() && !this.isAllowNegativeCoordinates()) {\n                geometry.x = Math.max(0, geometry.x);\n                geometry.y = Math.max(0, geometry.y);\n            }\n            if (geometry.relative && !cell.isEdge()) {\n                const parent = cell.getParent();\n                let angle = 0;\n                if (parent.isVertex()) {\n                    const style = this.getCurrentCellStyle(parent);\n                    angle = style.rotation ?? 0;\n                }\n                if (angle !== 0) {\n                    const rad = toRadians(-angle);\n                    const cos = Math.cos(rad);\n                    const sin = Math.sin(rad);\n                    const pt = getRotatedPoint(new Point(dx, dy), cos, sin, new Point(0, 0));\n                    dx = pt.x;\n                    dy = pt.y;\n                }\n                if (!geometry.offset) {\n                    geometry.offset = new Point(dx, dy);\n                }\n                else {\n                    geometry.offset.x = geometry.offset.x + dx;\n                    geometry.offset.y = geometry.offset.y + dy;\n                }\n            }\n            this.getDataModel().setGeometry(cell, geometry);\n        }\n    },\n    getCellContainmentArea(cell) {\n        if (!cell.isEdge()) {\n            const parent = cell.getParent();\n            if (parent && parent !== this.getDefaultParent()) {\n                const g = parent.getGeometry();\n                if (g) {\n                    let x = 0;\n                    let y = 0;\n                    let w = g.width;\n                    let h = g.height;\n                    if (this.isSwimlane(parent)) {\n                        const size = this.getStartSize(parent);\n                        const style = this.getCurrentCellStyle(parent);\n                        const dir = style.direction ?? DIRECTION.EAST;\n                        const flipH = style.flipH ?? false;\n                        const flipV = style.flipV ?? false;\n                        if (dir === DIRECTION.SOUTH || dir === DIRECTION.NORTH) {\n                            const tmp = size.width;\n                            size.width = size.height;\n                            size.height = tmp;\n                        }\n                        if ((dir === DIRECTION.EAST && !flipV) ||\n                            (dir === DIRECTION.NORTH && !flipH) ||\n                            (dir === DIRECTION.WEST && flipV) ||\n                            (dir === DIRECTION.SOUTH && flipH)) {\n                            x = size.width;\n                            y = size.height;\n                        }\n                        w -= size.width;\n                        h -= size.height;\n                    }\n                    return new Rectangle(x, y, w, h);\n                }\n            }\n        }\n        return null;\n    },\n    constrainChild(cell, sizeFirst = true) {\n        let geo = cell.getGeometry();\n        if (geo && (this.isConstrainRelativeChildren() || !geo.relative)) {\n            const parent = cell.getParent();\n            let max = this.getMaximumGraphBounds();\n            // Finds parent offset\n            if (max && parent) {\n                const off = this.getBoundingBoxFromGeometry([parent], false);\n                if (off) {\n                    max = Rectangle.fromRectangle(max);\n                    max.x -= off.x;\n                    max.y -= off.y;\n                }\n            }\n            if (this.isConstrainChild(cell)) {\n                let tmp = this.getCellContainmentArea(cell);\n                if (tmp) {\n                    const overlap = this.getOverlap(cell);\n                    if (overlap > 0) {\n                        tmp = Rectangle.fromRectangle(tmp);\n                        tmp.x -= tmp.width * overlap;\n                        tmp.y -= tmp.height * overlap;\n                        tmp.width += 2 * tmp.width * overlap;\n                        tmp.height += 2 * tmp.height * overlap;\n                    }\n                    // Find the intersection between max and tmp\n                    if (!max) {\n                        max = tmp;\n                    }\n                    else {\n                        max = Rectangle.fromRectangle(max);\n                        max.intersect(tmp);\n                    }\n                }\n            }\n            if (max) {\n                const cells = [cell];\n                if (!cell.isCollapsed()) {\n                    const desc = cell.getDescendants();\n                    for (const descItem of desc) {\n                        if (descItem.isVisible()) {\n                            cells.push(descItem);\n                        }\n                    }\n                }\n                const bbox = this.getBoundingBoxFromGeometry(cells, false);\n                if (bbox) {\n                    geo = geo.clone();\n                    // Cumulative horizontal movement\n                    let dx = 0;\n                    if (geo.width > max.width) {\n                        dx = geo.width - max.width;\n                        geo.width -= dx;\n                    }\n                    if (bbox.x + bbox.width > max.x + max.width) {\n                        dx -= bbox.x + bbox.width - max.x - max.width - dx;\n                    }\n                    // Cumulative vertical movement\n                    let dy = 0;\n                    if (geo.height > max.height) {\n                        dy = geo.height - max.height;\n                        geo.height -= dy;\n                    }\n                    if (bbox.y + bbox.height > max.y + max.height) {\n                        dy -= bbox.y + bbox.height - max.y - max.height - dy;\n                    }\n                    if (bbox.x < max.x) {\n                        dx -= bbox.x - max.x;\n                    }\n                    if (bbox.y < max.y) {\n                        dy -= bbox.y - max.y;\n                    }\n                    if (dx !== 0 || dy !== 0) {\n                        if (geo.relative) {\n                            // Relative geometries are moved via absolute offset\n                            if (!geo.offset) {\n                                geo.offset = new Point();\n                            }\n                            geo.offset.x += dx;\n                            geo.offset.y += dy;\n                        }\n                        else {\n                            geo.x += dx;\n                            geo.y += dy;\n                        }\n                    }\n                    this.getDataModel().setGeometry(cell, geo);\n                }\n            }\n        }\n    },\n    /*****************************************************************************\n     * Group: Cell retrieval\n     *****************************************************************************/\n    getChildCells(parent, vertices = false, edges = false) {\n        parent = parent ?? this.getDefaultParent();\n        const cells = parent.getChildCells(vertices, edges);\n        const result = [];\n        // Filters out the non-visible child cells\n        for (const cell of cells) {\n            if (cell.isVisible()) {\n                result.push(cell);\n            }\n        }\n        return result;\n    },\n    getCellAt(x, y, parent = null, vertices = true, edges = true, ignoreFn = null) {\n        if (!parent) {\n            parent = this.getCurrentRoot();\n            if (!parent) {\n                parent = this.getDataModel().getRoot();\n            }\n        }\n        if (parent) {\n            const childCount = parent.getChildCount();\n            for (let i = childCount - 1; i >= 0; i--) {\n                const cell = parent.getChildAt(i);\n                const result = this.getCellAt(x, y, cell, vertices, edges, ignoreFn);\n                if (result) {\n                    return result;\n                }\n                if (cell.isVisible() &&\n                    ((edges && cell.isEdge()) || (vertices && cell.isVertex()))) {\n                    const state = this.getView().getState(cell);\n                    if (state &&\n                        (!ignoreFn || !ignoreFn(state, x, y)) &&\n                        this.intersects(state, x, y)) {\n                        return cell;\n                    }\n                }\n            }\n        }\n        return null;\n    },\n    getCells(x, y, width, height, parent = null, result = [], intersection = null, ignoreFn = null, includeDescendants = false) {\n        if (width > 0 || height > 0 || intersection) {\n            const model = this.getDataModel();\n            const right = x + width;\n            const bottom = y + height;\n            if (!parent) {\n                parent = this.getCurrentRoot();\n                if (!parent) {\n                    parent = model.getRoot();\n                }\n            }\n            if (parent) {\n                for (const cell of parent.getChildren()) {\n                    const state = this.getView().getState(cell);\n                    if (state && cell.isVisible() && (!ignoreFn || !ignoreFn(state))) {\n                        const deg = state.style.rotation ?? 0;\n                        let box = state; // TODO: CHECK ME!!!! ==========================================================\n                        if (deg !== 0) {\n                            box = getBoundingBox(box, deg);\n                        }\n                        const hit = (intersection && cell.isVertex() && intersects(intersection, box)) ||\n                            (!intersection &&\n                                (cell.isEdge() || cell.isVertex()) &&\n                                box.x >= x &&\n                                box.y + box.height <= bottom &&\n                                box.y >= y &&\n                                box.x + box.width <= right);\n                        if (hit) {\n                            result.push(cell);\n                        }\n                        if (!hit || includeDescendants) {\n                            this.getCells(x, y, width, height, cell, result, intersection, ignoreFn, includeDescendants);\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    },\n    getCellsBeyond(x0, y0, parent = null, rightHalfpane = false, bottomHalfpane = false) {\n        const result = [];\n        if (rightHalfpane || bottomHalfpane) {\n            if (!parent) {\n                parent = this.getDefaultParent();\n            }\n            if (parent) {\n                for (const child of parent.getChildren()) {\n                    const state = this.getView().getState(child);\n                    if (child.isVisible() && state) {\n                        if ((!rightHalfpane || state.x >= x0) && (!bottomHalfpane || state.y >= y0)) {\n                            result.push(child);\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    },\n    intersects(state, x, y) {\n        const pts = state.absolutePoints;\n        if (pts.length > 0) {\n            const t2 = this.getEventTolerance() * this.getEventTolerance();\n            let pt = pts[0];\n            for (let i = 1; i < pts.length; i += 1) {\n                const next = pts[i];\n                if (pt && next) {\n                    const dist = ptSegDistSq(pt.x, pt.y, next.x, next.y, x, y);\n                    if (dist <= t2) {\n                        return true;\n                    }\n                }\n                pt = next;\n            }\n        }\n        else {\n            const alpha = toRadians(state.style.rotation ?? 0);\n            if (alpha !== 0) {\n                const cos = Math.cos(-alpha);\n                const sin = Math.sin(-alpha);\n                const cx = new Point(state.getCenterX(), state.getCenterY());\n                const pt = getRotatedPoint(new Point(x, y), cos, sin, cx);\n                x = pt.x;\n                y = pt.y;\n            }\n            if (contains(state, x, y)) {\n                return true;\n            }\n        }\n        return false;\n    },\n    isValidAncestor(cell, parent, recurse = false) {\n        return recurse ? parent.isAncestor(cell) : cell.getParent() === parent;\n    },\n    /*****************************************************************************\n     * Group: Graph behaviour\n     *****************************************************************************/\n    isCellLocked(cell) {\n        const geometry = cell.getGeometry();\n        return this.isCellsLocked() || (!!geometry && cell.isVertex() && geometry.relative);\n    },\n    isCellsLocked() {\n        return this.cellsLocked;\n    },\n    setCellsLocked(value) {\n        this.cellsLocked = value;\n    },\n    getCloneableCells(cells) {\n        return this.getDataModel().filterCells(cells, (cell) => {\n            return this.isCellCloneable(cell);\n        });\n    },\n    isCellCloneable(cell) {\n        return this.isCellsCloneable() && (this.getCurrentCellStyle(cell).cloneable ?? true);\n    },\n    isCellsCloneable() {\n        return this.cellsCloneable;\n    },\n    setCellsCloneable(value) {\n        this.cellsCloneable = value;\n    },\n    getExportableCells(cells) {\n        return this.getDataModel().filterCells(cells, (cell) => {\n            return this.canExportCell(cell);\n        });\n    },\n    canExportCell(_cell = null) {\n        return this.isExportEnabled();\n    },\n    getImportableCells(cells) {\n        return this.getDataModel().filterCells(cells, (cell) => {\n            return this.canImportCell(cell);\n        });\n    },\n    canImportCell(cell = null) {\n        return this.isImportEnabled();\n    },\n    isCellSelectable(_cell) {\n        return this.isCellsSelectable();\n    },\n    isCellsSelectable() {\n        return this.cellsSelectable;\n    },\n    setCellsSelectable(value) {\n        this.cellsSelectable = value;\n    },\n    getDeletableCells(cells) {\n        return this.getDataModel().filterCells(cells, (cell) => {\n            return this.isCellDeletable(cell);\n        });\n    },\n    isCellDeletable(cell) {\n        return this.isCellsDeletable() && (this.getCurrentCellStyle(cell).deletable ?? true);\n    },\n    isCellsDeletable() {\n        return this.cellsDeletable;\n    },\n    setCellsDeletable(value) {\n        this.cellsDeletable = value;\n    },\n    isCellRotatable(cell) {\n        return this.getCurrentCellStyle(cell).rotatable ?? true;\n    },\n    getMovableCells(cells) {\n        return this.getDataModel().filterCells(cells, (cell) => {\n            return this.isCellMovable(cell);\n        });\n    },\n    isCellMovable(cell) {\n        return (this.isCellsMovable() &&\n            !this.isCellLocked(cell) &&\n            (this.getCurrentCellStyle(cell).movable ?? true));\n    },\n    isCellsMovable() {\n        return this.cellsMovable;\n    },\n    setCellsMovable(value) {\n        this.cellsMovable = value;\n    },\n    isCellResizable(cell) {\n        return (this.isCellsResizable() &&\n            !this.isCellLocked(cell) &&\n            (this.getCurrentCellStyle(cell).resizable ?? true));\n    },\n    isCellsResizable() {\n        return this.cellsResizable;\n    },\n    setCellsResizable(value) {\n        this.cellsResizable = value;\n    },\n    isCellBendable(cell) {\n        return (this.isCellsBendable() &&\n            !this.isCellLocked(cell) &&\n            (this.getCurrentCellStyle(cell).bendable ?? true));\n    },\n    isCellsBendable() {\n        return this.cellsBendable;\n    },\n    setCellsBendable(value) {\n        this.cellsBendable = value;\n    },\n    isAutoSizeCell(cell) {\n        return this.isAutoSizeCells() || (this.getCurrentCellStyle(cell).autoSize ?? false);\n    },\n    isAutoSizeCells() {\n        return this.autoSizeCells;\n    },\n    setAutoSizeCells(value) {\n        this.autoSizeCells = value;\n    },\n    isExtendParent(cell) {\n        return !cell.isEdge() && this.isExtendParents();\n    },\n    isExtendParents() {\n        return this.extendParents;\n    },\n    setExtendParents(value) {\n        this.extendParents = value;\n    },\n    isExtendParentsOnAdd(cell) {\n        return this.extendParentsOnAdd;\n    },\n    setExtendParentsOnAdd(value) {\n        this.extendParentsOnAdd = value;\n    },\n    isExtendParentsOnMove() {\n        return this.extendParentsOnMove;\n    },\n    setExtendParentsOnMove(value) {\n        this.extendParentsOnMove = value;\n    },\n    /*****************************************************************************\n     * Group: Graph appearance\n     *****************************************************************************/\n    getCursorForCell(_cell) {\n        return null;\n    },\n    /*****************************************************************************\n     * Group: Graph display\n     *****************************************************************************/\n    getCellBounds(cell, includeEdges = false, includeDescendants = false) {\n        let cells = [cell];\n        // Includes all connected edges\n        if (includeEdges) {\n            cells = cells.concat(cell.getEdges());\n        }\n        let result = this.getView().getBounds(cells);\n        // Recursively includes the bounds of the children\n        if (includeDescendants) {\n            for (const child of cell.getChildren()) {\n                const tmp = this.getCellBounds(child, includeEdges, true);\n                if (result && tmp) {\n                    result.add(tmp);\n                }\n                else {\n                    result = tmp;\n                }\n            }\n        }\n        return result;\n    },\n    getBoundingBoxFromGeometry(cells, includeEdges = false) {\n        let result = null;\n        let tmp = null;\n        for (const cell of cells) {\n            if (includeEdges || cell.isVertex()) {\n                // Computes the bounding box for the points in the geometry\n                const geo = cell.getGeometry();\n                if (geo) {\n                    let bbox = null;\n                    if (cell.isEdge()) {\n                        const addPoint = (pt) => {\n                            if (pt) {\n                                if (!tmp) {\n                                    tmp = new Rectangle(pt.x, pt.y, 0, 0);\n                                }\n                                else {\n                                    tmp.add(new Rectangle(pt.x, pt.y, 0, 0));\n                                }\n                            }\n                        };\n                        if (!cell.getTerminal(true)) {\n                            addPoint(geo.getTerminalPoint(true));\n                        }\n                        if (!cell.getTerminal(false)) {\n                            addPoint(geo.getTerminalPoint(false));\n                        }\n                        const pts = geo.points;\n                        if (pts && pts.length > 0) {\n                            tmp = new Rectangle(pts[0].x, pts[0].y, 0, 0);\n                            for (let j = 1; j < pts.length; j++) {\n                                addPoint(pts[j]);\n                            }\n                        }\n                        bbox = tmp;\n                    }\n                    else {\n                        const parent = cell.getParent();\n                        if (geo.relative && parent) {\n                            if (parent.isVertex() && parent !== this.getView().currentRoot) {\n                                tmp = this.getBoundingBoxFromGeometry([parent], false);\n                                if (tmp) {\n                                    bbox = new Rectangle(geo.x * tmp.width, geo.y * tmp.height, geo.width, geo.height);\n                                    if (cells.indexOf(parent) >= 0) {\n                                        bbox.x += tmp.x;\n                                        bbox.y += tmp.y;\n                                    }\n                                }\n                            }\n                        }\n                        else {\n                            bbox = Rectangle.fromRectangle(geo);\n                            if (parent && parent.isVertex() && cells.indexOf(parent) >= 0) {\n                                tmp = this.getBoundingBoxFromGeometry([parent], false);\n                                if (tmp) {\n                                    bbox.x += tmp.x;\n                                    bbox.y += tmp.y;\n                                }\n                            }\n                        }\n                        if (bbox && geo.offset) {\n                            bbox.x += geo.offset.x;\n                            bbox.y += geo.offset.y;\n                        }\n                        const style = this.getCurrentCellStyle(cell);\n                        if (bbox) {\n                            const angle = style.rotation ?? 0;\n                            if (angle !== 0) {\n                                bbox = getBoundingBox(bbox, angle);\n                            }\n                        }\n                    }\n                    if (bbox) {\n                        if (!result) {\n                            result = Rectangle.fromRectangle(bbox);\n                        }\n                        else {\n                            result.add(bbox);\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    },\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1453, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1459, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/ConnectionsMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport ConnectionConstraint from '../other/ConnectionConstraint';\nimport { DIRECTION } from '../../util/Constants';\nimport { getRotatedPoint, toRadians } from '../../util/mathUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport Dictionary from '../../util/Dictionary';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const ConnectionsMixin = {\n    /*****************************************************************************\n     * Group: Cell connecting and connection constraints\n     *****************************************************************************/\n    constrainChildren: true,\n    constrainRelativeChildren: false,\n    disconnectOnMove: true,\n    cellsDisconnectable: true,\n    getOutlineConstraint(point, terminalState, me) {\n        if (terminalState.shape) {\n            const bounds = this.getView().getPerimeterBounds(terminalState);\n            const direction = terminalState.style.direction;\n            if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {\n                bounds.x += bounds.width / 2 - bounds.height / 2;\n                bounds.y += bounds.height / 2 - bounds.width / 2;\n                const tmp = bounds.width;\n                bounds.width = bounds.height;\n                bounds.height = tmp;\n            }\n            const alpha = toRadians(terminalState.shape.getShapeRotation());\n            if (alpha !== 0) {\n                const cos = Math.cos(-alpha);\n                const sin = Math.sin(-alpha);\n                const ct = new Point(bounds.getCenterX(), bounds.getCenterY());\n                point = getRotatedPoint(point, cos, sin, ct);\n            }\n            let sx = 1;\n            let sy = 1;\n            let dx = 0;\n            let dy = 0;\n            // LATER: Add flipping support for image shapes\n            if (terminalState.cell.isVertex()) {\n                let flipH = terminalState.style.flipH;\n                let flipV = terminalState.style.flipV;\n                if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {\n                    const tmp = flipH;\n                    flipH = flipV;\n                    flipV = tmp;\n                }\n                if (flipH) {\n                    sx = -1;\n                    dx = -bounds.width;\n                }\n                if (flipV) {\n                    sy = -1;\n                    dy = -bounds.height;\n                }\n            }\n            point = new Point((point.x - bounds.x) * sx - dx + bounds.x, (point.y - bounds.y) * sy - dy + bounds.y);\n            const x = bounds.width === 0\n                ? 0\n                : Math.round(((point.x - bounds.x) * 1000) / bounds.width) / 1000;\n            const y = bounds.height === 0\n                ? 0\n                : Math.round(((point.y - bounds.y) * 1000) / bounds.height) / 1000;\n            return new ConnectionConstraint(new Point(x, y), false);\n        }\n        return null;\n    },\n    getAllConnectionConstraints(terminal, source) {\n        return terminal?.shape?.stencil?.constraints ?? null;\n    },\n    getConnectionConstraint(edge, terminal, source = false) {\n        let point = null;\n        const x = edge.style[source ? 'exitX' : 'entryX'];\n        if (x !== undefined) {\n            const y = edge.style[source ? 'exitY' : 'entryY'];\n            if (y !== undefined) {\n                point = new Point(x, y);\n            }\n        }\n        let perimeter = false;\n        let dx = 0;\n        let dy = 0;\n        if (point) {\n            perimeter = edge.style[source ? 'exitPerimeter' : 'entryPerimeter'] || false;\n            // Add entry/exit offset\n            dx = edge.style[source ? 'exitDx' : 'entryDx'];\n            dy = edge.style[source ? 'exitDy' : 'entryDy'];\n            dx = Number.isFinite(dx) ? dx : 0;\n            dy = Number.isFinite(dy) ? dy : 0;\n        }\n        return new ConnectionConstraint(point, perimeter, null, dx, dy);\n    },\n    setConnectionConstraint(edge, terminal, source = false, constraint = null) {\n        if (constraint) {\n            this.batchUpdate(() => {\n                if (!constraint || !constraint.point) {\n                    this.setCellStyles(source ? 'exitX' : 'entryX', null, [edge]);\n                    this.setCellStyles(source ? 'exitY' : 'entryY', null, [edge]);\n                    this.setCellStyles(source ? 'exitDx' : 'entryDx', null, [edge]);\n                    this.setCellStyles(source ? 'exitDy' : 'entryDy', null, [edge]);\n                    this.setCellStyles(source ? 'exitPerimeter' : 'entryPerimeter', null, [edge]);\n                }\n                else if (constraint.point) {\n                    this.setCellStyles(source ? 'exitX' : 'entryX', constraint.point.x, [edge]);\n                    this.setCellStyles(source ? 'exitY' : 'entryY', constraint.point.y, [edge]);\n                    this.setCellStyles(source ? 'exitDx' : 'entryDx', constraint.dx, [edge]);\n                    this.setCellStyles(source ? 'exitDy' : 'entryDy', constraint.dy, [edge]);\n                    // Only writes 0 since 1 is default\n                    if (!constraint.perimeter) {\n                        this.setCellStyles(source ? 'exitPerimeter' : 'entryPerimeter', '0', [edge]);\n                    }\n                    else {\n                        this.setCellStyles(source ? 'exitPerimeter' : 'entryPerimeter', null, [edge]);\n                    }\n                }\n            });\n        }\n    },\n    getConnectionPoint(vertex, constraint, round = true) {\n        let point = null;\n        if (constraint.point) {\n            const bounds = this.getView().getPerimeterBounds(vertex);\n            const cx = new Point(bounds.getCenterX(), bounds.getCenterY());\n            const direction = vertex.style.direction;\n            let r1 = 0;\n            // Bounds need to be rotated by 90 degrees for further computation\n            if (vertex.style.anchorPointDirection) {\n                if (direction === DIRECTION.NORTH) {\n                    r1 += 270;\n                }\n                else if (direction === DIRECTION.WEST) {\n                    r1 += 180;\n                }\n                else if (direction === DIRECTION.SOUTH) {\n                    r1 += 90;\n                }\n                // Bounds need to be rotated by 90 degrees for further computation\n                if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {\n                    bounds.rotate90();\n                }\n            }\n            const { scale } = this.getView();\n            point = new Point(bounds.x + constraint.point.x * bounds.width + constraint.dx * scale, bounds.y + constraint.point.y * bounds.height + constraint.dy * scale);\n            // Rotation for direction before projection on perimeter\n            let r2 = vertex.style.rotation || 0;\n            if (constraint.perimeter) {\n                if (r1 !== 0) {\n                    // Only 90 degrees steps possible here so no trig needed\n                    let cos = 0;\n                    let sin = 0;\n                    if (r1 === 90) {\n                        sin = 1;\n                    }\n                    else if (r1 === 180) {\n                        cos = -1;\n                    }\n                    else if (r1 === 270) {\n                        sin = -1;\n                    }\n                    point = getRotatedPoint(point, cos, sin, cx);\n                }\n                point = this.getView().getPerimeterPoint(vertex, point, false);\n            }\n            else {\n                r2 += r1;\n                if (vertex.cell.isVertex()) {\n                    let flipH = vertex.style.flipH;\n                    let flipV = vertex.style.flipV;\n                    if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {\n                        const temp = flipH;\n                        flipH = flipV;\n                        flipV = temp;\n                    }\n                    if (flipH) {\n                        point.x = 2 * bounds.getCenterX() - point.x;\n                    }\n                    if (flipV) {\n                        point.y = 2 * bounds.getCenterY() - point.y;\n                    }\n                }\n            }\n            // Generic rotation after projection on perimeter\n            if (r2 !== 0 && point) {\n                const rad = toRadians(r2);\n                const cos = Math.cos(rad);\n                const sin = Math.sin(rad);\n                point = getRotatedPoint(point, cos, sin, cx);\n            }\n        }\n        if (round && point) {\n            point.x = Math.round(point.x);\n            point.y = Math.round(point.y);\n        }\n        return point;\n    },\n    connectCell(edge, terminal = null, source = false, constraint = null) {\n        this.batchUpdate(() => {\n            const previous = edge.getTerminal(source);\n            this.cellConnected(edge, terminal, source, constraint);\n            this.fireEvent(new EventObject(InternalEvent.CONNECT_CELL, 'edge', edge, 'terminal', terminal, 'source', source, 'previous', previous));\n        });\n        return edge;\n    },\n    cellConnected(edge, terminal, source = false, constraint = null) {\n        this.batchUpdate(() => {\n            const previous = edge.getTerminal(source);\n            // Updates the constraint\n            this.setConnectionConstraint(edge, terminal, source, constraint);\n            // Checks if the new terminal is a port, uses the ID of the port in the\n            // style and the parent of the port as the actual terminal of the edge.\n            if (this.isPortsEnabled()) {\n                let id = null;\n                if (terminal && this.isPort(terminal)) {\n                    id = terminal.getId();\n                    terminal = this.getTerminalForPort(terminal, source);\n                }\n                // Sets or resets all previous information for connecting to a child port\n                const key = source ? 'sourcePort' : 'targetPort';\n                this.setCellStyles(key, id, [edge]);\n            }\n            this.getDataModel().setTerminal(edge, terminal, source);\n            if (this.isResetEdgesOnConnect()) {\n                this.resetEdge(edge);\n            }\n            this.fireEvent(new EventObject(InternalEvent.CELL_CONNECTED, 'edge', edge, 'terminal', terminal, 'source', source, 'previous', previous));\n        });\n    },\n    disconnectGraph(cells) {\n        this.batchUpdate(() => {\n            const { scale, translate: tr } = this.getView();\n            // Fast lookup for finding cells in array\n            const dict = new Dictionary();\n            for (let i = 0; i < cells.length; i += 1) {\n                dict.put(cells[i], true);\n            }\n            for (const cell of cells) {\n                if (cell.isEdge()) {\n                    let geo = cell.getGeometry();\n                    if (geo) {\n                        const state = this.getView().getState(cell);\n                        const parent = cell.getParent();\n                        const pstate = parent ? this.getView().getState(parent) : null;\n                        if (state && pstate) {\n                            geo = geo.clone();\n                            const dx = -pstate.origin.x;\n                            const dy = -pstate.origin.y;\n                            const pts = state.absolutePoints;\n                            let src = cell.getTerminal(true);\n                            if (src && this.isCellDisconnectable(cell, src, true)) {\n                                while (src && !dict.get(src)) {\n                                    src = src.getParent();\n                                }\n                                if (!src && pts[0]) {\n                                    geo.setTerminalPoint(new Point(pts[0].x / scale - tr.x + dx, pts[0].y / scale - tr.y + dy), true);\n                                    this.getDataModel().setTerminal(cell, null, true);\n                                }\n                            }\n                            let trg = cell.getTerminal(false);\n                            if (trg && this.isCellDisconnectable(cell, trg, false)) {\n                                while (trg && !dict.get(trg)) {\n                                    trg = trg.getParent();\n                                }\n                                if (!trg) {\n                                    const n = pts.length - 1;\n                                    const p = pts[n];\n                                    if (p) {\n                                        geo.setTerminalPoint(new Point(p.x / scale - tr.x + dx, p.y / scale - tr.y + dy), false);\n                                        this.getDataModel().setTerminal(cell, null, false);\n                                    }\n                                }\n                            }\n                            this.getDataModel().setGeometry(cell, geo);\n                        }\n                    }\n                }\n            }\n        });\n    },\n    getConnections(cell, parent = null) {\n        return this.getEdges(cell, parent, true, true, false);\n    },\n    isConstrainChild(cell) {\n        return (this.isConstrainChildren() &&\n            !!cell.getParent() &&\n            !cell.getParent().isEdge());\n    },\n    isConstrainChildren() {\n        return this.constrainChildren;\n    },\n    setConstrainChildren(value) {\n        this.constrainChildren = value;\n    },\n    isConstrainRelativeChildren() {\n        return this.constrainRelativeChildren;\n    },\n    setConstrainRelativeChildren(value) {\n        this.constrainRelativeChildren = value;\n    },\n    /*****************************************************************************\n     * Group: Graph behaviour\n     *****************************************************************************/\n    isDisconnectOnMove() {\n        return this.disconnectOnMove;\n    },\n    setDisconnectOnMove(value) {\n        this.disconnectOnMove = value;\n    },\n    isCellDisconnectable(cell, terminal = null, source = false) {\n        return this.isCellsDisconnectable() && !this.isCellLocked(cell);\n    },\n    isCellsDisconnectable() {\n        return this.cellsDisconnectable;\n    },\n    setCellsDisconnectable(value) {\n        this.cellsDisconnectable = value;\n    },\n    isValidSource(cell) {\n        return ((cell == null && this.isAllowDanglingEdges()) ||\n            (cell != null &&\n                (!cell.isEdge() || this.isConnectableEdges()) &&\n                cell.isConnectable()));\n    },\n    isValidTarget(cell) {\n        return this.isValidSource(cell);\n    },\n    isValidConnection(source, target) {\n        return this.isValidSource(source) && this.isValidTarget(target);\n    },\n    setConnectable(connectable) {\n        const connectionHandler = this.getPlugin('ConnectionHandler');\n        connectionHandler?.setEnabled(connectable);\n    },\n    isConnectable() {\n        const connectionHandler = this.getPlugin('ConnectionHandler');\n        return connectionHandler?.isEnabled() ?? false;\n    },\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1825, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1831, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/DragDropMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const DragDropMixin = {\n    dropEnabled: false,\n    splitEnabled: true,\n    autoScroll: true,\n    isAutoScroll() {\n        return this.autoScroll;\n    },\n    autoExtend: true,\n    isAutoExtend() {\n        return this.autoExtend;\n    },\n    /*****************************************************************************\n     * Group: Graph behaviour\n     *****************************************************************************/\n    isDropEnabled() {\n        return this.dropEnabled;\n    },\n    setDropEnabled(value) {\n        this.dropEnabled = value;\n    },\n    /*****************************************************************************\n     * Group: Split behaviour\n     *****************************************************************************/\n    isSplitEnabled() {\n        return this.splitEnabled;\n    },\n    setSplitEnabled(value) {\n        this.splitEnabled = value;\n    },\n    isSplitTarget(target, cells = [], evt) {\n        if (target.isEdge() &&\n            cells.length === 1 &&\n            cells[0].isConnectable() &&\n            !this.getEdgeValidationError(target, target.getTerminal(true), cells[0])) {\n            const src = target.getTerminal(true);\n            const trg = target.getTerminal(false);\n            return !cells[0].isAncestor(src) && !cells[0].isAncestor(trg);\n        }\n        return false;\n    },\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcA,GACA,yEAAyE;;;;AAClE,MAAM,gBAAgB;IACzB,aAAa;IACb,cAAc;IACd,YAAY;IACZ;QACI,OAAO,IAAI,CAAC,UAAU;IAC1B;IACA,YAAY;IACZ;QACI,OAAO,IAAI,CAAC,UAAU;IAC1B;IACA;;iFAE6E,GAC7E;QACI,OAAO,IAAI,CAAC,WAAW;IAC3B;IACA,gBAAe,KAAK;QAChB,IAAI,CAAC,WAAW,GAAG;IACvB;IACA;;iFAE6E,GAC7E;QACI,OAAO,IAAI,CAAC,YAAY;IAC5B;IACA,iBAAgB,KAAK;QACjB,IAAI,CAAC,YAAY,GAAG;IACxB;IACA,eAAc,MAAM,EAAE,QAAQ,EAAE,EAAE,GAAG;QACjC,IAAI,OAAO,MAAM,MACb,MAAM,MAAM,KAAK,KACjB,KAAK,CAAC,EAAE,CAAC,aAAa,MACtB,CAAC,IAAI,CAAC,sBAAsB,CAAC,QAAQ,OAAO,WAAW,CAAC,OAAO,KAAK,CAAC,EAAE,GAAG;YAC1E,MAAM,MAAM,OAAO,WAAW,CAAC;YAC/B,MAAM,MAAM,OAAO,WAAW,CAAC;YAC/B,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,UAAU,CAAC;QAC7D;QACA,OAAO;IACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1885, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1891, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/EdgeMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Dictionary from '../../util/Dictionary';\nimport { removeDuplicates } from '../../util/arrayUtils';\nimport { findNearestSegment } from '../../util/mathUtils';\nimport Cell from '../cell/Cell';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport Geometry from '../geometry/Geometry';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const EdgeMixin = {\n    resetEdgesOnResize: false,\n    isResetEdgesOnResize() {\n        return this.resetEdgesOnResize;\n    },\n    resetEdgesOnMove: false,\n    isResetEdgesOnMove() {\n        return this.resetEdgesOnMove;\n    },\n    resetEdgesOnConnect: true,\n    isResetEdgesOnConnect() {\n        return this.resetEdgesOnConnect;\n    },\n    connectableEdges: false,\n    allowDanglingEdges: true,\n    cloneInvalidEdges: false,\n    alternateEdgeStyle: {},\n    edgeLabelsMovable: true,\n    // ***************************************************************************\n    // Group: Graph Behaviour\n    // ***************************************************************************\n    isEdgeLabelsMovable() {\n        return this.edgeLabelsMovable;\n    },\n    setEdgeLabelsMovable(value) {\n        this.edgeLabelsMovable = value;\n    },\n    setAllowDanglingEdges(value) {\n        this.allowDanglingEdges = value;\n    },\n    isAllowDanglingEdges() {\n        return this.allowDanglingEdges;\n    },\n    setConnectableEdges(value) {\n        this.connectableEdges = value;\n    },\n    isConnectableEdges() {\n        return this.connectableEdges;\n    },\n    setCloneInvalidEdges(value) {\n        this.cloneInvalidEdges = value;\n    },\n    isCloneInvalidEdges() {\n        return this.cloneInvalidEdges;\n    },\n    // ***************************************************************************\n    // Group: Cell alignment and orientation\n    // ***************************************************************************\n    flipEdge(edge) {\n        if (this.alternateEdgeStyle) {\n            this.batchUpdate(() => {\n                const style = edge.getStyle();\n                if (Object.keys(style).length) {\n                    this.getDataModel().setStyle(edge, this.alternateEdgeStyle);\n                }\n                else {\n                    this.getDataModel().setStyle(edge, {});\n                }\n                // Removes all existing control points\n                this.resetEdge(edge);\n                this.fireEvent(new EventObject(InternalEvent.FLIP_EDGE, { edge }));\n            });\n        }\n        return edge;\n    },\n    splitEdge(edge, cells, newEdge, dx = 0, dy = 0, x, y, parent = null) {\n        parent = parent ?? edge.getParent();\n        const source = edge.getTerminal(true);\n        this.batchUpdate(() => {\n            if (!newEdge) {\n                newEdge = this.cloneCell(edge);\n                // Removes waypoints before/after new cell\n                const state = this.getView().getState(edge);\n                let geo = newEdge.getGeometry();\n                if (geo && state) {\n                    const t = this.getView().translate;\n                    const s = this.getView().scale;\n                    const idx = findNearestSegment(state, (dx + t.x) * s, (dy + t.y) * s);\n                    geo.points = geo.points.slice(0, idx);\n                    geo = edge.getGeometry();\n                    if (geo) {\n                        geo = geo.clone();\n                        geo.points = geo.points.slice(idx);\n                        this.getDataModel().setGeometry(edge, geo);\n                    }\n                }\n            }\n            this.cellsMoved(cells, dx, dy, false, false);\n            this.cellsAdded(cells, parent, parent ? parent.getChildCount() : 0, null, null, true);\n            this.cellsAdded([newEdge], parent, parent ? parent.getChildCount() : 0, source, cells[0], false);\n            this.cellConnected(edge, cells[0], true);\n            this.fireEvent(new EventObject(InternalEvent.SPLIT_EDGE, { edge, cells, newEdge, dx, dy }));\n        });\n        return newEdge;\n    },\n    insertEdge(...args) {\n        let parent;\n        let id;\n        let value;\n        let source;\n        let target;\n        let style;\n        if (args.length === 1 && typeof args[0] === 'object') {\n            const params = args[0];\n            parent = params.parent;\n            id = params.id;\n            value = params.value;\n            source = params.source;\n            target = params.target;\n            style = params.style;\n        }\n        else {\n            // otherwise treat as individual arguments\n            [parent, id, value, source, target, style] = args;\n        }\n        const edge = this.createEdge(parent, id, value, source, target, style);\n        return this.addEdge(edge, parent, source, target);\n    },\n    createEdge(parent = null, id, value, source = null, target = null, style = {}) {\n        // Creates the edge\n        const edge = new Cell(value, new Geometry(), style);\n        edge.setId(id);\n        edge.setEdge(true);\n        edge.geometry.relative = true;\n        return edge;\n    },\n    addEdge(edge, parent = null, source = null, target = null, index = null) {\n        return this.addCell(edge, parent, index, source, target);\n    },\n    // ***************************************************************************\n    // Group: Folding\n    // ***************************************************************************\n    addAllEdges(cells) {\n        const allCells = cells.slice();\n        return removeDuplicates(allCells.concat(this.getAllEdges(cells)));\n    },\n    getAllEdges(cells) {\n        let edges = [];\n        if (cells) {\n            for (let i = 0; i < cells.length; i += 1) {\n                const edgeCount = cells[i].getEdgeCount();\n                for (let j = 0; j < edgeCount; j++) {\n                    edges.push(cells[i].getEdgeAt(j));\n                }\n                // Recurses\n                const children = cells[i].getChildren();\n                edges = edges.concat(this.getAllEdges(children));\n            }\n        }\n        return edges;\n    },\n    getIncomingEdges(cell, parent = null) {\n        return this.getEdges(cell, parent, true, false, false);\n    },\n    getOutgoingEdges(cell, parent = null) {\n        return this.getEdges(cell, parent, false, true, false);\n    },\n    getEdges(cell, parent = null, incoming = true, outgoing = true, includeLoops = true, recurse = false) {\n        let edges = [];\n        const isCollapsed = cell.isCollapsed();\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = cell.getChildAt(i);\n            if (isCollapsed || !child.isVisible()) {\n                edges = edges.concat(child.getEdges(incoming, outgoing));\n            }\n        }\n        edges = edges.concat(cell.getEdges(incoming, outgoing));\n        const result = [];\n        for (let i = 0; i < edges.length; i += 1) {\n            const state = this.getView().getState(edges[i]);\n            const source = state\n                ? state.getVisibleTerminal(true)\n                : this.getView().getVisibleTerminal(edges[i], true);\n            const target = state\n                ? state.getVisibleTerminal(false)\n                : this.getView().getVisibleTerminal(edges[i], false);\n            if ((includeLoops && source === target) ||\n                (source !== target &&\n                    ((incoming &&\n                        target === cell &&\n                        (!parent || this.isValidAncestor(source, parent, recurse))) ||\n                        (outgoing &&\n                            source === cell &&\n                            (!parent || this.isValidAncestor(target, parent, recurse)))))) {\n                result.push(edges[i]);\n            }\n        }\n        return result;\n    },\n    // ***************************************************************************\n    // Group: Cell retrieval\n    // ***************************************************************************\n    getChildEdges(parent) {\n        return this.getChildCells(parent, false, true);\n    },\n    getEdgesBetween(source, target, directed = false) {\n        const edges = this.getEdges(source);\n        const result = [];\n        // Checks if the edge is connected to the correct\n        // cell and returns the first match\n        for (let i = 0; i < edges.length; i += 1) {\n            const state = this.getView().getState(edges[i]);\n            const src = state\n                ? state.getVisibleTerminal(true)\n                : this.getView().getVisibleTerminal(edges[i], true);\n            const trg = state\n                ? state.getVisibleTerminal(false)\n                : this.getView().getVisibleTerminal(edges[i], false);\n            if ((src === source && trg === target) ||\n                (!directed && src === target && trg === source)) {\n                result.push(edges[i]);\n            }\n        }\n        return result;\n    },\n    // ***************************************************************************\n    // Group: Cell moving\n    // ***************************************************************************\n    resetEdges(cells) {\n        // Prepares faster cells lookup\n        const dict = new Dictionary();\n        for (let i = 0; i < cells.length; i += 1) {\n            dict.put(cells[i], true);\n        }\n        this.batchUpdate(() => {\n            for (let i = 0; i < cells.length; i += 1) {\n                const edges = cells[i].getEdges();\n                for (let j = 0; j < edges.length; j++) {\n                    const state = this.getView().getState(edges[j]);\n                    const source = state\n                        ? state.getVisibleTerminal(true)\n                        : this.getView().getVisibleTerminal(edges[j], true);\n                    const target = state\n                        ? state.getVisibleTerminal(false)\n                        : this.getView().getVisibleTerminal(edges[j], false);\n                    // Checks if one of the terminals is not in the given array\n                    if (!dict.get(source) || !dict.get(target)) {\n                        this.resetEdge(edges[j]);\n                    }\n                }\n                this.resetEdges(cells[i].getChildren());\n            }\n        });\n    },\n    resetEdge(edge) {\n        let geo = edge.getGeometry();\n        // Resets the control points\n        if (geo && geo.points && geo.points.length > 0) {\n            geo = geo.clone();\n            geo.points = [];\n            this.getDataModel().setGeometry(edge, geo);\n        }\n        return edge;\n    },\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2166, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2172, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/EditingMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { isMultiTouchEvent } from '../../util/EventUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const EditingMixin = {\n    cellsEditable: true,\n    /*****************************************************************************\n     * Group: Cell in-place editing\n     *****************************************************************************/\n    startEditing(evt) {\n        this.startEditingAtCell(null, evt);\n    },\n    startEditingAtCell(cell = null, evt) {\n        if (!evt || !isMultiTouchEvent(evt)) {\n            if (!cell) {\n                cell = this.getSelectionCell();\n                if (cell && !this.isCellEditable(cell)) {\n                    cell = null;\n                }\n            }\n            else {\n                this.fireEvent(new EventObject(InternalEvent.START_EDITING, { cell, event: evt }));\n                const cellEditorHandler = this.getPlugin('CellEditorHandler');\n                cellEditorHandler?.startEditing(cell, evt);\n                this.fireEvent(new EventObject(InternalEvent.EDITING_STARTED, { cell, event: evt }));\n            }\n        }\n    },\n    getEditingValue(cell, evt) {\n        return this.convertValueToString(cell);\n    },\n    stopEditing(cancel = false) {\n        const cellEditorHandler = this.getPlugin('CellEditorHandler');\n        cellEditorHandler?.stopEditing(cancel);\n        this.fireEvent(new EventObject(InternalEvent.EDITING_STOPPED, { cancel }));\n    },\n    labelChanged(cell, value, evt) {\n        this.batchUpdate(() => {\n            const old = cell.value;\n            this.cellLabelChanged(cell, value, this.isAutoSizeCell(cell));\n            this.fireEvent(new EventObject(InternalEvent.LABEL_CHANGED, {\n                cell: cell,\n                value: value,\n                old: old,\n                event: evt,\n            }));\n        });\n        return cell;\n    },\n    cellLabelChanged(cell, value, autoSize = false) {\n        this.batchUpdate(() => {\n            this.getDataModel().setValue(cell, value);\n            if (autoSize) {\n                this.cellSizeUpdated(cell, false);\n            }\n        });\n    },\n    /*****************************************************************************\n     * Group: Graph behaviour\n     *****************************************************************************/\n    isEditing(cell = null) {\n        const cellEditorHandler = this.getPlugin('CellEditorHandler');\n        const editingCell = cellEditorHandler?.getEditingCell();\n        return !cell ? !!editingCell : cell === editingCell;\n    },\n    isCellEditable(cell) {\n        return (this.isCellsEditable() &&\n            !this.isCellLocked(cell) &&\n            (this.getCurrentCellStyle(cell).editable ?? true));\n    },\n    isCellsEditable() {\n        return this.cellsEditable;\n    },\n    setCellsEditable(value) {\n        this.cellsEditable = value;\n    },\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcA;;;AACA;AACA;AACA;;;;AAEO,MAAM,eAAe;IACxB,eAAe;IACf;;iFAE6E,GAC7E,cAAa,GAAG;QACZ,IAAI,CAAC,kBAAkB,CAAC,MAAM;IAClC;IACA,oBAAmB,OAAO,IAAI,EAAE,GAAG;QAC/B,IAAI,CAAC,OAAO,CAAC,CAAA,GAAA,+JAAA,CAAA,oBAAiB,AAAD,EAAE,MAAM;YACjC,IAAI,CAAC,MAAM;gBACP,OAAO,IAAI,CAAC,gBAAgB;gBAC5B,IAAI,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO;oBACpC,OAAO;gBACX;YACJ,OACK;gBACD,IAAI,CAAC,SAAS,CAAC,IAAI,yKAAA,CAAA,UAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,aAAa,EAAE;oBAAE;oBAAM,OAAO;gBAAI;gBAC/E,MAAM,oBAAoB,IAAI,CAAC,SAAS,CAAC;gBACzC,mBAAmB,aAAa,MAAM;gBACtC,IAAI,CAAC,SAAS,CAAC,IAAI,yKAAA,CAAA,UAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,eAAe,EAAE;oBAAE;oBAAM,OAAO;gBAAI;YACrF;QACJ;IACJ;IACA,iBAAgB,IAAI,EAAE,GAAG;QACrB,OAAO,IAAI,CAAC,oBAAoB,CAAC;IACrC;IACA,aAAY,SAAS,KAAK;QACtB,MAAM,oBAAoB,IAAI,CAAC,SAAS,CAAC;QACzC,mBAAmB,YAAY;QAC/B,IAAI,CAAC,SAAS,CAAC,IAAI,yKAAA,CAAA,UAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,eAAe,EAAE;YAAE;QAAO;IAC3E;IACA,cAAa,IAAI,EAAE,KAAK,EAAE,GAAG;QACzB,IAAI,CAAC,WAAW,CAAC;YACb,MAAM,MAAM,KAAK,KAAK;YACtB,IAAI,CAAC,gBAAgB,CAAC,MAAM,OAAO,IAAI,CAAC,cAAc,CAAC;YACvD,IAAI,CAAC,SAAS,CAAC,IAAI,yKAAA,CAAA,UAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,aAAa,EAAE;gBACxD,MAAM;gBACN,OAAO;gBACP,KAAK;gBACL,OAAO;YACX;QACJ;QACA,OAAO;IACX;IACA,kBAAiB,IAAI,EAAE,KAAK,EAAE,WAAW,KAAK;QAC1C,IAAI,CAAC,WAAW,CAAC;YACb,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,MAAM;YACnC,IAAI,UAAU;gBACV,IAAI,CAAC,eAAe,CAAC,MAAM;YAC/B;QACJ;IACJ;IACA;;iFAE6E,GAC7E,WAAU,OAAO,IAAI;QACjB,MAAM,oBAAoB,IAAI,CAAC,SAAS,CAAC;QACzC,MAAM,cAAc,mBAAmB;QACvC,OAAO,CAAC,OAAO,CAAC,CAAC,cAAc,SAAS;IAC5C;IACA,gBAAe,IAAI;QACf,OAAQ,IAAI,CAAC,eAAe,MACxB,CAAC,IAAI,CAAC,YAAY,CAAC,SACnB,CAAC,IAAI,CAAC,mBAAmB,CAAC,MAAM,QAAQ,IAAI,IAAI;IACxD;IACA;QACI,OAAO,IAAI,CAAC,aAAa;IAC7B;IACA,kBAAiB,KAAK;QAClB,IAAI,CAAC,aAAa,GAAG;IACzB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2271, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2277, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/EventsMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalMouseEvent from '../event/InternalMouseEvent';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { getClientX, getClientY, isAltDown, isConsumed, isControlDown, isLeftMouseButton, isMetaDown, isMouseEvent, isMultiTouchEvent, isPenEvent, isPopupTrigger, isShiftDown, isTouchEvent, } from '../../util/EventUtils';\nimport Point from '../geometry/Point';\nimport { convertPoint } from '../../util/styleUtils';\nimport { NONE } from '../../util/Constants';\nimport Client from '../../Client';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const EventsMixin = {\n    // TODO: Document me!\n    lastTouchEvent: null,\n    doubleClickCounter: 0,\n    lastTouchCell: null,\n    fireDoubleClick: null,\n    tapAndHoldThread: null,\n    lastMouseX: null,\n    lastMouseY: null,\n    isMouseTrigger: null,\n    ignoreMouseEvents: null,\n    mouseMoveRedirect: null,\n    mouseUpRedirect: null,\n    lastEvent: null, // FIXME: Check if this can be more specific - DOM events or mxEventObjects!\n    escapeEnabled: true,\n    invokesStopCellEditing: true,\n    enterStopsCellEditing: false,\n    isMouseDown: false,\n    nativeDblClickEnabled: true,\n    doubleTapEnabled: true,\n    doubleTapTimeout: 500,\n    doubleTapTolerance: 25,\n    lastTouchX: 0,\n    lastTouchY: 0,\n    lastTouchTime: 0,\n    tapAndHoldEnabled: true,\n    tapAndHoldDelay: 500,\n    tapAndHoldInProgress: false,\n    tapAndHoldValid: false,\n    initialTouchX: 0,\n    initialTouchY: 0,\n    tolerance: 4,\n    isNativeDblClickEnabled() {\n        return this.nativeDblClickEnabled;\n    },\n    getEventTolerance() {\n        return this.tolerance;\n    },\n    setEventTolerance(tolerance) {\n        this.tolerance = tolerance;\n    },\n    escape(evt) {\n        this.fireEvent(new EventObject(InternalEvent.ESCAPE, { event: evt }));\n    },\n    click(me) {\n        const evt = me.getEvent();\n        let cell = me.getCell();\n        const mxe = new EventObject(InternalEvent.CLICK, { event: evt, cell });\n        if (me.isConsumed()) {\n            mxe.consume();\n        }\n        this.fireEvent(mxe);\n        if (this.isEnabled() && !isConsumed(evt) && !mxe.isConsumed()) {\n            if (cell) {\n                if (this.isTransparentClickEvent(evt)) {\n                    let active = false;\n                    const tmp = this.getCellAt(me.graphX, me.graphY, null, false, false, (state) => {\n                        const selected = this.isCellSelected(state.cell);\n                        active = active || selected;\n                        return (!active ||\n                            selected ||\n                            (state.cell !== cell && state.cell.isAncestor(cell)));\n                    });\n                    if (tmp) {\n                        cell = tmp;\n                    }\n                }\n            }\n            else if (this.isSwimlaneSelectionEnabled()) {\n                cell = this.getSwimlaneAt(me.getGraphX(), me.getGraphY());\n                if (cell != null && (!this.isToggleEvent(evt) || !isAltDown(evt))) {\n                    let temp = cell;\n                    let swimlanes = [];\n                    while (temp != null) {\n                        temp = temp.getParent();\n                        const state = this.getView().getState(temp);\n                        if (this.isSwimlane(temp) && state != null) {\n                            swimlanes.push(temp);\n                        }\n                    }\n                    // Selects ancestors for selected swimlanes\n                    if (swimlanes.length > 0) {\n                        swimlanes = swimlanes.reverse();\n                        swimlanes.splice(0, 0, cell);\n                        swimlanes.push(cell);\n                        for (let i = 0; i < swimlanes.length - 1; i += 1) {\n                            if (this.isCellSelected(swimlanes[i])) {\n                                cell = swimlanes[this.isToggleEvent(evt) ? i : i + 1];\n                            }\n                        }\n                    }\n                }\n            }\n            if (cell) {\n                this.selectCellForEvent(cell, evt);\n            }\n            else if (!this.isToggleEvent(evt)) {\n                this.clearSelection();\n            }\n        }\n        return false;\n    },\n    dblClick(evt, cell = null) {\n        const mxe = new EventObject(InternalEvent.DOUBLE_CLICK, { event: evt, cell });\n        this.fireEvent(mxe);\n        // Handles the event if it has not been consumed\n        if (this.isEnabled() &&\n            !isConsumed(evt) &&\n            !mxe.isConsumed() &&\n            cell &&\n            this.isCellEditable(cell) &&\n            !this.isEditing(cell)) {\n            this.startEditingAtCell(cell, evt);\n            InternalEvent.consume(evt);\n        }\n    },\n    tapAndHold(me) {\n        const evt = me.getEvent();\n        const mxe = new EventObject(InternalEvent.TAP_AND_HOLD, {\n            event: evt,\n            cell: me.getCell(),\n        });\n        const panningHandler = this.getPlugin('PanningHandler');\n        const connectionHandler = this.getPlugin('ConnectionHandler');\n        // LATER: Check if event should be consumed if me is consumed\n        this.fireEvent(mxe);\n        if (mxe.isConsumed()) {\n            // Resets the state of the panning handler\n            panningHandler && (panningHandler.panningTrigger = false);\n        }\n        // Handles the event if it has not been consumed\n        if (this.isEnabled() &&\n            !isConsumed(evt) &&\n            !mxe.isConsumed() &&\n            connectionHandler &&\n            connectionHandler.isEnabled()) {\n            const cell = connectionHandler.marker.getCell(me);\n            if (cell) {\n                const state = this.getView().getState(cell);\n                if (state) {\n                    connectionHandler.marker.currentColor = connectionHandler.marker.validColor;\n                    connectionHandler.marker.markedState = state;\n                    connectionHandler.marker.mark();\n                    connectionHandler.first = new Point(me.getGraphX(), me.getGraphY());\n                    connectionHandler.edgeState = connectionHandler.createEdgeState(me);\n                    connectionHandler.previous = state;\n                    connectionHandler.fireEvent(new EventObject(InternalEvent.START, { state: connectionHandler.previous }));\n                }\n            }\n        }\n    },\n    addMouseListener(listener) {\n        this.mouseListeners.push(listener);\n    },\n    removeMouseListener(listener) {\n        for (let i = 0; i < this.mouseListeners.length; i += 1) {\n            if (this.mouseListeners[i] === listener) {\n                this.mouseListeners.splice(i, 1);\n                break;\n            }\n        }\n    },\n    updateMouseEvent(me, evtName) {\n        const pt = convertPoint(this.getContainer(), me.getX(), me.getY());\n        me.graphX = pt.x - this.getPanDx();\n        me.graphY = pt.y - this.getPanDy();\n        // Searches for rectangles using method if native hit detection is disabled on shape\n        if (!me.getCell() && this.isMouseDown && evtName === InternalEvent.MOUSE_MOVE) {\n            const cell = this.getCellAt(pt.x, pt.y, null, true, true, (state) => {\n                return (!state.shape ||\n                    state.shape.paintBackground !== this.paintBackground ||\n                    state.style.pointerEvents ||\n                    state.shape.fill !== NONE);\n            });\n            me.state = cell ? this.getView().getState(cell) : null;\n        }\n        return me;\n    },\n    getStateForTouchEvent(evt) {\n        const x = getClientX(evt);\n        const y = getClientY(evt);\n        // Dispatches the drop event to the graph which\n        // consumes and executes the source function\n        const pt = convertPoint(this.getContainer(), x, y);\n        const cell = this.getCellAt(pt.x, pt.y);\n        return cell ? this.getView().getState(cell) : null;\n    },\n    isEventIgnored(evtName, me, sender) {\n        const mouseEvent = isMouseEvent(me.getEvent());\n        let result = false;\n        // Drops events that are fired more than once\n        if (me.getEvent() === this.lastEvent) {\n            result = true;\n        }\n        else {\n            this.lastEvent = me.getEvent();\n        }\n        // Installs event listeners to capture the complete gesture from the event source\n        // for non-MS touch events as a workaround for all events for the same geture being\n        // fired from the event source even if that was removed from the DOM.\n        const eventSource = this.getEventSource();\n        if (eventSource && evtName !== InternalEvent.MOUSE_MOVE) {\n            InternalEvent.removeGestureListeners(eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);\n            this.mouseMoveRedirect = null;\n            this.mouseUpRedirect = null;\n            this.setEventSource(null);\n        }\n        else if (!Client.IS_GC && eventSource && me.getSource() !== eventSource) {\n            result = true;\n        }\n        else if (eventSource &&\n            Client.IS_TOUCH &&\n            evtName === InternalEvent.MOUSE_DOWN &&\n            !mouseEvent &&\n            !isPenEvent(me.getEvent())) {\n            this.setEventSource(me.getSource());\n            (this.mouseMoveRedirect = (evt) => {\n                this.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, this.getStateForTouchEvent(evt)));\n            }),\n                (this.mouseUpRedirect = (evt) => {\n                    this.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, this.getStateForTouchEvent(evt)));\n                }),\n                InternalEvent.addGestureListeners(eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);\n        }\n        // Factored out the workarounds for FF to make it easier to override/remove\n        // Note this method has side-effects!\n        if (this.isSyntheticEventIgnored(evtName, me, sender)) {\n            result = true;\n        }\n        // Never fires mouseUp/-Down for double clicks\n        if (!isPopupTrigger(this.lastEvent) &&\n            evtName !== InternalEvent.MOUSE_MOVE &&\n            this.lastEvent.detail === 2) {\n            return true;\n        }\n        // Filters out of sequence events or mixed event types during a gesture\n        if (evtName === InternalEvent.MOUSE_UP && this.isMouseDown) {\n            this.isMouseDown = false;\n        }\n        else if (evtName === InternalEvent.MOUSE_DOWN && !this.isMouseDown) {\n            this.isMouseDown = true;\n            this.isMouseTrigger = mouseEvent;\n        }\n        // Drops mouse events that are fired during touch gestures as a workaround for Webkit\n        // and mouse events that are not in sync with the current internal button state\n        else if (!result &&\n            (((!Client.IS_FF || evtName !== InternalEvent.MOUSE_MOVE) &&\n                this.isMouseDown &&\n                this.isMouseTrigger !== mouseEvent) ||\n                (evtName === InternalEvent.MOUSE_DOWN && this.isMouseDown) ||\n                (evtName === InternalEvent.MOUSE_UP && !this.isMouseDown))) {\n            result = true;\n        }\n        if (!result && evtName === InternalEvent.MOUSE_DOWN) {\n            this.lastMouseX = me.getX();\n            this.lastMouseY = me.getY();\n        }\n        return result;\n    },\n    isSyntheticEventIgnored(evtName, me, sender) {\n        let result = false;\n        const mouseEvent = isMouseEvent(me.getEvent());\n        // LATER: This does not cover all possible cases that can go wrong in FF\n        if (this.ignoreMouseEvents && mouseEvent && evtName !== InternalEvent.MOUSE_MOVE) {\n            this.ignoreMouseEvents = evtName !== InternalEvent.MOUSE_UP;\n            result = true;\n        }\n        else if (Client.IS_FF && !mouseEvent && evtName === InternalEvent.MOUSE_UP) {\n            this.ignoreMouseEvents = true;\n        }\n        return result;\n    },\n    isEventSourceIgnored(evtName, me) {\n        const source = me.getSource();\n        if (!source)\n            return true;\n        // @ts-ignore nodeName could exist\n        const name = source.nodeName ? source.nodeName.toLowerCase() : '';\n        const candidate = !isMouseEvent(me.getEvent()) || isLeftMouseButton(me.getEvent());\n        return (evtName === InternalEvent.MOUSE_DOWN &&\n            candidate &&\n            (name === 'select' ||\n                name === 'option' ||\n                (name === 'input' &&\n                    // @ts-ignore type could exist\n                    source.type !== 'checkbox' &&\n                    // @ts-ignore type could exist\n                    source.type !== 'radio' &&\n                    // @ts-ignore type could exist\n                    source.type !== 'button' &&\n                    // @ts-ignore type could exist\n                    source.type !== 'submit' &&\n                    // @ts-ignore type could exist\n                    source.type !== 'file')));\n    },\n    getEventState(state) {\n        return state;\n    },\n    fireMouseEvent(evtName, me, sender) {\n        sender = sender ?? this;\n        if (this.isEventSourceIgnored(evtName, me)) {\n            const tooltipHandler = this.getPlugin('TooltipHandler');\n            if (tooltipHandler) {\n                tooltipHandler.hide();\n            }\n            return;\n        }\n        // Updates the graph coordinates in the event\n        me = this.updateMouseEvent(me, evtName);\n        // Detects and processes double taps for touch-based devices which do not have native double click events\n        // or where detection of double click is not always possible (quirks, IE10+). Note that this can only handle\n        // double clicks on cells because the sequence of events in IE prevents detection on the background, it fires\n        // two mouse ups, one of which without a cell but no mousedown for the second click which means we cannot\n        // detect which mouseup(s) are part of the first click, ie we do not know when the first click ends.\n        if ((!this.nativeDblClickEnabled && !isPopupTrigger(me.getEvent())) ||\n            (this.doubleTapEnabled &&\n                Client.IS_TOUCH &&\n                (isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent())))) {\n            const currentTime = new Date().getTime();\n            if (evtName === InternalEvent.MOUSE_DOWN) {\n                if (this.lastTouchEvent &&\n                    this.lastTouchEvent !== me.getEvent() &&\n                    currentTime - this.lastTouchTime < this.doubleTapTimeout &&\n                    Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance &&\n                    Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance &&\n                    this.doubleClickCounter < 2) {\n                    this.doubleClickCounter += 1;\n                    let doubleClickFired = false;\n                    if (evtName === InternalEvent.MOUSE_UP) {\n                        if (me.getCell() === this.lastTouchCell && this.lastTouchCell) {\n                            this.lastTouchTime = 0;\n                            const cell = this.lastTouchCell;\n                            this.lastTouchCell = null;\n                            this.dblClick(me.getEvent(), cell);\n                            doubleClickFired = true;\n                        }\n                    }\n                    else {\n                        this.fireDoubleClick = true;\n                        this.lastTouchTime = 0;\n                    }\n                    if (doubleClickFired) {\n                        InternalEvent.consume(me.getEvent());\n                        return;\n                    }\n                }\n                else if (!this.lastTouchEvent || this.lastTouchEvent !== me.getEvent()) {\n                    this.lastTouchCell = me.getCell();\n                    this.lastTouchX = me.getX();\n                    this.lastTouchY = me.getY();\n                    this.lastTouchTime = currentTime;\n                    this.lastTouchEvent = me.getEvent();\n                    this.doubleClickCounter = 0;\n                }\n            }\n            else if ((this.isMouseDown || evtName === InternalEvent.MOUSE_UP) &&\n                this.fireDoubleClick) {\n                this.fireDoubleClick = false;\n                const cell = this.lastTouchCell;\n                this.lastTouchCell = null;\n                this.isMouseDown = false;\n                // Workaround for Chrome/Safari not firing native double click events for double touch on background\n                const valid = cell ||\n                    ((isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent())) &&\n                        (Client.IS_GC || Client.IS_SF));\n                if (valid &&\n                    Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance &&\n                    Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance) {\n                    this.dblClick(me.getEvent(), cell);\n                }\n                else {\n                    InternalEvent.consume(me.getEvent());\n                }\n                return;\n            }\n        }\n        if (!this.isEventIgnored(evtName, me, sender)) {\n            const state = me.getState();\n            // Updates the event state via getEventState\n            me.state = state ? this.getEventState(state) : null;\n            this.fireEvent(new EventObject(InternalEvent.FIRE_MOUSE_EVENT, { eventName: evtName, event: me }));\n            if (Client.IS_SF || Client.IS_GC || me.getEvent().target !== this.getContainer()) {\n                const container = this.getContainer();\n                if (evtName === InternalEvent.MOUSE_MOVE &&\n                    this.isMouseDown &&\n                    this.isAutoScroll() &&\n                    !isMultiTouchEvent(me.getEvent())) {\n                    this.scrollPointToVisible(me.getGraphX(), me.getGraphY(), this.isAutoExtend());\n                }\n                else if (evtName === InternalEvent.MOUSE_UP &&\n                    this.isIgnoreScrollbars() &&\n                    this.isTranslateToScrollPosition() &&\n                    (container.scrollLeft !== 0 || container.scrollTop !== 0)) {\n                    const s = this.getView().scale;\n                    const tr = this.getView().translate;\n                    this.getView().setTranslate(tr.x - container.scrollLeft / s, tr.y - container.scrollTop / s);\n                    container.scrollLeft = 0;\n                    container.scrollTop = 0;\n                }\n                const mouseListeners = this.mouseListeners;\n                // Does not change returnValue in Opera\n                if (!me.getEvent().preventDefault) {\n                    me.getEvent().returnValue = true;\n                }\n                for (const l of mouseListeners) {\n                    if (evtName === InternalEvent.MOUSE_DOWN) {\n                        l.mouseDown(sender, me);\n                    }\n                    else if (evtName === InternalEvent.MOUSE_MOVE) {\n                        l.mouseMove(sender, me);\n                    }\n                    else if (evtName === InternalEvent.MOUSE_UP) {\n                        l.mouseUp(sender, me);\n                    }\n                }\n                // Invokes the click handler\n                if (evtName === InternalEvent.MOUSE_UP) {\n                    this.click(me);\n                }\n            }\n            // Detects tapAndHold events using a timer\n            if ((isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent())) &&\n                evtName === InternalEvent.MOUSE_DOWN &&\n                this.tapAndHoldEnabled &&\n                !this.tapAndHoldInProgress) {\n                this.tapAndHoldInProgress = true;\n                this.initialTouchX = me.getGraphX();\n                this.initialTouchY = me.getGraphY();\n                const handler = () => {\n                    if (this.tapAndHoldValid) {\n                        this.tapAndHold(me);\n                    }\n                    this.tapAndHoldInProgress = false;\n                    this.tapAndHoldValid = false;\n                };\n                if (this.tapAndHoldThread) {\n                    window.clearTimeout(this.tapAndHoldThread);\n                }\n                this.tapAndHoldThread = window.setTimeout(handler, this.tapAndHoldDelay);\n                this.tapAndHoldValid = true;\n            }\n            else if (evtName === InternalEvent.MOUSE_UP) {\n                this.tapAndHoldInProgress = false;\n                this.tapAndHoldValid = false;\n            }\n            else if (this.tapAndHoldValid) {\n                this.tapAndHoldValid =\n                    Math.abs(this.initialTouchX - me.getGraphX()) < this.tolerance &&\n                        Math.abs(this.initialTouchY - me.getGraphY()) < this.tolerance;\n            }\n            const cellEditorHandler = this.getPlugin('CellEditorHandler');\n            // Stops editing for all events other than from cellEditorHandler\n            if (evtName === InternalEvent.MOUSE_DOWN &&\n                this.isEditing() &&\n                !cellEditorHandler?.isEventSource(me.getEvent())) {\n                this.stopEditing(!this.isInvokesStopCellEditing());\n            }\n            this.consumeMouseEvent(evtName, me, sender);\n        }\n    },\n    consumeMouseEvent(evtName, me, sender) {\n        sender = sender ?? this;\n        // Workaround for duplicate click in Windows 8 with Chrome/FF/Opera with touch\n        if (evtName === InternalEvent.MOUSE_DOWN && isTouchEvent(me.getEvent())) {\n            me.consume(false);\n        }\n    },\n    fireGestureEvent(evt, cell = null) {\n        // Resets double tap event handling when gestures take place\n        this.lastTouchTime = 0;\n        this.fireEvent(new EventObject(InternalEvent.GESTURE, { event: evt, cell }));\n    },\n    sizeDidChange() {\n        const bounds = this.getGraphBounds();\n        const border = this.getBorder();\n        let width = Math.max(0, bounds.x) + bounds.width + 2 * border;\n        let height = Math.max(0, bounds.y) + bounds.height + 2 * border;\n        const minimumContainerSize = this.getMinimumContainerSize();\n        if (minimumContainerSize) {\n            width = Math.max(width, minimumContainerSize.width);\n            height = Math.max(height, minimumContainerSize.height);\n        }\n        if (this.isResizeContainer()) {\n            this.doResizeContainer(width, height);\n        }\n        if (this.isPreferPageSize() || this.isPageVisible()) {\n            const size = this.getPreferredPageSize(bounds, Math.max(1, width), Math.max(1, height));\n            width = size.width * this.getView().scale;\n            height = size.height * this.getView().scale;\n        }\n        const minimumGraphSize = this.getMinimumGraphSize();\n        if (minimumGraphSize) {\n            width = Math.max(width, minimumGraphSize.width * this.getView().scale);\n            height = Math.max(height, minimumGraphSize.height * this.getView().scale);\n        }\n        width = Math.ceil(width);\n        height = Math.ceil(height);\n        // @ts-ignore\n        const root = this.getView().getDrawPane().ownerSVGElement;\n        if (root) {\n            root.style.minWidth = `${Math.max(1, width)}px`;\n            root.style.minHeight = `${Math.max(1, height)}px`;\n            root.style.width = '100%';\n            root.style.height = '100%';\n        }\n        this.updatePageBreaks(this.isPageBreaksVisible(), width, height);\n        this.fireEvent(new EventObject(InternalEvent.SIZE, { bounds }));\n    },\n    isCloneEvent(evt) {\n        return isControlDown(evt);\n    },\n    isTransparentClickEvent(evt) {\n        return false;\n    },\n    isToggleEvent(evt) {\n        return Client.IS_MAC ? isMetaDown(evt) : isControlDown(evt);\n    },\n    isGridEnabledEvent(evt) {\n        return !isAltDown(evt);\n    },\n    isConstrainedEvent(evt) {\n        return isShiftDown(evt);\n    },\n    isIgnoreTerminalEvent(_evt) {\n        return false;\n    },\n    getPointForEvent(evt, addOffset = true) {\n        const p = convertPoint(this.getContainer(), getClientX(evt), getClientY(evt));\n        const s = this.getView().scale;\n        const tr = this.getView().translate;\n        const off = addOffset ? this.getGridSize() / 2 : 0;\n        p.x = this.snap(p.x / s - tr.x - off);\n        p.y = this.snap(p.y / s - tr.y - off);\n        return p;\n    },\n    isEscapeEnabled() {\n        return this.escapeEnabled;\n    },\n    setEscapeEnabled(value) {\n        this.escapeEnabled = value;\n    },\n    isInvokesStopCellEditing() {\n        return this.invokesStopCellEditing;\n    },\n    setInvokesStopCellEditing(value) {\n        this.invokesStopCellEditing = value;\n    },\n    isEnterStopsCellEditing() {\n        return this.enterStopsCellEditing;\n    },\n    setEnterStopsCellEditing(value) {\n        this.enterStopsCellEditing = value;\n    },\n    getCursorForMouseEvent(me) {\n        const cell = me.getCell();\n        return cell ? this.getCursorForCell(cell) : null;\n    },\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2804, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2810, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/FoldingMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Image from '../image/ImageBox';\nimport Client from '../../Client';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { getValue } from '../../util/Utils';\nimport { toRadians } from '../../util/mathUtils';\nimport Rectangle from '../geometry/Rectangle';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const FoldingMixin = {\n    options: {\n        foldingEnabled: true,\n        collapsedImage: new Image(`${Client.imageBasePath}/collapsed.gif`, 9, 9),\n        expandedImage: new Image(`${Client.imageBasePath}/expanded.gif`, 9, 9),\n        collapseToPreferredSize: true,\n    },\n    collapseExpandResource: Client.language != 'none' ? 'collapse-expand' : '',\n    getCollapseExpandResource() {\n        return this.collapseExpandResource;\n    },\n    isFoldingEnabled() {\n        return this.options.foldingEnabled;\n    },\n    getFoldableCells(cells, collapse = false) {\n        return this.getDataModel().filterCells(cells, (cell) => {\n            return this.isCellFoldable(cell, collapse);\n        });\n    },\n    isCellFoldable(cell, collapse) {\n        const style = this.getCurrentCellStyle(cell);\n        return cell.getChildCount() > 0 && (style.foldable ?? true);\n    },\n    getFoldingImage(state) {\n        if (state != null && this.isFoldingEnabled() && !state.cell.isEdge()) {\n            const tmp = state.cell.isCollapsed();\n            if (this.isCellFoldable(state.cell, !tmp)) {\n                return tmp ? this.options.collapsedImage : this.options.expandedImage;\n            }\n        }\n        return null;\n    },\n    foldCells(collapse = false, recurse = false, cells = null, checkFoldable = false, _evt = null) {\n        if (cells == null) {\n            cells = this.getFoldableCells(this.getSelectionCells(), collapse);\n        }\n        this.stopEditing(false);\n        this.batchUpdate(() => {\n            this.cellsFolded(cells, collapse, recurse, checkFoldable);\n            this.fireEvent(new EventObject(InternalEvent.FOLD_CELLS, 'collapse', collapse, 'recurse', recurse, 'cells', cells));\n        });\n        return cells;\n    },\n    cellsFolded(cells = null, collapse = false, recurse = false, checkFoldable = false) {\n        if (cells != null && cells.length > 0) {\n            this.batchUpdate(() => {\n                for (let i = 0; i < cells.length; i += 1) {\n                    if ((!checkFoldable || this.isCellFoldable(cells[i], collapse)) &&\n                        collapse !== cells[i].isCollapsed()) {\n                        this.getDataModel().setCollapsed(cells[i], collapse);\n                        this.swapBounds(cells[i], collapse);\n                        if (this.isExtendParent(cells[i])) {\n                            this.extendParent(cells[i]);\n                        }\n                        if (recurse) {\n                            const children = cells[i].getChildren();\n                            this.cellsFolded(children, collapse, recurse);\n                        }\n                        this.constrainChild(cells[i]);\n                    }\n                }\n                this.fireEvent(new EventObject(InternalEvent.CELLS_FOLDED, { cells, collapse, recurse }));\n            });\n        }\n    },\n    swapBounds(cell, willCollapse = false) {\n        let geo = cell.getGeometry();\n        if (geo != null) {\n            geo = geo.clone();\n            this.updateAlternateBounds(cell, geo, willCollapse);\n            geo.swap();\n            this.getDataModel().setGeometry(cell, geo);\n        }\n    },\n    updateAlternateBounds(cell = null, geo = null, willCollapse = false) {\n        if (cell != null && geo != null) {\n            const style = this.getCurrentCellStyle(cell);\n            if (geo.alternateBounds == null) {\n                let bounds = geo;\n                if (this.options.collapseToPreferredSize) {\n                    const tmp = this.getPreferredSizeForCell(cell);\n                    if (tmp != null) {\n                        bounds = tmp;\n                        const startSize = getValue(style, 'startSize');\n                        if (startSize > 0) {\n                            bounds.height = Math.max(bounds.height, startSize);\n                        }\n                    }\n                }\n                geo.alternateBounds = new Rectangle(0, 0, bounds.width, bounds.height);\n            }\n            if (geo.alternateBounds != null) {\n                geo.alternateBounds.x = geo.x;\n                geo.alternateBounds.y = geo.y;\n                const alpha = toRadians(style.rotation || 0);\n                if (alpha !== 0) {\n                    const dx = geo.alternateBounds.getCenterX() - geo.getCenterX();\n                    const dy = geo.alternateBounds.getCenterY() - geo.getCenterY();\n                    const cos = Math.cos(alpha);\n                    const sin = Math.sin(alpha);\n                    const dx2 = cos * dx - sin * dy;\n                    const dy2 = sin * dx + cos * dy;\n                    geo.alternateBounds.x += dx2 - dx;\n                    geo.alternateBounds.y += dy2 - dy;\n                }\n            }\n        }\n    },\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2953, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2959, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/GroupingMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Cell from '../cell/Cell';\nimport { sortCells } from '../../util/styleUtils';\nimport Geometry from '../geometry/Geometry';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport Rectangle from '../geometry/Rectangle';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const GroupingMixin = {\n    groupCells(group, border = 0, cells) {\n        if (!cells)\n            cells = sortCells(this.getSelectionCells(), true);\n        if (!cells)\n            cells = this.getCellsForGroup(cells);\n        if (group == null) {\n            group = this.createGroupCell(cells);\n        }\n        const bounds = this.getBoundsForGroup(group, cells, border);\n        if (cells.length > 1 && bounds != null) {\n            // Uses parent of group or previous parent of first child\n            let parent = group.getParent();\n            if (parent == null) {\n                parent = cells[0].getParent();\n            }\n            this.batchUpdate(() => {\n                // Checks if the group has a geometry and\n                // creates one if one does not exist\n                if (group.getGeometry() == null) {\n                    this.getDataModel().setGeometry(group, new Geometry());\n                }\n                // Adds the group into the parent\n                let index = parent.getChildCount();\n                this.cellsAdded([group], parent, index, null, null, false, false, false);\n                // Adds the children into the group and moves\n                index = group.getChildCount();\n                this.cellsAdded(cells, group, index, null, null, false, false, false);\n                this.cellsMoved(cells, -bounds.x, -bounds.y, false, false, false);\n                // Resizes the group\n                this.cellsResized([group], [bounds], false);\n                this.fireEvent(new EventObject(InternalEvent.GROUP_CELLS, { group, border, cells }));\n            });\n        }\n        return group;\n    },\n    getCellsForGroup(cells) {\n        const result = [];\n        if (cells != null && cells.length > 0) {\n            const parent = cells[0].getParent();\n            result.push(cells[0]);\n            // Filters selection cells with the same parent\n            for (let i = 1; i < cells.length; i += 1) {\n                if (cells[i].getParent() === parent) {\n                    result.push(cells[i]);\n                }\n            }\n        }\n        return result;\n    },\n    getBoundsForGroup(group, children, border) {\n        const result = this.getBoundingBoxFromGeometry(children, true);\n        if (result != null) {\n            if (this.isSwimlane(group)) {\n                const size = this.getStartSize(group);\n                result.x -= size.width;\n                result.y -= size.height;\n                result.width += size.width;\n                result.height += size.height;\n            }\n            // Adds the border\n            if (border != null) {\n                result.x -= border;\n                result.y -= border;\n                result.width += 2 * border;\n                result.height += 2 * border;\n            }\n        }\n        return result;\n    },\n    createGroupCell(cells) {\n        const group = new Cell('');\n        group.setVertex(true);\n        group.setConnectable(false);\n        return group;\n    },\n    ungroupCells(cells) {\n        let result = [];\n        if (cells == null) {\n            cells = this.getCellsForUngroup();\n        }\n        if (cells != null && cells.length > 0) {\n            this.batchUpdate(() => {\n                const _cells = cells;\n                for (let i = 0; i < _cells.length; i += 1) {\n                    let children = _cells[i].getChildren();\n                    if (children != null && children.length > 0) {\n                        children = children.slice();\n                        const parent = _cells[i].getParent();\n                        const index = parent.getChildCount();\n                        this.cellsAdded(children, parent, index, null, null, true);\n                        result = result.concat(children);\n                        // Fix relative child cells\n                        for (const child of children) {\n                            const state = this.getView().getState(child);\n                            let geo = child.getGeometry();\n                            if (state != null && geo != null && geo.relative) {\n                                geo = geo.clone();\n                                geo.x = state.origin.x;\n                                geo.y = state.origin.y;\n                                geo.relative = false;\n                                this.getDataModel().setGeometry(child, geo);\n                            }\n                        }\n                    }\n                }\n                this.removeCellsAfterUngroup(_cells);\n                this.fireEvent(new EventObject(InternalEvent.UNGROUP_CELLS, { cells }));\n            });\n        }\n        return result;\n    },\n    getCellsForUngroup() {\n        const cells = this.getSelectionCells();\n        // Finds the cells with children\n        const tmp = [];\n        for (let i = 0; i < cells.length; i += 1) {\n            if (cells[i].isVertex() && cells[i].getChildCount() > 0) {\n                tmp.push(cells[i]);\n            }\n        }\n        return tmp;\n    },\n    removeCellsAfterUngroup(cells) {\n        this.cellsRemoved(this.addAllEdges(cells));\n    },\n    removeCellsFromParent(cells) {\n        if (cells == null) {\n            cells = this.getSelectionCells();\n        }\n        this.batchUpdate(() => {\n            const parent = this.getDefaultParent();\n            const index = parent.getChildCount();\n            this.cellsAdded(cells, parent, index, null, null, true);\n            this.fireEvent(new EventObject(InternalEvent.REMOVE_CELLS_FROM_PARENT, { cells }));\n        });\n        return cells;\n    },\n    updateGroupBounds(cells, border = 0, moveGroup = false, topBorder = 0, rightBorder = 0, bottomBorder = 0, leftBorder = 0) {\n        if (cells == null) {\n            cells = this.getSelectionCells();\n        }\n        border = border != null ? border : 0;\n        moveGroup = moveGroup != null ? moveGroup : false;\n        topBorder = topBorder != null ? topBorder : 0;\n        rightBorder = rightBorder != null ? rightBorder : 0;\n        bottomBorder = bottomBorder != null ? bottomBorder : 0;\n        leftBorder = leftBorder != null ? leftBorder : 0;\n        this.batchUpdate(() => {\n            for (let i = cells.length - 1; i >= 0; i--) {\n                let geo = cells[i].getGeometry();\n                if (geo == null) {\n                    continue;\n                }\n                const children = this.getChildCells(cells[i]);\n                if (children != null && children.length > 0) {\n                    const bounds = this.getBoundingBoxFromGeometry(children, true);\n                    if (bounds != null && bounds.width > 0 && bounds.height > 0) {\n                        // Adds the size of the title area for swimlanes\n                        const size = ((this.isSwimlane(cells[i])\n                            ? this.getActualStartSize(cells[i], true)\n                            : new Rectangle()));\n                        geo = geo.clone();\n                        if (moveGroup) {\n                            geo.x = Math.round(geo.x + bounds.x - border - size.x - leftBorder);\n                            geo.y = Math.round(geo.y + bounds.y - border - size.y - topBorder);\n                        }\n                        geo.width = Math.round(bounds.width + 2 * border + size.x + leftBorder + rightBorder + size.width);\n                        geo.height = Math.round(bounds.height + 2 * border + size.y + topBorder + bottomBorder + size.height);\n                        this.getDataModel().setGeometry(cells[i], geo);\n                        this.moveCells(children, border + size.x - bounds.x + leftBorder, border + size.y - bounds.y + topBorder);\n                    }\n                }\n            }\n        });\n        return cells;\n    },\n    /*****************************************************************************\n     * Group: Drilldown\n     *****************************************************************************/\n    enterGroup(cell) {\n        cell = cell || this.getSelectionCell();\n        if (cell != null && this.isValidRoot(cell)) {\n            this.getView().setCurrentRoot(cell);\n            this.clearSelection();\n        }\n    },\n    exitGroup() {\n        const root = this.getDataModel().getRoot();\n        const current = this.getCurrentRoot();\n        if (current != null) {\n            let next = current.getParent();\n            // Finds the next valid root in the hierarchy\n            while (next !== root && !this.isValidRoot(next) && next.getParent() !== root) {\n                next = next.getParent();\n            }\n            // Clears the current root if the new root is\n            // the model's root or one of the layers.\n            if (next === root || next.getParent() === root) {\n                this.getView().setCurrentRoot(null);\n            }\n            else {\n                this.getView().setCurrentRoot(next);\n            }\n            const state = this.getView().getState(current);\n            // Selects the previous root in the graph\n            if (state != null) {\n                this.setSelectionCell(current);\n            }\n        }\n    },\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3208, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3214, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/ImageMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const ImageMixin = {\n    addImageBundle(bundle) {\n        this.imageBundles.push(bundle);\n    },\n    removeImageBundle(bundle) {\n        const tmp = [];\n        for (let i = 0; i < this.imageBundles.length; i += 1) {\n            if (this.imageBundles[i] !== bundle) {\n                tmp.push(this.imageBundles[i]);\n            }\n        }\n        this.imageBundles = tmp;\n    },\n    getImageFromBundles(key) {\n        if (key) {\n            for (let i = 0; i < this.imageBundles.length; i += 1) {\n                const image = this.imageBundles[i].getImage(key);\n                if (image) {\n                    return image;\n                }\n            }\n        }\n        return null;\n    },\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcA,GACA,yEAAyE;;;;AAClE,MAAM,aAAa;IACtB,gBAAe,MAAM;QACjB,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;IAC3B;IACA,mBAAkB,MAAM;QACpB,MAAM,MAAM,EAAE;QACd,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,KAAK,EAAG;YAClD,IAAI,IAAI,CAAC,YAAY,CAAC,EAAE,KAAK,QAAQ;gBACjC,IAAI,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE;YACjC;QACJ;QACA,IAAI,CAAC,YAAY,GAAG;IACxB;IACA,qBAAoB,GAAG;QACnB,IAAI,KAAK;YACL,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,KAAK,EAAG;gBAClD,MAAM,QAAQ,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,QAAQ,CAAC;gBAC5C,IAAI,OAAO;oBACP,OAAO;gBACX;YACJ;QACJ;QACA,OAAO;IACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3257, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3263, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/LabelMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const LabelMixin = {\n    getLabel(cell) {\n        let result = '';\n        if (this.isLabelsVisible() && cell != null) {\n            const style = this.getCurrentCellStyle(cell);\n            if (!(style.noLabel ?? false)) {\n                result = this.convertValueToString(cell);\n            }\n        }\n        return result;\n    },\n    isHtmlLabel(_cell) {\n        return this.isHtmlLabels();\n    },\n    labelsVisible: true,\n    isLabelsVisible() {\n        return this.labelsVisible;\n    },\n    htmlLabels: false,\n    isHtmlLabels() {\n        return this.htmlLabels;\n    },\n    setHtmlLabels(value) {\n        this.htmlLabels = value;\n    },\n    isWrapping(cell) {\n        return this.getCurrentCellStyle(cell).whiteSpace === 'wrap';\n    },\n    isLabelClipped(cell) {\n        return this.getCurrentCellStyle(cell).overflow === 'hidden';\n    },\n    isLabelMovable(cell) {\n        return (!this.isCellLocked(cell) &&\n            ((cell.isEdge() && this.isEdgeLabelsMovable()) ||\n                (cell.isVertex() && this.isVertexLabelsMovable())));\n    },\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcA,GACA,yEAAyE;;;;AAClE,MAAM,aAAa;IACtB,UAAS,IAAI;QACT,IAAI,SAAS;QACb,IAAI,IAAI,CAAC,eAAe,MAAM,QAAQ,MAAM;YACxC,MAAM,QAAQ,IAAI,CAAC,mBAAmB,CAAC;YACvC,IAAI,CAAC,CAAC,MAAM,OAAO,IAAI,KAAK,GAAG;gBAC3B,SAAS,IAAI,CAAC,oBAAoB,CAAC;YACvC;QACJ;QACA,OAAO;IACX;IACA,aAAY,KAAK;QACb,OAAO,IAAI,CAAC,YAAY;IAC5B;IACA,eAAe;IACf;QACI,OAAO,IAAI,CAAC,aAAa;IAC7B;IACA,YAAY;IACZ;QACI,OAAO,IAAI,CAAC,UAAU;IAC1B;IACA,eAAc,KAAK;QACf,IAAI,CAAC,UAAU,GAAG;IACtB;IACA,YAAW,IAAI;QACX,OAAO,IAAI,CAAC,mBAAmB,CAAC,MAAM,UAAU,KAAK;IACzD;IACA,gBAAe,IAAI;QACf,OAAO,IAAI,CAAC,mBAAmB,CAAC,MAAM,QAAQ,KAAK;IACvD;IACA,gBAAe,IAAI;QACf,OAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,SACvB,CAAC,AAAC,KAAK,MAAM,MAAM,IAAI,CAAC,mBAAmB,MACtC,KAAK,QAAQ,MAAM,IAAI,CAAC,qBAAqB,EAAG;IAC7D;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3316, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3322, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/OrderMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { sortCells } from '../../util/styleUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const OrderMixin = {\n    orderCells(back = false, cells) {\n        if (!cells)\n            cells = this.getSelectionCells();\n        if (!cells) {\n            cells = sortCells(this.getSelectionCells(), true);\n        }\n        this.batchUpdate(() => {\n            this.cellsOrdered(cells, back);\n            const event = new EventObject(InternalEvent.ORDER_CELLS, 'back', back, 'cells', cells);\n            this.fireEvent(event);\n        });\n        return cells;\n    },\n    cellsOrdered(cells, back = false) {\n        this.batchUpdate(() => {\n            for (let i = 0; i < cells.length; i += 1) {\n                const parent = cells[i].getParent();\n                if (back) {\n                    this.getDataModel().add(parent, cells[i], i);\n                }\n                else {\n                    this.getDataModel().add(parent, cells[i], parent ? parent.getChildCount() - 1 : 0);\n                }\n            }\n            this.fireEvent(new EventObject(InternalEvent.CELLS_ORDERED, { back, cells }));\n        });\n    },\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcA;;;AACA;AACA;AACA;;;;AAEO,MAAM,aAAa;IACtB,YAAW,OAAO,KAAK,EAAE,KAAK;QAC1B,IAAI,CAAC,OACD,QAAQ,IAAI,CAAC,iBAAiB;QAClC,IAAI,CAAC,OAAO;YACR,QAAQ,CAAA,GAAA,+JAAA,CAAA,YAAS,AAAD,EAAE,IAAI,CAAC,iBAAiB,IAAI;QAChD;QACA,IAAI,CAAC,WAAW,CAAC;YACb,IAAI,CAAC,YAAY,CAAC,OAAO;YACzB,MAAM,QAAQ,IAAI,yKAAA,CAAA,UAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,WAAW,EAAE,QAAQ,MAAM,SAAS;YAChF,IAAI,CAAC,SAAS,CAAC;QACnB;QACA,OAAO;IACX;IACA,cAAa,KAAK,EAAE,OAAO,KAAK;QAC5B,IAAI,CAAC,WAAW,CAAC;YACb,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,KAAK,EAAG;gBACtC,MAAM,SAAS,KAAK,CAAC,EAAE,CAAC,SAAS;gBACjC,IAAI,MAAM;oBACN,IAAI,CAAC,YAAY,GAAG,GAAG,CAAC,QAAQ,KAAK,CAAC,EAAE,EAAE;gBAC9C,OACK;oBACD,IAAI,CAAC,YAAY,GAAG,GAAG,CAAC,QAAQ,KAAK,CAAC,EAAE,EAAE,SAAS,OAAO,aAAa,KAAK,IAAI;gBACpF;YACJ;YACA,IAAI,CAAC,SAAS,CAAC,IAAI,yKAAA,CAAA,UAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,aAAa,EAAE;gBAAE;gBAAM;YAAM;QAC9E;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3375, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3381, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/PageBreaksMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport Point from '../geometry/Point';\nimport PolylineShape from '../geometry/edge/PolylineShape';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const PageBreaksMixin = {\n    horizontalPageBreaks: null,\n    verticalPageBreaks: null,\n    updatePageBreaks(visible, _width, _height) {\n        const { scale, translate: tr } = this.getView();\n        const fmt = this.getPageFormat();\n        const ps = scale * this.getPageScale();\n        const bounds = new Rectangle(0, 0, fmt.width * ps, fmt.height * ps);\n        const gb = Rectangle.fromRectangle(this.getGraphBounds());\n        gb.width = Math.max(1, gb.width);\n        gb.height = Math.max(1, gb.height);\n        bounds.x =\n            Math.floor((gb.x - tr.x * scale) / bounds.width) * bounds.width + tr.x * scale;\n        bounds.y =\n            Math.floor((gb.y - tr.y * scale) / bounds.height) * bounds.height + tr.y * scale;\n        gb.width = Math.ceil((gb.width + (gb.x - bounds.x)) / bounds.width) * bounds.width;\n        gb.height =\n            Math.ceil((gb.height + (gb.y - bounds.y)) / bounds.height) * bounds.height;\n        // Does not show page breaks if the scale is too small\n        visible =\n            visible && Math.min(bounds.width, bounds.height) > this.getMinPageBreakDist();\n        const horizontalCount = visible ? Math.ceil(gb.height / bounds.height) + 1 : 0;\n        const verticalCount = visible ? Math.ceil(gb.width / bounds.width) + 1 : 0;\n        const right = (verticalCount - 1) * bounds.width;\n        const bottom = (horizontalCount - 1) * bounds.height;\n        if (this.horizontalPageBreaks == null && horizontalCount > 0) {\n            this.horizontalPageBreaks = [];\n        }\n        if (this.verticalPageBreaks == null && verticalCount > 0) {\n            this.verticalPageBreaks = [];\n        }\n        const drawPageBreaks = (breaks) => {\n            if (breaks != null) {\n                const count = breaks === this.horizontalPageBreaks ? horizontalCount : verticalCount;\n                for (let i = 0; i <= count; i += 1) {\n                    const pts = breaks === this.horizontalPageBreaks\n                        ? [\n                            new Point(Math.round(bounds.x), Math.round(bounds.y + i * bounds.height)),\n                            new Point(Math.round(bounds.x + right), Math.round(bounds.y + i * bounds.height)),\n                        ]\n                        : [\n                            new Point(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y)),\n                            new Point(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y + bottom)),\n                        ];\n                    if (breaks[i] != null) {\n                        breaks[i].points = pts;\n                        breaks[i].redraw();\n                    }\n                    else {\n                        const pageBreak = new PolylineShape(pts, this.getPageBreakColor());\n                        pageBreak.dialect = this.getDialect();\n                        pageBreak.pointerEvents = false;\n                        pageBreak.isDashed = this.isPageBreakDashed();\n                        pageBreak.init(this.getView().backgroundPane);\n                        pageBreak.redraw();\n                        breaks[i] = pageBreak;\n                    }\n                }\n                for (let i = count; i < breaks.length; i += 1) {\n                    breaks[i].destroy();\n                }\n                breaks.splice(count, breaks.length - count);\n            }\n        };\n        drawPageBreaks(this.horizontalPageBreaks);\n        drawPageBreaks(this.verticalPageBreaks);\n    },\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3465, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3471, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/OverlaysMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellOverlay from '../cell/CellOverlay';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const OverlaysMixin = {\n    addCellOverlay(cell, overlay) {\n        cell.overlays.push(overlay);\n        // Immediately update the cell display if the state exists\n        const state = this.getView().getState(cell);\n        if (state) {\n            this.getCellRenderer().redraw(state);\n        }\n        this.fireEvent(new EventObject(InternalEvent.ADD_OVERLAY, { cell, overlay }));\n        return overlay;\n    },\n    getCellOverlays(cell) {\n        return cell.overlays;\n    },\n    removeCellOverlay(cell, overlay = null) {\n        if (!overlay) {\n            this.removeCellOverlays(cell);\n        }\n        else {\n            const index = cell.overlays.indexOf(overlay);\n            if (index >= 0) {\n                cell.overlays.splice(index, 1);\n                // Immediately updates the cell display if the state exists\n                const state = this.getView().getState(cell);\n                if (state) {\n                    this.getCellRenderer().redraw(state);\n                }\n                this.fireEvent(new EventObject(InternalEvent.REMOVE_OVERLAY, { cell, overlay }));\n            }\n            else {\n                overlay = null;\n            }\n        }\n        return overlay;\n    },\n    removeCellOverlays(cell) {\n        const { overlays } = cell;\n        cell.overlays = [];\n        // Immediately updates the cell display if the state exists\n        const state = this.getView().getState(cell);\n        if (state) {\n            this.getCellRenderer().redraw(state);\n        }\n        for (let i = 0; i < overlays.length; i += 1) {\n            this.fireEvent(new EventObject(InternalEvent.REMOVE_OVERLAY, 'cell', cell, 'overlay', overlays[i]));\n        }\n        return overlays;\n    },\n    clearCellOverlays(cell = null) {\n        cell = cell ?? this.getDataModel().getRoot();\n        if (!cell)\n            return;\n        this.removeCellOverlays(cell);\n        // Recursively removes all overlays from the children\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = cell.getChildAt(i);\n            this.clearCellOverlays(child); // recurse\n        }\n    },\n    setCellWarning(cell, warning = null, img, isSelect = false) {\n        img = img ?? this.getWarningImage();\n        if (warning && warning.length > 0) {\n            // Creates the overlay with the image and warning\n            const overlay = new CellOverlay(img, `<font color=red>${warning}</font>`);\n            // Adds a handler for single mouseclicks to select the cell\n            if (isSelect) {\n                overlay.addListener(InternalEvent.CLICK, (sender, evt) => {\n                    if (this.isEnabled()) {\n                        this.setSelectionCell(cell);\n                    }\n                });\n            }\n            // Sets and returns the overlay in the graph\n            return this.addCellOverlay(cell, overlay);\n        }\n        this.removeCellOverlays(cell);\n        return null;\n    },\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcA;;;AAEA;AACA;AAFA;;;;AAIO,MAAM,gBAAgB;IACzB,gBAAe,IAAI,EAAE,OAAO;QACxB,KAAK,QAAQ,CAAC,IAAI,CAAC;QACnB,0DAA0D;QAC1D,MAAM,QAAQ,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC;QACtC,IAAI,OAAO;YACP,IAAI,CAAC,eAAe,GAAG,MAAM,CAAC;QAClC;QACA,IAAI,CAAC,SAAS,CAAC,IAAI,yKAAA,CAAA,UAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,WAAW,EAAE;YAAE;YAAM;QAAQ;QAC1E,OAAO;IACX;IACA,iBAAgB,IAAI;QAChB,OAAO,KAAK,QAAQ;IACxB;IACA,mBAAkB,IAAI,EAAE,UAAU,IAAI;QAClC,IAAI,CAAC,SAAS;YACV,IAAI,CAAC,kBAAkB,CAAC;QAC5B,OACK;YACD,MAAM,QAAQ,KAAK,QAAQ,CAAC,OAAO,CAAC;YACpC,IAAI,SAAS,GAAG;gBACZ,KAAK,QAAQ,CAAC,MAAM,CAAC,OAAO;gBAC5B,2DAA2D;gBAC3D,MAAM,QAAQ,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC;gBACtC,IAAI,OAAO;oBACP,IAAI,CAAC,eAAe,GAAG,MAAM,CAAC;gBAClC;gBACA,IAAI,CAAC,SAAS,CAAC,IAAI,yKAAA,CAAA,UAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,cAAc,EAAE;oBAAE;oBAAM;gBAAQ;YACjF,OACK;gBACD,UAAU;YACd;QACJ;QACA,OAAO;IACX;IACA,oBAAmB,IAAI;QACnB,MAAM,EAAE,QAAQ,EAAE,GAAG;QACrB,KAAK,QAAQ,GAAG,EAAE;QAClB,2DAA2D;QAC3D,MAAM,QAAQ,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC;QACtC,IAAI,OAAO;YACP,IAAI,CAAC,eAAe,GAAG,MAAM,CAAC;QAClC;QACA,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,KAAK,EAAG;YACzC,IAAI,CAAC,SAAS,CAAC,IAAI,yKAAA,CAAA,UAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,cAAc,EAAE,QAAQ,MAAM,WAAW,QAAQ,CAAC,EAAE;QACrG;QACA,OAAO;IACX;IACA,mBAAkB,OAAO,IAAI;QACzB,OAAO,QAAQ,IAAI,CAAC,YAAY,GAAG,OAAO;QAC1C,IAAI,CAAC,MACD;QACJ,IAAI,CAAC,kBAAkB,CAAC;QACxB,qDAAqD;QACrD,MAAM,aAAa,KAAK,aAAa;QACrC,IAAK,IAAI,IAAI,GAAG,IAAI,YAAY,KAAK,EAAG;YACpC,MAAM,QAAQ,KAAK,UAAU,CAAC;YAC9B,IAAI,CAAC,iBAAiB,CAAC,QAAQ,UAAU;QAC7C;IACJ;IACA,gBAAe,IAAI,EAAE,UAAU,IAAI,EAAE,GAAG,EAAE,WAAW,KAAK;QACtD,MAAM,OAAO,IAAI,CAAC,eAAe;QACjC,IAAI,WAAW,QAAQ,MAAM,GAAG,GAAG;YAC/B,iDAAiD;YACjD,MAAM,UAAU,IAAI,wKAAA,CAAA,UAAW,CAAC,KAAK,CAAC,gBAAgB,EAAE,QAAQ,OAAO,CAAC;YACxE,2DAA2D;YAC3D,IAAI,UAAU;gBACV,QAAQ,WAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,KAAK,EAAE,CAAC,QAAQ;oBAC9C,IAAI,IAAI,CAAC,SAAS,IAAI;wBAClB,IAAI,CAAC,gBAAgB,CAAC;oBAC1B;gBACJ;YACJ;YACA,4CAA4C;YAC5C,OAAO,IAAI,CAAC,cAAc,CAAC,MAAM;QACrC;QACA,IAAI,CAAC,kBAAkB,CAAC;QACxB,OAAO;IACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3577, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3583, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/PanningMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { hasScrollbars } from '../../util/styleUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport Rectangle from '../geometry/Rectangle';\nimport Point from '../geometry/Point';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const PanningMixin = {\n    shiftPreview1: null,\n    shiftPreview2: null,\n    useScrollbarsForPanning: true,\n    isUseScrollbarsForPanning() {\n        return this.useScrollbarsForPanning;\n    },\n    timerAutoScroll: false,\n    isTimerAutoScroll() {\n        return this.timerAutoScroll;\n    },\n    allowAutoPanning: false,\n    isAllowAutoPanning() {\n        return this.allowAutoPanning;\n    },\n    panDx: 0,\n    getPanDx() {\n        return this.panDx;\n    },\n    setPanDx(dx) {\n        this.panDx = dx;\n    },\n    panDy: 0,\n    getPanDy() {\n        return this.panDy;\n    },\n    setPanDy(dy) {\n        this.panDy = dy;\n    },\n    panGraph(dx, dy) {\n        const container = this.getContainer();\n        if (this.useScrollbarsForPanning && hasScrollbars(container)) {\n            container.scrollLeft = -dx;\n            container.scrollTop = -dy;\n        }\n        else {\n            const canvas = this.getView().getCanvas();\n            // Puts everything inside the container in a DIV so that it\n            // can be moved without changing the state of the container\n            if (dx === 0 && dy === 0) {\n                canvas.removeAttribute('transform');\n                if (this.shiftPreview1) {\n                    let child = this.shiftPreview1.firstChild;\n                    while (child) {\n                        const next = child.nextSibling;\n                        container.appendChild(child);\n                        child = next;\n                    }\n                    if (this.shiftPreview1.parentNode) {\n                        this.shiftPreview1.parentNode.removeChild(this.shiftPreview1);\n                    }\n                    this.shiftPreview1 = null;\n                    container.appendChild(canvas.parentNode);\n                    const shiftPreview2 = this.shiftPreview2;\n                    child = shiftPreview2.firstChild;\n                    while (child) {\n                        const next = child.nextSibling;\n                        container.appendChild(child);\n                        child = next;\n                    }\n                    if (shiftPreview2.parentNode) {\n                        shiftPreview2.parentNode.removeChild(shiftPreview2);\n                    }\n                    this.shiftPreview2 = null;\n                }\n            }\n            else {\n                canvas.setAttribute('transform', `translate(${dx},${dy})`);\n                if (!this.shiftPreview1) {\n                    // Needs two divs for stuff before and after the SVG element\n                    this.shiftPreview1 = document.createElement('div');\n                    this.shiftPreview1.style.position = 'absolute';\n                    this.shiftPreview1.style.overflow = 'visible';\n                    this.shiftPreview2 = document.createElement('div');\n                    this.shiftPreview2.style.position = 'absolute';\n                    this.shiftPreview2.style.overflow = 'visible';\n                    let current = this.shiftPreview1;\n                    let child = container.firstChild;\n                    while (child) {\n                        const next = child.nextSibling;\n                        // SVG element is moved via transform attribute\n                        // @ts-ignore\n                        if (child !== canvas.parentNode) {\n                            current.appendChild(child);\n                        }\n                        else {\n                            current = this.shiftPreview2;\n                        }\n                        child = next;\n                    }\n                    // Inserts elements only if not empty\n                    if (this.shiftPreview1.firstChild) {\n                        container.insertBefore(this.shiftPreview1, canvas.parentNode);\n                    }\n                    if (this.shiftPreview2.firstChild) {\n                        container.appendChild(this.shiftPreview2);\n                    }\n                }\n                this.shiftPreview1.style.left = `${dx}px`;\n                this.shiftPreview1.style.top = `${dy}px`;\n                if (this.shiftPreview2) {\n                    this.shiftPreview2.style.left = `${dx}px`;\n                    this.shiftPreview2.style.top = `${dy}px`;\n                }\n            }\n            this.panDx = dx;\n            this.panDy = dy;\n            this.fireEvent(new EventObject(InternalEvent.PAN));\n        }\n    },\n    scrollCellToVisible(cell, center = false) {\n        const x = -this.getView().translate.x;\n        const y = -this.getView().translate.y;\n        const state = this.getView().getState(cell);\n        if (state) {\n            const bounds = new Rectangle(x + state.x, y + state.y, state.width, state.height);\n            if (center && this.getContainer()) {\n                const w = this.getContainer().clientWidth;\n                const h = this.getContainer().clientHeight;\n                bounds.x = bounds.getCenterX() - w / 2;\n                bounds.width = w;\n                bounds.y = bounds.getCenterY() - h / 2;\n                bounds.height = h;\n            }\n            const tr = new Point(this.getView().translate.x, this.getView().translate.y);\n            if (this.scrollRectToVisible(bounds)) {\n                // Triggers an update via the view's event source\n                const tr2 = new Point(this.getView().translate.x, this.getView().translate.y);\n                this.getView().translate.x = tr.x;\n                this.getView().translate.y = tr.y;\n                this.getView().setTranslate(tr2.x, tr2.y);\n            }\n        }\n    },\n    scrollRectToVisible(rect) {\n        let isChanged = false;\n        const container = this.getContainer();\n        const w = container.offsetWidth;\n        const h = container.offsetHeight;\n        const widthLimit = Math.min(w, rect.width);\n        const heightLimit = Math.min(h, rect.height);\n        if (hasScrollbars(container)) {\n            rect.x += this.getView().translate.x;\n            rect.y += this.getView().translate.y;\n            let dx = container.scrollLeft - rect.x;\n            const ddx = Math.max(dx - container.scrollLeft, 0);\n            if (dx > 0) {\n                container.scrollLeft -= dx + 2;\n            }\n            else {\n                dx = rect.x + widthLimit - container.scrollLeft - container.clientWidth;\n                if (dx > 0) {\n                    container.scrollLeft += dx + 2;\n                }\n            }\n            let dy = container.scrollTop - rect.y;\n            const ddy = Math.max(0, dy - container.scrollTop);\n            if (dy > 0) {\n                container.scrollTop -= dy + 2;\n            }\n            else {\n                dy = rect.y + heightLimit - container.scrollTop - container.clientHeight;\n                if (dy > 0) {\n                    container.scrollTop += dy + 2;\n                }\n            }\n            if (!this.useScrollbarsForPanning && (ddx != 0 || ddy != 0)) {\n                this.getView().setTranslate(ddx, ddy);\n            }\n        }\n        else {\n            const x = -this.getView().translate.x;\n            const y = -this.getView().translate.y;\n            const s = this.getView().scale;\n            if (rect.x + widthLimit > x + w) {\n                this.getView().translate.x -= (rect.x + widthLimit - w - x) / s;\n                isChanged = true;\n            }\n            if (rect.y + heightLimit > y + h) {\n                this.getView().translate.y -= (rect.y + heightLimit - h - y) / s;\n                isChanged = true;\n            }\n            if (rect.x < x) {\n                this.getView().translate.x += (x - rect.x) / s;\n                isChanged = true;\n            }\n            if (rect.y < y) {\n                this.getView().translate.y += (y - rect.y) / s;\n                isChanged = true;\n            }\n            if (isChanged) {\n                this.getView().refresh();\n                const selectionCellsHandler = this.getPlugin('SelectionCellsHandler');\n                // Repaints selection marker (ticket 18)\n                if (selectionCellsHandler) {\n                    selectionCellsHandler.refresh();\n                }\n            }\n        }\n        return isChanged;\n    },\n    setPanning(enabled) {\n        const panningHandler = this.getPlugin('PanningHandler');\n        panningHandler && (panningHandler.panningEnabled = enabled);\n    },\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3810, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3816, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/PortsMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nexport const PortsMixin = {\n    portsEnabled: true,\n    isPort(cell) {\n        return false;\n    },\n    getTerminalForPort(cell, _source = false) {\n        return cell.getParent();\n    },\n    isPortsEnabled() {\n        return this.portsEnabled;\n    },\n    setPortsEnabled(value) {\n        this.portsEnabled = value;\n    },\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcA;;;AACO,MAAM,aAAa;IACtB,cAAc;IACd,QAAO,IAAI;QACP,OAAO;IACX;IACA,oBAAmB,IAAI,EAAE,UAAU,KAAK;QACpC,OAAO,KAAK,SAAS;IACzB;IACA;QACI,OAAO,IAAI,CAAC,YAAY;IAC5B;IACA,iBAAgB,KAAK;QACjB,IAAI,CAAC,YAAY,GAAG;IACxB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3848, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3854, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/SelectionMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Cell from '../cell/Cell';\nimport Dictionary from '../../util/Dictionary';\nimport RootChange from '../undoable_changes/RootChange';\nimport ChildChange from '../undoable_changes/ChildChange';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const SelectionMixin = {\n    selectionModel: null,\n    getSelectionModel() {\n        return this.selectionModel;\n    },\n    setSelectionModel(selectionModel) {\n        this.selectionModel = selectionModel;\n    },\n    /*****************************************************************************\n     * Selection\n     *****************************************************************************/\n    isCellSelected(cell) {\n        return this.selectionModel.isSelected(cell);\n    },\n    isSelectionEmpty() {\n        return this.selectionModel.isEmpty();\n    },\n    clearSelection() {\n        this.selectionModel.clear();\n    },\n    getSelectionCount() {\n        return this.selectionModel.cells.length;\n    },\n    getSelectionCell() {\n        return this.selectionModel.cells[0];\n    },\n    getSelectionCells() {\n        return this.selectionModel.cells.slice();\n    },\n    setSelectionCell(cell) {\n        this.selectionModel.setCell(cell);\n    },\n    setSelectionCells(cells) {\n        this.selectionModel.setCells(cells);\n    },\n    addSelectionCell(cell) {\n        this.selectionModel.addCell(cell);\n    },\n    addSelectionCells(cells) {\n        this.selectionModel.addCells(cells);\n    },\n    removeSelectionCell(cell) {\n        this.selectionModel.removeCell(cell);\n    },\n    removeSelectionCells(cells) {\n        this.selectionModel.removeCells(cells);\n    },\n    selectRegion(rect, evt) {\n        const cells = this.getCells(rect.x, rect.y, rect.width, rect.height);\n        this.selectCellsForEvent(cells, evt);\n        return cells;\n    },\n    selectNextCell() {\n        this.selectCell(true);\n    },\n    selectPreviousCell() {\n        this.selectCell();\n    },\n    selectParentCell() {\n        this.selectCell(false, true);\n    },\n    selectChildCell() {\n        this.selectCell(false, false, true);\n    },\n    selectCell(isNext = false, isParent = false, isChild = false) {\n        const cell = this.selectionModel.cells.length > 0 ? this.selectionModel.cells[0] : null;\n        if (this.selectionModel.cells.length > 1) {\n            this.selectionModel.clear();\n        }\n        const parent = cell ? cell.getParent() : this.getDefaultParent();\n        const childCount = parent.getChildCount();\n        if (!cell && childCount > 0) {\n            const child = parent.getChildAt(0);\n            this.setSelectionCell(child);\n        }\n        else if (parent &&\n            (!cell || isParent) &&\n            this.getView().getState(parent) &&\n            parent.getGeometry()) {\n            if (this.getCurrentRoot() !== parent) {\n                this.setSelectionCell(parent);\n            }\n        }\n        else if (cell && isChild) {\n            const tmp = cell.getChildCount();\n            if (tmp > 0) {\n                const child = cell.getChildAt(0);\n                this.setSelectionCell(child);\n            }\n        }\n        else if (childCount > 0) {\n            let i = parent.getIndex(cell);\n            if (isNext) {\n                i++;\n                const child = parent.getChildAt(i % childCount);\n                this.setSelectionCell(child);\n            }\n            else {\n                i--;\n                const index = i < 0 ? childCount - 1 : i;\n                const child = parent.getChildAt(index);\n                this.setSelectionCell(child);\n            }\n        }\n    },\n    selectAll(parent, descendants = false) {\n        parent = parent ?? this.getDefaultParent();\n        const cells = descendants\n            ? parent.filterDescendants((cell) => {\n                return cell !== parent && !!this.getView().getState(cell);\n            })\n            : parent.getChildren();\n        this.setSelectionCells(cells);\n    },\n    selectVertices(parent, selectGroups = false) {\n        this.selectCells(true, false, parent, selectGroups);\n    },\n    selectEdges(parent) {\n        this.selectCells(false, true, parent);\n    },\n    selectCells(vertices = false, edges = false, parent, selectGroups = false) {\n        parent = parent ?? this.getDefaultParent();\n        const filter = (cell) => {\n            const p = cell.getParent();\n            return (!!this.getView().getState(cell) &&\n                (((selectGroups || cell.getChildCount() === 0) &&\n                    cell.isVertex() &&\n                    vertices &&\n                    p &&\n                    !p.isEdge()) ||\n                    (cell.isEdge() && edges)));\n        };\n        const cells = parent.filterDescendants(filter);\n        this.setSelectionCells(cells);\n    },\n    selectCellForEvent(cell, evt) {\n        const isSelected = this.isCellSelected(cell);\n        if (this.isToggleEvent(evt)) {\n            if (isSelected) {\n                this.removeSelectionCell(cell);\n            }\n            else {\n                this.addSelectionCell(cell);\n            }\n        }\n        else if (!isSelected || this.getSelectionCount() !== 1) {\n            this.setSelectionCell(cell);\n        }\n    },\n    selectCellsForEvent(cells, evt) {\n        if (this.isToggleEvent(evt)) {\n            this.addSelectionCells(cells);\n        }\n        else {\n            this.setSelectionCells(cells);\n        }\n    },\n    isSiblingSelected(cell) {\n        const parent = cell.getParent();\n        const childCount = parent.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = parent.getChildAt(i);\n            if (cell !== child && this.isCellSelected(child)) {\n                return true;\n            }\n        }\n        return false;\n    },\n    /*****************************************************************************\n     * Selection state\n     *****************************************************************************/\n    getSelectionCellsForChanges(changes, ignoreFn = null) {\n        const dict = new Dictionary();\n        const cells = [];\n        const addCell = (cell) => {\n            if (!dict.get(cell) && this.getDataModel().contains(cell)) {\n                if (cell.isEdge() || cell.isVertex()) {\n                    dict.put(cell, true);\n                    cells.push(cell);\n                }\n                else {\n                    const childCount = cell.getChildCount();\n                    for (let i = 0; i < childCount; i += 1) {\n                        addCell(cell.getChildAt(i));\n                    }\n                }\n            }\n        };\n        for (let i = 0; i < changes.length; i += 1) {\n            const change = changes[i];\n            if (change.constructor !== RootChange && (!ignoreFn || !ignoreFn(change))) {\n                let cell = null;\n                if (change instanceof ChildChange) {\n                    cell = change.child;\n                }\n                else if (change.cell && change.cell instanceof Cell) {\n                    cell = change.cell;\n                }\n                if (cell) {\n                    addCell(cell);\n                }\n            }\n        }\n        return cells;\n    },\n    updateSelection() {\n        const cells = this.getSelectionCells();\n        const removed = [];\n        for (const cell of cells) {\n            if (!this.getDataModel().contains(cell) || !cell.isVisible()) {\n                removed.push(cell);\n            }\n            else {\n                let par = cell.getParent();\n                while (par && par !== this.getView().currentRoot) {\n                    if (par.isCollapsed() || !par.isVisible()) {\n                        removed.push(cell);\n                        break;\n                    }\n                    par = par.getParent();\n                }\n            }\n        }\n        this.removeSelectionCells(removed);\n    },\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4082, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4088, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/SnapMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const SnapMixin = {\n    snapTolerance: 0,\n    getSnapTolerance() {\n        return this.snapTolerance;\n    },\n    gridSize: 10,\n    gridEnabled: true,\n    snap(value) {\n        if (this.gridEnabled) {\n            value = Math.round(value / this.gridSize) * this.gridSize;\n        }\n        return value;\n    },\n    snapDelta(delta, bounds, ignoreGrid = false, ignoreHorizontal = false, ignoreVertical = false) {\n        const t = this.getView().translate;\n        const s = this.getView().scale;\n        if (!ignoreGrid && this.gridEnabled) {\n            const tol = this.gridSize * s * 0.5;\n            if (!ignoreHorizontal) {\n                const tx = bounds.x - (this.snap(bounds.x / s - t.x) + t.x) * s;\n                if (Math.abs(delta.x - tx) < tol) {\n                    delta.x = 0;\n                }\n                else {\n                    delta.x = this.snap(delta.x / s) * s - tx;\n                }\n            }\n            if (!ignoreVertical) {\n                const ty = bounds.y - (this.snap(bounds.y / s - t.y) + t.y) * s;\n                if (Math.abs(delta.y - ty) < tol) {\n                    delta.y = 0;\n                }\n                else {\n                    delta.y = this.snap(delta.y / s) * s - ty;\n                }\n            }\n        }\n        else {\n            const tol = 0.5 * s;\n            if (!ignoreHorizontal) {\n                const tx = bounds.x - (Math.round(bounds.x / s - t.x) + t.x) * s;\n                if (Math.abs(delta.x - tx) < tol) {\n                    delta.x = 0;\n                }\n                else {\n                    delta.x = Math.round(delta.x / s) * s - tx;\n                }\n            }\n            if (!ignoreVertical) {\n                const ty = bounds.y - (Math.round(bounds.y / s - t.y) + t.y) * s;\n                if (Math.abs(delta.y - ty) < tol) {\n                    delta.y = 0;\n                }\n                else {\n                    delta.y = Math.round(delta.y / s) * s - ty;\n                }\n            }\n        }\n        return delta;\n    },\n    isGridEnabled() {\n        return this.gridEnabled;\n    },\n    setGridEnabled(value) {\n        this.gridEnabled = value;\n    },\n    getGridSize() {\n        return this.gridSize;\n    },\n    setGridSize(value) {\n        this.gridSize = value;\n    },\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcA,GACA,yEAAyE;;;;AAClE,MAAM,YAAY;IACrB,eAAe;IACf;QACI,OAAO,IAAI,CAAC,aAAa;IAC7B;IACA,UAAU;IACV,aAAa;IACb,MAAK,KAAK;QACN,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,QAAQ,KAAK,KAAK,CAAC,QAAQ,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ;QAC7D;QACA,OAAO;IACX;IACA,WAAU,KAAK,EAAE,MAAM,EAAE,aAAa,KAAK,EAAE,mBAAmB,KAAK,EAAE,iBAAiB,KAAK;QACzF,MAAM,IAAI,IAAI,CAAC,OAAO,GAAG,SAAS;QAClC,MAAM,IAAI,IAAI,CAAC,OAAO,GAAG,KAAK;QAC9B,IAAI,CAAC,cAAc,IAAI,CAAC,WAAW,EAAE;YACjC,MAAM,MAAM,IAAI,CAAC,QAAQ,GAAG,IAAI;YAChC,IAAI,CAAC,kBAAkB;gBACnB,MAAM,KAAK,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI;gBAC9D,IAAI,KAAK,GAAG,CAAC,MAAM,CAAC,GAAG,MAAM,KAAK;oBAC9B,MAAM,CAAC,GAAG;gBACd,OACK;oBACD,MAAM,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,KAAK,IAAI;gBAC3C;YACJ;YACA,IAAI,CAAC,gBAAgB;gBACjB,MAAM,KAAK,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI;gBAC9D,IAAI,KAAK,GAAG,CAAC,MAAM,CAAC,GAAG,MAAM,KAAK;oBAC9B,MAAM,CAAC,GAAG;gBACd,OACK;oBACD,MAAM,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,KAAK,IAAI;gBAC3C;YACJ;QACJ,OACK;YACD,MAAM,MAAM,MAAM;YAClB,IAAI,CAAC,kBAAkB;gBACnB,MAAM,KAAK,OAAO,CAAC,GAAG,CAAC,KAAK,KAAK,CAAC,OAAO,CAAC,GAAG,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI;gBAC/D,IAAI,KAAK,GAAG,CAAC,MAAM,CAAC,GAAG,MAAM,KAAK;oBAC9B,MAAM,CAAC,GAAG;gBACd,OACK;oBACD,MAAM,CAAC,GAAG,KAAK,KAAK,CAAC,MAAM,CAAC,GAAG,KAAK,IAAI;gBAC5C;YACJ;YACA,IAAI,CAAC,gBAAgB;gBACjB,MAAM,KAAK,OAAO,CAAC,GAAG,CAAC,KAAK,KAAK,CAAC,OAAO,CAAC,GAAG,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI;gBAC/D,IAAI,KAAK,GAAG,CAAC,MAAM,CAAC,GAAG,MAAM,KAAK;oBAC9B,MAAM,CAAC,GAAG;gBACd,OACK;oBACD,MAAM,CAAC,GAAG,KAAK,KAAK,CAAC,MAAM,CAAC,GAAG,KAAK,IAAI;gBAC5C;YACJ;QACJ;QACA,OAAO;IACX;IACA;QACI,OAAO,IAAI,CAAC,WAAW;IAC3B;IACA,gBAAe,KAAK;QAChB,IAAI,CAAC,WAAW,GAAG;IACvB;IACA;QACI,OAAO,IAAI,CAAC,QAAQ;IACxB;IACA,aAAY,KAAK;QACb,IAAI,CAAC,QAAQ,GAAG;IACpB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4174, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4180, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/SwimlaneMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport { convertPoint } from '../../util/styleUtils';\nimport { mod } from '../../util/mathUtils';\nimport { DEFAULT_STARTSIZE, DIRECTION, SHAPE } from '../../util/Constants';\nimport { getClientX, getClientY } from '../../util/EventUtils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const SwimlaneMixin = {\n    swimlaneSelectionEnabled: true,\n    swimlaneNesting: true,\n    swimlaneIndicatorColorAttribute: 'fillColor',\n    getSwimlane(cell = null) {\n        while (cell && !this.isSwimlane(cell)) {\n            cell = cell.getParent();\n        }\n        return cell;\n    },\n    getSwimlaneAt(x, y, parent) {\n        if (!parent) {\n            parent = this.getCurrentRoot();\n            if (!parent) {\n                parent = this.getDataModel().getRoot();\n            }\n        }\n        if (parent) {\n            const childCount = parent.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                const child = parent.getChildAt(i);\n                if (child) {\n                    const result = this.getSwimlaneAt(x, y, child);\n                    if (result != null) {\n                        return result;\n                    }\n                    if (child.isVisible() && this.isSwimlane(child)) {\n                        const state = this.getView().getState(child);\n                        if (state && this.intersects(state, x, y)) {\n                            return child;\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    },\n    hitsSwimlaneContent(swimlane, x, y) {\n        const state = this.getView().getState(swimlane);\n        const size = this.getStartSize(swimlane);\n        if (state) {\n            const scale = this.getView().getScale();\n            x -= state.x;\n            y -= state.y;\n            if (size.width > 0 && x > 0 && x > size.width * scale) {\n                return true;\n            }\n            if (size.height > 0 && y > 0 && y > size.height * scale) {\n                return true;\n            }\n        }\n        return false;\n    },\n    getStartSize(swimlane, ignoreState = false) {\n        const result = new Rectangle();\n        const style = this.getCurrentCellStyle(swimlane, ignoreState);\n        const size = style.startSize ?? DEFAULT_STARTSIZE;\n        if (style.horizontal ?? true) {\n            result.height = size;\n        }\n        else {\n            result.width = size;\n        }\n        return result;\n    },\n    getSwimlaneDirection(style) {\n        const dir = style.direction ?? DIRECTION.EAST;\n        const flipH = style.flipH;\n        const flipV = style.flipV;\n        const h = style.horizontal ?? true;\n        let n = h ? 0 : 3;\n        if (dir === DIRECTION.NORTH) {\n            n--;\n        }\n        else if (dir === DIRECTION.WEST) {\n            n += 2;\n        }\n        else if (dir === DIRECTION.SOUTH) {\n            n += 1;\n        }\n        const _mod = mod(n, 2);\n        if (flipH && _mod === 1) {\n            n += 2;\n        }\n        if (flipV && _mod === 0) {\n            n += 2;\n        }\n        return [DIRECTION.NORTH, DIRECTION.EAST, DIRECTION.SOUTH, DIRECTION.WEST][mod(n, 4)];\n    },\n    getActualStartSize(swimlane, ignoreState = false) {\n        const result = new Rectangle();\n        if (this.isSwimlane(swimlane, ignoreState)) {\n            const style = this.getCurrentCellStyle(swimlane, ignoreState);\n            const size = style.startSize ?? DEFAULT_STARTSIZE;\n            const dir = this.getSwimlaneDirection(style);\n            if (dir === DIRECTION.NORTH) {\n                result.y = size;\n            }\n            else if (dir === DIRECTION.WEST) {\n                result.x = size;\n            }\n            else if (dir === DIRECTION.SOUTH) {\n                result.height = size;\n            }\n            else {\n                result.width = size;\n            }\n        }\n        return result;\n    },\n    isSwimlane(cell, ignoreState = false) {\n        if (cell && cell.getParent() !== this.getDataModel().getRoot() && !cell.isEdge()) {\n            return this.getCurrentCellStyle(cell, ignoreState).shape === SHAPE.SWIMLANE;\n        }\n        return false;\n    },\n    isValidDropTarget(cell, cells, evt) {\n        return (cell &&\n            ((this.isSplitEnabled() && this.isSplitTarget(cell, cells, evt)) ||\n                (!cell.isEdge() &&\n                    (this.isSwimlane(cell) || (cell.getChildCount() > 0 && !cell.isCollapsed())))));\n    },\n    getDropTarget(cells, evt, cell = null, clone = false) {\n        if (!this.isSwimlaneNesting()) {\n            for (let i = 0; i < cells.length; i += 1) {\n                if (this.isSwimlane(cells[i])) {\n                    return null;\n                }\n            }\n        }\n        const pt = convertPoint(this.getContainer(), getClientX(evt), getClientY(evt));\n        pt.x -= this.getPanDx();\n        pt.y -= this.getPanDy();\n        const swimlane = this.getSwimlaneAt(pt.x, pt.y);\n        if (!cell) {\n            cell = swimlane;\n        }\n        else if (swimlane) {\n            // Checks if the cell is an ancestor of the swimlane\n            // under the mouse and uses the swimlane in that case\n            let tmp = swimlane.getParent();\n            while (tmp && this.isSwimlane(tmp) && tmp !== cell) {\n                tmp = tmp.getParent();\n            }\n            if (tmp === cell) {\n                cell = swimlane;\n            }\n        }\n        while (cell &&\n            !this.isValidDropTarget(cell, cells, evt) &&\n            !this.getDataModel().isLayer(cell)) {\n            cell = cell.getParent();\n        }\n        // Checks if parent is dropped into child if not cloning\n        let parentCell = cell;\n        if (!clone) {\n            while (parentCell && cells.indexOf(parentCell) < 0) {\n                parentCell = parentCell.getParent();\n            }\n        }\n        return !this.getDataModel().isLayer(cell) && !parentCell ? cell : null;\n    },\n    isSwimlaneNesting() {\n        return this.swimlaneNesting;\n    },\n    setSwimlaneNesting(value) {\n        this.swimlaneNesting = value;\n    },\n    isSwimlaneSelectionEnabled() {\n        return this.swimlaneSelectionEnabled;\n    },\n    setSwimlaneSelectionEnabled(value) {\n        this.swimlaneSelectionEnabled = value;\n    },\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4375, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4381, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/TerminalMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Dictionary from '../../util/Dictionary';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const TerminalMixin = {\n    isTerminalPointMovable(cell, source) {\n        return true;\n    },\n    getOpposites(edges, terminal = null, includeSources = true, includeTargets = true) {\n        const terminals = [];\n        // Fast lookup to avoid duplicates in terminals array\n        const dict = new Dictionary();\n        for (let i = 0; i < edges.length; i += 1) {\n            const state = this.getView().getState(edges[i]);\n            const source = state\n                ? state.getVisibleTerminal(true)\n                : this.getView().getVisibleTerminal(edges[i], true);\n            const target = state\n                ? state.getVisibleTerminal(false)\n                : this.getView().getVisibleTerminal(edges[i], false);\n            // Checks if the terminal is the source of the edge and if the\n            // target should be stored in the result\n            if (source === terminal && target && target !== terminal && includeTargets) {\n                if (!dict.get(target)) {\n                    dict.put(target, true);\n                    terminals.push(target);\n                }\n            }\n            // Checks if the terminal is the taget of the edge and if the\n            // source should be stored in the result\n            else if (target === terminal && source && source !== terminal && includeSources) {\n                if (!dict.get(source)) {\n                    dict.put(source, true);\n                    terminals.push(source);\n                }\n            }\n        }\n        return terminals;\n    },\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcA;;;AACA;;AAEO,MAAM,gBAAgB;IACzB,wBAAuB,IAAI,EAAE,MAAM;QAC/B,OAAO;IACX;IACA,cAAa,KAAK,EAAE,WAAW,IAAI,EAAE,iBAAiB,IAAI,EAAE,iBAAiB,IAAI;QAC7E,MAAM,YAAY,EAAE;QACpB,qDAAqD;QACrD,MAAM,OAAO,IAAI,+JAAA,CAAA,UAAU;QAC3B,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,KAAK,EAAG;YACtC,MAAM,QAAQ,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,EAAE;YAC9C,MAAM,SAAS,QACT,MAAM,kBAAkB,CAAC,QACzB,IAAI,CAAC,OAAO,GAAG,kBAAkB,CAAC,KAAK,CAAC,EAAE,EAAE;YAClD,MAAM,SAAS,QACT,MAAM,kBAAkB,CAAC,SACzB,IAAI,CAAC,OAAO,GAAG,kBAAkB,CAAC,KAAK,CAAC,EAAE,EAAE;YAClD,8DAA8D;YAC9D,wCAAwC;YACxC,IAAI,WAAW,YAAY,UAAU,WAAW,YAAY,gBAAgB;gBACxE,IAAI,CAAC,KAAK,GAAG,CAAC,SAAS;oBACnB,KAAK,GAAG,CAAC,QAAQ;oBACjB,UAAU,IAAI,CAAC;gBACnB;YACJ,OAGK,IAAI,WAAW,YAAY,UAAU,WAAW,YAAY,gBAAgB;gBAC7E,IAAI,CAAC,KAAK,GAAG,CAAC,SAAS;oBACnB,KAAK,GAAG,CAAC,QAAQ;oBACjB,UAAU,IAAI,CAAC;gBACnB;YACJ;QACJ;QACA,OAAO;IACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4429, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4435, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/TooltipMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { htmlEntities } from '../../util/StringUtils';\nimport Translations from '../../util/Translations';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const TooltipMixin = {\n    getTooltip(state, node, x, y) {\n        let tip = null;\n        // Checks if the mouse is over the folding icon\n        if (state.control &&\n            (node === state.control.node || node.parentNode === state.control.node)) {\n            tip = this.getCollapseExpandResource();\n            tip = htmlEntities(Translations.get(tip) || tip, true).replace(/\\\\n/g, '<br>');\n        }\n        if (!tip && state.overlays) {\n            state.overlays.visit((id, shape) => {\n                // LATER: Exit loop if tip is not null\n                if (!tip && (node === shape.node || node.parentNode === shape.node)) {\n                    tip = shape.overlay ? shape.overlay.toString() ?? null : null;\n                }\n            });\n        }\n        if (!tip) {\n            const selectionCellsHandler = this.getPlugin('SelectionCellsHandler');\n            const handler = selectionCellsHandler?.getHandler(state.cell);\n            if (handler &&\n                'getTooltipForNode' in handler &&\n                typeof handler.getTooltipForNode === 'function') {\n                tip = handler.getTooltipForNode(node);\n            }\n        }\n        if (!tip) {\n            tip = this.getTooltipForCell(state.cell);\n        }\n        return tip;\n    },\n    getTooltipForCell(cell) {\n        let tip = null;\n        if (cell && 'getTooltip' in cell) {\n            // @ts-ignore getTooltip() must exists.\n            tip = cell.getTooltip();\n        }\n        else {\n            tip = this.convertValueToString(cell);\n        }\n        return tip;\n    },\n    setTooltips(enabled) {\n        const tooltipHandler = this.getPlugin('TooltipHandler');\n        tooltipHandler?.setEnabled(enabled);\n    },\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcA;;;AACA;AACA;;;AAEO,MAAM,eAAe;IACxB,YAAW,KAAK,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC;QACxB,IAAI,MAAM;QACV,+CAA+C;QAC/C,IAAI,MAAM,OAAO,IACb,CAAC,SAAS,MAAM,OAAO,CAAC,IAAI,IAAI,KAAK,UAAU,KAAK,MAAM,OAAO,CAAC,IAAI,GAAG;YACzE,MAAM,IAAI,CAAC,yBAAyB;YACpC,MAAM,CAAA,GAAA,gKAAA,CAAA,eAAY,AAAD,EAAE,iKAAA,CAAA,UAAY,CAAC,GAAG,CAAC,QAAQ,KAAK,MAAM,OAAO,CAAC,QAAQ;QAC3E;QACA,IAAI,CAAC,OAAO,MAAM,QAAQ,EAAE;YACxB,MAAM,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI;gBACtB,sCAAsC;gBACtC,IAAI,CAAC,OAAO,CAAC,SAAS,MAAM,IAAI,IAAI,KAAK,UAAU,KAAK,MAAM,IAAI,GAAG;oBACjE,MAAM,MAAM,OAAO,GAAG,MAAM,OAAO,CAAC,QAAQ,MAAM,OAAO;gBAC7D;YACJ;QACJ;QACA,IAAI,CAAC,KAAK;YACN,MAAM,wBAAwB,IAAI,CAAC,SAAS,CAAC;YAC7C,MAAM,UAAU,uBAAuB,WAAW,MAAM,IAAI;YAC5D,IAAI,WACA,uBAAuB,WACvB,OAAO,QAAQ,iBAAiB,KAAK,YAAY;gBACjD,MAAM,QAAQ,iBAAiB,CAAC;YACpC;QACJ;QACA,IAAI,CAAC,KAAK;YACN,MAAM,IAAI,CAAC,iBAAiB,CAAC,MAAM,IAAI;QAC3C;QACA,OAAO;IACX;IACA,mBAAkB,IAAI;QAClB,IAAI,MAAM;QACV,IAAI,QAAQ,gBAAgB,MAAM;YAC9B,uCAAuC;YACvC,MAAM,KAAK,UAAU;QACzB,OACK;YACD,MAAM,IAAI,CAAC,oBAAoB,CAAC;QACpC;QACA,OAAO;IACX;IACA,aAAY,OAAO;QACf,MAAM,iBAAiB,IAAI,CAAC,SAAS,CAAC;QACtC,gBAAgB,WAAW;IAC/B;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4499, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4505, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/ValidationMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Translations from '../../util/Translations';\nimport { isNode } from '../../util/domUtils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const ValidationMixin = {\n    validationAlert(message) {\n        alert(message);\n    },\n    isEdgeValid(edge, source, target) {\n        return !this.getEdgeValidationError(edge, source, target);\n    },\n    getEdgeValidationError(edge = null, source = null, target = null) {\n        if (edge && !this.isAllowDanglingEdges() && (!source || !target)) {\n            return '';\n        }\n        if (edge && !edge.getTerminal(true) && !edge.getTerminal(false)) {\n            return null;\n        }\n        // Checks if we're dealing with a loop\n        if (!this.isAllowLoops() && source === target && source) {\n            return '';\n        }\n        // Checks if the connection is generally allowed\n        if (!this.isValidConnection(source, target)) {\n            return '';\n        }\n        if (source && target) {\n            let error = '';\n            // Checks if the cells are already connected\n            // and adds an error message if required\n            if (!this.isMultigraph()) {\n                const tmp = this.getDataModel().getEdgesBetween(source, target, true);\n                // Checks if the source and target are not connected by another edge\n                if (tmp.length > 1 || (tmp.length === 1 && tmp[0] !== edge)) {\n                    error += `${Translations.get(this.getAlreadyConnectedResource()) ||\n                        this.getAlreadyConnectedResource()}\\n`;\n                }\n            }\n            // Gets the number of outgoing edges from the source\n            // and the number of incoming edges from the target\n            // without counting the edge being currently changed.\n            const sourceOut = source.getDirectedEdgeCount(true, edge);\n            const targetIn = target.getDirectedEdgeCount(false, edge);\n            // Checks the change against each multiplicity rule\n            for (const multiplicity of this.multiplicities) {\n                const err = multiplicity.check(this, // needs to cast to Graph\n                edge, source, target, sourceOut, targetIn);\n                if (err != null) {\n                    error += err;\n                }\n            }\n            // Validates the source and target terminals independently\n            const err = this.validateEdge(edge, source, target);\n            if (err != null) {\n                error += err;\n            }\n            return error.length > 0 ? error : null;\n        }\n        return this.isAllowDanglingEdges() ? null : '';\n    },\n    validateEdge(edge = null, source = null, target = null) {\n        return null;\n    },\n    validateGraph(cell = null, context) {\n        cell = cell ?? this.getDataModel().getRoot();\n        if (!cell) {\n            return 'The root does not exist!';\n        }\n        context = context ?? {};\n        let isValid = true;\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const tmp = cell.getChildAt(i);\n            let ctx = context;\n            if (this.isValidRoot(tmp)) {\n                ctx = {};\n            }\n            const warn = this.validateGraph(tmp, ctx);\n            if (warn) {\n                this.setCellWarning(tmp, warn.replace(/\\n/g, '<br>'));\n            }\n            else {\n                this.setCellWarning(tmp, null);\n            }\n            isValid = isValid && warn == null;\n        }\n        let warning = '';\n        // Adds error for invalid children if collapsed (children invisible)\n        if (cell && cell.isCollapsed() && !isValid) {\n            warning += `${Translations.get(this.getContainsValidationErrorsResource()) ||\n                this.getContainsValidationErrorsResource()}\\n`;\n        }\n        // Checks edges and cells using the defined multiplicities\n        if (cell && cell.isEdge()) {\n            warning +=\n                this.getEdgeValidationError(cell, cell.getTerminal(true), cell.getTerminal(false)) || '';\n        }\n        else {\n            warning += this.getCellValidationError(cell) || '';\n        }\n        // Checks custom validation rules\n        const err = this.validateCell(cell, context);\n        if (err != null) {\n            warning += err;\n        }\n        // Updates the display with the warning icons\n        // before any potential alerts are displayed.\n        // LATER: Move this into addCellOverlay. Redraw\n        // should check if overlay was added or removed.\n        if (cell.getParent() == null) {\n            this.getView().validate();\n        }\n        return warning.length > 0 || !isValid ? warning : null;\n    },\n    getCellValidationError(cell) {\n        const outCount = cell.getDirectedEdgeCount(true);\n        const inCount = cell.getDirectedEdgeCount(false);\n        const value = cell.getValue();\n        let error = '';\n        for (let i = 0; i < this.multiplicities.length; i += 1) {\n            const rule = this.multiplicities[i];\n            if (rule.source &&\n                isNode(value, rule.type, rule.attr, rule.value) &&\n                (outCount > rule.max || outCount < rule.min)) {\n                error += `${rule.countError}\\n`;\n            }\n            else if (!rule.source &&\n                isNode(value, rule.type, rule.attr, rule.value) &&\n                (inCount > rule.max || inCount < rule.min)) {\n                error += `${rule.countError}\\n`;\n            }\n        }\n        return error.length > 0 ? error : null;\n    },\n    validateCell(cell, context) {\n        return null;\n    },\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4649, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4655, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/VertexMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Cell from '../cell/Cell';\nimport Geometry from '../geometry/Geometry';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const VertexMixin = {\n    vertexLabelsMovable: false,\n    allowNegativeCoordinates: true,\n    isAllowNegativeCoordinates() {\n        return this.allowNegativeCoordinates;\n    },\n    setAllowNegativeCoordinates(value) {\n        this.allowNegativeCoordinates = value;\n    },\n    insertVertex(...args) {\n        let parent;\n        let id;\n        let value;\n        let x;\n        let y;\n        let width;\n        let height;\n        let style;\n        let relative;\n        let geometryClass;\n        if (args.length === 1 && typeof args[0] === 'object') {\n            const params = args[0];\n            parent = params.parent;\n            id = params.id;\n            value = params.value;\n            x = 'x' in params ? params.x : params.position?.[0];\n            y = 'y' in params ? params.y : params.position?.[1];\n            width = 'width' in params ? params.width : params.size?.[0];\n            height = 'height' in params ? params.height : params.size?.[1];\n            style = params.style;\n            relative = params.relative;\n            geometryClass = params.geometryClass;\n        }\n        else {\n            // Otherwise treat as arguments\n            [parent, id, value, x, y, width, height, style, relative, geometryClass] = args;\n        }\n        const vertex = this.createVertex(parent, id, value, x, y, width, height, style, relative, geometryClass);\n        return this.addCell(vertex, parent);\n    },\n    createVertex(_parent, id, value, x, y, width, height, style, relative = false, geometryClass = Geometry) {\n        // Creates the geometry for the vertex\n        const geometry = new geometryClass(x, y, width, height);\n        geometry.relative = relative;\n        // Creates the vertex\n        const vertex = new Cell(value, geometry, style);\n        vertex.setId(id);\n        vertex.setVertex(true);\n        vertex.setConnectable(true);\n        return vertex;\n    },\n    getChildVertices(parent) {\n        return this.getChildCells(parent, true, false);\n    },\n    isVertexLabelsMovable() {\n        return this.vertexLabelsMovable;\n    },\n    setVertexLabelsMovable(value) {\n        this.vertexLabelsMovable = value;\n    },\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcA;;;AAEA;AADA;;;AAGO,MAAM,cAAc;IACvB,qBAAqB;IACrB,0BAA0B;IAC1B;QACI,OAAO,IAAI,CAAC,wBAAwB;IACxC;IACA,6BAA4B,KAAK;QAC7B,IAAI,CAAC,wBAAwB,GAAG;IACpC;IACA,cAAa,GAAG,IAAI;QAChB,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI,KAAK,MAAM,KAAK,KAAK,OAAO,IAAI,CAAC,EAAE,KAAK,UAAU;YAClD,MAAM,SAAS,IAAI,CAAC,EAAE;YACtB,SAAS,OAAO,MAAM;YACtB,KAAK,OAAO,EAAE;YACd,QAAQ,OAAO,KAAK;YACpB,IAAI,OAAO,SAAS,OAAO,CAAC,GAAG,OAAO,QAAQ,EAAE,CAAC,EAAE;YACnD,IAAI,OAAO,SAAS,OAAO,CAAC,GAAG,OAAO,QAAQ,EAAE,CAAC,EAAE;YACnD,QAAQ,WAAW,SAAS,OAAO,KAAK,GAAG,OAAO,IAAI,EAAE,CAAC,EAAE;YAC3D,SAAS,YAAY,SAAS,OAAO,MAAM,GAAG,OAAO,IAAI,EAAE,CAAC,EAAE;YAC9D,QAAQ,OAAO,KAAK;YACpB,WAAW,OAAO,QAAQ;YAC1B,gBAAgB,OAAO,aAAa;QACxC,OACK;YACD,+BAA+B;YAC/B,CAAC,QAAQ,IAAI,OAAO,GAAG,GAAG,OAAO,QAAQ,OAAO,UAAU,cAAc,GAAG;QAC/E;QACA,MAAM,SAAS,IAAI,CAAC,YAAY,CAAC,QAAQ,IAAI,OAAO,GAAG,GAAG,OAAO,QAAQ,OAAO,UAAU;QAC1F,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ;IAChC;IACA,cAAa,OAAO,EAAE,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,WAAW,KAAK,EAAE,gBAAgB,yKAAA,CAAA,UAAQ;QACnG,sCAAsC;QACtC,MAAM,WAAW,IAAI,cAAc,GAAG,GAAG,OAAO;QAChD,SAAS,QAAQ,GAAG;QACpB,qBAAqB;QACrB,MAAM,SAAS,IAAI,iKAAA,CAAA,UAAI,CAAC,OAAO,UAAU;QACzC,OAAO,KAAK,CAAC;QACb,OAAO,SAAS,CAAC;QACjB,OAAO,cAAc,CAAC;QACtB,OAAO;IACX;IACA,kBAAiB,MAAM;QACnB,OAAO,IAAI,CAAC,aAAa,CAAC,QAAQ,MAAM;IAC5C;IACA;QACI,OAAO,IAAI,CAAC,mBAAmB;IACnC;IACA,wBAAuB,KAAK;QACxB,IAAI,CAAC,mBAAmB,GAAG;IAC/B;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4736, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4742, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/ZoomMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport { hasScrollbars } from '../../util/styleUtils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const ZoomMixin = {\n    zoomFactor: 1.2,\n    keepSelectionVisibleOnZoom: false,\n    centerZoom: true,\n    zoomIn() {\n        this.zoom(this.zoomFactor);\n    },\n    zoomOut() {\n        this.zoom(1 / this.zoomFactor);\n    },\n    zoomActual() {\n        if (this.getView().scale === 1) {\n            this.getView().setTranslate(0, 0);\n        }\n        else {\n            this.getView().translate.x = 0;\n            this.getView().translate.y = 0;\n            this.getView().setScale(1);\n        }\n    },\n    zoomTo(scale, center = false) {\n        this.zoom(scale / this.getView().scale, center);\n    },\n    zoom(factor, center) {\n        center = center ?? this.centerZoom;\n        const scale = Math.round(this.getView().scale * factor * 100) / 100;\n        const state = this.getView().getState(this.getSelectionCell());\n        const container = this.getContainer();\n        factor = scale / this.getView().scale;\n        if (this.keepSelectionVisibleOnZoom && state != null) {\n            const rect = new Rectangle(state.x * factor, state.y * factor, state.width * factor, state.height * factor);\n            // Refreshes the display only once if a scroll is carried out\n            this.getView().scale = scale;\n            if (!this.scrollRectToVisible(rect)) {\n                this.getView().revalidate();\n                // Forces an event to be fired but does not revalidate again\n                this.getView().setScale(scale);\n            }\n        }\n        else {\n            const _hasScrollbars = hasScrollbars(this.getContainer());\n            if (center && !_hasScrollbars) {\n                let dx = container.offsetWidth;\n                let dy = container.offsetHeight;\n                if (factor > 1) {\n                    const f = (factor - 1) / (scale * 2);\n                    dx *= -f;\n                    dy *= -f;\n                }\n                else {\n                    const f = (1 / factor - 1) / (this.getView().scale * 2);\n                    dx *= f;\n                    dy *= f;\n                }\n                this.getView().scaleAndTranslate(scale, this.getView().translate.x + dx, this.getView().translate.y + dy);\n            }\n            else {\n                // Allows for changes of translate and scrollbars during setscale\n                const tx = this.getView().translate.x;\n                const ty = this.getView().translate.y;\n                const sl = container.scrollLeft;\n                const st = container.scrollTop;\n                this.getView().setScale(scale);\n                if (_hasScrollbars) {\n                    let dx = 0;\n                    let dy = 0;\n                    if (center) {\n                        dx = (container.offsetWidth * (factor - 1)) / 2;\n                        dy = (container.offsetHeight * (factor - 1)) / 2;\n                    }\n                    container.scrollLeft =\n                        (this.getView().translate.x - tx) * this.getView().scale +\n                            Math.round(sl * factor + dx);\n                    container.scrollTop =\n                        (this.getView().translate.y - ty) * this.getView().scale +\n                            Math.round(st * factor + dy);\n                }\n            }\n        }\n    },\n    zoomToRect(rect) {\n        const container = this.getContainer();\n        const scaleX = container.clientWidth / rect.width;\n        const scaleY = container.clientHeight / rect.height;\n        const aspectFactor = scaleX / scaleY;\n        // Remove any overlap of the rect outside the client area\n        rect.x = Math.max(0, rect.x);\n        rect.y = Math.max(0, rect.y);\n        let rectRight = Math.min(container.scrollWidth, rect.x + rect.width);\n        let rectBottom = Math.min(container.scrollHeight, rect.y + rect.height);\n        rect.width = rectRight - rect.x;\n        rect.height = rectBottom - rect.y;\n        // The selection area has to be increased to the same aspect\n        // ratio as the container, centred around the centre point of the\n        // original rect passed in.\n        if (aspectFactor < 1.0) {\n            // Height needs increasing\n            const newHeight = rect.height / aspectFactor;\n            const deltaHeightBuffer = (newHeight - rect.height) / 2.0;\n            rect.height = newHeight;\n            // Assign up to half the buffer to the upper part of the rect, not crossing 0\n            // put the rest on the bottom\n            const upperBuffer = Math.min(rect.y, deltaHeightBuffer);\n            rect.y -= upperBuffer;\n            // Check if the bottom has extended too far\n            rectBottom = Math.min(container.scrollHeight, rect.y + rect.height);\n            rect.height = rectBottom - rect.y;\n        }\n        else {\n            // Width needs increasing\n            const newWidth = rect.width * aspectFactor;\n            const deltaWidthBuffer = (newWidth - rect.width) / 2.0;\n            rect.width = newWidth;\n            // Assign up to half the buffer to the upper part of the rect, not crossing 0\n            // put the rest on the bottom\n            const leftBuffer = Math.min(rect.x, deltaWidthBuffer);\n            rect.x -= leftBuffer;\n            // Check if the right hand side has extended too far\n            rectRight = Math.min(container.scrollWidth, rect.x + rect.width);\n            rect.width = rectRight - rect.x;\n        }\n        const scale = container.clientWidth / rect.width;\n        const newScale = this.getView().scale * scale;\n        if (!hasScrollbars(this.getContainer())) {\n            this.getView().scaleAndTranslate(newScale, this.getView().translate.x - rect.x / this.getView().scale, this.getView().translate.y - rect.y / this.getView().scale);\n        }\n        else {\n            this.getView().setScale(newScale);\n            container.scrollLeft = Math.round(rect.x * scale);\n            container.scrollTop = Math.round(rect.y * scale);\n        }\n    },\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4886, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4892, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/mixins/_graph-mixins-apply.js"],"sourcesContent":["/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { mixInto } from '../../util/Utils';\nimport { Graph } from '../Graph';\nimport { CellsMixin } from './CellsMixin';\nimport { ConnectionsMixin } from './ConnectionsMixin';\nimport { DragDropMixin } from './DragDropMixin';\nimport { EdgeMixin } from './EdgeMixin';\nimport { EditingMixin } from './EditingMixin';\nimport { EventsMixin } from './EventsMixin';\nimport { FoldingMixin } from './FoldingMixin';\nimport { GroupingMixin } from './GroupingMixin';\nimport { ImageMixin } from './ImageMixin';\nimport { LabelMixin } from './LabelMixin';\nimport { OrderMixin } from './OrderMixin';\nimport { OverlaysMixin } from './OverlaysMixin';\nimport { PageBreaksMixin } from './PageBreaksMixin';\nimport { PanningMixin } from './PanningMixin';\nimport { PortsMixin } from './PortsMixin';\nimport { SelectionMixin } from './SelectionMixin';\nimport { SnapMixin } from './SnapMixin';\nimport { SwimlaneMixin } from './SwimlaneMixin';\nimport { TerminalMixin } from './TerminalMixin';\nimport { TooltipMixin } from './TooltipMixin';\nimport { ValidationMixin } from './ValidationMixin';\nimport { VertexMixin } from './VertexMixin';\nimport { ZoomMixin } from './ZoomMixin';\nexport const applyGraphMixins = () => {\n    const mixIntoGraph = mixInto(Graph);\n    // Apply the mixins in alphabetic order to ease maintenance.\n    // The order should have no influence of the resulting Graph prototype.\n    for (const mixin of [\n        CellsMixin,\n        ConnectionsMixin,\n        DragDropMixin,\n        EdgeMixin,\n        EditingMixin,\n        EventsMixin,\n        FoldingMixin,\n        GroupingMixin,\n        ImageMixin,\n        LabelMixin,\n        OrderMixin,\n        PageBreaksMixin,\n        OverlaysMixin,\n        PanningMixin,\n        PortsMixin,\n        SelectionMixin,\n        SnapMixin,\n        SwimlaneMixin,\n        TerminalMixin,\n        TooltipMixin,\n        ValidationMixin,\n        VertexMixin,\n        ZoomMixin,\n    ]) {\n        mixIntoGraph(mixin);\n    }\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AADA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AACO,MAAM,mBAAmB;IAC5B,MAAM,eAAe,CAAA,GAAA,0JAAA,CAAA,UAAO,AAAD,EAAE,0JAAA,CAAA,QAAK;IAClC,4DAA4D;IAC5D,uEAAuE;IACvE,KAAK,MAAM,SAAS;QAChB,yKAAA,CAAA,aAAU;QACV,+KAAA,CAAA,mBAAgB;QAChB,4KAAA,CAAA,gBAAa;QACb,wKAAA,CAAA,YAAS;QACT,2KAAA,CAAA,eAAY;QACZ,0KAAA,CAAA,cAAW;QACX,2KAAA,CAAA,eAAY;QACZ,4KAAA,CAAA,gBAAa;QACb,yKAAA,CAAA,aAAU;QACV,yKAAA,CAAA,aAAU;QACV,yKAAA,CAAA,aAAU;QACV,8KAAA,CAAA,kBAAe;QACf,4KAAA,CAAA,gBAAa;QACb,2KAAA,CAAA,eAAY;QACZ,yKAAA,CAAA,aAAU;QACV,6KAAA,CAAA,iBAAc;QACd,wKAAA,CAAA,YAAS;QACT,4KAAA,CAAA,gBAAa;QACb,4KAAA,CAAA,gBAAa;QACb,2KAAA,CAAA,eAAY;QACZ,8KAAA,CAAA,kBAAe;QACf,0KAAA,CAAA,cAAW;QACX,wKAAA,CAAA,YAAS;KACZ,CAAE;QACC,aAAa;IACjB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4991, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}