{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/types.mjs"],"sourcesContent":["export const types = {\n    Point: 1,\n    Line: 2,\n    Ellipse: 3,\n    Rect: 4,\n    Polyline: 5,\n    Polygon: 6,\n    Curve: 7,\n    Path: 8\n};\n"],"names":[],"mappings":";;;AAAO,MAAM,QAAQ;IACjB,OAAO;IACP,MAAM;IACN,SAAS;IACT,MAAM;IACN,UAAU;IACV,SAAS;IACT,OAAO;IACP,MAAM;AACV","ignoreList":[0]}},
    {"offset": {"line": 20, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 26, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/geometry.helpers.mjs"],"sourcesContent":["// Declare shorthands to the most used math functions.\nconst {\n    round,\n    floor,\n    PI\n} = Math;\n\nexport const scale = {\n\n    // Return the `value` from the `domain` interval scaled to the `range` interval.\n    linear: function(domain, range, value) {\n\n        var domainSpan = domain[1] - domain[0];\n        var rangeSpan = range[1] - range[0];\n        return (((value - domain[0]) / domainSpan) * rangeSpan + range[0]) || 0;\n    }\n};\n\nexport const normalizeAngle = function(angle) {\n\n    return (angle % 360) + (angle < 0 ? 360 : 0);\n};\n\nexport const snapToGrid = function(value, gridSize) {\n\n    return gridSize * round(value / gridSize);\n};\n\nexport const toDeg = function(rad) {\n\n    return (180 * rad / PI) % 360;\n};\n\nexport const toRad = function(deg, over360) {\n\n    over360 = over360 || false;\n    deg = over360 ? deg : (deg % 360);\n    return deg * PI / 180;\n};\n\n// Return a random integer from the interval [min,max], inclusive.\nexport const random = function(min, max) {\n\n    if (max === undefined) {\n        // use first argument as max, min is 0\n        max = (min === undefined) ? 1 : min;\n        min = 0;\n\n    } else if (max < min) {\n        // switch max and min\n        const temp = min;\n        min = max;\n        max = temp;\n    }\n\n    return floor((Math.random() * (max - min + 1)) + min);\n};\n\n"],"names":[],"mappings":"AAAA,sDAAsD;;;;;;;;;AACtD,MAAM,EACF,KAAK,EACL,KAAK,EACL,EAAE,EACL,GAAG;AAEG,MAAM,QAAQ;IAEjB,gFAAgF;IAChF,QAAQ,SAAS,MAAM,EAAE,KAAK,EAAE,KAAK;QAEjC,IAAI,aAAa,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE;QACtC,IAAI,YAAY,KAAK,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE;QACnC,OAAO,AAAE,CAAC,QAAQ,MAAM,CAAC,EAAE,IAAI,aAAc,YAAY,KAAK,CAAC,EAAE,IAAK;IAC1E;AACJ;AAEO,MAAM,iBAAiB,SAAS,KAAK;IAExC,OAAO,AAAC,QAAQ,MAAO,CAAC,QAAQ,IAAI,MAAM,CAAC;AAC/C;AAEO,MAAM,aAAa,SAAS,KAAK,EAAE,QAAQ;IAE9C,OAAO,WAAW,MAAM,QAAQ;AACpC;AAEO,MAAM,QAAQ,SAAS,GAAG;IAE7B,OAAO,AAAC,MAAM,MAAM,KAAM;AAC9B;AAEO,MAAM,QAAQ,SAAS,GAAG,EAAE,OAAO;IAEtC,UAAU,WAAW;IACrB,MAAM,UAAU,MAAO,MAAM;IAC7B,OAAO,MAAM,KAAK;AACtB;AAGO,MAAM,SAAS,SAAS,GAAG,EAAE,GAAG;IAEnC,IAAI,QAAQ,WAAW;QACnB,sCAAsC;QACtC,MAAM,AAAC,QAAQ,YAAa,IAAI;QAChC,MAAM;IAEV,OAAO,IAAI,MAAM,KAAK;QAClB,qBAAqB;QACrB,MAAM,OAAO;QACb,MAAM;QACN,MAAM;IACV;IAEA,OAAO,MAAM,AAAC,KAAK,MAAM,KAAK,CAAC,MAAM,MAAM,CAAC,IAAK;AACrD","ignoreList":[0]}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 77, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/line.bearing.mjs"],"sourcesContent":["// @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n// @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\nimport { toDeg, toRad } from './geometry.helpers.mjs';\n\nconst {\n    cos,\n    sin,\n    atan2\n} = Math;\n\nexport const bearing = function(p, q) {\n\n    var lat1 = toRad(p.y);\n    var lat2 = toRad(q.y);\n    var lon1 = p.x;\n    var lon2 = q.x;\n    var dLon = toRad(lon2 - lon1);\n    var y = sin(dLon) * cos(lat2);\n    var x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);\n    var brng = toDeg(atan2(y, x));\n\n    var bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n\n    var index = brng - 22.5;\n    if (index < 0)\n        index += 360;\n    index = parseInt(index / 45);\n\n    return bearings[index];\n};\n"],"names":[],"mappings":"AAAA,iFAAiF;AACjF,gFAAgF;;;;AAChF;;AAEA,MAAM,EACF,GAAG,EACH,GAAG,EACH,KAAK,EACR,GAAG;AAEG,MAAM,UAAU,SAAS,CAAC,EAAE,CAAC;IAEhC,IAAI,OAAO,CAAA,GAAA,mKAAA,CAAA,QAAK,AAAD,EAAE,EAAE,CAAC;IACpB,IAAI,OAAO,CAAA,GAAA,mKAAA,CAAA,QAAK,AAAD,EAAE,EAAE,CAAC;IACpB,IAAI,OAAO,EAAE,CAAC;IACd,IAAI,OAAO,EAAE,CAAC;IACd,IAAI,OAAO,CAAA,GAAA,mKAAA,CAAA,QAAK,AAAD,EAAE,OAAO;IACxB,IAAI,IAAI,IAAI,QAAQ,IAAI;IACxB,IAAI,IAAI,IAAI,QAAQ,IAAI,QAAQ,IAAI,QAAQ,IAAI,QAAQ,IAAI;IAC5D,IAAI,OAAO,CAAA,GAAA,mKAAA,CAAA,QAAK,AAAD,EAAE,MAAM,GAAG;IAE1B,IAAI,WAAW;QAAC;QAAM;QAAK;QAAM;QAAK;QAAM;QAAK;QAAM;KAAI;IAE3D,IAAI,QAAQ,OAAO;IACnB,IAAI,QAAQ,GACR,SAAS;IACb,QAAQ,SAAS,QAAQ;IAEzB,OAAO,QAAQ,CAAC,MAAM;AAC1B","ignoreList":[0]}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/line.squaredLength.mjs"],"sourcesContent":["// @return {integer} length without sqrt\n// @note for applications where the exact length is not necessary (e.g. compare only)\nexport const squaredLength = function(start, end) {\n\n    var x0 = start.x;\n    var y0 = start.y;\n    var x1 = end.x;\n    var y1 = end.y;\n    return (x0 -= x1) * x0 + (y0 -= y1) * y0;\n};\n"],"names":[],"mappings":"AAAA,wCAAwC;AACxC,qFAAqF;;;;AAC9E,MAAM,gBAAgB,SAAS,KAAK,EAAE,GAAG;IAE5C,IAAI,KAAK,MAAM,CAAC;IAChB,IAAI,KAAK,MAAM,CAAC;IAChB,IAAI,KAAK,IAAI,CAAC;IACd,IAAI,KAAK,IAAI,CAAC;IACd,OAAO,CAAC,MAAM,EAAE,IAAI,KAAK,CAAC,MAAM,EAAE,IAAI;AAC1C","ignoreList":[0]}},
    {"offset": {"line": 127, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 133, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/line.length.mjs"],"sourcesContent":["import { squaredLength } from './line.squaredLength.mjs';\n\nexport const length = function(start, end) {\n    return Math.sqrt(squaredLength(start, end));\n};\n"],"names":[],"mappings":";;;AAAA;;AAEO,MAAM,SAAS,SAAS,KAAK,EAAE,GAAG;IACrC,OAAO,KAAK,IAAI,CAAC,CAAA,GAAA,qKAAA,CAAA,gBAAa,AAAD,EAAE,OAAO;AAC1C","ignoreList":[0]}},
    {"offset": {"line": 141, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 147, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/point.mjs"],"sourcesContent":["/*\n    Point is the most basic object consisting of x/y coordinate.\n\n    Possible instantiations are:\n    * `Point(10, 20)`\n    * `new Point(10, 20)`\n    * `Point('10 20')`\n    * `Point(Point(10, 20))`\n*/\nimport { normalizeAngle, random, snapToGrid, toDeg, toRad } from './geometry.helpers.mjs';\nimport { bearing } from './line.bearing.mjs';\nimport { squaredLength } from './line.squaredLength.mjs';\nimport { length } from './line.length.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    abs,\n    cos,\n    sin,\n    sqrt,\n    min,\n    max,\n    atan2,\n    round,\n    pow,\n    PI\n} = Math;\n\nexport const Point = function(x, y) {\n\n    if (!(this instanceof Point)) {\n        return new Point(x, y);\n    }\n\n    if (typeof x === 'string') {\n        var xy = x.split(x.indexOf('@') === -1 ? ' ' : '@');\n        x = parseFloat(xy[0]);\n        y = parseFloat(xy[1]);\n\n    } else if (Object(x) === x) {\n        y = x.y;\n        x = x.x;\n    }\n\n    this.x = x === undefined ? 0 : x;\n    this.y = y === undefined ? 0 : y;\n};\n\n// Alternative constructor, from polar coordinates.\n// @param {number} Distance.\n// @param {number} Angle in radians.\n// @param {point} [optional] Origin.\nPoint.fromPolar = function(distance, angle, origin) {\n\n    origin = new Point(origin);\n    var x = abs(distance * cos(angle));\n    var y = abs(distance * sin(angle));\n    var deg = normalizeAngle(toDeg(angle));\n\n    if (deg < 90) {\n        y = -y;\n\n    } else if (deg < 180) {\n        x = -x;\n        y = -y;\n\n    } else if (deg < 270) {\n        x = -x;\n    }\n\n    return new Point(origin.x + x, origin.y + y);\n};\n\n// Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\nPoint.random = function(x1, x2, y1, y2) {\n\n    return new Point(random(x1, x2), random(y1, y2));\n};\n\nPoint.prototype = {\n\n    type: types.Point,\n\n    chooseClosest: function(points) {\n\n        var n = points.length;\n        if (n === 1) return new Point(points[0]);\n        var closest = null;\n        var minSqrDistance = Infinity;\n        for (var i = 0; i < n; i++) {\n            var p = new Point(points[i]);\n            var sqrDistance = this.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                closest = p;\n                minSqrDistance = sqrDistance;\n            }\n        }\n        return closest;\n    },\n\n    // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\n    // otherwise return point itself.\n    // (see Squeak Smalltalk, Point>>adhereTo:)\n    adhereToRect: function(r) {\n\n        if (r.containsPoint(this)) {\n            return this;\n        }\n\n        this.x = min(max(this.x, r.x), r.x + r.width);\n        this.y = min(max(this.y, r.y), r.y + r.height);\n        return this;\n    },\n\n    // Compute the angle between vector from me to p1 and the vector from me to p2.\n    // ordering of points p1 and p2 is important!\n    // theta function's angle convention:\n    // returns angles between 0 and 180 when the angle is counterclockwise\n    // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones\n    // returns NaN if any of the points p1, p2 is coincident with this point\n    angleBetween: function(p1, p2) {\n\n        var angleBetween = (this.equals(p1) || this.equals(p2)) ? NaN : (this.theta(p2) - this.theta(p1));\n\n        if (angleBetween < 0) {\n            angleBetween += 360; // correction to keep angleBetween between 0 and 360\n        }\n\n        return angleBetween;\n    },\n\n    // Return the bearing between me and the given point.\n    bearing: function(point) {\n        return bearing(this, point);\n    },\n\n    // Returns change in angle from my previous position (-dx, -dy) to my new position\n    // relative to ref point.\n    changeInAngle: function(dx, dy, ref) {\n\n        // Revert the translation and measure the change in angle around x-axis.\n        return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);\n    },\n\n    clone: function() {\n\n        return new Point(this);\n    },\n\n    // Returns the cross product of this point relative to two other points\n    // this point is the common point\n    // point p1 lies on the first vector, point p2 lies on the second vector\n    // watch out for the ordering of points p1 and p2!\n    // positive result indicates a clockwise (\"right\") turn from first to second vector\n    // negative result indicates a counterclockwise (\"left\") turn from first to second vector\n    // zero indicates that the first and second vector are collinear\n    // note that the above directions are reversed from the usual answer on the Internet\n    // that is because we are in a left-handed coord system (because the y-axis points downward)\n    cross: function(p1, p2) {\n\n        return (p1 && p2) ? (((p2.x - this.x) * (p1.y - this.y)) - ((p2.y - this.y) * (p1.x - this.x))) : NaN;\n    },\n\n    difference: function(dx, dy) {\n\n        if ((Object(dx) === dx)) {\n            dy = dx.y;\n            dx = dx.x;\n        }\n\n        return new Point(this.x - (dx || 0), this.y - (dy || 0));\n    },\n\n    // Returns distance between me and point `p`.\n    distance: function(p) {\n        return length(this, p);\n    },\n\n    // Returns the dot product of this point with given other point\n    dot: function(p) {\n\n        return p ? (this.x * p.x + this.y * p.y) : NaN;\n    },\n\n    equals: function(p) {\n\n        return !!p &&\n            this.x === p.x &&\n            this.y === p.y;\n    },\n\n    // Linear interpolation\n    lerp: function(p, t) {\n\n        var x = this.x;\n        var y = this.y;\n        return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);\n    },\n\n    magnitude: function() {\n\n        return sqrt((this.x * this.x) + (this.y * this.y)) || 0.01;\n    },\n\n    // Returns a manhattan (taxi-cab) distance between me and point `p`.\n    manhattanDistance: function(p) {\n\n        return abs(p.x - this.x) + abs(p.y - this.y);\n    },\n\n    // Move point on line starting from ref ending at me by\n    // distance distance.\n    move: function(ref, distance) {\n\n        var theta = toRad((new Point(ref)).theta(this));\n        var offset = this.offset(cos(theta) * distance, -sin(theta) * distance);\n        return offset;\n    },\n\n    // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\n    normalize: function(length) {\n\n        var scale = (length || 1) / this.magnitude();\n        return this.scale(scale, scale);\n    },\n\n    // Offset me by the specified amount.\n    offset: function(dx, dy) {\n\n        if ((Object(dx) === dx)) {\n            dy = dx.y;\n            dx = dx.x;\n        }\n\n        this.x += dx || 0;\n        this.y += dy || 0;\n        return this;\n    },\n\n    // Returns a point that is the reflection of me with\n    // the center of inversion in ref point.\n    reflection: function(ref) {\n\n        return (new Point(ref)).move(this, this.distance(ref));\n    },\n\n    // Rotate point by angle around origin.\n    // Angle is flipped because this is a left-handed coord system (y-axis points downward).\n    rotate: function(origin, angle) {\n\n        if (angle === 0) return this;\n\n        origin = origin || new Point(0, 0);\n\n        angle = toRad(normalizeAngle(-angle));\n        var cosAngle = cos(angle);\n        var sinAngle = sin(angle);\n\n        var x = (cosAngle * (this.x - origin.x)) - (sinAngle * (this.y - origin.y)) + origin.x;\n        var y = (sinAngle * (this.x - origin.x)) + (cosAngle * (this.y - origin.y)) + origin.y;\n\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        return this;\n    },\n\n    // Scale point with origin.\n    scale: function(sx, sy, origin) {\n\n        origin = (origin && new Point(origin)) || new Point(0, 0);\n        this.x = origin.x + sx * (this.x - origin.x);\n        this.y = origin.y + sy * (this.y - origin.y);\n        return this;\n    },\n\n    snapToGrid: function(gx, gy) {\n\n        this.x = snapToGrid(this.x, gx);\n        this.y = snapToGrid(this.y, gy || gx);\n        return this;\n    },\n\n    squaredDistance: function(p) {\n        return squaredLength(this, p);\n    },\n\n    // Compute the angle between me and `p` and the x axis.\n    // (cartesian-to-polar coordinates conversion)\n    // Return theta angle in degrees.\n    theta: function(p) {\n\n        p = new Point(p);\n\n        // Invert the y-axis.\n        var y = -(p.y - this.y);\n        var x = p.x - this.x;\n        var rad = atan2(y, x); // defined for all 0 corner cases\n\n        // Correction for III. and IV. quadrant.\n        if (rad < 0) {\n            rad = 2 * PI + rad;\n        }\n\n        return 180 * rad / PI;\n    },\n\n    toJSON: function() {\n\n        return { x: this.x, y: this.y };\n    },\n\n    // Converts rectangular to polar coordinates.\n    // An origin can be specified, otherwise it's 0@0.\n    toPolar: function(o) {\n\n        o = (o && new Point(o)) || new Point(0, 0);\n        var x = this.x;\n        var y = this.y;\n        this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\n        this.y = toRad(o.theta(new Point(x, y)));\n        return this;\n    },\n\n    toString: function() {\n\n        return this.x + '@' + this.y;\n    },\n\n    serialize: function() {\n\n        return this.x + ',' + this.y;\n    },\n\n    update: function(x, y) {\n\n        if ((Object(x) === x)) {\n            y = x.y;\n            x = x.x;\n        }\n\n        this.x = x || 0;\n        this.y = y || 0;\n        return this;\n    },\n\n    // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.\n    // Returns NaN if p is at 0,0.\n    vectorAngle: function(p) {\n\n        var zero = new Point(0, 0);\n        return zero.angleBetween(this, p);\n    }\n};\n\nPoint.prototype.translate = Point.prototype.offset;\n\n// For backwards compatibility:\nexport const point = Point;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 438, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 444, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/ellipse.mjs"],"sourcesContent":["import { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    sqrt,\n    round,\n    pow\n} = Math;\n\nexport const Ellipse = function(c, a, b) {\n\n    if (!(this instanceof Ellipse)) {\n        return new Ellipse(c, a, b);\n    }\n\n    if (c instanceof Ellipse) {\n        return new Ellipse(new Point(c.x, c.y), c.a, c.b);\n    }\n\n    c = new Point(c);\n    this.x = c.x;\n    this.y = c.y;\n    this.a = a;\n    this.b = b;\n};\n\nEllipse.fromRect = function(rect) {\n\n    rect = new Rect(rect);\n    return new Ellipse(rect.center(), rect.width / 2, rect.height / 2);\n};\n\nEllipse.prototype = {\n\n    type: types.Ellipse,\n\n    bbox: function() {\n\n        return new Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n    },\n\n    /**\n     * @returns {g.Point}\n     */\n    center: function() {\n\n        return new Point(this.x, this.y);\n    },\n\n    clone: function() {\n\n        return new Ellipse(this);\n    },\n\n    /**\n     * @param {g.Point} p\n     * @returns {boolean}\n     */\n    containsPoint: function(p) {\n\n        return this.normalizedDistance(p) <= 1;\n    },\n\n    equals: function(ellipse) {\n\n        return !!ellipse &&\n            ellipse.x === this.x &&\n            ellipse.y === this.y &&\n            ellipse.a === this.a &&\n            ellipse.b === this.b;\n    },\n\n    // inflate by dx and dy\n    // @param dx {delta_x} representing additional size to x\n    // @param dy {delta_y} representing additional size to y -\n    // dy param is not required -> in that case y is sized by dx\n    inflate: function(dx, dy) {\n        if (dx === undefined) {\n            dx = 0;\n        }\n\n        if (dy === undefined) {\n            dy = dx;\n        }\n\n        this.a += 2 * dx;\n        this.b += 2 * dy;\n\n        return this;\n    },\n\n    intersectionWithLine: function(line) {\n\n        var intersections = [];\n        var a1 = line.start;\n        var a2 = line.end;\n        var rx = this.a;\n        var ry = this.b;\n        var dir = line.vector();\n        var diff = a1.difference(new Point(this));\n        var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n        var mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n\n        var a = dir.dot(mDir);\n        var b = dir.dot(mDiff);\n        var c = diff.dot(mDiff) - 1.0;\n        var d = b * b - a * c;\n\n        if (d < 0) {\n            return null;\n        } else if (d > 0) {\n            var root = sqrt(d);\n            var ta = (-b - root) / a;\n            var tb = (-b + root) / a;\n\n            if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {\n                // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside\n                return null;\n            } else {\n                if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));\n                if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));\n            }\n        } else {\n            var t = -b / a;\n            if (0 <= t && t <= 1) {\n                intersections.push(a1.lerp(a2, t));\n            } else {\n                // outside\n                return null;\n            }\n        }\n\n        return intersections;\n    },\n\n    // Find point on me where line from my center to\n    // point p intersects my boundary.\n    // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\n    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n        p = new Point(p);\n\n        if (angle) p.rotate(new Point(this.x, this.y), angle);\n\n        var dx = p.x - this.x;\n        var dy = p.y - this.y;\n        var result;\n\n        if (dx === 0) {\n            result = this.bbox().pointNearestToPoint(p);\n            if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n            return result;\n        }\n\n        var m = dy / dx;\n        var mSquared = m * m;\n        var aSquared = this.a * this.a;\n        var bSquared = this.b * this.b;\n\n        var x = sqrt(1 / ((1 / aSquared) + (mSquared / bSquared)));\n        x = dx < 0 ? -x : x;\n\n        var y = m * x;\n        result = new Point(this.x + x, this.y + y);\n\n        if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n        return result;\n    },\n\n    /**\n     * @param {g.Point} point\n     * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\n     */\n    normalizedDistance: function(point) {\n\n        var x0 = point.x;\n        var y0 = point.y;\n        var a = this.a;\n        var b = this.b;\n        var x = this.x;\n        var y = this.y;\n\n        return ((x0 - x) * (x0 - x)) / (a * a) + ((y0 - y) * (y0 - y)) / (b * b);\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        this.a = round(this.a * f) / f;\n        this.b = round(this.b * f) / f;\n        return this;\n    },\n\n    /** Compute angle between tangent and x axis\n     * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\n     * @returns {number} angle between tangent and x axis\n     */\n    tangentTheta: function(p) {\n\n        var refPointDelta = 30;\n        var x0 = p.x;\n        var y0 = p.y;\n        var a = this.a;\n        var b = this.b;\n        var center = this.bbox().center();\n        var m = center.x;\n        var n = center.y;\n\n        var q1 = x0 > center.x + a / 2;\n        var q3 = x0 < center.x - a / 2;\n\n        var y, x;\n        if (q1 || q3) {\n            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n            x = (a * a / (x0 - m)) - (a * a * (y0 - n) * (y - n)) / (b * b * (x0 - m)) + m;\n\n        } else {\n            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n            y = (b * b / (y0 - n)) - (b * b * (x0 - m) * (x - m)) / (a * a * (y0 - n)) + n;\n        }\n\n        return (new Point(x, y)).theta(p);\n\n    },\n\n    toString: function() {\n\n        return (new Point(this.x, this.y)).toString() + ' ' + this.a + ' ' + this.b;\n    }\n};\n\n// For backwards compatibility:\nexport const ellipse = Ellipse;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 637, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 643, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/line.mjs"],"sourcesContent":["import { Point } from './point.mjs';\nimport { Rect } from './rect.mjs';\nimport { bearing } from './line.bearing.mjs';\nimport { squaredLength } from './line.squaredLength.mjs';\nimport { length } from './line.length.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    max,\n    min\n} = Math;\n\nexport const Line = function(p1, p2) {\n\n    if (!(this instanceof Line)) {\n        return new Line(p1, p2);\n    }\n\n    if (p1 instanceof Line) {\n        return new Line(p1.start, p1.end);\n    }\n\n    this.start = new Point(p1);\n    this.end = new Point(p2);\n};\n\nLine.prototype = {\n\n    type: types.Line,\n\n    // @returns the angle of incline of the line.\n    angle: function() {\n\n        var horizontalPoint = new Point(this.start.x + 1, this.start.y);\n        return this.start.angleBetween(this.end, horizontalPoint);\n    },\n\n    bbox: function() {\n\n        var left = min(this.start.x, this.end.x);\n        var top = min(this.start.y, this.end.y);\n        var right = max(this.start.x, this.end.x);\n        var bottom = max(this.start.y, this.end.y);\n\n        return new Rect(left, top, (right - left), (bottom - top));\n    },\n\n    // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n    // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n    bearing: function() {\n        return bearing(this.start, this.end);\n    },\n\n    clone: function() {\n\n        return new Line(this.start, this.end);\n    },\n\n    // @return {point} the closest point on the line to point `p`\n    closestPoint: function(p) {\n\n        return this.pointAt(this.closestPointNormalizedLength(p));\n    },\n\n    closestPointLength: function(p) {\n\n        return this.closestPointNormalizedLength(p) * this.length();\n    },\n\n    // @return {number} the normalized length of the closest point on the line to point `p`\n    closestPointNormalizedLength: function(p) {\n\n        var product = this.vector().dot((new Line(this.start, p)).vector());\n        var cpNormalizedLength = min(1, max(0, product / this.squaredLength()));\n\n        // cpNormalizedLength returns `NaN` if this line has zero length\n        // we can work with that - if `NaN`, return 0\n        if (cpNormalizedLength !== cpNormalizedLength) return 0; // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`\n        // (`NaN` is the only value that is not equal to itself)\n\n        return cpNormalizedLength;\n    },\n\n    closestPointTangent: function(p) {\n\n        return this.tangentAt(this.closestPointNormalizedLength(p));\n    },\n\n    // Returns `true` if the point lies on the line.\n    containsPoint: function(p) {\n\n        var start = this.start;\n        var end = this.end;\n\n        if (start.cross(p, end) !== 0) return false;\n        // else: cross product of 0 indicates that this line and the vector to `p` are collinear\n\n        var length = this.length();\n        if ((new Line(start, p)).length() > length) return false;\n        if ((new Line(p, end)).length() > length) return false;\n        // else: `p` lies between start and end of the line\n\n        return true;\n    },\n\n    // Divides the line into two at requested `ratio` between 0 and 1.\n    divideAt: function(ratio) {\n\n        var dividerPoint = this.pointAt(ratio);\n\n        // return array with two lines\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end)\n        ];\n    },\n\n    // Divides the line into two at requested `length`.\n    divideAtLength: function(length) {\n\n        var dividerPoint = this.pointAtLength(length);\n\n        // return array with two new lines\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end)\n        ];\n    },\n\n    equals: function(l) {\n\n        return !!l &&\n            this.start.x === l.start.x &&\n            this.start.y === l.start.y &&\n            this.end.x === l.end.x &&\n            this.end.y === l.end.y;\n    },\n\n    // @return {point} Point where I'm intersecting a line.\n    // @return [point] Points where I'm intersecting a rectangle.\n    // @see Squeak Smalltalk, LineSegment>>intersectionWith:\n    intersect: function(shape, opt) {\n\n        if (shape && shape.intersectionWithLine) {\n            var intersection = shape.intersectionWithLine(this, opt);\n\n            // Backwards compatibility\n            if (intersection && (shape instanceof Line)) {\n                intersection = intersection[0];\n            }\n\n            return intersection;\n        }\n\n        return null;\n    },\n\n    intersectionWithLine: function(line) {\n\n        var pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n        var pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);\n        var det = (pt1Dir.x * pt2Dir.y) - (pt1Dir.y * pt2Dir.x);\n        var deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);\n        var alpha = (deltaPt.x * pt2Dir.y) - (deltaPt.y * pt2Dir.x);\n        var beta = (deltaPt.x * pt1Dir.y) - (deltaPt.y * pt1Dir.x);\n\n        if (det === 0 || alpha * det < 0 || beta * det < 0) {\n            // No intersection found.\n            return null;\n        }\n\n        if (det > 0) {\n            if (alpha > det || beta > det) {\n                return null;\n            }\n\n        } else {\n            if (alpha < det || beta < det) {\n                return null;\n            }\n        }\n\n        return [new Point(\n            this.start.x + (alpha * pt1Dir.x / det),\n            this.start.y + (alpha * pt1Dir.y / det)\n        )];\n    },\n\n    isDifferentiable: function() {\n\n        return !this.start.equals(this.end);\n    },\n\n    // @return {double} length of the line\n    length: function() {\n        return length(this.start, this.end);\n    },\n\n    // @return {point} my midpoint\n    midpoint: function() {\n\n        return new Point(\n            (this.start.x + this.end.x) / 2,\n            (this.start.y + this.end.y) / 2\n        );\n    },\n\n    parallel: function(distance) {\n        const l = this.clone();\n        if (!this.isDifferentiable()) return l;\n        const { start, end } = l;\n        const eRef = start.clone().rotate(end, 270);\n        const sRef = end.clone().rotate(start, 90);\n        start.move(sRef, distance);\n        end.move(eRef, distance);\n        return l;\n    },\n\n    // @return {point} my point at 't' <0,1>\n    pointAt: function(t) {\n\n        var start = this.start;\n        var end = this.end;\n\n        if (t <= 0) return start.clone();\n        if (t >= 1) return end.clone();\n\n        return start.lerp(end, t);\n    },\n\n    pointAtLength: function(length) {\n\n        var start = this.start;\n        var end = this.end;\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var lineLength = this.length();\n        if (length >= lineLength) return (fromStart ? end.clone() : start.clone());\n\n        return this.pointAt((fromStart ? (length) : (lineLength - length)) / lineLength);\n    },\n\n    // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\n    pointOffset: function(p) {\n\n        // Find the sign of the determinant of vectors (start,end), where p is the query point.\n        p = new Point(p);\n        var start = this.start;\n        var end = this.end;\n        var determinant = ((end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x));\n\n        return determinant / this.length();\n    },\n\n    rotate: function(origin, angle) {\n\n        this.start.rotate(origin, angle);\n        this.end.rotate(origin, angle);\n        return this;\n    },\n\n    round: function(precision) {\n\n        this.start.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.start.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    // @return {number} scale the line so that it has the requested length\n    setLength: function(length) {\n\n        var currentLength = this.length();\n        if (!currentLength) return this;\n\n        var scaleFactor = length / currentLength;\n        return this.scale(scaleFactor, scaleFactor, this.start);\n    },\n\n    // @return {integer} length without sqrt\n    // @note for applications where the exact length is not necessary (e.g. compare only)\n    squaredLength: function() {\n        return squaredLength(this.start, this.end);\n    },\n\n    tangentAt: function(t) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var start = this.start;\n        var end = this.end;\n\n        var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1\n\n        var tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    tangentAtLength: function(length) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var start = this.start;\n        var end = this.end;\n\n        var tangentStart = this.pointAtLength(length);\n\n        var tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    toString: function() {\n\n        return this.start.toString() + ' ' + this.end.toString();\n    },\n\n    serialize: function() {\n\n        return this.start.serialize() + ' ' + this.end.serialize();\n    },\n\n    translate: function(tx, ty) {\n\n        this.start.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    },\n\n    // @return vector {point} of the line\n    vector: function() {\n\n        return new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n    }\n};\n\n// For backwards compatibility:\nLine.prototype.intersection = Line.prototype.intersect;\n\n\n// For backwards compatibility:\nexport const line = Line;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 897, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 903, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/rect.mjs"],"sourcesContent":["import { toRad } from './geometry.helpers.mjs';\nimport { Line } from './line.mjs';\nimport { Point } from './point.mjs';\nimport { Ellipse } from './ellipse.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    abs,\n    cos,\n    sin,\n    min,\n    max,\n    round,\n    pow\n} = Math;\n\nexport const Rect = function(x, y, w, h) {\n\n    if (!(this instanceof Rect)) {\n        return new Rect(x, y, w, h);\n    }\n\n    if ((Object(x) === x)) {\n        y = x.y;\n        w = x.width;\n        h = x.height;\n        x = x.x;\n    }\n\n    this.x = x === undefined ? 0 : x;\n    this.y = y === undefined ? 0 : y;\n    this.width = w === undefined ? 0 : w;\n    this.height = h === undefined ? 0 : h;\n};\n\nRect.fromEllipse = function(e) {\n\n    e = new Ellipse(e);\n    return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\n};\n\nRect.fromPointUnion = function(...points) {\n\n    if (points.length === 0) return null;\n\n    const p = new Point();\n    let minX, minY, maxX, maxY;\n    minX = minY = Infinity;\n    maxX = maxY = -Infinity;\n\n    for (let i = 0; i < points.length; i++) {\n        p.update(points[i]);\n        const x = p.x;\n        const y = p.y;\n\n        if (x < minX) minX = x;\n        if (x > maxX) maxX = x;\n        if (y < minY) minY = y;\n        if (y > maxY) maxY = y;\n    }\n\n    return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\n\nRect.fromRectUnion = function(...rects) {\n\n    if (rects.length === 0) return null;\n\n    const r = new Rect();\n    let minX, minY, maxX, maxY;\n    minX = minY = Infinity;\n    maxX = maxY = -Infinity;\n\n    for (let i = 0; i < rects.length; i++) {\n        r.update(rects[i]);\n        const x = r.x;\n        const y = r.y;\n        const mX = x + r.width;\n        const mY = y + r.height;\n\n        if (x < minX) minX = x;\n        if (mX > maxX) maxX = mX;\n        if (y < minY) minY = y;\n        if (mY > maxY) maxY = mY;\n    }\n\n    return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\n\nRect.prototype = {\n\n    type: types.Rect,\n\n    // Find my bounding box when I'm rotated with the center of rotation in the center of me.\n    // @return r {rectangle} representing a bounding box\n    bbox: function(angle) {\n        return this.clone().rotateAroundCenter(angle);\n    },\n\n    rotateAroundCenter: function(angle) {\n        if (!angle) return this;\n        const { width, height } = this;\n        const theta = toRad(angle);\n        const st = abs(sin(theta));\n        const ct = abs(cos(theta));\n        const w = width * ct + height * st;\n        const h = width * st + height * ct;\n        this.x += (width - w) / 2;\n        this.y += (height - h) / 2;\n        this.width = w;\n        this.height = h;\n        return this;\n    },\n\n    bottomLeft: function() {\n\n        return new Point(this.x, this.y + this.height);\n    },\n\n    bottomLine: function() {\n\n        return new Line(this.bottomLeft(), this.bottomRight());\n    },\n\n    bottomMiddle: function() {\n\n        return new Point(this.x + this.width / 2, this.y + this.height);\n    },\n\n    center: function() {\n\n        return new Point(this.x + this.width / 2, this.y + this.height / 2);\n    },\n\n    clone: function() {\n\n        return new Rect(this);\n    },\n\n    // @return {bool} true if point p is inside me.\n    // @param {bool} strict If true, the point has to be strictly inside (not on the border).\n    containsPoint: function(p, opt) {\n        let x, y;\n        if (!p || (typeof p === 'string')) {\n            // Backwards compatibility: if the point is not provided,\n            // the point is considered to be the origin [0, 0].\n            ({ x, y } = new Point(p));\n        } else {\n            // Do not create a new Point object if the point is already a Point-like object.\n            ({ x = 0, y = 0 } = p);\n        }\n        return opt && opt.strict\n            ? (x > this.x && x < this.x + this.width && y > this.y && y < this.y + this.height)\n            : x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;\n    },\n\n    // @return {bool} true if rectangle `r` is inside me.\n    containsRect: function(r) {\n\n        var r0 = new Rect(this).normalize();\n        var r1 = new Rect(r).normalize();\n        var w0 = r0.width;\n        var h0 = r0.height;\n        var w1 = r1.width;\n        var h1 = r1.height;\n\n        if (!w0 || !h0 || !w1 || !h1) {\n            // At least one of the dimensions is 0\n            return false;\n        }\n\n        var x0 = r0.x;\n        var y0 = r0.y;\n        var x1 = r1.x;\n        var y1 = r1.y;\n\n        w1 += x1;\n        w0 += x0;\n        h1 += y1;\n        h0 += y0;\n\n        return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\n    },\n\n    corner: function() {\n\n        return new Point(this.x + this.width, this.y + this.height);\n    },\n\n    // @return {boolean} true if rectangles are equal.\n    equals: function(r) {\n\n        var mr = (new Rect(this)).normalize();\n        var nr = (new Rect(r)).normalize();\n        return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\n    },\n\n    // inflate by dx and dy, recompute origin [x, y]\n    // @param dx {delta_x} representing additional size to x\n    // @param dy {delta_y} representing additional size to y -\n    // dy param is not required -> in that case y is sized by dx\n    inflate: function(dx, dy) {\n\n        if (dx === undefined) {\n            dx = 0;\n        }\n\n        if (dy === undefined) {\n            dy = dx;\n        }\n\n        this.x -= dx;\n        this.y -= dy;\n        this.width += 2 * dx;\n        this.height += 2 * dy;\n\n        return this;\n    },\n\n    // @return {rect} if rectangles intersect, {null} if not.\n    intersect: function(r) {\n\n        var myOrigin = this.origin();\n        var myCorner = this.corner();\n        var rOrigin = r.origin();\n        var rCorner = r.corner();\n\n        // No intersection found\n        if (rCorner.x <= myOrigin.x ||\n            rCorner.y <= myOrigin.y ||\n            rOrigin.x >= myCorner.x ||\n            rOrigin.y >= myCorner.y) return null;\n\n        var x = max(myOrigin.x, rOrigin.x);\n        var y = max(myOrigin.y, rOrigin.y);\n\n        return new Rect(x, y, min(myCorner.x, rCorner.x) - x, min(myCorner.y, rCorner.y) - y);\n    },\n\n    intersectionWithLine: function(line) {\n\n        var r = this;\n        var rectLines = [r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine()];\n        var points = [];\n        var dedupeArr = [];\n        var pt, i;\n\n        var n = rectLines.length;\n        for (i = 0; i < n; i++) {\n\n            pt = line.intersect(rectLines[i]);\n            if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\n                points.push(pt);\n                dedupeArr.push(pt.toString());\n            }\n        }\n\n        return points.length > 0 ? points : null;\n    },\n\n    // Find point on my boundary where line starting\n    // from my center ending in point p intersects me.\n    // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\n    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n        p = new Point(p);\n        var center = new Point(this.x + this.width / 2, this.y + this.height / 2);\n        var result;\n\n        if (angle) p.rotate(center, angle);\n\n        // (clockwise, starting from the top side)\n        var sides = [\n            this.topLine(),\n            this.rightLine(),\n            this.bottomLine(),\n            this.leftLine()\n        ];\n        var connector = new Line(center, p);\n\n        for (var i = sides.length - 1; i >= 0; --i) {\n            var intersection = sides[i].intersection(connector);\n            if (intersection !== null) {\n                result = intersection;\n                break;\n            }\n        }\n        if (result && angle) result.rotate(center, -angle);\n        return result;\n    },\n\n    leftLine: function() {\n\n        return new Line(this.topLeft(), this.bottomLeft());\n    },\n\n    leftMiddle: function() {\n\n        return new Point(this.x, this.y + this.height / 2);\n    },\n\n    maxRectScaleToFit: function(rect, origin) {\n\n        rect = new Rect(rect);\n        origin || (origin = rect.center());\n\n        var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\n        var ox = origin.x;\n        var oy = origin.y;\n\n        // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\n        // so when the scale is applied the point is still inside the rectangle.\n\n        sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;\n\n        // Top Left\n        var p1 = rect.topLeft();\n        if (p1.x < ox) {\n            sx1 = (this.x - ox) / (p1.x - ox);\n        }\n        if (p1.y < oy) {\n            sy1 = (this.y - oy) / (p1.y - oy);\n        }\n        // Bottom Right\n        var p2 = rect.bottomRight();\n        if (p2.x > ox) {\n            sx2 = (this.x + this.width - ox) / (p2.x - ox);\n        }\n        if (p2.y > oy) {\n            sy2 = (this.y + this.height - oy) / (p2.y - oy);\n        }\n        // Top Right\n        var p3 = rect.topRight();\n        if (p3.x > ox) {\n            sx3 = (this.x + this.width - ox) / (p3.x - ox);\n        }\n        if (p3.y < oy) {\n            sy3 = (this.y - oy) / (p3.y - oy);\n        }\n        // Bottom Left\n        var p4 = rect.bottomLeft();\n        if (p4.x < ox) {\n            sx4 = (this.x - ox) / (p4.x - ox);\n        }\n        if (p4.y > oy) {\n            sy4 = (this.y + this.height - oy) / (p4.y - oy);\n        }\n\n        return {\n            sx: min(sx1, sx2, sx3, sx4),\n            sy: min(sy1, sy2, sy3, sy4)\n        };\n    },\n\n    maxRectUniformScaleToFit: function(rect, origin) {\n\n        var scale = this.maxRectScaleToFit(rect, origin);\n        return min(scale.sx, scale.sy);\n    },\n\n    // Move and expand me.\n    // @param r {rectangle} representing deltas\n    moveAndExpand: function(r) {\n\n        this.x += r.x || 0;\n        this.y += r.y || 0;\n        this.width += r.width || 0;\n        this.height += r.height || 0;\n        return this;\n    },\n\n    // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\n    // If width < 0 the function swaps the left and right corners,\n    // and it swaps the top and bottom corners if height < 0\n    // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\n    normalize: function() {\n\n        var newx = this.x;\n        var newy = this.y;\n        var newwidth = this.width;\n        var newheight = this.height;\n        if (this.width < 0) {\n            newx = this.x + this.width;\n            newwidth = -this.width;\n        }\n        if (this.height < 0) {\n            newy = this.y + this.height;\n            newheight = -this.height;\n        }\n        this.x = newx;\n        this.y = newy;\n        this.width = newwidth;\n        this.height = newheight;\n        return this;\n    },\n\n    // Offset me by the specified amount.\n    offset: function(dx, dy) {\n\n        // pretend that this is a point and call offset()\n        // rewrites x and y according to dx and dy\n        return Point.prototype.offset.call(this, dx, dy);\n    },\n\n    origin: function() {\n\n        return new Point(this.x, this.y);\n    },\n\n    // @return {point} a point on my boundary nearest to the given point.\n    // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\n    pointNearestToPoint: function(point) {\n\n        point = new Point(point);\n        if (this.containsPoint(point)) {\n            var side = this.sideNearestToPoint(point);\n            switch (side) {\n                case 'right':\n                    return new Point(this.x + this.width, point.y);\n                case 'left':\n                    return new Point(this.x, point.y);\n                case 'bottom':\n                    return new Point(point.x, this.y + this.height);\n                case 'top':\n                    return new Point(point.x, this.y);\n            }\n        }\n        return point.adhereToRect(this);\n    },\n\n    rightLine: function() {\n\n        return new Line(this.topRight(), this.bottomRight());\n    },\n\n    rightMiddle: function() {\n\n        return new Point(this.x + this.width, this.y + this.height / 2);\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        this.width = round(this.width * f) / f;\n        this.height = round(this.height * f) / f;\n        return this;\n    },\n\n    // Scale rectangle with origin.\n    scale: function(sx, sy, origin) {\n\n        origin = this.origin().scale(sx, sy, origin);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width *= sx;\n        this.height *= sy;\n        return this;\n    },\n\n    // @return {string} (left|right|top|bottom) side which is nearest to point\n    // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\n    sideNearestToPoint: function(point) {\n\n        point = new Point(point);\n        var distToLeft = point.x - this.x;\n        var distToRight = (this.x + this.width) - point.x;\n        var distToTop = point.y - this.y;\n        var distToBottom = (this.y + this.height) - point.y;\n        var closest = distToLeft;\n        var side = 'left';\n\n        if (distToRight < closest) {\n            closest = distToRight;\n            side = 'right';\n        }\n        if (distToTop < closest) {\n            closest = distToTop;\n            side = 'top';\n        }\n        if (distToBottom < closest) {\n            // closest = distToBottom;\n            side = 'bottom';\n        }\n        return side;\n    },\n\n    snapToGrid: function(gx, gy) {\n\n        var origin = this.origin().snapToGrid(gx, gy);\n        var corner = this.corner().snapToGrid(gx, gy);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width = corner.x - origin.x;\n        this.height = corner.y - origin.y;\n        return this;\n    },\n\n    toJSON: function() {\n\n        return { x: this.x, y: this.y, width: this.width, height: this.height };\n    },\n\n    topLine: function() {\n\n        return new Line(this.topLeft(), this.topRight());\n    },\n\n    topMiddle: function() {\n\n        return new Point(this.x + this.width / 2, this.y);\n    },\n\n    topRight: function() {\n\n        return new Point(this.x + this.width, this.y);\n    },\n\n    toString: function() {\n\n        return this.origin().toString() + ' ' + this.corner().toString();\n    },\n\n    // @return {rect} representing the union of both rectangles.\n    union: function(rect) {\n\n        return Rect.fromRectUnion(this, rect);\n    },\n\n    update: function(x, y, w, h) {\n\n        if ((Object(x) === x)) {\n            y = x.y;\n            w = x.width;\n            h = x.height;\n            x = x.x;\n        }\n\n        this.x = x || 0;\n        this.y = y || 0;\n        this.width = w || 0;\n        this.height = h || 0;\n        return this;\n    }\n};\n\nRect.prototype.bottomRight = Rect.prototype.corner;\n\nRect.prototype.topLeft = Rect.prototype.origin;\n\nRect.prototype.translate = Rect.prototype.offset;\n\n// For backwards compatibility:\nexport const rect = Rect;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1360, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1366, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/points.mjs"],"sourcesContent":["export function parsePoints(svgString) {\n\n    // Step 1: Discard surrounding spaces\n    const trimmedString = svgString.trim();\n    if (trimmedString === '') return [];\n\n    const points = [];\n\n    // Step 2: Split at commas (+ their surrounding spaces) or at multiple spaces\n    // ReDoS mitigation: Have an anchor at the beginning of each alternation\n    // Note: This doesn't simplify double (or more) commas - causes empty coords\n    // This regex is used by `split()`, so it doesn't need to use /g\n    const coords = trimmedString.split(/\\b\\s*,\\s*|,\\s*|\\s+/);\n\n    const numCoords = coords.length;\n    for (let i = 0; i < numCoords; i += 2) {\n        // Step 3: Convert each coord to number\n        // Note: If the coord cannot be converted to a number, it will be `NaN`\n        // Note: If the coord is empty (\"\", e.g. from \",,\" input), it will be `0`\n        // Note: If we end up with an odd number of coords, the last point's second coord will be `NaN`\n        points.push({ x: +coords[i], y: +coords[i + 1] });\n    }\n    return points;\n}\n\nexport function clonePoints(points) {\n    const numPoints = points.length;\n    if (numPoints === 0) return [];\n    const newPoints = [];\n    for (let i = 0; i < numPoints; i++) {\n        const point = points[i].clone();\n        newPoints.push(point);\n    }\n    return newPoints;\n}\n\n// Returns a convex-hull polyline from this polyline.\n// Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).\n// Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.\n// Minimal polyline is found (only vertices of the hull are reported, no collinear points).\nexport function convexHull(points) {\n\n    const { abs } = Math;\n\n    var i;\n    var n;\n\n    var numPoints = points.length;\n    if (numPoints === 0) return []; // if points array is empty\n\n    // step 1: find the starting point - point with the lowest y (if equality, highest x)\n    var startPoint;\n    for (i = 0; i < numPoints; i++) {\n        if (startPoint === undefined) {\n            // if this is the first point we see, set it as start point\n            startPoint = points[i];\n\n        } else if (points[i].y < startPoint.y) {\n            // start point should have lowest y from all points\n            startPoint = points[i];\n\n        } else if ((points[i].y === startPoint.y) && (points[i].x > startPoint.x)) {\n            // if two points have the lowest y, choose the one that has highest x\n            // there are no points to the right of startPoint - no ambiguity about theta 0\n            // if there are several coincident start point candidates, first one is reported\n            startPoint = points[i];\n        }\n    }\n\n    // step 2: sort the list of points\n    // sorting by angle between line from startPoint to point and the x-axis (theta)\n\n    // step 2a: create the point records = [point, originalIndex, angle]\n    var sortedPointRecords = [];\n    for (i = 0; i < numPoints; i++) {\n\n        var angle = startPoint.theta(points[i]);\n        if (angle === 0) {\n            angle = 360; // give highest angle to start point\n            // the start point will end up at end of sorted list\n            // the start point will end up at beginning of hull points list\n        }\n\n        var entry = [points[i], i, angle];\n        sortedPointRecords.push(entry);\n    }\n\n    // step 2b: sort the list in place\n    sortedPointRecords.sort(function(record1, record2) {\n        // returning a negative number here sorts record1 before record2\n        // if first angle is smaller than second, first angle should come before second\n\n        var sortOutput = record1[2] - record2[2];  // negative if first angle smaller\n        if (sortOutput === 0) {\n            // if the two angles are equal, sort by originalIndex\n            sortOutput = record2[1] - record1[1]; // negative if first index larger\n            // coincident points will be sorted in reverse-numerical order\n            // so the coincident points with lower original index will be considered first\n        }\n\n        return sortOutput;\n    });\n\n    // step 2c: duplicate start record from the top of the stack to the bottom of the stack\n    if (sortedPointRecords.length > 2) {\n        var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];\n        sortedPointRecords.unshift(startPointRecord);\n    }\n\n    // step 3a: go through sorted points in order and find those with right turns\n    // we want to get our results in clockwise order\n    var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull\n    var hullPointRecords = []; // stack of records with right turns - hull point candidates\n\n    var currentPointRecord;\n    var currentPoint;\n    var lastHullPointRecord;\n    var lastHullPoint;\n    var secondLastHullPointRecord;\n    var secondLastHullPoint;\n    while (sortedPointRecords.length !== 0) {\n\n        currentPointRecord = sortedPointRecords.pop();\n        currentPoint = currentPointRecord[0];\n\n        // check if point has already been discarded\n        // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'\n        if (insidePoints.hasOwnProperty(currentPointRecord[0] + '@@' + currentPointRecord[1])) {\n            // this point had an incorrect turn at some previous iteration of this loop\n            // this disqualifies it from possibly being on the hull\n            continue;\n        }\n\n        var correctTurnFound = false;\n        while (!correctTurnFound) {\n\n            if (hullPointRecords.length < 2) {\n                // not enough points for comparison, just add current point\n                hullPointRecords.push(currentPointRecord);\n                correctTurnFound = true;\n\n            } else {\n                lastHullPointRecord = hullPointRecords.pop();\n                lastHullPoint = lastHullPointRecord[0];\n                secondLastHullPointRecord = hullPointRecords.pop();\n                secondLastHullPoint = secondLastHullPointRecord[0];\n\n                var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\n                if (crossProduct < 0) {\n                    // found a right turn\n                    hullPointRecords.push(secondLastHullPointRecord);\n                    hullPointRecords.push(lastHullPointRecord);\n                    hullPointRecords.push(currentPointRecord);\n                    correctTurnFound = true;\n\n                } else if (crossProduct === 0) {\n                    // the three points are collinear\n                    // three options:\n                    // there may be a 180 or 0 degree angle at lastHullPoint\n                    // or two of the three points are coincident\n                    var THRESHOLD = 1e-10; // we have to take rounding errors into account\n                    var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n                    if (abs(angleBetween - 180) < THRESHOLD) { // rounding around 180 to 180\n                        // if the cross product is 0 because the angle is 180 degrees\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // do not do anything with current point\n                        // correct turn not found\n\n                    } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n                        // if the cross product is 0 because two points are the same\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // do not do anything with current point\n                        // correct turn not found\n\n                    } else if (abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) { // rounding around 0 and 360 to 0\n                        // if the cross product is 0 because the angle is 0 degrees\n                        // remove last hull point from hull BUT do not discard it\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // put last hull point back into the sorted point records list\n                        sortedPointRecords.push(lastHullPointRecord);\n                        // we are switching the order of the 0deg and 180deg points\n                        // correct turn not found\n                    }\n\n                } else {\n                    // found a left turn\n                    // discard last hull point (add to insidePoints)\n                    //insidePoints.unshift(lastHullPoint);\n                    insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                    // reenter second-to-last hull point (will be last at next iter of loop)\n                    hullPointRecords.push(secondLastHullPointRecord);\n                    // do not do anything with current point\n                    // correct turn not found\n                }\n            }\n        }\n    }\n    // at this point, hullPointRecords contains the output points in clockwise order\n    // the points start with lowest-y,highest-x startPoint, and end at the same point\n\n    // step 3b: remove duplicated startPointRecord from the end of the array\n    if (hullPointRecords.length > 2) {\n        hullPointRecords.pop();\n    }\n\n    // step 4: find the lowest originalIndex record and put it at the beginning of hull\n    var lowestHullIndex; // the lowest originalIndex on the hull\n    var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n    n = hullPointRecords.length;\n    for (i = 0; i < n; i++) {\n\n        var currentHullIndex = hullPointRecords[i][1];\n\n        if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n            lowestHullIndex = currentHullIndex;\n            indexOfLowestHullIndexRecord = i;\n        }\n    }\n\n    var hullPointRecordsReordered = [];\n    if (indexOfLowestHullIndexRecord > 0) {\n        var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);\n        var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);\n        hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n\n    } else {\n        hullPointRecordsReordered = hullPointRecords;\n    }\n\n    var hullPoints = [];\n    n = hullPointRecordsReordered.length;\n    for (i = 0; i < n; i++) {\n        hullPoints.push(hullPointRecordsReordered[i][0]);\n    }\n\n    return hullPoints;\n}\n"],"names":[],"mappings":";;;;;AAAO,SAAS,YAAY,SAAS;IAEjC,qCAAqC;IACrC,MAAM,gBAAgB,UAAU,IAAI;IACpC,IAAI,kBAAkB,IAAI,OAAO,EAAE;IAEnC,MAAM,SAAS,EAAE;IAEjB,6EAA6E;IAC7E,wEAAwE;IACxE,4EAA4E;IAC5E,gEAAgE;IAChE,MAAM,SAAS,cAAc,KAAK,CAAC;IAEnC,MAAM,YAAY,OAAO,MAAM;IAC/B,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,KAAK,EAAG;QACnC,uCAAuC;QACvC,uEAAuE;QACvE,yEAAyE;QACzE,+FAA+F;QAC/F,OAAO,IAAI,CAAC;YAAE,GAAG,CAAC,MAAM,CAAC,EAAE;YAAE,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE;QAAC;IACnD;IACA,OAAO;AACX;AAEO,SAAS,YAAY,MAAM;IAC9B,MAAM,YAAY,OAAO,MAAM;IAC/B,IAAI,cAAc,GAAG,OAAO,EAAE;IAC9B,MAAM,YAAY,EAAE;IACpB,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,IAAK;QAChC,MAAM,QAAQ,MAAM,CAAC,EAAE,CAAC,KAAK;QAC7B,UAAU,IAAI,CAAC;IACnB;IACA,OAAO;AACX;AAMO,SAAS,WAAW,MAAM;IAE7B,MAAM,EAAE,GAAG,EAAE,GAAG;IAEhB,IAAI;IACJ,IAAI;IAEJ,IAAI,YAAY,OAAO,MAAM;IAC7B,IAAI,cAAc,GAAG,OAAO,EAAE,EAAE,2BAA2B;IAE3D,qFAAqF;IACrF,IAAI;IACJ,IAAK,IAAI,GAAG,IAAI,WAAW,IAAK;QAC5B,IAAI,eAAe,WAAW;YAC1B,2DAA2D;YAC3D,aAAa,MAAM,CAAC,EAAE;QAE1B,OAAO,IAAI,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG,WAAW,CAAC,EAAE;YACnC,mDAAmD;YACnD,aAAa,MAAM,CAAC,EAAE;QAE1B,OAAO,IAAI,AAAC,MAAM,CAAC,EAAE,CAAC,CAAC,KAAK,WAAW,CAAC,IAAM,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG,WAAW,CAAC,EAAG;YACvE,qEAAqE;YACrE,8EAA8E;YAC9E,gFAAgF;YAChF,aAAa,MAAM,CAAC,EAAE;QAC1B;IACJ;IAEA,kCAAkC;IAClC,gFAAgF;IAEhF,oEAAoE;IACpE,IAAI,qBAAqB,EAAE;IAC3B,IAAK,IAAI,GAAG,IAAI,WAAW,IAAK;QAE5B,IAAI,QAAQ,WAAW,KAAK,CAAC,MAAM,CAAC,EAAE;QACtC,IAAI,UAAU,GAAG;YACb,QAAQ,KAAK,oCAAoC;QACjD,oDAAoD;QACpD,+DAA+D;QACnE;QAEA,IAAI,QAAQ;YAAC,MAAM,CAAC,EAAE;YAAE;YAAG;SAAM;QACjC,mBAAmB,IAAI,CAAC;IAC5B;IAEA,kCAAkC;IAClC,mBAAmB,IAAI,CAAC,SAAS,OAAO,EAAE,OAAO;QAC7C,gEAAgE;QAChE,+EAA+E;QAE/E,IAAI,aAAa,OAAO,CAAC,EAAE,GAAG,OAAO,CAAC,EAAE,EAAG,kCAAkC;QAC7E,IAAI,eAAe,GAAG;YAClB,qDAAqD;YACrD,aAAa,OAAO,CAAC,EAAE,GAAG,OAAO,CAAC,EAAE,EAAE,iCAAiC;QACvE,8DAA8D;QAC9D,8EAA8E;QAClF;QAEA,OAAO;IACX;IAEA,uFAAuF;IACvF,IAAI,mBAAmB,MAAM,GAAG,GAAG;QAC/B,IAAI,mBAAmB,kBAAkB,CAAC,mBAAmB,MAAM,GAAG,EAAE;QACxE,mBAAmB,OAAO,CAAC;IAC/B;IAEA,6EAA6E;IAC7E,gDAAgD;IAChD,IAAI,eAAe,CAAC,GAAG,+DAA+D;IACtF,IAAI,mBAAmB,EAAE,EAAE,4DAA4D;IAEvF,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,MAAO,mBAAmB,MAAM,KAAK,EAAG;QAEpC,qBAAqB,mBAAmB,GAAG;QAC3C,eAAe,kBAAkB,CAAC,EAAE;QAEpC,4CAA4C;QAC5C,gFAAgF;QAChF,IAAI,aAAa,cAAc,CAAC,kBAAkB,CAAC,EAAE,GAAG,OAAO,kBAAkB,CAAC,EAAE,GAAG;YAGnF;QACJ;QAEA,IAAI,mBAAmB;QACvB,MAAO,CAAC,iBAAkB;YAEtB,IAAI,iBAAiB,MAAM,GAAG,GAAG;gBAC7B,2DAA2D;gBAC3D,iBAAiB,IAAI,CAAC;gBACtB,mBAAmB;YAEvB,OAAO;gBACH,sBAAsB,iBAAiB,GAAG;gBAC1C,gBAAgB,mBAAmB,CAAC,EAAE;gBACtC,4BAA4B,iBAAiB,GAAG;gBAChD,sBAAsB,yBAAyB,CAAC,EAAE;gBAElD,IAAI,eAAe,oBAAoB,KAAK,CAAC,eAAe;gBAE5D,IAAI,eAAe,GAAG;oBAClB,qBAAqB;oBACrB,iBAAiB,IAAI,CAAC;oBACtB,iBAAiB,IAAI,CAAC;oBACtB,iBAAiB,IAAI,CAAC;oBACtB,mBAAmB;gBAEvB,OAAO,IAAI,iBAAiB,GAAG;oBAC3B,iCAAiC;oBACjC,iBAAiB;oBACjB,wDAAwD;oBACxD,4CAA4C;oBAC5C,IAAI,YAAY,OAAO,+CAA+C;oBACtE,IAAI,eAAe,cAAc,YAAY,CAAC,qBAAqB;oBACnE,IAAI,IAAI,eAAe,OAAO,WAAW;wBACrC,6DAA6D;wBAC7D,gDAAgD;wBAChD,sCAAsC;wBACtC,YAAY,CAAC,mBAAmB,CAAC,EAAE,GAAG,OAAO,mBAAmB,CAAC,EAAE,CAAC,GAAG;wBACvE,gEAAgE;wBAChE,iBAAiB,IAAI,CAAC;oBACtB,wCAAwC;oBACxC,yBAAyB;oBAE7B,OAAO,IAAI,cAAc,MAAM,CAAC,iBAAiB,oBAAoB,MAAM,CAAC,gBAAgB;wBACxF,4DAA4D;wBAC5D,gDAAgD;wBAChD,sCAAsC;wBACtC,YAAY,CAAC,mBAAmB,CAAC,EAAE,GAAG,OAAO,mBAAmB,CAAC,EAAE,CAAC,GAAG;wBACvE,gEAAgE;wBAChE,iBAAiB,IAAI,CAAC;oBACtB,wCAAwC;oBACxC,yBAAyB;oBAE7B,OAAO,IAAI,IAAI,AAAC,CAAC,eAAe,CAAC,IAAI,MAAO,KAAK,WAAW;wBACxD,2DAA2D;wBAC3D,yDAAyD;wBACzD,gEAAgE;wBAChE,iBAAiB,IAAI,CAAC;wBACtB,8DAA8D;wBAC9D,mBAAmB,IAAI,CAAC;oBACxB,2DAA2D;oBAC3D,yBAAyB;oBAC7B;gBAEJ,OAAO;oBACH,oBAAoB;oBACpB,gDAAgD;oBAChD,sCAAsC;oBACtC,YAAY,CAAC,mBAAmB,CAAC,EAAE,GAAG,OAAO,mBAAmB,CAAC,EAAE,CAAC,GAAG;oBACvE,wEAAwE;oBACxE,iBAAiB,IAAI,CAAC;gBACtB,wCAAwC;gBACxC,yBAAyB;gBAC7B;YACJ;QACJ;IACJ;IACA,gFAAgF;IAChF,iFAAiF;IAEjF,wEAAwE;IACxE,IAAI,iBAAiB,MAAM,GAAG,GAAG;QAC7B,iBAAiB,GAAG;IACxB;IAEA,mFAAmF;IACnF,IAAI,iBAAiB,uCAAuC;IAC5D,IAAI,+BAA+B,CAAC,GAAG,+CAA+C;IACtF,IAAI,iBAAiB,MAAM;IAC3B,IAAK,IAAI,GAAG,IAAI,GAAG,IAAK;QAEpB,IAAI,mBAAmB,gBAAgB,CAAC,EAAE,CAAC,EAAE;QAE7C,IAAI,oBAAoB,aAAa,mBAAmB,iBAAiB;YACrE,kBAAkB;YAClB,+BAA+B;QACnC;IACJ;IAEA,IAAI,4BAA4B,EAAE;IAClC,IAAI,+BAA+B,GAAG;QAClC,IAAI,gBAAgB,iBAAiB,KAAK,CAAC;QAC3C,IAAI,iBAAiB,iBAAiB,KAAK,CAAC,GAAG;QAC/C,4BAA4B,cAAc,MAAM,CAAC;IAErD,OAAO;QACH,4BAA4B;IAChC;IAEA,IAAI,aAAa,EAAE;IACnB,IAAI,0BAA0B,MAAM;IACpC,IAAK,IAAI,GAAG,IAAI,GAAG,IAAK;QACpB,WAAW,IAAI,CAAC,yBAAyB,CAAC,EAAE,CAAC,EAAE;IACnD;IAEA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1578, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1584, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/extend.mjs"],"sourcesContent":["// Local helper function.\n// Add properties from arguments on top of properties from `obj`.\n// This allows for rudimentary inheritance.\n// - The `obj` argument acts as parent.\n// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.\n// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.\nexport function extend(obj) {\n    // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.\n    // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)\n    // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?\n    // - First, realize that both of those quasiclasses would still have their own separate constructor function.\n    // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.\n    // - This method provides a way to do exactly that.\n    // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.\n    // - Therefore, to continue with the example above:\n    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`\n    //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.\n    //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.\n    //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.\n    // - Multiple inheritance is also possible, if multiple arguments are provided.\n    // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?\n    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`\n    //   - The ancestors are applied in order of appearance.\n    //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.\n    //   - Any number of ancestors may be provided.\n    // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.\n    // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).\n    //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.\n    //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.\n    // - Therefore, both of the following are valid:\n    //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`\n    //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`\n\n    var i;\n    var n;\n\n    var args = [];\n    n = arguments.length;\n    for (i = 1; i < n; i++) { // skip over obj\n        args.push(arguments[i]);\n    }\n\n    if (!obj) throw new Error('Missing a parent object.');\n    var child = Object.create(obj);\n\n    n = args.length;\n    for (i = 0; i < n; i++) {\n\n        var src = args[i];\n\n        var inheritedProperty;\n        var key;\n        for (key in src) {\n\n            if (src.hasOwnProperty(key)) {\n                delete child[key]; // delete property inherited from parent\n                inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src\n                Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)\n            }\n        }\n    }\n\n    return child;\n}\n"],"names":[],"mappings":"AAAA,yBAAyB;AACzB,iEAAiE;AACjE,2CAA2C;AAC3C,uCAAuC;AACvC,iIAAiI;AACjI,iHAAiH;;;;AAC1G,SAAS,OAAO,GAAG;IACtB,wKAAwK;IACxK,wHAAwH;IACxH,wIAAwI;IACxI,6GAA6G;IAC7G,wHAAwH;IACxH,mDAAmD;IACnD,8JAA8J;IAC9J,mDAAmD;IACnD,6EAA6E;IAC7E,2GAA2G;IAC3G,6KAA6K;IAC7K,qFAAqF;IACrF,+EAA+E;IAC/E,oIAAoI;IACpI,uGAAuG;IACvG,wDAAwD;IACxD,6HAA6H;IAC7H,+CAA+C;IAC/C,0JAA0J;IAC1J,wKAAwK;IACxK,8GAA8G;IAC9G,+GAA+G;IAC/G,gDAAgD;IAChD,qFAAqF;IACrF,qEAAqE;IAErE,IAAI;IACJ,IAAI;IAEJ,IAAI,OAAO,EAAE;IACb,IAAI,UAAU,MAAM;IACpB,IAAK,IAAI,GAAG,IAAI,GAAG,IAAK;QACpB,KAAK,IAAI,CAAC,SAAS,CAAC,EAAE;IAC1B;IAEA,IAAI,CAAC,KAAK,MAAM,IAAI,MAAM;IAC1B,IAAI,QAAQ,OAAO,MAAM,CAAC;IAE1B,IAAI,KAAK,MAAM;IACf,IAAK,IAAI,GAAG,IAAI,GAAG,IAAK;QAEpB,IAAI,MAAM,IAAI,CAAC,EAAE;QAEjB,IAAI;QACJ,IAAI;QACJ,IAAK,OAAO,IAAK;YAEb,IAAI,IAAI,cAAc,CAAC,MAAM;gBACzB,OAAO,KAAK,CAAC,IAAI,EAAE,wCAAwC;gBAC3D,oBAAoB,OAAO,wBAAwB,CAAC,KAAK,MAAM,0CAA0C;gBACzG,OAAO,cAAc,CAAC,OAAO,KAAK,oBAAoB,uEAAuE;YACjI;QACJ;IACJ;IAEA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1643, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1649, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/polyline.mjs"],"sourcesContent":["import { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { Line } from './line.mjs';\nimport { types } from './types.mjs';\nimport { clonePoints, parsePoints, convexHull } from './points.mjs';\n\n\nexport const Polyline = function(points) {\n\n    if (!(this instanceof Polyline)) {\n        return new Polyline(points);\n    }\n\n    if (typeof points === 'string') {\n        return new Polyline.parse(points);\n    }\n\n    this.points = (Array.isArray(points) ? points.map(Point) : []);\n};\n\nPolyline.parse = function(svgString) {\n    return new Polyline(parsePoints(svgString));\n};\n\nPolyline.fromRect = function(rect) {\n    return new Polyline([\n        rect.topLeft(),\n        rect.topRight(),\n        rect.bottomRight(),\n        rect.bottomLeft(),\n        rect.topLeft(),\n    ]);\n};\n\nPolyline.prototype = {\n\n    type: types.Polyline,\n\n    bbox: function() {\n\n        var x1 = Infinity;\n        var x2 = -Infinity;\n        var y1 = Infinity;\n        var y2 = -Infinity;\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            var x = point.x;\n            var y = point.y;\n\n            if (x < x1) x1 = x;\n            if (x > x2) x2 = x;\n            if (y < y1) y1 = y;\n            if (y > y2) y2 = y;\n        }\n\n        return new Rect(x1, y1, x2 - x1, y2 - y1);\n    },\n\n    clone: function() {\n        return new Polyline(clonePoints(this.points));\n    },\n\n    closestPoint: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n\n        return this.pointAtLength(cpLength);\n    },\n\n    closestPointLength: function(p) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return 0; // if points array is empty\n        if (numPoints === 1) return 0; // if there is only one point\n\n        var cpLength;\n        var minSqrDistance = Infinity;\n        var length = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n\n            var line = new Line(points[i], points[i + 1]);\n            var lineLength = line.length();\n\n            var cpNormalizedLength = line.closestPointNormalizedLength(p);\n            var cp = line.pointAt(cpNormalizedLength);\n\n            var sqrDistance = cp.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                minSqrDistance = sqrDistance;\n                cpLength = length + (cpNormalizedLength * lineLength);\n            }\n\n            length += lineLength;\n        }\n\n        return cpLength;\n    },\n\n    closestPointNormalizedLength: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n        if (cpLength === 0) return 0; // shortcut\n\n        var length = this.length();\n        if (length === 0) return 0; // prevents division by zero\n\n        return cpLength / length;\n    },\n\n    closestPointTangent: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n\n        return this.tangentAtLength(cpLength);\n    },\n\n    // Returns `true` if the area surrounded by the polyline contains the point `p`.\n    // Implements the even-odd SVG algorithm (self-intersections are \"outside\").\n    // (Uses horizontal rays to the right of `p` to look for intersections.)\n    // Closes open polylines (always imagines a final closing segment).\n    containsPoint: function(p) {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return false; // shortcut (this polyline has no points)\n\n        var x = p.x;\n        var y = p.y;\n\n        // initialize a final closing segment by creating one from last-first points on polyline\n        var startIndex = numPoints - 1; // start of current polyline segment\n        var endIndex = 0; // end of current polyline segment\n        var numIntersections = 0;\n        var segment = new Line();\n        var ray = new Line();\n        var rayEnd = new Point();\n        for (; endIndex < numPoints; endIndex++) {\n            var start = points[startIndex];\n            var end = points[endIndex];\n            if (p.equals(start)) return true; // shortcut (`p` is a point on polyline)\n            // current polyline segment\n            segment.start = start;\n            segment.end = end;\n            if (segment.containsPoint(p)) return true; // shortcut (`p` lies on a polyline segment)\n\n            // do we have an intersection?\n            if (((y <= start.y) && (y > end.y)) || ((y > start.y) && (y <= end.y))) {\n                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n                // (when `y === start.y === end.y`)\n                // this conditional branch IS entered when `segment` touches `ray` at only one point\n                // (e.g. when `y === start.y !== end.y`)\n                // since this branch is entered again for the following segment, the two touches cancel out\n\n                var xDifference = (((start.x - x) > (end.x - x)) ? (start.x - x) : (end.x - x));\n                if (xDifference >= 0) {\n                    // segment lies at least partially to the right of `p`\n                    rayEnd.x = x + xDifference;\n                    rayEnd.y = y; // right\n                    ray.start = p;\n                    ray.end = rayEnd;\n                    if (segment.intersect(ray)) {\n                        // an intersection was detected to the right of `p`\n                        numIntersections++;\n                    }\n                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n            }\n\n            // move to check the next polyline segment\n            startIndex = endIndex;\n        }\n\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return ((numIntersections % 2) === 1);\n    },\n\n    close: function() {\n        const { start, end, points } = this;\n        if (start && end && !start.equals(end)) {\n            points.push(start.clone());\n        }\n        return this;\n    },\n\n    lengthPoints: function() {\n        return this.points;\n    },\n\n    convexHull: function() {\n        return new Polyline(convexHull(this.points));\n    },\n\n    // Checks whether two polylines are exactly the same.\n    // If `p` is undefined or null, returns false.\n    equals: function(p) {\n\n        if (!p) return false;\n\n        var points = this.points;\n        var otherPoints = p.points;\n\n        var numPoints = points.length;\n        if (otherPoints.length !== numPoints) return false; // if the two polylines have different number of points, they cannot be equal\n\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            var otherPoint = p.points[i];\n\n            // as soon as an inequality is found in points, return false\n            if (!point.equals(otherPoint)) return false;\n        }\n\n        // if no inequality found in points, return true\n        return true;\n    },\n\n    intersectionWithLine: function(l) {\n        var line = new Line(l);\n        var intersections = [];\n        var points = this.lengthPoints();\n        var l2 = new Line();\n        for (var i = 0, n = points.length - 1; i < n; i++) {\n            l2.start = points[i];\n            l2.end = points[i + 1];\n            var int = line.intersectionWithLine(l2);\n            if (int) intersections.push(int[0]);\n        }\n        return (intersections.length > 0) ? intersections : null;\n    },\n\n    isDifferentiable: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return false;\n\n        var line = new Line();\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            line.start = points[i];\n            line.end = points[i + 1];\n            // as soon as a differentiable line is found between two points, return true\n            if (line.isDifferentiable()) return true;\n        }\n\n        // if no differentiable line is found between pairs of points, return false\n        return false;\n    },\n\n    length: function() {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return 0; // if points array is empty\n\n        var length = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            length += points[i].distance(points[i + 1]);\n        }\n\n        return length;\n    },\n\n    pointAt: function(ratio) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n        if (ratio <= 0) return points[0].clone();\n        if (ratio >= 1) return points[numPoints - 1].clone();\n\n        var polylineLength = this.length();\n        var length = polylineLength * ratio;\n\n        return this.pointAtLength(length);\n    },\n\n    pointAtLength: function(length) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var l = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var a = points[index];\n            var b = points[index + 1];\n            var line = new Line(a, b);\n            var d = a.distance(b);\n\n            if (length <= (l + d)) {\n                return line.pointAtLength((fromStart ? 1 : -1) * (length - l));\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the polyline, return last endpoint\n        var lastPoint = (fromStart ? points[numPoints - 1] : points[0]);\n        return lastPoint.clone();\n    },\n\n    round: function(precision) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].round(precision);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].scale(sx, sy, origin);\n        }\n\n        return this;\n    },\n\n    simplify: function(opt = {}) {\n\n        const points = this.points;\n        if (points.length < 3) return this; // we need at least 3 points\n\n        // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification\n\n        // Due to the nature of the algorithm, we do not use 0 as the default value for `threshold`\n        // because of the rounding errors that can occur when comparing distances.\n        const threshold = opt.threshold || 1e-10; // = max distance of middle point from chord to be simplified\n\n        // start at the beginning of the polyline and go forward\n        let currentIndex = 0;\n        // we need at least one intermediate point (3 points) in every iteration\n        // as soon as that stops being true, we know we reached the end of the polyline\n        while (points[currentIndex + 2]) {\n            const firstIndex = currentIndex;\n            const middleIndex = (currentIndex + 1);\n            const lastIndex = (currentIndex + 2);\n\n            const firstPoint = points[firstIndex];\n            const middlePoint = points[middleIndex];\n            const lastPoint = points[lastIndex];\n\n            const chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n            const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n            const closestPointDistance = closestPoint.distance(middlePoint);\n            if (closestPointDistance <= threshold) {\n                // middle point is close enough to the chord = simplify\n                // 1) remove middle point:\n                points.splice(middleIndex, 1);\n                // 2) in next iteration, investigate the newly-created triplet of points\n                //    - do not change `currentIndex`\n                //    = (first point stays, point after removed point becomes middle point)\n            } else {\n                // middle point is far from the chord\n                // 1) preserve middle point\n                // 2) in next iteration, move `currentIndex` by one step:\n                currentIndex += 1;\n                //    = (point after first point becomes first point)\n            }\n        }\n\n        // `points` array was modified in-place\n        return this;\n    },\n\n    tangentAt: function(ratio) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return null; // if there is only one point\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        var polylineLength = this.length();\n        var length = polylineLength * ratio;\n\n        return this.tangentAtLength(length);\n    },\n\n    tangentAtLength: function(length) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return null; // if there is only one point\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var lastValidLine; // differentiable (with a tangent)\n        var l = 0; // length so far\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var a = points[index];\n            var b = points[index + 1];\n            var line = new Line(a, b);\n            var d = a.distance(b);\n\n            if (line.isDifferentiable()) { // has a tangent line (line length is not 0)\n                if (length <= (l + d)) {\n                    return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));\n                }\n\n                lastValidLine = line;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the polyline, return last valid endpoint\n        if (lastValidLine) {\n            var ratio = (fromStart ? 1 : 0);\n            return lastValidLine.tangentAt(ratio);\n        }\n\n        // if no valid line, return null\n        return null;\n    },\n\n    toString: function() {\n\n        return this.points + '';\n    },\n\n    translate: function(tx, ty) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].translate(tx, ty);\n        }\n\n        return this;\n    },\n\n    // Return svgString that can be used to recreate this line.\n    serialize: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return ''; // if points array is empty\n\n        var output = '';\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            output += point.x + ',' + point.y + ' ';\n        }\n\n        return output.trim();\n    }\n};\n\nObject.defineProperty(Polyline.prototype, 'start', {\n    // Getter for the first point of the polyline.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        return this.points[0];\n    },\n});\n\nObject.defineProperty(Polyline.prototype, 'end', {\n    // Getter for the last point of the polyline.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        return this.points[numPoints - 1];\n    },\n});\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2050, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2056, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/polygon.mjs"],"sourcesContent":["import { Point } from './point.mjs';\nimport { Polyline } from './polyline.mjs';\nimport { extend } from './extend.mjs';\nimport { types } from './types.mjs';\nimport { clonePoints, parsePoints, convexHull } from './points.mjs';\n\nexport const Polygon = function(points) {\n\n    if (!(this instanceof Polygon)) {\n        return new Polygon(points);\n    }\n\n    if (typeof points === 'string') {\n        return new Polygon.parse(points);\n    }\n\n    this.points = (Array.isArray(points) ? points.map(Point) : []);\n};\n\nPolygon.parse = function(svgString) {\n    return new Polygon(parsePoints(svgString));\n};\n\nPolygon.fromRect = function(rect) {\n    return new Polygon([\n        rect.topLeft(),\n        rect.topRight(),\n        rect.bottomRight(),\n        rect.bottomLeft()\n    ]);\n};\n\nPolygon.prototype = extend(Polyline.prototype, {\n\n    type: types.Polygon,\n\n    clone: function() {\n        return new Polygon(clonePoints(this.points));\n    },\n\n    convexHull: function() {\n        return new Polygon(convexHull(this.points));\n    },\n\n    lengthPoints: function() {\n        const { start, end, points } = this;\n        if (points.length <= 1 || start.equals(end)) return points;\n        return [...points, start.clone()];\n    }\n\n});\n"],"names":[],"mappings":";;;AAAA;AAIA;AAFA;AADA;AAEA;;;;;;AAGO,MAAM,UAAU,SAAS,MAAM;IAElC,IAAI,CAAC,CAAC,IAAI,YAAY,OAAO,GAAG;QAC5B,OAAO,IAAI,QAAQ;IACvB;IAEA,IAAI,OAAO,WAAW,UAAU;QAC5B,OAAO,IAAI,QAAQ,KAAK,CAAC;IAC7B;IAEA,IAAI,CAAC,MAAM,GAAI,MAAM,OAAO,CAAC,UAAU,OAAO,GAAG,CAAC,qJAAA,CAAA,QAAK,IAAI,EAAE;AACjE;AAEA,QAAQ,KAAK,GAAG,SAAS,SAAS;IAC9B,OAAO,IAAI,QAAQ,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD,EAAE;AACnC;AAEA,QAAQ,QAAQ,GAAG,SAAS,IAAI;IAC5B,OAAO,IAAI,QAAQ;QACf,KAAK,OAAO;QACZ,KAAK,QAAQ;QACb,KAAK,WAAW;QAChB,KAAK,UAAU;KAClB;AACL;AAEA,QAAQ,SAAS,GAAG,CAAA,GAAA,sJAAA,CAAA,SAAM,AAAD,EAAE,wJAAA,CAAA,WAAQ,CAAC,SAAS,EAAE;IAE3C,MAAM,qJAAA,CAAA,QAAK,CAAC,OAAO;IAEnB,OAAO;QACH,OAAO,IAAI,QAAQ,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD,EAAE,IAAI,CAAC,MAAM;IAC9C;IAEA,YAAY;QACR,OAAO,IAAI,QAAQ,CAAA,GAAA,sJAAA,CAAA,aAAU,AAAD,EAAE,IAAI,CAAC,MAAM;IAC7C;IAEA,cAAc;QACV,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,IAAI;QACnC,IAAI,OAAO,MAAM,IAAI,KAAK,MAAM,MAAM,CAAC,MAAM,OAAO;QACpD,OAAO;eAAI;YAAQ,MAAM,KAAK;SAAG;IACrC;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 2106, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2112, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/intersection.mjs"],"sourcesContent":["import { Line } from './line.mjs';\nimport { Polygon } from './polygon.mjs';\nimport { Rect } from './rect.mjs';\nimport { types } from './types.mjs';\n\nexport function exists(shape1, shape2, shape1opt, shape2opt) {\n    switch (shape1.type) {\n        case types.Line: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return lineWithLine(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case types.Ellipse: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return ellipseWithLine(shape1, shape2);\n                }\n                case types.Ellipse: {\n                    return ellipseWithEllipse(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case types.Rect: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return rectWithLine(shape1, shape2);\n                }\n                case types.Ellipse: {\n                    return rectWithEllipse(shape1, shape2);\n                }\n                case types.Rect: {\n                    return rectWithRect(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case types.Polyline: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return polylineWithLine(shape1, shape2);\n                }\n                case types.Ellipse: {\n                    return polylineWithEllipse(shape1, shape2);\n                }\n                case types.Rect: {\n                    return polylineWithRect(shape1, shape2);\n                }\n                case types.Polyline: {\n                    return polylineWithPolyline(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case types.Polygon: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return polygonWithLine(shape1, shape2);\n                }\n                case types.Ellipse: {\n                    return polygonWithEllipse(shape1, shape2);\n                }\n                case types.Rect: {\n                    return polygonWithRect(shape1, shape2);\n                }\n                case types.Polyline: {\n                    return polygonWithPolyline(shape1, shape2);\n                }\n                case types.Polygon: {\n                    return polygonWithPolygon(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case types.Path: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return pathWithLine(shape1, shape2, shape1opt);\n                }\n                case types.Ellipse: {\n                    return pathWithEllipse(shape1, shape2, shape1opt);\n                }\n                case types.Rect: {\n                    return pathWithRect(shape1, shape2, shape1opt);\n                }\n                case types.Polyline: {\n                    return pathWithPolyline(shape1, shape2, shape1opt);\n                }\n                case types.Polygon: {\n                    return pathWithPolygon(shape1, shape2, shape1opt);\n                }\n                case types.Path: {\n                    return pathWithPath(shape1, shape2, shape1opt, shape2opt);\n                }\n            }\n            break;\n        }\n    }\n    // None of the cases above\n    switch (shape2.type) {\n        case types.Ellipse:\n        case types.Rect:\n        case types.Polyline:\n        case types.Polygon:\n        case types.Path: {\n            return exists(shape2, shape1, shape2opt, shape1opt);\n        }\n        default: {\n            throw Error(`The intersection for ${shape1} and ${shape2} could not be found.`);\n        }\n    }\n}\n\n/* Line */\n\nexport function lineWithLine(line1, line2) {\n    const x1 = line1.start.x;\n    const y1 = line1.start.y;\n    const x2 = line1.end.x;\n    const y2 = line1.end.y;\n    const x3 = line2.start.x;\n    const y3 = line2.start.y;\n    const x4 = line2.end.x;\n    const y4 = line2.end.y;\n    const s1x = x2 - x1;\n    const s1y = y2 - y1;\n    const s2x = x4 - x3;\n    const s2y = y4 - y3;\n    const s3x = x1 - x3;\n    const s3y = y1 - y3;\n    const p = s1x * s2y - s2x * s1y;\n    const s = (s1x * s3y - s1y * s3x) / p;\n    const t = (s2x * s3y - s2y * s3x) / p;\n    return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n}\n\n/* Ellipse */\n\nexport function ellipseWithLine(ellipse, line) {\n    const rex = ellipse.a;\n    const rey = ellipse.b;\n    const xe = ellipse.x;\n    const ye = ellipse.y;\n    const x1 = line.start.x - xe;\n    const x2 = line.end.x - xe;\n    const y1 = line.start.y - ye;\n    const y2 = line.end.y - ye;\n    const rex_2 = rex * rex;\n    const rey_2 = rey * rey;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const A = dx * dx / rex_2 + dy * dy / rey_2;\n    const B = 2 * x1 * dx / rex_2 + 2 * y1 * dy / rey_2;\n    const C = x1 * x1 / rex_2 + y1 * y1 / rey_2 - 1;\n    const D = B * B - 4 * A * C;\n    if (D === 0) {\n        const t = -B / 2 / A;\n        return t >= 0 && t <= 1;\n    } else if (D > 0) {\n        const sqrt = Math.sqrt(D);\n        const t1 = (-B + sqrt) / 2 / A;\n        const t2 = (-B - sqrt) / 2 / A;\n        return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);\n    }\n    return false;\n}\n\nexport function ellipseWithEllipse(ellipse1, ellipse2) {\n    return _ellipsesIntersection(ellipse1, 0, ellipse2, 0);\n}\n\n/* Rect */\n\nexport function rectWithLine(rect, line) {\n    const { start, end } = line;\n    const { x, y, width, height } = rect;\n    if (\n        (start.x > x + width && end.x > x + width)\n        || (start.x < x && end.x < x)\n        || (start.y > y + height && end.y > y + height)\n        || (start.y < y && end.y < y)\n    ) {\n        return false;\n    }\n    if (rect.containsPoint(line.start) || rect.containsPoint(line.end)) {\n        return true;\n    }\n    return lineWithLine(rect.topLine(), line)\n        || lineWithLine(rect.rightLine(), line)\n        || lineWithLine(rect.bottomLine(), line)\n        || lineWithLine(rect.leftLine(), line);\n}\n\nexport function rectWithEllipse(rect, ellipse) {\n    if (!rectWithRect(rect, Rect.fromEllipse(ellipse))) return false;\n    return polygonWithEllipse(Polygon.fromRect(rect), ellipse);\n}\n\nexport function rectWithRect(rect1, rect2) {\n    return rect1.x < rect2.x + rect2.width\n        && rect1.x + rect1.width > rect2.x\n        && rect1.y < rect2.y + rect2.height\n        && rect1.y + rect1.height > rect2.y;\n}\n\n/* Polyline */\n\nexport function polylineWithLine(polyline, line) {\n    return _polylineWithLine(polyline, line, { interior: false });\n}\n\nexport function polylineWithEllipse(polyline, ellipse) {\n    return _polylineWithEllipse(polyline, ellipse, { interior: false });\n}\n\nexport function polylineWithRect(polyline, rect) {\n    return _polylineWithRect(polyline, rect, { interior: false });\n}\n\nexport function polylineWithPolyline(polyline1, polyline2) {\n    return _polylineWithPolyline(polyline1, polyline2, { interior: false });\n}\n\n/* Polygon */\n\nexport function polygonWithLine(polygon, line) {\n    return _polylineWithLine(polygon, line, { interior: true });\n}\n\nexport function polygonWithEllipse(polygon, ellipse) {\n    return _polylineWithEllipse(polygon, ellipse, { interior: true });\n}\n\nexport function polygonWithRect(polygon, rect) {\n    return _polylineWithRect(polygon, rect, { interior: true });\n}\n\nexport function polygonWithPolyline(polygon, polyline) {\n    return _polylineWithPolyline(polygon, polyline, { interior: true });\n}\n\nexport function polygonWithPolygon(polygon1, polygon2) {\n    return _polylineWithPolygon(polygon1, polygon2, { interior: true });\n}\n\n/* Path */\n\nexport function pathWithLine(path, line, pathOpt) {\n    return path.getSubpaths().some(subpath => {\n        const [polyline] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return polygonWithLine(polyline, line);\n        } else {\n            return polylineWithLine(polyline, line);\n        }\n    });\n}\n\nexport function pathWithEllipse(path, ellipse, pathOpt) {\n    return path.getSubpaths().some(subpath => {\n        const [polyline] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return polygonWithEllipse(polyline, ellipse);\n        } else {\n            return polylineWithEllipse(polyline, ellipse);\n        }\n    });\n}\n\nexport function pathWithRect(path, rect, pathOpt) {\n    return pathWithPolygon(path, Polygon.fromRect(rect), pathOpt);\n}\n\nexport function pathWithPolyline(path, polyline, pathOpt) {\n    return _pathWithPolyline(path, polyline, pathOpt, { interior: false });\n}\n\nexport function pathWithPolygon(path, polygon, pathOpt) {\n    return _pathWithPolyline(path, polygon, pathOpt, { interior: true });\n}\n\nexport function pathWithPath(path1, path2, pathOpt1, pathOpt2) {\n    return path1.getSubpaths().some(subpath => {\n        const [polyline1] = subpath.toPolylines(pathOpt1);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return pathWithPolygon(path2, polyline1, pathOpt2);\n        } else {\n            return pathWithPolyline(path2, polyline1, pathOpt2);\n        }\n    });\n}\n\nfunction _polylineWithLine(polyline, line, opt = {}) {\n    const { interior = false } = opt;\n    let thisPoints;\n    if (interior) {\n        if (polyline.containsPoint(line.start)) {\n            // If any point of the polyline lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the start point)\n            return true;\n        }\n        const { start, end, points } = polyline;\n        thisPoints = end.equals(start) ? points : [...points, start];\n    } else {\n        thisPoints = polyline.points;\n    }\n    const { length } = thisPoints;\n    const segment = new Line();\n    for (let i = 0; i < length - 1; i++) {\n        segment.start = thisPoints[i];\n        segment.end = thisPoints[i + 1];\n        if (lineWithLine(line, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _polylineWithEllipse(polyline, ellipse, opt = {}) {\n    const { start, end, points } = polyline;\n    if (ellipse.containsPoint(start)) {\n        return true;\n    }\n    let thisPoints;\n    const { interior = false } = opt;\n    if (interior) {\n        if (polyline.containsPoint(ellipse.center())) {\n            // If any point of the ellipse lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the center point)\n            return true;\n        }\n        thisPoints = end.equals(start) ? points : [...points, start];\n    } else {\n        thisPoints = points;\n    }\n\n    const { length } = thisPoints;\n    const segment = new Line();\n    for (let i = 0; i < length - 1; i++) {\n        segment.start = thisPoints[i];\n        segment.end = thisPoints[i + 1];\n        if (ellipseWithLine(ellipse, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _polylineWithRect(polyline, rect, opt) {\n    const polygon = Polygon.fromRect(rect);\n    return _polylineWithPolygon(polyline, polygon, opt);\n}\n\nfunction _pathWithPolyline(path, polyline1, pathOpt, opt) {\n    return path.getSubpaths().some(subpath => {\n        const [polyline2] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return _polylineWithPolygon(polyline1, polyline2, opt);\n        } else {\n            return _polylineWithPolyline(polyline1, polyline2, opt);\n        }\n    });\n}\n\nfunction _polylineWithPolyline(polyline1, polyline2, opt = {}) {\n    const { interior = false } = opt;\n    let thisPolyline;\n    if (interior) {\n        const { start } = polyline2;\n        if (polyline1.containsPoint(start)) {\n            // If any point of the polyline lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the start point)\n            return true;\n        }\n        thisPolyline = polyline1.clone().close();\n    } else {\n        thisPolyline = polyline1;\n    }\n    const otherPoints = polyline2.points;\n    const { length } = otherPoints;\n    const segment = new Line();\n    for (let i = 0; i < length - 1; i++) {\n        segment.start = otherPoints[i];\n        segment.end = otherPoints[i + 1];\n        if (polylineWithLine(thisPolyline, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _polylineWithPolygon(polyline, polygon, opt) {\n    return polygon.containsPoint(polyline.start) || _polylineWithPolyline(polyline, polygon.clone().close(), opt);\n}\n\nfunction _ellipsesIntersection(e1, w1, e2, w2) {\n    const { cos, sin } = Math;\n    const sinW1 = sin(w1);\n    const cosW1 = cos(w1);\n    const sinW2 = sin(w2);\n    const cosW2 = cos(w2);\n    const sinW1s = sinW1 * sinW1;\n    const cosW1s = cosW1 * cosW1;\n    const sinCos1 = sinW1 * cosW1;\n    const sinW2s = sinW2 * sinW2;\n    const cosW2s = cosW2 * cosW2;\n    const sinCos2 = sinW2 * cosW2;\n    const a1s = e1.a * e1.a;\n    const b1s = e1.b * e1.b;\n    const a2s = e2.a * e2.a;\n    const b2s = e2.b * e2.b;\n    const A1 = a1s * sinW1s + b1s * cosW1s;\n    const A2 = a2s * sinW2s + b2s * cosW2s;\n    const B1 = a1s * cosW1s + b1s * sinW1s;\n    const B2 = a2s * cosW2s + b2s * sinW2s;\n    let C1 = 2 * (b1s - a1s) * sinCos1;\n    let C2 = 2 * (b2s - a2s) * sinCos2;\n    let D1 = (-2 * A1 * e1.x - C1 * e1.y);\n    let D2 = (-2 * A2 * e2.x - C2 * e2.y);\n    let E1 = (-C1 * e1.x - 2 * B1 * e1.y);\n    let E2 = (-C2 * e2.x - 2 * B2 * e2.y);\n    const F1 = A1 * e1.x * e1.x + B1 * e1.y * e1.y + C1 * e1.x * e1.y - a1s * b1s;\n    const F2 = A2 * e2.x * e2.x + B2 * e2.y * e2.y + C2 * e2.x * e2.y - a2s * b2s;\n\n    C1 = C1 / 2;\n    C2 = C2 / 2;\n    D1 = D1 / 2;\n    D2 = D2 / 2;\n    E1 = E1 / 2;\n    E2 = E2 / 2;\n\n    const l3 = det3([\n        [A1, C1, D1],\n        [C1, B1, E1],\n        [D1, E1, F1]\n    ]);\n    const l0 = det3([\n        [A2, C2, D2],\n        [C2, B2, E2],\n        [D2, E2, F2]\n    ]);\n    const l2 = 0.33333333 * (det3([\n        [A2, C1, D1],\n        [C2, B1, E1],\n        [D2, E1, F1]\n    ]) + det3([\n        [A1, C2, D1],\n        [C1, B2, E1],\n        [D1, E2, F1]\n    ]) + det3([\n        [A1, C1, D2],\n        [C1, B1, E2],\n        [D1, E1, F2]\n    ]));\n    const l1 = 0.33333333 * (det3([\n        [A1, C2, D2],\n        [C1, B2, E2],\n        [D1, E2, F2]\n    ]) + det3([\n        [A2, C1, D2],\n        [C2, B1, E2],\n        [D2, E1, F2]\n    ]) + det3([\n        [A2, C2, D1],\n        [C2, B2, E1],\n        [D2, E2, F1]\n    ]));\n\n    const delta1 = det2([\n        [l3, l2],\n        [l2, l1]\n    ]);\n    const delta2 = det2([\n        [l3, l1],\n        [l2, l0]\n    ]);\n    const delta3 = det2([\n        [l2, l1],\n        [l1, l0]\n    ]);\n\n    const dP = det2([\n        [2 * delta1, delta2],\n        [delta2, 2 * delta3]\n    ]);\n\n    if (dP > 0 && (l1 > 0 || l2 > 0)) {\n        return false;\n    }\n    return true;\n}\n\nfunction det2(m) {\n    return m[0][0] * m[1][1] - m[0][1] * m[1][0];\n}\n\nfunction det3(m) {\n    return m[0][0] * m[1][1] * m[2][2] -\n        m[0][0] * m[1][2] * m[2][1] -\n        m[0][1] * m[1][0] * m[2][2] +\n        m[0][1] * m[1][2] * m[2][0] +\n        m[0][2] * m[1][0] * m[2][1] -\n        m[0][2] * m[1][1] * m[2][0];\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2763, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2769, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/index.mjs"],"sourcesContent":["// Geometry library.\n// -----------------\n\nexport * from './geometry.helpers.mjs';\nexport * from './bezier.mjs';\nexport * from './curve.mjs';\nexport * from './ellipse.mjs';\nexport * from './line.mjs';\nexport * from './path.mjs';\nexport * from './point.mjs';\nexport * from './polyline.mjs';\nexport * from './polygon.mjs';\nexport * from './rect.mjs';\nexport * from './types.mjs';\n\nimport * as _intersection from './intersection.mjs';\nexport const intersection = _intersection;\n"],"names":[],"mappings":"AAAA,oBAAoB;AACpB,oBAAoB;;;;AAcpB;;;;;;;;;;;;;AACO,MAAM,eAAe","ignoreList":[0]}},
    {"offset": {"line": 2788, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2802, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/curve.mjs"],"sourcesContent":["import { Point } from './point.mjs';\nimport { Rect } from './rect.mjs';\nimport { Line } from './line.mjs';\nimport { Polyline } from './polyline.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    abs,\n    sqrt,\n    min,\n    max,\n    pow\n} = Math;\n\nexport const Curve = function(p1, p2, p3, p4) {\n\n    if (!(this instanceof Curve)) {\n        return new Curve(p1, p2, p3, p4);\n    }\n\n    if (p1 instanceof Curve) {\n        return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);\n    }\n\n    this.start = new Point(p1);\n    this.controlPoint1 = new Point(p2);\n    this.controlPoint2 = new Point(p3);\n    this.end = new Point(p4);\n};\n\n// Curve passing through points.\n// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\n// @param {array} points Array of points through which the smooth line will go.\n// @return {array} curves.\nCurve.throughPoints = (function() {\n\n    // Get open-ended Bezier Spline Control Points.\n    // @param knots Input Knot Bezier spline points (At least two points!).\n    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n    function getCurveControlPoints(knots) {\n\n        var firstControlPoints = [];\n        var secondControlPoints = [];\n        var n = knots.length - 1;\n        var i;\n\n        // Special case: Bezier curve should be a straight line.\n        if (n == 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new Point(\n                (2 * knots[0].x + knots[1].x) / 3,\n                (2 * knots[0].y + knots[1].y) / 3\n            );\n\n            // P2 = 2P1  P0\n            secondControlPoints[0] = new Point(\n                2 * firstControlPoints[0].x - knots[0].x,\n                2 * firstControlPoints[0].y - knots[0].y\n            );\n\n            return [firstControlPoints, secondControlPoints];\n        }\n\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        var rhs = [];\n\n        // Set right hand side X values.\n        for (i = 1; i < n - 1; i++) {\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n        // Get first control points X-values.\n        var x = getFirstControlPoints(rhs);\n\n        // Set right hand side Y values.\n        for (i = 1; i < n - 1; ++i) {\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n        // Get first control points Y-values.\n        var y = getFirstControlPoints(rhs);\n\n        // Fill output arrays.\n        for (i = 0; i < n; i++) {\n            // First control point.\n            firstControlPoints.push(new Point(x[i], y[i]));\n\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new Point(\n                    2 * knots [i + 1].x - x[i + 1],\n                    2 * knots[i + 1].y - y[i + 1]\n                ));\n\n            } else {\n                secondControlPoints.push(new Point(\n                    (knots[n].x + x[n - 1]) / 2,\n                    (knots[n].y + y[n - 1]) / 2\n                ));\n            }\n        }\n\n        return [firstControlPoints, secondControlPoints];\n    }\n\n    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n    // @param rhs Right hand side vector.\n    // @return Solution vector.\n    function getFirstControlPoints(rhs) {\n\n        var n = rhs.length;\n        // `x` is a solution vector.\n        var x = [];\n        var tmp = [];\n        var b = 2.0;\n\n        x[0] = rhs[0] / b;\n\n        // Decomposition and forward substitution.\n        for (var i = 1; i < n; i++) {\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n\n        for (i = 1; i < n; i++) {\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n\n        return x;\n    }\n\n    return function(points) {\n\n        if (!points || (Array.isArray(points) && points.length < 2)) {\n            throw new Error('At least 2 points are required');\n        }\n\n        var controlPoints = getCurveControlPoints(points);\n\n        var curves = [];\n        var n = controlPoints[0].length;\n        for (var i = 0; i < n; i++) {\n\n            var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n            var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n\n            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n        }\n\n        return curves;\n    };\n})();\n\nCurve.prototype = {\n\n    type: types.Curve,\n\n    // Returns a bbox that tightly envelops the curve.\n    bbox: function() {\n\n        var start = this.start;\n        var controlPoint1 = this.controlPoint1;\n        var controlPoint2 = this.controlPoint2;\n        var end = this.end;\n\n        var x0 = start.x;\n        var y0 = start.y;\n        var x1 = controlPoint1.x;\n        var y1 = controlPoint1.y;\n        var x2 = controlPoint2.x;\n        var y2 = controlPoint2.y;\n        var x3 = end.x;\n        var y3 = end.y;\n\n        var points = new Array(); // local extremes\n        var tvalues = new Array(); // t values of local extremes\n        var bounds = [new Array(), new Array()];\n\n        var a, b, c, t;\n        var t1, t2;\n        var b2ac, sqrtb2ac;\n\n        for (var i = 0; i < 2; ++i) {\n\n            if (i === 0) {\n                b = 6 * x0 - 12 * x1 + 6 * x2;\n                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                c = 3 * x1 - 3 * x0;\n\n            } else {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n\n            if (abs(a) < 1e-12) { // Numerical robustness\n                if (abs(b) < 1e-12) { // Numerical robustness\n                    continue;\n                }\n\n                t = -c / b;\n                if ((0 < t) && (t < 1)) tvalues.push(t);\n\n                continue;\n            }\n\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = sqrt(b2ac);\n\n            if (b2ac < 0) continue;\n\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if ((0 < t1) && (t1 < 1)) tvalues.push(t1);\n\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if ((0 < t2) && (t2 < 1)) tvalues.push(t2);\n        }\n\n        var j = tvalues.length;\n        var jlen = j;\n        var mt;\n        var x, y;\n\n        while (j--) {\n            t = tvalues[j];\n            mt = 1 - t;\n\n            x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n            bounds[0][j] = x;\n\n            y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n            bounds[1][j] = y;\n\n            points[j] = { X: x, Y: y };\n        }\n\n        tvalues[jlen] = 0;\n        tvalues[jlen + 1] = 1;\n\n        points[jlen] = { X: x0, Y: y0 };\n        points[jlen + 1] = { X: x3, Y: y3 };\n\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n\n        tvalues.length = jlen + 2;\n        bounds[0].length = jlen + 2;\n        bounds[1].length = jlen + 2;\n        points.length = jlen + 2;\n\n        var left = min.apply(null, bounds[0]);\n        var top = min.apply(null, bounds[1]);\n        var right = max.apply(null, bounds[0]);\n        var bottom = max.apply(null, bounds[1]);\n\n        return new Rect(left, top, (right - left), (bottom - top));\n    },\n\n    clone: function() {\n\n        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    },\n\n    // Returns the point on the curve closest to point `p`\n    closestPoint: function(p, opt) {\n\n        return this.pointAtT(this.closestPointT(p, opt));\n    },\n\n    closestPointLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);\n    },\n\n    closestPointNormalizedLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        var cpLength = this.closestPointLength(p, localOpt);\n        if (!cpLength) return 0;\n\n        var length = this.length(localOpt);\n        if (length === 0) return 0;\n\n        return cpLength / length;\n    },\n\n    // Returns `t` of the point on the curve closest to point `p`\n    closestPointT: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // does not use localOpt\n\n        // identify the subdivision that contains the point:\n        var investigatedSubdivision;\n        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n        var investigatedSubdivisionEndT;\n        var distFromStart; // distance of point from start of baseline\n        var distFromEnd; // distance of point from end of baseline\n        var chordLength; // distance between start and end of the subdivision\n        var minSumDist; // lowest observed sum of the two distances\n        var n = subdivisions.length;\n        var subdivisionSize = (n ? (1 / n) : 0);\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n\n            var startDist = currentSubdivision.start.distance(p);\n            var endDist = currentSubdivision.end.distance(p);\n            var sumDist = startDist + endDist;\n\n            // check that the point is closest to current subdivision and not any other\n            if (!minSumDist || (sumDist < minSumDist)) {\n                investigatedSubdivision = currentSubdivision;\n\n                investigatedSubdivisionStartT = i * subdivisionSize;\n                investigatedSubdivisionEndT = (i + 1) * subdivisionSize;\n\n                distFromStart = startDist;\n                distFromEnd = endDist;\n\n                chordLength = currentSubdivision.start.distance(currentSubdivision.end);\n\n                minSumDist = sumDist;\n            }\n        }\n\n        var precisionRatio = pow(10, -precision);\n\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        while (true) {\n\n            // check if we have reached at least one required observed precision\n            // - calculated as: the difference in distances from point to start and end divided by the distance\n            // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n            // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n            // - this criterion works well for points lying far away from the curve\n            var startPrecisionRatio = (distFromStart ? (abs(distFromStart - distFromEnd) / distFromStart) : 0);\n            var endPrecisionRatio = (distFromEnd ? (abs(distFromStart - distFromEnd) / distFromEnd) : 0);\n            var hasRequiredPrecision = ((startPrecisionRatio < precisionRatio) || (endPrecisionRatio < precisionRatio));\n\n            // check if we have reached at least one required minimal distance\n            // - calculated as: the subdivision chord length multiplied by precisionRatio\n            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n            // - this is a backup criterion that works well for points lying \"almost at\" the curve\n            var hasMinimalStartDistance = (distFromStart ? (distFromStart < (chordLength * precisionRatio)) : true);\n            var hasMinimalEndDistance = (distFromEnd ? (distFromEnd < (chordLength * precisionRatio)) : true);\n            var hasMinimalDistance = (hasMinimalStartDistance || hasMinimalEndDistance);\n\n            // do we stop now?\n            if (hasRequiredPrecision || hasMinimalDistance) {\n                return ((distFromStart <= distFromEnd) ? investigatedSubdivisionStartT : investigatedSubdivisionEndT);\n            }\n\n            // otherwise, set up for next iteration\n            var divided = investigatedSubdivision.divide(0.5);\n            subdivisionSize /= 2;\n\n            var startDist1 = divided[0].start.distance(p);\n            var endDist1 = divided[0].end.distance(p);\n            var sumDist1 = startDist1 + endDist1;\n\n            var startDist2 = divided[1].start.distance(p);\n            var endDist2 = divided[1].end.distance(p);\n            var sumDist2 = startDist2 + endDist2;\n\n            if (sumDist1 <= sumDist2) {\n                investigatedSubdivision = divided[0];\n\n                investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved\n\n                distFromStart = startDist1;\n                distFromEnd = endDist1;\n\n            } else {\n                investigatedSubdivision = divided[1];\n\n                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n                distFromStart = startDist2;\n                distFromEnd = endDist2;\n            }\n        }\n    },\n\n    closestPointTangent: function(p, opt) {\n\n        return this.tangentAtT(this.closestPointT(p, opt));\n    },\n\n    // Returns `true` if the area surrounded by the curve contains the point `p`.\n    // Implements the even-odd algorithm (self-intersections are \"outside\").\n    // Closes open curves (always imagines a closing segment).\n    // Precision may be adjusted by passing an `opt` object.\n    containsPoint: function(p, opt) {\n\n        var polyline = this.toPolyline(opt);\n        return polyline.containsPoint(p);\n    },\n\n    // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    // For a function that uses `t`, use Curve.divideAtT().\n    divideAt: function(ratio, opt) {\n\n        if (ratio <= 0) return this.divideAtT(0);\n        if (ratio >= 1) return this.divideAtT(1);\n\n        var t = this.tAt(ratio, opt);\n\n        return this.divideAtT(t);\n    },\n\n    // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAtLength: function(length, opt) {\n\n        var t = this.tAtLength(length, opt);\n\n        return this.divideAtT(t);\n    },\n\n    // Divides the curve into two at point defined by `t` between 0 and 1.\n    // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).\n    // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau\n    divideAtT: function(t) {\n\n        var start = this.start;\n        var controlPoint1 = this.controlPoint1;\n        var controlPoint2 = this.controlPoint2;\n        var end = this.end;\n\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return [\n                new Curve(start, start, start, start),\n                new Curve(start, controlPoint1, controlPoint2, end)\n            ];\n        }\n\n        if (t >= 1) {\n            return [\n                new Curve(start, controlPoint1, controlPoint2, end),\n                new Curve(end, end, end, end)\n            ];\n        }\n\n        var dividerPoints = this.getSkeletonPoints(t);\n\n        var startControl1 = dividerPoints.startControlPoint1;\n        var startControl2 = dividerPoints.startControlPoint2;\n        var divider = dividerPoints.divider;\n        var dividerControl1 = dividerPoints.dividerControlPoint1;\n        var dividerControl2 = dividerPoints.dividerControlPoint2;\n\n        // return array with two new curves\n        return [\n            new Curve(start, startControl1, startControl2, divider),\n            new Curve(divider, dividerControl1, dividerControl2, end)\n        ];\n    },\n\n    // Returns the distance between the curve's start and end points.\n    endpointDistance: function() {\n\n        return this.start.distance(this.end);\n    },\n\n    // Checks whether two curves are exactly the same.\n    equals: function(c) {\n\n        return !!c &&\n            this.start.x === c.start.x &&\n            this.start.y === c.start.y &&\n            this.controlPoint1.x === c.controlPoint1.x &&\n            this.controlPoint1.y === c.controlPoint1.y &&\n            this.controlPoint2.x === c.controlPoint2.x &&\n            this.controlPoint2.y === c.controlPoint2.y &&\n            this.end.x === c.end.x &&\n            this.end.y === c.end.y;\n    },\n\n    // Returns five helper points necessary for curve division.\n    getSkeletonPoints: function(t) {\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return {\n                startControlPoint1: start.clone(),\n                startControlPoint2: start.clone(),\n                divider: start.clone(),\n                dividerControlPoint1: control1.clone(),\n                dividerControlPoint2: control2.clone()\n            };\n        }\n\n        if (t >= 1) {\n            return {\n                startControlPoint1: control1.clone(),\n                startControlPoint2: control2.clone(),\n                divider: end.clone(),\n                dividerControlPoint1: end.clone(),\n                dividerControlPoint2: end.clone()\n            };\n        }\n\n        var midpoint1 = (new Line(start, control1)).pointAt(t);\n        var midpoint2 = (new Line(control1, control2)).pointAt(t);\n        var midpoint3 = (new Line(control2, end)).pointAt(t);\n\n        var subControl1 = (new Line(midpoint1, midpoint2)).pointAt(t);\n        var subControl2 = (new Line(midpoint2, midpoint3)).pointAt(t);\n\n        var divider = (new Line(subControl1, subControl2)).pointAt(t);\n\n        var output = {\n            startControlPoint1: midpoint1,\n            startControlPoint2: subControl1,\n            divider: divider,\n            dividerControlPoint1: subControl2,\n            dividerControlPoint2: midpoint3\n        };\n\n        return output;\n    },\n\n    // Returns a list of curves whose flattened length is better than `opt.precision`.\n    // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%\n    // (Observed difference is not real precision, but close enough as long as special cases are covered)\n    // As a rule of thumb, increasing `precision` by 1 requires 2 more iterations (= levels of division operations)\n    // - Precision 0 (endpointDistance) - 0 iterations => total of 2^0 - 1 = 0 operations (1 subdivision)\n    // - Precision 1 (<10% error) - 2 iterations => total of 2^2 - 1 = 3 operations (4 subdivisions)\n    // - Precision 2 (<1% error) - 4 iterations => total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)\n    // - Precision 3 (<0.1% error) - 6 iterations => total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)\n    // - Precision 4 (<0.01% error) - 8 iterations => total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)\n    // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)\n    getSubdivisions: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.subdivisions\n        // not using localOpt\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        var subdivisions = [new Curve(start, control1, control2, end)];\n        if (precision === 0) return subdivisions;\n\n        // special case #1: point-like curves\n        // - no need to calculate subdivisions, they would all be identical\n        var isPoint = !this.isDifferentiable();\n        if (isPoint) return subdivisions;\n\n        var previousLength = this.endpointDistance();\n\n        var precisionRatio = pow(10, -precision);\n\n        // special case #2: sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n        // - not a problem for further iterations because cubic curves cannot have more than two local extrema\n        // - (i.e. cubic curves cannot intersect the baseline more than once)\n        // - therefore starting from iteration = 2 ensures that subsequent iterations do not produce sampling with equal length\n        // - (unless it's a straight-line curve, see below)\n        var minIterations = 2; // = 2*1\n\n        // special case #3: straight-line curves have the same observed length in all iterations\n        // - this causes observed precision ratio to always be 0 (= lower than `precisionRatio`, which is our exit condition)\n        // - we enforce the expected number of iterations = 2 * precision\n        var isLine = ((control1.cross(start, end) === 0) && (control2.cross(start, end) === 0));\n        if (isLine) {\n            minIterations = (2 * precision);\n        }\n\n        // recursively divide curve at `t = 0.5`\n        // until we reach `minIterations`\n        // and until the difference between observed length at subsequent iterations is lower than `precision`\n        var iteration = 0;\n        while (true) {\n            iteration += 1;\n\n            // divide all subdivisions\n            var newSubdivisions = [];\n            var numSubdivisions = subdivisions.length;\n            for (var i = 0; i < numSubdivisions; i++) {\n\n                var currentSubdivision = subdivisions[i];\n                var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)\n                newSubdivisions.push(divided[0], divided[1]);\n            }\n\n            // measure new length\n            var length = 0;\n            var numNewSubdivisions = newSubdivisions.length;\n            for (var j = 0; j < numNewSubdivisions; j++) {\n\n                var currentNewSubdivision = newSubdivisions[j];\n                length += currentNewSubdivision.endpointDistance();\n            }\n\n            // check if we have reached minimum number of iterations\n            if (iteration >= minIterations) {\n\n                // check if we have reached required observed precision\n                var observedPrecisionRatio = ((length !== 0) ? ((length - previousLength) / length) : 0);\n                if (observedPrecisionRatio < precisionRatio) {\n                    return newSubdivisions;\n                }\n            }\n\n            // otherwise, set up for next iteration\n            subdivisions = newSubdivisions;\n            previousLength = length;\n        }\n    },\n\n    isDifferentiable: function() {\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    },\n\n    // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.\n    length: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // not using localOpt\n\n        var length = 0;\n        var n = subdivisions.length;\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n            length += currentSubdivision.endpointDistance();\n        }\n\n        return length;\n    },\n\n    // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)\n    lengthAtT: function(t, opt) {\n\n        if (t <= 0) return 0;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.subdivisions\n        // not using localOpt\n\n        var subCurve = this.divide(t)[0];\n        var subCurveLength = subCurve.length({ precision: precision });\n\n        return subCurveLength;\n    },\n\n    // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    // Mirrors Line.pointAt() function.\n    // For a function that tracks `t`, use Curve.pointAtT().\n    pointAt: function(ratio, opt) {\n\n        if (ratio <= 0) return this.start.clone();\n        if (ratio >= 1) return this.end.clone();\n\n        var t = this.tAt(ratio, opt);\n\n        return this.pointAtT(t);\n    },\n\n    // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    pointAtLength: function(length, opt) {\n\n        var t = this.tAtLength(length, opt);\n\n        return this.pointAtT(t);\n    },\n\n    // Returns the point at provided `t` between 0 and 1.\n    // `t` does not track distance along curve as it does in Line objects.\n    // Non-linear relationship, speeds up and slows down as curve warps!\n    // For linear length-based solution, use Curve.pointAt().\n    pointAtT: function(t) {\n\n        if (t <= 0) return this.start.clone();\n        if (t >= 1) return this.end.clone();\n\n        return this.getSkeletonPoints(t).divider;\n    },\n\n    // Default precision\n    PRECISION: 3,\n\n    round: function(precision) {\n\n        this.start.round(precision);\n        this.controlPoint1.round(precision);\n        this.controlPoint2.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.start.scale(sx, sy, origin);\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n    tangentAt: function(ratio, opt) {\n\n        if (!this.isDifferentiable()) return null;\n\n        if (ratio < 0) ratio = 0;\n        else if (ratio > 1) ratio = 1;\n\n        var t = this.tAt(ratio, opt);\n\n        return this.tangentAtT(t);\n    },\n\n    // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n    tangentAtLength: function(length, opt) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var t = this.tAtLength(length, opt);\n\n        return this.tangentAtT(t);\n    },\n\n    // Returns a tangent line at requested `t`.\n    tangentAtT: function(t) {\n\n        if (!this.isDifferentiable()) return null;\n\n        if (t < 0) t = 0;\n        else if (t > 1) t = 1;\n\n        var skeletonPoints = this.getSkeletonPoints(t);\n\n        var p1 = skeletonPoints.startControlPoint2;\n        var p2 = skeletonPoints.dividerControlPoint1;\n\n        var tangentStart = skeletonPoints.divider;\n\n        var tangentLine = new Line(p1, p2);\n        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    tAt: function(ratio, opt) {\n\n        if (ratio <= 0) return 0;\n        if (ratio >= 1) return 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        var curveLength = this.length(localOpt);\n        var length = curveLength * ratio;\n\n        return this.tAtLength(length, localOpt);\n    },\n\n    // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    // Uses `precision` to approximate length within `precision` (always underestimates)\n    // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated\n    // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper\n    // - Precision 0 (chooses one of the two endpoints) - 0 levels\n    // - Precision 1 (chooses one of 5 points, <10% error) - 1 level\n    // - Precision 2 (<1% error) - 3 levels\n    // - Precision 3 (<0.1% error) - 7 levels\n    // - Precision 4 (<0.01% error) - 15 levels\n    tAtLength: function(length, opt) {\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        // identify the subdivision that contains the point at requested `length`:\n        var investigatedSubdivision;\n        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n        var investigatedSubdivisionEndT;\n        //var baseline; // straightened version of subdivision to investigate\n        //var baselinePoint; // point on the baseline that is the requested distance away from start\n        var baselinePointDistFromStart; // distance of baselinePoint from start of baseline\n        var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline\n        var l = 0; // length so far\n        var n = subdivisions.length;\n        var subdivisionSize = 1 / n;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var currentSubdivision = subdivisions[i];\n            var d = currentSubdivision.endpointDistance(); // length of current subdivision\n\n            if (length <= (l + d)) {\n                investigatedSubdivision = currentSubdivision;\n\n                investigatedSubdivisionStartT = index * subdivisionSize;\n                investigatedSubdivisionEndT = (index + 1) * subdivisionSize;\n\n                baselinePointDistFromStart = (fromStart ? (length - l) : ((d + l) - length));\n                baselinePointDistFromEnd = (fromStart ? ((d + l) - length) : (length - l));\n\n                break;\n            }\n\n            l += d;\n        }\n\n        if (!investigatedSubdivision) return (fromStart ? 1 : 0); // length requested is out of range - return maximum t\n        // note that precision affects what length is recorded\n        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n        var curveLength = this.length(localOpt);\n\n        var precisionRatio = pow(10, -precision);\n\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        while (true) {\n\n            // check if we have reached required observed precision\n            var observedPrecisionRatio;\n\n            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromStart / curveLength) : 0);\n            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;\n            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromEnd / curveLength) : 0);\n            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT;\n\n            // otherwise, set up for next iteration\n            var newBaselinePointDistFromStart;\n            var newBaselinePointDistFromEnd;\n\n            var divided = investigatedSubdivision.divide(0.5);\n            subdivisionSize /= 2;\n\n            var baseline1Length = divided[0].endpointDistance();\n            var baseline2Length = divided[1].endpointDistance();\n\n            if (baselinePointDistFromStart <= baseline1Length) { // point at requested length is inside divided[0]\n                investigatedSubdivision = divided[0];\n\n                investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved\n\n                newBaselinePointDistFromStart = baselinePointDistFromStart;\n                newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n\n            } else { // point at requested length is inside divided[1]\n                investigatedSubdivision = divided[1];\n\n                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n                newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n                newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n            }\n\n            baselinePointDistFromStart = newBaselinePointDistFromStart;\n            baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n        }\n    },\n\n    // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n    // Flattened length is no more than 10^(-precision) away from real curve length.\n    toPoints: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // not using localOpt\n\n        var points = [subdivisions[0].start.clone()];\n        var n = subdivisions.length;\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n            points.push(currentSubdivision.end.clone());\n        }\n\n        return points;\n    },\n\n    // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n    // Flattened length is no more than 10^(-precision) away from real curve length.\n    toPolyline: function(opt) {\n\n        return new Polyline(this.toPoints(opt));\n    },\n\n    toString: function() {\n\n        return this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.start.translate(tx, ty);\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nCurve.prototype.divide = Curve.prototype.divideAtT;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3554, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3560, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/path.mjs"],"sourcesContent":["// Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.\n// Path created is not guaranteed to be a valid (serializable) path (might not start with an M).\nimport { Polyline } from './polyline.mjs';\nimport { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { Line } from './line.mjs';\nimport { Curve } from './curve.mjs';\nimport { types } from './types.mjs';\nimport { extend } from './extend.mjs';\nexport const Path = function(arg) {\n\n    if (!(this instanceof Path)) {\n        return new Path(arg);\n    }\n\n    if (typeof arg === 'string') { // create from a path data string\n        return new Path.parse(arg);\n    }\n\n    this.segments = [];\n\n    var i;\n    var n;\n\n    if (!arg) {\n        // don't do anything\n\n    } else if (Array.isArray(arg) && arg.length !== 0) { // if arg is a non-empty array\n        // flatten one level deep\n        // so we can chain arbitrary Path.createSegment results\n        arg = arg.reduce(function(acc, val) {\n            return acc.concat(val);\n        }, []);\n\n        n = arg.length;\n        if (arg[0].isSegment) { // create from an array of segments\n            for (i = 0; i < n; i++) {\n\n                var segment = arg[i];\n\n                this.appendSegment(segment);\n            }\n\n        } else { // create from an array of Curves and/or Lines\n            var previousObj = null;\n            for (i = 0; i < n; i++) {\n\n                var obj = arg[i];\n\n                if (!((obj instanceof Line) || (obj instanceof Curve))) {\n                    throw new Error('Cannot construct a path segment from the provided object.');\n                }\n\n                if (i === 0) this.appendSegment(Path.createSegment('M', obj.start));\n\n                // if objects do not link up, moveto segments are inserted to cover the gaps\n                if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path.createSegment('M', obj.start));\n\n                if (obj instanceof Line) {\n                    this.appendSegment(Path.createSegment('L', obj.end));\n\n                } else if (obj instanceof Curve) {\n                    this.appendSegment(Path.createSegment('C', obj.controlPoint1, obj.controlPoint2, obj.end));\n                }\n\n                previousObj = obj;\n            }\n        }\n\n    } else if (arg.isSegment) { // create from a single segment\n        this.appendSegment(arg);\n\n    } else if (arg instanceof Line) { // create from a single Line\n        this.appendSegment(Path.createSegment('M', arg.start));\n        this.appendSegment(Path.createSegment('L', arg.end));\n\n    } else if (arg instanceof Curve) { // create from a single Curve\n        this.appendSegment(Path.createSegment('M', arg.start));\n        this.appendSegment(Path.createSegment('C', arg.controlPoint1, arg.controlPoint2, arg.end));\n\n    } else if (arg instanceof Polyline) { // create from a Polyline\n        if (!(arg.points && (arg.points.length !== 0))) return; // if Polyline has no points, leave Path empty\n\n        n = arg.points.length;\n        for (i = 0; i < n; i++) {\n\n            var point = arg.points[i];\n\n            if (i === 0) this.appendSegment(Path.createSegment('M', point));\n            else this.appendSegment(Path.createSegment('L', point));\n        }\n\n    } else { // unknown object\n        throw new Error('Cannot construct a path from the provided object.');\n    }\n};\n\n// More permissive than V.normalizePathData and Path.prototype.serialize.\n// Allows path data strings that do not start with a Moveto command (unlike SVG specification).\n// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').\n// Allows for command argument chaining.\n// Throws an error if wrong number of arguments is provided with a command.\n// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).\nPath.parse = function(pathData) {\n\n    if (!pathData) return new Path();\n\n    var path = new Path();\n\n    var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n    var commands = pathData.match(commandRe);\n\n    var numCommands = commands.length;\n    for (var i = 0; i < numCommands; i++) {\n\n        var command = commands[i];\n        var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n        var args = command.match(argRe);\n\n        var segment = Path.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]\n        path.appendSegment(segment);\n    }\n\n    return path;\n};\n\n// Create a segment or an array of segments.\n// Accepts unlimited points/coords arguments after `type`.\nPath.createSegment = function(type) {\n\n    if (!type) throw new Error('Type must be provided.');\n\n    var segmentConstructor = Path.segmentTypes[type];\n    if (!segmentConstructor) throw new Error(type + ' is not a recognized path segment type.');\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 1; i < n; i++) { // do not add first element (`type`) to args array\n        args.push(arguments[i]);\n    }\n\n    return applyToNew(segmentConstructor, args);\n};\n\nPath.prototype = {\n\n    type: types.Path,\n\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if argument is not a segment or an array of segments.\n    appendSegment: function(arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        var currentSegment;\n\n        var previousSegment = ((numSegments !== 0) ? segments[numSegments - 1] : null); // if we are appending to an empty path, previousSegment is null\n        var nextSegment = null;\n\n        if (!Array.isArray(arg)) { // arg is a segment\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.push(currentSegment);\n\n        } else { // arg is an array of segments\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.push(currentSegment);\n                previousSegment = currentSegment;\n            }\n        }\n    },\n\n    // Returns the bbox of the path.\n    // If path has no segments, returns null.\n    // If path has only invisible segments, returns bbox of the end point of last segment.\n    bbox: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var bbox;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            if (segment.isVisible) {\n                var segmentBBox = segment.bbox();\n                bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n            }\n        }\n\n        if (bbox) return bbox;\n\n        // if the path has only invisible elements, return end point of last segment\n        var lastSegment = segments[numSegments - 1];\n        return new Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);\n    },\n\n    // Returns a new path that is a clone of this path.\n    clone: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        var path = new Path();\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i].clone();\n            path.appendSegment(segment);\n        }\n\n        return path;\n    },\n\n    closestPoint: function(p, opt) {\n\n        var t = this.closestPointT(p, opt);\n        if (!t) return null;\n\n        return this.pointAtT(t);\n    },\n\n    closestPointLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var t = this.closestPointT(p, localOpt);\n        if (!t) return 0;\n\n        return this.lengthAtT(t, localOpt);\n    },\n\n    closestPointNormalizedLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var cpLength = this.closestPointLength(p, localOpt);\n        if (cpLength === 0) return 0; // shortcut\n\n        var length = this.length(localOpt);\n        if (length === 0) return 0; // prevents division by zero\n\n        return cpLength / length;\n    },\n\n    // Private function.\n    closestPointT: function(p, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var closestPointT;\n        var minSquaredDistance = Infinity;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n\n            if (segment.isVisible) {\n                var segmentClosestPointT = segment.closestPointT(p, {\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                var squaredDistance = (new Line(segmentClosestPoint, p)).squaredLength();\n\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointT = { segmentIndex: i, value: segmentClosestPointT };\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n\n        if (closestPointT) return closestPointT;\n\n        // if no visible segment, return end of last segment\n        return { segmentIndex: numSegments - 1, value: 1 };\n    },\n\n    closestPointTangent: function(p, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var closestPointTangent;\n        var minSquaredDistance = Infinity;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n\n            if (segment.isDifferentiable()) {\n                var segmentClosestPointT = segment.closestPointT(p, {\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                var squaredDistance = (new Line(segmentClosestPoint, p)).squaredLength();\n\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n\n        if (closestPointTangent) return closestPointTangent;\n\n        // if no valid segment, return null\n        return null;\n    },\n\n    // Returns `true` if the area surrounded by the path contains the point `p`.\n    // Implements the even-odd algorithm (self-intersections are \"outside\").\n    // Closes open paths (always imagines a final closing segment).\n    // Precision may be adjusted by passing an `opt` object.\n    containsPoint: function(p, opt) {\n\n        var polylines = this.toPolylines(opt);\n        if (!polylines) return false; // shortcut (this path has no polylines)\n\n        var numPolylines = polylines.length;\n\n        // how many component polylines does `p` lie within?\n        var numIntersections = 0;\n        for (var i = 0; i < numPolylines; i++) {\n            var polyline = polylines[i];\n            if (polyline.containsPoint(p)) {\n                // `p` lies within this polyline\n                numIntersections++;\n            }\n        }\n\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return ((numIntersections % 2) === 1);\n    },\n\n    // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.divideAtLength(length, localOpt);\n    },\n\n    // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAtLength: function(length, opt) {\n\n        var numSegments = this.segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var i;\n        var segment;\n\n        // identify the segment to divide:\n\n        var l = 0; // length so far\n        var divided;\n        var dividedSegmentIndex;\n        var lastValidSegment; // visible AND differentiable\n        var lastValidSegmentIndex;\n        var t;\n        for (i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            segment = this.getSegment(index);\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isDifferentiable()) { // segment is not just a point\n                lastValidSegment = segment;\n                lastValidSegmentIndex = index;\n\n                if (length <= (l + d)) {\n                    dividedSegmentIndex = index;\n                    divided = segment.divideAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                    break;\n                }\n            }\n\n            l += d;\n        }\n\n        if (!lastValidSegment) { // no valid segment found\n            return null;\n        }\n\n        // else: the path contains at least one valid segment\n\n        if (!divided) { // the desired length is greater than the length of the path\n            dividedSegmentIndex = lastValidSegmentIndex;\n            t = (fromStart ? 1 : 0);\n            divided = lastValidSegment.divideAtT(t);\n        }\n\n        // create a copy of this path and replace the identified segment with its two divided parts:\n\n        var pathCopy = this.clone();\n        pathCopy.replaceSegment(dividedSegmentIndex, divided);\n\n        var divisionStartIndex = dividedSegmentIndex;\n        var divisionMidIndex = dividedSegmentIndex + 1;\n        var divisionEndIndex = dividedSegmentIndex + 2;\n\n        // do not insert the part if it looks like a point\n        if (!divided[0].isDifferentiable()) {\n            pathCopy.removeSegment(divisionStartIndex);\n            divisionMidIndex -= 1;\n            divisionEndIndex -= 1;\n        }\n\n        // insert a Moveto segment to ensure secondPath will be valid:\n        var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n        pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n        divisionEndIndex += 1;\n\n        // do not insert the part if it looks like a point\n        if (!divided[1].isDifferentiable()) {\n            pathCopy.removeSegment(divisionEndIndex - 1);\n            divisionEndIndex -= 1;\n        }\n\n        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n        var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n        for (i = divisionEndIndex; i < pathCopy.segments.length; i++) {\n\n            var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n            segment = pathCopy.getSegment(i);\n\n            if ((segment.type === 'Z') && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n                // pathCopy segment's subpathStartSegment is different from original segment's one\n                // convert this Closepath segment to a Lineto and replace it in pathCopy\n                var convertedSegment = Path.createSegment('L', originalSegment.end);\n                pathCopy.replaceSegment(i, convertedSegment);\n            }\n        }\n\n        // distribute pathCopy segments into two paths and return those:\n\n        var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n        var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n\n        return [firstPath, secondPath];\n    },\n\n    // Checks whether two paths are exactly the same.\n    // If `p` is undefined or null, returns false.\n    equals: function(p) {\n\n        if (!p) return false;\n\n        var segments = this.segments;\n        var otherSegments = p.segments;\n\n        var numSegments = segments.length;\n        if (otherSegments.length !== numSegments) return false; // if the two paths have different number of segments, they cannot be equal\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var otherSegment = otherSegments[i];\n\n            // as soon as an inequality is found in segments, return false\n            if ((segment.type !== otherSegment.type) || (!segment.equals(otherSegment))) return false;\n        }\n\n        // if no inequality found in segments, return true\n        return true;\n    },\n\n    // Accepts negative indices.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    getSegment: function(index) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        return segments[index];\n    },\n\n    // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.\n    getSegmentSubdivisions: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.segmentSubdivisions\n        // not using localOpt\n\n        var segmentSubdivisions = [];\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segment.getSubdivisions({ precision: precision });\n            segmentSubdivisions.push(subdivisions);\n        }\n\n        return segmentSubdivisions;\n    },\n\n    // Returns an array of subpaths of this path.\n    // Invalid paths are validated first.\n    // Returns `[]` if path has no segments.\n    getSubpaths: function() {\n\n        const validatedPath = this.clone().validate();\n\n        const segments = validatedPath.segments;\n        const numSegments = segments.length;\n\n        const subpaths = [];\n        for (let i = 0; i < numSegments; i++) {\n\n            const segment = segments[i];\n            if (segment.isSubpathStart) {\n                // we encountered a subpath start segment\n                // create a new path for segment, and push it to list of subpaths\n                subpaths.push(new Path(segment));\n\n            } else {\n                // append current segment to the last subpath\n                subpaths[subpaths.length - 1].appendSegment(segment);\n            }\n        }\n\n        return subpaths;\n    },\n\n    // Insert `arg` at given `index`.\n    // `index = 0` means insert at the beginning.\n    // `index = segments.length` means insert at the end.\n    // Accepts negative indices, from `-1` to `-(segments.length + 1)`.\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if index is out of range.\n    // Throws an error if argument is not a segment or an array of segments.\n    insertSegment: function(index, arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        // note that these are incremented compared to getSegments()\n        // we can insert after last element (note that this changes the meaning of index -1)\n        if (index < 0) index = numSegments + index + 1; // convert negative indices to positive\n        if (index > numSegments || index < 0) throw new Error('Index out of range.');\n\n        var currentSegment;\n\n        var previousSegment = null;\n        var nextSegment = null;\n\n        if (numSegments !== 0) {\n            if (index >= 1) {\n                previousSegment = segments[index - 1];\n                nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null\n\n            } else { // if index === 0\n                // previousSegment is null\n                nextSegment = segments[0];\n            }\n        }\n\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.splice(index, 0, currentSegment);\n\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                previousSegment = currentSegment;\n            }\n        }\n    },\n\n    intersectionWithLine: function(line, opt) {\n\n        var intersection = null;\n        var polylines = this.toPolylines(opt);\n        if (!polylines) return null;\n        for (var i = 0, n = polylines.length; i < n; i++) {\n            var polyline = polylines[i];\n            var polylineIntersection = line.intersect(polyline);\n            if (polylineIntersection) {\n                intersection || (intersection = []);\n                if (Array.isArray(polylineIntersection)) {\n                    Array.prototype.push.apply(intersection, polylineIntersection);\n                } else {\n                    intersection.push(polylineIntersection);\n                }\n            }\n        }\n\n        return intersection;\n    },\n\n    isDifferentiable: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            // as soon as a differentiable segment is found in segments, return true\n            if (segment.isDifferentiable()) return true;\n        }\n\n        // if no differentiable segment is found in segments, return false\n        return false;\n    },\n\n    // Checks whether current path segments are valid.\n    // Note that d is allowed to be empty - should disable rendering of the path.\n    isValid: function() {\n\n        var segments = this.segments;\n        var isValid = (segments.length === 0) || (segments[0].type === 'M'); // either empty or first segment is a Moveto\n        return isValid;\n    },\n\n    // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.\n    // If path has no segments, returns 0.\n    length: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return 0; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var length = 0;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n            length += segment.length({ subdivisions: subdivisions });\n        }\n\n        return length;\n    },\n\n    // Private function.\n    lengthAtT: function(t, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return 0; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return 0; // regardless of t.value\n\n        var tValue = t.value;\n        if (segmentIndex >= numSegments) {\n            segmentIndex = numSegments - 1;\n            tValue = 1;\n        } else if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var subdivisions;\n        var length = 0;\n        for (var i = 0; i < segmentIndex; i++) {\n\n            var segment = segments[i];\n            subdivisions = segmentSubdivisions[i];\n            length += segment.length({ precisison: precision, subdivisions: subdivisions });\n        }\n\n        segment = segments[segmentIndex];\n        subdivisions = segmentSubdivisions[segmentIndex];\n        length += segment.lengthAtT(tValue, { precisison: precision, subdivisions: subdivisions });\n\n        return length;\n    },\n\n    // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    pointAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio <= 0) return this.start.clone();\n        if (ratio >= 1) return this.end.clone();\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.pointAtLength(length, localOpt);\n    },\n\n    // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    // Accepts negative length.\n    pointAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (length === 0) return this.start.clone();\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastVisibleSegment;\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isVisible) {\n                if (length <= (l + d)) {\n                    return segment.pointAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                }\n\n                lastVisibleSegment = segment;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return last visible segment endpoint\n        if (lastVisibleSegment) return (fromStart ? lastVisibleSegment.end : lastVisibleSegment.start);\n\n        // if no visible segment, return last segment end point (no matter if fromStart or no)\n        var lastSegment = segments[numSegments - 1];\n        return lastSegment.end.clone();\n    },\n\n    // Private function.\n    pointAtT: function(t) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return segments[0].pointAtT(0);\n        if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);\n\n        var tValue = t.value;\n        if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        return segments[segmentIndex].pointAtT(tValue);\n    },\n\n    // Default precision\n    PRECISION: 3,\n\n    // Helper method for adding segments.\n    prepareSegment: function(segment, previousSegment, nextSegment) {\n\n        // insert after previous segment and before previous segment's next segment\n        segment.previousSegment = previousSegment;\n        segment.nextSegment = nextSegment;\n        if (previousSegment) previousSegment.nextSegment = segment;\n        if (nextSegment) nextSegment.previousSegment = segment;\n\n        var updateSubpathStart = segment;\n        if (segment.isSubpathStart) {\n            segment.subpathStartSegment = segment; // assign self as subpath start segment\n            updateSubpathStart = nextSegment; // start updating from next segment\n        }\n\n        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n        if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);\n\n        return segment;\n    },\n\n    // Remove the segment at `index`.\n    // Accepts negative indices, from `-1` to `-segments.length`.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    removeSegment: function(index) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        var removedSegment = segments.splice(index, 1)[0];\n        var previousSegment = removedSegment.previousSegment;\n        var nextSegment = removedSegment.nextSegment;\n\n        // link the previous and next segments together (if present)\n        if (previousSegment) previousSegment.nextSegment = nextSegment; // may be null\n        if (nextSegment) nextSegment.previousSegment = previousSegment; // may be null\n\n        // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached\n        if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n    },\n\n    // Replace the segment at `index` with `arg`.\n    // Accepts negative indices, from `-1` to `-segments.length`.\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    // Throws an error if argument is not a segment or an array of segments.\n    replaceSegment: function(index, arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        var currentSegment;\n\n        var replacedSegment = segments[index];\n        var previousSegment = replacedSegment.previousSegment;\n        var nextSegment = replacedSegment.nextSegment;\n\n        var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?\n\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.splice(index, 1, currentSegment); // directly replace\n\n            if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            segments.splice(index, 1);\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                previousSegment = currentSegment;\n\n                if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n            }\n        }\n\n        // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached\n        if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n    },\n\n    round: function(precision) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.round(precision);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.scale(sx, sy, origin);\n        }\n\n        return this;\n    },\n\n    segmentAt: function(ratio, opt) {\n\n        var index = this.segmentIndexAt(ratio, opt);\n        if (!index) return null;\n\n        return this.getSegment(index);\n    },\n\n    // Accepts negative length.\n    segmentAtLength: function(length, opt) {\n\n        var index = this.segmentIndexAtLength(length, opt);\n        if (!index) return null;\n\n        return this.getSegment(index);\n    },\n\n    segmentIndexAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.segmentIndexAtLength(length, localOpt);\n    },\n\n    // Accepts negative length.\n    segmentIndexAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastVisibleSegmentIndex = null;\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isVisible) {\n                if (length <= (l + d)) return index;\n                lastVisibleSegmentIndex = index;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return last visible segment index\n        // if no visible segment, return null\n        return lastVisibleSegmentIndex;\n    },\n\n    // Returns a string that can be used to reconstruct the path.\n    // Additional error checking compared to toString (must start with M segment).\n    serialize: function() {\n\n        if (!this.isValid()) throw new Error('Invalid path segments.');\n\n        return this.toString();\n    },\n\n    // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    tangentAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.tangentAtLength(length, localOpt);\n    },\n\n    // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    // Accepts negative length.\n    tangentAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastValidSegment; // visible AND differentiable (with a tangent)\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isDifferentiable()) {\n                if (length <= (l + d)) {\n                    return segment.tangentAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                }\n\n                lastValidSegment = segment;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n        if (lastValidSegment) {\n            var t = (fromStart ? 1 : 0);\n            return lastValidSegment.tangentAtT(t);\n        }\n\n        // if no valid segment, return null\n        return null;\n    },\n\n    // Private function.\n    tangentAtT: function(t) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return segments[0].tangentAtT(0);\n        if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);\n\n        var tValue = t.value;\n        if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        return segments[segmentIndex].tangentAtT(tValue);\n    },\n\n    toPoints: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\n        var points = [];\n        var partialPoints = [];\n        for (var i = 0; i < numSegments; i++) {\n            var segment = segments[i];\n            if (segment.isVisible) {\n                var currentSegmentSubdivisions = segmentSubdivisions[i];\n                if (currentSegmentSubdivisions.length > 0) {\n                    var subdivisionPoints = currentSegmentSubdivisions.map(function(curve) {\n                        return curve.start;\n                    });\n                    Array.prototype.push.apply(partialPoints, subdivisionPoints);\n                } else {\n                    partialPoints.push(segment.start);\n                }\n            } else if (partialPoints.length > 0) {\n                partialPoints.push(segments[i - 1].end);\n                points.push(partialPoints);\n                partialPoints = [];\n            }\n        }\n\n        if (partialPoints.length > 0) {\n            partialPoints.push(this.end);\n            points.push(partialPoints);\n        }\n        return points;\n    },\n\n    toPolylines: function(opt) {\n\n        var polylines = [];\n        var points = this.toPoints(opt);\n        if (!points) return null;\n        for (var i = 0, n = points.length; i < n; i++) {\n            polylines.push(new Polyline(points[i]));\n        }\n\n        return polylines;\n    },\n\n    toString: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        var pathData = '';\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            pathData += segment.serialize() + ' ';\n        }\n\n        return pathData.trim();\n    },\n\n    translate: function(tx, ty) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.translate(tx, ty);\n        }\n\n        return this;\n    },\n\n    // Helper method for updating subpath start of segments, starting with the one provided.\n    updateSubpathStartSegment: function(segment) {\n\n        var previousSegment = segment.previousSegment; // may be null\n        while (segment && !segment.isSubpathStart) {\n\n            // assign previous segment's subpath start segment to this segment\n            if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment; // may be null\n            else segment.subpathStartSegment = null; // if segment had no previous segment, assign null - creates an invalid path!\n\n            previousSegment = segment;\n            segment = segment.nextSegment; // move on to the segment after etc.\n        }\n    },\n\n    // If the path is not valid, insert M 0 0 at the beginning.\n    // Path with no segments is considered valid, so nothing is inserted.\n    validate: function() {\n\n        if (!this.isValid()) this.insertSegment(0, Path.createSegment('M', 0, 0));\n        return this;\n    }\n};\n\nObject.defineProperty(Path.prototype, 'start', {\n    // Getter for the first visible endpoint of the path.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            if (segment.isVisible) return segment.start;\n        }\n\n        // if no visible segment, return last segment end point\n        return segments[numSegments - 1].end;\n    }\n});\n\nObject.defineProperty(Path.prototype, 'end', {\n    // Getter for the last visible endpoint of the path.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null;\n\n        for (var i = numSegments - 1; i >= 0; i--) {\n\n            var segment = segments[i];\n            if (segment.isVisible) return segment.end;\n        }\n\n        // if no visible segment, return last segment end point\n        return segments[numSegments - 1].end;\n    }\n});\n\n\n// Local helper function.\n// Use an array of arguments to call a constructor (function called with `new`).\n// Adapted from https://stackoverflow.com/a/8843181/2263595\n// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).\n// - If that is the case, use `new constructor(arg1, arg2)`, for example.\n// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.\n// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.\nfunction applyToNew(constructor, argsArray) {\n    // The `new` keyword can only be applied to functions that take a limited number of arguments.\n    // - We can fake that with .bind().\n    // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.\n    // - So `new (constructor.bind(thisArg, arg1, arg2...))`\n    // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.\n    // We need to pass in a variable number of arguments to the bind() call.\n    // - We can use .apply().\n    // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n    // - `thisArg` can still be anything because `new` overwrites it.\n    // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.\n    // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n\n    // The function expects `argsArray[0]` to be `thisArg`.\n    // - This means that whatever is sent as the first element will be ignored.\n    // - The constructor will only see arguments starting from argsArray[1].\n    // - So, a new dummy element is inserted at the start of the array.\n    argsArray.unshift(null);\n\n    return new (Function.prototype.bind.apply(constructor, argsArray));\n}\n\n// Path segment interface:\nvar segmentPrototype = {\n\n    // virtual\n    bbox: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    clone: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPoint: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPointLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPointNormalizedLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.\n    closestPointT: function(p) {\n\n        if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);\n\n        throw new Error('Neither closestPointT() nor closestPointNormalizedLength() function is implemented.');\n    },\n\n    // virtual\n    closestPointTangent: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    divideAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    divideAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to divideAt() function if divideAtT() is not defined for segment.\n    divideAtT: function(t) {\n\n        if (this.divideAt) return this.divideAt(t);\n\n        throw new Error('Neither divideAtT() nor divideAt() function is implemented.');\n    },\n\n    // virtual\n    equals: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    getSubdivisions: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    isDifferentiable: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    isSegment: true,\n\n    isSubpathStart: false, // true for Moveto segments\n\n    isVisible: true, // false for Moveto segments\n\n    // virtual\n    length: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Return a fraction of result of length() function if lengthAtT() is not defined for segment.\n    lengthAtT: function(t) {\n\n        if (t <= 0) return 0;\n\n        var length = this.length();\n\n        if (t >= 1) return length;\n\n        return length * t;\n    },\n\n    nextSegment: null, // needed for subpath start segment updating\n\n    // virtual\n    pointAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    pointAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to pointAt() function if pointAtT() is not defined for segment.\n    pointAtT: function(t) {\n\n        if (this.pointAt) return this.pointAt(t);\n\n        throw new Error('Neither pointAtT() nor pointAt() function is implemented.');\n    },\n\n    previousSegment: null, // needed to get segment start property\n\n    // virtual\n    round: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    subpathStartSegment: null, // needed to get Closepath segment end property\n\n    // virtual\n    scale: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    serialize: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    tangentAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    tangentAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.\n    tangentAtT: function(t) {\n\n        if (this.tangentAt) return this.tangentAt(t);\n\n        throw new Error('Neither tangentAtT() nor tangentAt() function is implemented.');\n    },\n\n    // virtual\n    toString: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    translate: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    }\n};\n\n// usually directly assigned\n// getter for Closepath\nObject.defineProperty(segmentPrototype, 'end', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    writable: true\n});\n\n// always a getter\n// always throws error for Moveto\nObject.defineProperty(segmentPrototype, 'start', {\n    // get a reference to the end point of previous segment\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        if (!this.previousSegment) throw new Error('Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)');\n\n        return this.previousSegment.end;\n    }\n});\n\n// virtual\nObject.defineProperty(segmentPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        throw new Error('Bad segment declaration. No type specified.');\n    }\n});\n\n// Path segment implementations:\nvar Lineto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Lineto)) { // switching context of `this` to Lineto when called without `new`\n        return applyToNew(Lineto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof Line) { // lines provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' lines provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 2) {\n            this.end = new Point(+args[0], +args[1]);\n            return this;\n\n        } else if (n < 2) {\n            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a poly-line segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                outputArray.push(applyToNew(Lineto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 1) {\n            this.end = new Point(args[0]);\n            return this;\n\n        } else { // this is a poly-line segment\n            var segmentPoint;\n            outputArray = [];\n            for (i = 0; i < n; i += 1) {\n\n                segmentPoint = args[i];\n                outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar linetoPrototype = {\n\n    clone: function() {\n\n        return new Lineto(this.end);\n    },\n\n    divideAt: function(ratio) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAt(ratio);\n        return [\n            new Lineto(divided[0]),\n            new Lineto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAtLength(length);\n        return [\n            new Lineto(divided[0]),\n            new Lineto(divided[1])\n        ];\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment) return false;\n\n        return !this.start.equals(this.end);\n    },\n\n    round: function(precision) {\n\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var end = this.end;\n        return this.type + ' ' + end.x + ' ' + end.y;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(linetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'L'\n});\n\nLineto.prototype = extend(segmentPrototype, Line.prototype, linetoPrototype);\n\nvar Curveto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Curveto)) { // switching context of `this` to Curveto when called without `new`\n        return applyToNew(Curveto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof Curve) { // curves provided\n        if (n === 1) {\n            this.controlPoint1 = args[0].controlPoint1.clone();\n            this.controlPoint2 = args[0].controlPoint2.clone();\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' curves provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 6) {\n            this.controlPoint1 = new Point(+args[0], +args[1]);\n            this.controlPoint2 = new Point(+args[2], +args[3]);\n            this.end = new Point(+args[4], +args[5]);\n            return this;\n\n        } else if (n < 6) {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a poly-bezier segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 6) { // coords come in groups of six\n\n                segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6\n                outputArray.push(applyToNew(Curveto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 3) {\n            this.controlPoint1 = new Point(args[0]);\n            this.controlPoint2 = new Point(args[1]);\n            this.end = new Point(args[2]);\n            return this;\n\n        } else if (n < 3) {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' points provided).');\n\n        } else { // this is a poly-bezier segment\n            var segmentPoints;\n            outputArray = [];\n            for (i = 0; i < n; i += 3) { // points come in groups of three\n\n                segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3\n                outputArray.push(applyToNew(Curveto, segmentPoints));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar curvetoPrototype = {\n\n    clone: function() {\n\n        return new Curveto(this.controlPoint1, this.controlPoint2, this.end);\n    },\n\n    divideAt: function(ratio, opt) {\n\n        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAt(ratio, opt);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length, opt) {\n\n        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAtLength(length, opt);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    divideAtT: function(t) {\n\n        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAtT(t);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment) return false;\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    },\n\n    round: function(precision) {\n\n        this.controlPoint1.round(precision);\n        this.controlPoint2.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var c1 = this.controlPoint1;\n        var c2 = this.controlPoint2;\n        var end = this.end;\n        return this.type + ' ' + c1.x + ' ' + c1.y + ' ' + c2.x + ' ' + c2.y + ' ' + end.x + ' ' + end.y;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(curvetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'C'\n});\n\nCurveto.prototype = extend(segmentPrototype, Curve.prototype, curvetoPrototype);\n\nvar Moveto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Moveto)) { // switching context of `this` to Moveto when called without `new`\n        return applyToNew(Moveto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof Line) { // lines provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' lines provided).');\n        }\n\n    } else if (args[0] instanceof Curve) { // curves provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' curves provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 2) {\n            this.end = new Point(+args[0], +args[1]);\n            return this;\n\n        } else if (n < 2) {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a moveto-with-subsequent-poly-line segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));\n                else outputArray.push(applyToNew(Lineto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 1) {\n            this.end = new Point(args[0]);\n            return this;\n\n        } else { // this is a moveto-with-subsequent-poly-line segment\n            var segmentPoint;\n            outputArray = [];\n            for (i = 0; i < n; i += 1) { // points come one by one\n\n                segmentPoint = args[i];\n                if (i === 0) outputArray.push(new Moveto(segmentPoint));\n                else outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar movetoPrototype = {\n\n    bbox: function() {\n\n        return null;\n    },\n\n    clone: function() {\n\n        return new Moveto(this.end);\n    },\n\n    closestPoint: function() {\n\n        return this.end.clone();\n    },\n\n    closestPointNormalizedLength: function() {\n\n        return 0;\n    },\n\n    closestPointLength: function() {\n\n        return 0;\n    },\n\n    closestPointT: function() {\n\n        return 1;\n    },\n\n    closestPointTangent: function() {\n\n        return null;\n    },\n\n    divideAt: function() {\n\n        return [\n            this.clone(),\n            this.clone()\n        ];\n    },\n\n    divideAtLength: function() {\n\n        return [\n            this.clone(),\n            this.clone()\n        ];\n    },\n\n    equals: function(m) {\n\n        return this.end.equals(m.end);\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        return false;\n    },\n\n    isSubpathStart: true,\n\n    isVisible: false,\n\n    length: function() {\n\n        return 0;\n    },\n\n    lengthAtT: function() {\n\n        return 0;\n    },\n\n    pointAt: function() {\n\n        return this.end.clone();\n    },\n\n    pointAtLength: function() {\n\n        return this.end.clone();\n    },\n\n    pointAtT: function() {\n\n        return this.end.clone();\n    },\n\n    round: function(precision) {\n\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var end = this.end;\n        return this.type + ' ' + end.x + ' ' + end.y;\n    },\n\n    tangentAt: function() {\n\n        return null;\n    },\n\n    tangentAtLength: function() {\n\n        return null;\n    },\n\n    tangentAtT: function() {\n\n        return null;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(movetoPrototype, 'start', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        throw new Error('Illegal access. Moveto segments should not need a start property.');\n    }\n});\n\nObject.defineProperty(movetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'M'\n});\n\nMoveto.prototype = extend(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object\n\nvar Closepath = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Closepath)) { // switching context of `this` to Closepath when called without `new`\n        return applyToNew(Closepath, args);\n    }\n\n    if (n > 0) {\n        throw new Error('Closepath constructor expects no arguments.');\n    }\n\n    return this;\n};\n\nvar closepathPrototype = {\n\n    clone: function() {\n\n        return new Closepath();\n    },\n\n    divideAt: function(ratio) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAt(ratio);\n        return [\n            // if we didn't actually cut into the segment, first divided part can stay as Z\n            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n            new Lineto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAtLength(length);\n        return [\n            // if we didn't actually cut into the segment, first divided part can stay as Z\n            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n            new Lineto(divided[1])\n        ];\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment || !this.subpathStartSegment) return false;\n\n        return !this.start.equals(this.end);\n    },\n\n    round: function() {\n\n        return this;\n    },\n\n    scale: function() {\n\n        return this;\n    },\n\n    serialize: function() {\n\n        return this.type;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.end;\n    },\n\n    translate: function() {\n\n        return this;\n    }\n};\n\nObject.defineProperty(closepathPrototype, 'end', {\n    // get a reference to the end point of subpath start segment\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        if (!this.subpathStartSegment) throw new Error('Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)');\n\n        return this.subpathStartSegment.end;\n    }\n});\n\nObject.defineProperty(closepathPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'Z'\n});\n\nClosepath.prototype = extend(segmentPrototype, Line.prototype, closepathPrototype);\n\nvar segmentTypes = Path.segmentTypes = {\n    L: Lineto,\n    C: Curveto,\n    M: Moveto,\n    Z: Closepath,\n    z: Closepath\n};\n\nPath.regexSupportedData = new RegExp('^[\\\\s\\\\d' + Object.keys(segmentTypes).join('') + ',.]*$');\n\nPath.isDataSupported = function(data) {\n\n    if (typeof data !== 'string') return false;\n    return this.regexSupportedData.test(data);\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5278, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5284, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/g/bezier.mjs"],"sourcesContent":["import { Path } from './path.mjs';\nimport { Curve } from './curve.mjs';\nimport { Point } from './point.mjs';\n\nexport const bezier = {\n\n    // Cubic Bezier curve path through points.\n    // @deprecated\n    // @param {array} points Array of points through which the smooth line will go.\n    // @return {array} SVG Path commands as an array\n    curveThroughPoints: function(points) {\n\n        console.warn('deprecated');\n\n        return new Path(Curve.throughPoints(points)).serialize();\n    },\n\n    // Get open-ended Bezier Spline Control Points.\n    // @deprecated\n    // @param knots Input Knot Bezier spline points (At least two points!).\n    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n    getCurveControlPoints: function(knots) {\n\n        console.warn('deprecated');\n\n        var firstControlPoints = [];\n        var secondControlPoints = [];\n        var n = knots.length - 1;\n        var i;\n\n        // Special case: Bezier curve should be a straight line.\n        if (n == 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new Point(\n                (2 * knots[0].x + knots[1].x) / 3,\n                (2 * knots[0].y + knots[1].y) / 3\n            );\n\n            // P2 = 2P1  P0\n            secondControlPoints[0] = new Point(\n                2 * firstControlPoints[0].x - knots[0].x,\n                2 * firstControlPoints[0].y - knots[0].y\n            );\n\n            return [firstControlPoints, secondControlPoints];\n        }\n\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        var rhs = [];\n\n        // Set right hand side X values.\n        for (i = 1; i < n - 1; i++) {\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n        // Get first control points X-values.\n        var x = this.getFirstControlPoints(rhs);\n\n        // Set right hand side Y values.\n        for (i = 1; i < n - 1; ++i) {\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n        // Get first control points Y-values.\n        var y = this.getFirstControlPoints(rhs);\n\n        // Fill output arrays.\n        for (i = 0; i < n; i++) {\n            // First control point.\n            firstControlPoints.push(new Point(x[i], y[i]));\n\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new Point(\n                    2 * knots [i + 1].x - x[i + 1],\n                    2 * knots[i + 1].y - y[i + 1]\n                ));\n\n            } else {\n                secondControlPoints.push(new Point(\n                    (knots[n].x + x[n - 1]) / 2,\n                    (knots[n].y + y[n - 1]) / 2)\n                );\n            }\n        }\n\n        return [firstControlPoints, secondControlPoints];\n    },\n\n    // Divide a Bezier curve into two at point defined by value 't' <0,1>.\n    // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\n    // @deprecated\n    // @param control points (start, control start, control end, end)\n    // @return a function that accepts t and returns 2 curves.\n    getCurveDivider: function(p0, p1, p2, p3) {\n\n        console.warn('deprecated');\n\n        var curve = new Curve(p0, p1, p2, p3);\n\n        return function divideCurve(t) {\n\n            var divided = curve.divide(t);\n\n            return [{\n                p0: divided[0].start,\n                p1: divided[0].controlPoint1,\n                p2: divided[0].controlPoint2,\n                p3: divided[0].end\n            }, {\n                p0: divided[1].start,\n                p1: divided[1].controlPoint1,\n                p2: divided[1].controlPoint2,\n                p3: divided[1].end\n            }];\n        };\n    },\n\n    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n    // @deprecated\n    // @param rhs Right hand side vector.\n    // @return Solution vector.\n    getFirstControlPoints: function(rhs) {\n\n        console.warn('deprecated');\n\n        var n = rhs.length;\n        // `x` is a solution vector.\n        var x = [];\n        var tmp = [];\n        var b = 2.0;\n\n        x[0] = rhs[0] / b;\n\n        // Decomposition and forward substitution.\n        for (var i = 1; i < n; i++) {\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n\n        for (i = 1; i < n; i++) {\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n\n        return x;\n    },\n\n    // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\n    // a parametric curve x = x(t)/w(t), y = y(t)/w(t), nd the parameter value t\n    // which corresponds to that point.\n    // @deprecated\n    // @param control points (start, control start, control end, end)\n    // @return a function that accepts a point and returns t.\n    getInversionSolver: function(p0, p1, p2, p3) {\n\n        console.warn('deprecated');\n\n        var curve = new Curve(p0, p1, p2, p3);\n\n        return function solveInversion(p) {\n\n            return curve.closestPointT(p);\n        };\n    }\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5423, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}