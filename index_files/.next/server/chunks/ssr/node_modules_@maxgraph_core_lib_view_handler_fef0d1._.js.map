{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/handler/ConstraintHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Image from '../image/ImageBox';\nimport Client from '../../Client';\nimport { DEFAULT_VALID_COLOR, DIALECT, HIGHLIGHT_OPACITY, HIGHLIGHT_SIZE, HIGHLIGHT_STROKEWIDTH, } from '../../util/Constants';\nimport InternalEvent from '../event/InternalEvent';\nimport { intersects } from '../../util/mathUtils';\nimport Rectangle from '../geometry/Rectangle';\nimport ImageShape from '../geometry/node/ImageShape';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport { isShiftDown } from '../../util/EventUtils';\n/**\n * Handles constraints on connection targets. This class is in charge of\n * showing fixed points when the mouse is over a vertex and handles constraints\n * to establish new connections.\n *\n * @class ConstraintHandler\n */\nclass ConstraintHandler {\n    constructor(graph) {\n        /**\n         * {@link Image} to be used as the image for fixed connection points.\n         */\n        this.pointImage = new Image(`${Client.imageBasePath}/point.gif`, 5, 5);\n        this.currentFocus = null;\n        this.currentFocusArea = null;\n        this.focusIcons = [];\n        this.constraints = null;\n        this.currentConstraint = null;\n        this.focusHighlight = null;\n        this.focusPoints = [];\n        this.currentPoint = null;\n        /**\n         * Specifies if events are handled. Default is true.\n         */\n        this.enabled = true;\n        /**\n         * Specifies the color for the highlight. Default is {@link DEFAULT_VALID_COLOR}.\n         */\n        this.highlightColor = DEFAULT_VALID_COLOR;\n        this.mouseleaveHandler = null;\n        this.graph = graph;\n        // Adds a graph model listener to update the current focus on changes\n        this.resetHandler = () => {\n            if (this.currentFocus && !this.graph.view.getState(this.currentFocus.cell)) {\n                this.reset();\n            }\n            else {\n                this.redraw();\n            }\n        };\n        this.graph.model.addListener(InternalEvent.CHANGE, this.resetHandler);\n        this.graph.view.addListener(InternalEvent.SCALE_AND_TRANSLATE, this.resetHandler);\n        this.graph.view.addListener(InternalEvent.TRANSLATE, this.resetHandler);\n        this.graph.view.addListener(InternalEvent.SCALE, this.resetHandler);\n        this.graph.addListener(InternalEvent.ROOT, this.resetHandler);\n    }\n    /**\n     * Returns true if events are handled. This implementation\n     * returns {@link enabled}.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling. This implementation\n     * updates {@link enabled}.\n     *\n     * @param {boolean} enabled - Boolean that specifies the new enabled state.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Resets the state of this handler.\n     */\n    reset() {\n        for (let i = 0; i < this.focusIcons.length; i += 1) {\n            this.focusIcons[i].destroy();\n        }\n        this.focusIcons = [];\n        if (this.focusHighlight) {\n            this.focusHighlight.destroy();\n            this.focusHighlight = null;\n        }\n        this.currentConstraint = null;\n        this.currentFocusArea = null;\n        this.currentPoint = null;\n        this.currentFocus = null;\n        this.focusPoints = [];\n    }\n    /**\n     * Returns the tolerance to be used for intersecting connection points. This\n     * implementation returns {@link mxGraph.tolerance}.\n     *\n     * @param me {@link mxMouseEvent} whose tolerance should be returned.\n     */\n    getTolerance(me) {\n        return this.graph.getEventTolerance();\n    }\n    /**\n     * Returns the tolerance to be used for intersecting connection points.\n     */\n    getImageForConstraint(state, constraint, point) {\n        return this.pointImage;\n    }\n    /**\n     * Returns true if the given {@link mxMouseEvent} should be ignored in {@link update}. This\n     * implementation always returns false.\n     */\n    isEventIgnored(me, source = false) {\n        return false;\n    }\n    /**\n     * Returns true if the given state should be ignored. This always returns false.\n     */\n    isStateIgnored(state, source = false) {\n        return false;\n    }\n    /**\n     * Destroys the {@link focusIcons} if they exist.\n     */\n    destroyIcons() {\n        for (let i = 0; i < this.focusIcons.length; i += 1) {\n            this.focusIcons[i].destroy();\n        }\n        this.focusIcons = [];\n        this.focusPoints = [];\n    }\n    /**\n     * Destroys the {@link focusHighlight} if one exists.\n     */\n    destroyFocusHighlight() {\n        if (this.focusHighlight) {\n            this.focusHighlight.destroy();\n            this.focusHighlight = null;\n        }\n    }\n    /**\n     * Returns true if the current focused state should not be changed for the given event.\n     * This returns true if shift and alt are pressed.\n     */\n    isKeepFocusEvent(me) {\n        return isShiftDown(me.getEvent());\n    }\n    /**\n     * Returns the cell for the given event.\n     */\n    getCellForEvent(me, point) {\n        let cell = me.getCell();\n        // Gets cell under actual point if different from event location\n        if (!cell && point && (me.getGraphX() !== point.x || me.getGraphY() !== point.y)) {\n            cell = this.graph.getCellAt(point.x, point.y);\n        }\n        // Uses connectable parent vertex if one exists\n        if (cell && !cell.isConnectable()) {\n            const parent = cell.getParent();\n            if (parent && parent.isVertex() && parent.isConnectable()) {\n                cell = parent;\n            }\n        }\n        if (cell) {\n            return this.graph.isCellLocked(cell) ? null : cell;\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Updates the state of this handler based on the given {@link mxMouseEvent}.\n     * Source is a boolean indicating if the cell is a source or target.\n     */\n    update(me, source, existingEdge, point) {\n        if (this.isEnabled() && !this.isEventIgnored(me)) {\n            // Lazy installation of mouseleave handler\n            if (!this.mouseleaveHandler && this.graph.container) {\n                this.mouseleaveHandler = () => {\n                    this.reset();\n                };\n                InternalEvent.addListener(this.graph.container, 'mouseleave', this.resetHandler);\n            }\n            const tol = this.getTolerance(me);\n            const x = point ? point.x : me.getGraphX();\n            const y = point ? point.y : me.getGraphY();\n            const grid = new Rectangle(x - tol, y - tol, 2 * tol, 2 * tol);\n            const mouse = new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol);\n            const state = this.graph.view.getState(this.getCellForEvent(me, point));\n            // Keeps focus icons visible while over vertex bounds and no other cell under mouse or shift is pressed\n            if (!this.isKeepFocusEvent(me) &&\n                (!this.currentFocusArea ||\n                    !this.currentFocus ||\n                    state ||\n                    !this.currentFocus.cell.isVertex() ||\n                    !intersects(this.currentFocusArea, mouse)) &&\n                state !== this.currentFocus) {\n                this.currentFocusArea = null;\n                this.currentFocus = null;\n                this.setFocus(me, state, source);\n            }\n            this.currentConstraint = null;\n            this.currentPoint = null;\n            let minDistSq = null;\n            let tmp;\n            if (this.focusIcons.length > 0 &&\n                this.constraints &&\n                (!state || this.currentFocus === state)) {\n                const cx = mouse.getCenterX();\n                const cy = mouse.getCenterY();\n                for (let i = 0; i < this.focusIcons.length; i += 1) {\n                    const dx = cx - this.focusIcons[i].bounds.getCenterX();\n                    const dy = cy - this.focusIcons[i].bounds.getCenterY();\n                    tmp = dx * dx + dy * dy;\n                    if ((this.intersects(this.focusIcons[i], mouse, source, existingEdge) ||\n                        (point &&\n                            this.intersects(this.focusIcons[i], grid, source, existingEdge))) &&\n                        (minDistSq === null || tmp < minDistSq)) {\n                        this.currentConstraint = this.constraints[i];\n                        this.currentPoint = this.focusPoints[i];\n                        minDistSq = tmp;\n                        tmp = this.focusIcons[i].bounds.clone();\n                        tmp.grow(HIGHLIGHT_SIZE + 1);\n                        tmp.width -= 1;\n                        tmp.height -= 1;\n                        if (!this.focusHighlight) {\n                            const hl = this.createHighlightShape();\n                            hl.dialect = DIALECT.SVG;\n                            hl.pointerEvents = false;\n                            hl.init(this.graph.getView().getOverlayPane());\n                            this.focusHighlight = hl;\n                            const getState = () => {\n                                return this.currentFocus ? this.currentFocus : state;\n                            };\n                            InternalEvent.redirectMouseEvents(hl.node, this.graph, getState);\n                        }\n                        this.focusHighlight.bounds = tmp;\n                        this.focusHighlight.redraw();\n                    }\n                }\n            }\n            if (!this.currentConstraint) {\n                this.destroyFocusHighlight();\n            }\n        }\n        else {\n            this.currentConstraint = null;\n            this.currentFocus = null;\n            this.currentPoint = null;\n        }\n    }\n    /**\n     * Transfers the focus to the given state as a source or target terminal. If\n     * the handler is not enabled then the outline is painted, but the constraints\n     * are ignored.\n     */\n    redraw() {\n        if (this.currentFocus && this.constraints && this.focusIcons.length > 0) {\n            const state = this.graph.view.getState(this.currentFocus.cell);\n            this.currentFocus = state;\n            this.currentFocusArea = new Rectangle(state.x, state.y, state.width, state.height);\n            for (let i = 0; i < this.constraints.length; i += 1) {\n                const cp = this.graph.getConnectionPoint(state, this.constraints[i]);\n                const img = this.getImageForConstraint(state, this.constraints[i], cp);\n                const bounds = new Rectangle(Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);\n                this.focusIcons[i].bounds = bounds;\n                this.focusIcons[i].redraw();\n                this.currentFocusArea.add(this.focusIcons[i].bounds);\n                this.focusPoints[i] = cp;\n            }\n        }\n    }\n    /**\n     * Transfers the focus to the given state as a source or target terminal. If\n     * the handler is not enabled then the outline is painted, but the constraints\n     * are ignored.\n     */\n    setFocus(me, state, source) {\n        this.constraints =\n            state && !this.isStateIgnored(state, source) && state.cell.isConnectable()\n                ? this.isEnabled()\n                    ? this.graph.getAllConnectionConstraints(state, source) ?? []\n                    : []\n                : null;\n        // Only uses cells which have constraints\n        if (this.constraints && state) {\n            this.currentFocus = state;\n            this.currentFocusArea = new Rectangle(state.x, state.y, state.width, state.height);\n            for (let i = 0; i < this.focusIcons.length; i += 1) {\n                this.focusIcons[i].destroy();\n            }\n            this.focusIcons = [];\n            this.focusPoints = [];\n            for (let i = 0; i < this.constraints.length; i += 1) {\n                const cp = this.graph.getConnectionPoint(state, this.constraints[i]);\n                const img = this.getImageForConstraint(state, this.constraints[i], cp);\n                const { src } = img;\n                const bounds = new Rectangle(Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);\n                const icon = new ImageShape(bounds, src);\n                icon.dialect =\n                    this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n                icon.preserveImageAspect = false;\n                icon.init(this.graph.getView().getDecoratorPane());\n                // Move the icon behind all other overlays\n                if (icon.node.previousSibling) {\n                    icon.node.parentNode?.insertBefore(icon.node, icon.node.parentNode.firstChild);\n                }\n                const getState = () => {\n                    return this.currentFocus ? this.currentFocus : state;\n                };\n                icon.redraw();\n                InternalEvent.redirectMouseEvents(icon.node, this.graph, getState);\n                this.currentFocusArea.add(icon.bounds);\n                this.focusIcons.push(icon);\n                this.focusPoints.push(cp);\n            }\n            this.currentFocusArea.grow(this.getTolerance(me));\n        }\n        else {\n            this.destroyIcons();\n            this.destroyFocusHighlight();\n        }\n    }\n    /**\n     * Create the shape used to paint the highlight.\n     *\n     * Returns true if the given icon intersects the given point.\n     */\n    createHighlightShape() {\n        const hl = new RectangleShape(new Rectangle(), this.highlightColor, this.highlightColor, HIGHLIGHT_STROKEWIDTH);\n        hl.opacity = HIGHLIGHT_OPACITY;\n        return hl;\n    }\n    /**\n     * Returns true if the given icon intersects the given rectangle.\n     */\n    intersects(icon, mouse, source, existingEdge) {\n        return intersects(icon.bounds, mouse);\n    }\n    /**\n     * Destroy this handler.\n     */\n    onDestroy() {\n        this.reset();\n        this.graph.model.removeListener(this.resetHandler);\n        this.graph.view.removeListener(this.resetHandler);\n        this.graph.removeListener(this.resetHandler);\n        if (this.mouseleaveHandler && this.graph.container) {\n            InternalEvent.removeListener(this.graph.container, 'mouseleave', this.mouseleaveHandler);\n            this.mouseleaveHandler = null;\n        }\n    }\n}\nexport default ConstraintHandler;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 343, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 349, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/handler/config.js"],"sourcesContent":["/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { CONNECT_HANDLE_FILLCOLOR, EDGE_SELECTION_COLOR, EDGE_SELECTION_DASHED, EDGE_SELECTION_STROKEWIDTH, HANDLE_FILLCOLOR, HANDLE_SIZE, HANDLE_STROKECOLOR, LABEL_HANDLE_FILLCOLOR, LABEL_HANDLE_SIZE, VERTEX_SELECTION_COLOR, VERTEX_SELECTION_DASHED, VERTEX_SELECTION_STROKEWIDTH, } from '../../util/Constants';\nimport { shallowCopy } from '../../util/cloneUtils';\n/**\n * Global configuration for {@link EdgeHandler} (including subclasses).\n *\n * @experimental Subject to change or removal. maxGraph's global configuration may be modified in the future without prior notice.\n * @since 0.14.0\n * @category Configuration\n */\nexport const EdgeHandlerConfig = {\n    connectFillColor: CONNECT_HANDLE_FILLCOLOR,\n    handleShape: 'square',\n    selectionColor: EDGE_SELECTION_COLOR,\n    selectionStrokeWidth: EDGE_SELECTION_STROKEWIDTH,\n    selectionDashed: EDGE_SELECTION_DASHED,\n};\nconst defaultEdgeHandlerConfig = { ...EdgeHandlerConfig };\n/**\n * Resets {@link EdgeHandlerConfig} to default values.\n *\n * @experimental Subject to change or removal. maxGraph's global configuration may be modified in the future without prior notice.\n * @since 0.14.0\n * @category Configuration\n */\nexport const resetEdgeHandlerConfig = () => {\n    shallowCopy(defaultEdgeHandlerConfig, EdgeHandlerConfig);\n};\n/**\n * Global configuration for handles, used {@link VertexHandler} and {@link EdgeHandler} (including subclasses).\n *\n * @experimental Subject to change or removal. maxGraph's global configuration may be modified in the future without prior notice.\n * @since 0.14.0\n * @category Configuration\n */\nexport const HandleConfig = {\n    /**\n     * Defines the default color to be used for the handle fill color. Use `none` for no color.\n     * @default {@link HANDLE_FILLCOLOR}\n     */\n    fillColor: HANDLE_FILLCOLOR,\n    /**\n     * Defines the color to be used for the label handle fill color. Use `none` for no color.\n     * @default {@link LABEL_HANDLE_FILLCOLOR}\n     */\n    labelFillColor: LABEL_HANDLE_FILLCOLOR,\n    /**\n     * Defines the default size for label handles.\n     * @default {@link LABEL_HANDLE_SIZE}\n     */\n    labelSize: LABEL_HANDLE_SIZE,\n    /**\n     * Defines the default size for handles.\n     * @default {@link HANDLE_SIZE}\n     */\n    size: HANDLE_SIZE,\n    /**\n     * Defines the default color to be used for the handle stroke color. Use `none` for no color.\n     * @default {@link HANDLE_STROKECOLOR}\n     */\n    strokeColor: HANDLE_STROKECOLOR,\n};\nconst defaultHandleConfig = { ...HandleConfig };\n/**\n * Resets {@link HandleConfig} to default values.\n *\n * @experimental Subject to change or removal. maxGraph's global configuration may be modified in the future without prior notice.\n * @since 0.14.0\n * @category Configuration\n */\nexport const resetHandleConfig = () => {\n    shallowCopy(defaultHandleConfig, HandleConfig);\n};\n/**\n * Global configuration for {@link VertexHandler}.\n *\n * @experimental Subject to change or removal. maxGraph's global configuration may be modified in the future without prior notice.\n * @since 0.12.0\n * @category Configuration\n */\nexport const VertexHandlerConfig = {\n    /**\n     * Enable rotation handle\n     * @default false\n     */\n    rotationEnabled: false,\n    /**\n     * Defines the default color to be used for the selection border of vertices. Use `none` for no color.\n     * @default {@link VERTEX_SELECTION_COLOR}\n     * @since 0.14.0\n     */\n    selectionColor: VERTEX_SELECTION_COLOR,\n    /**\n     * Defines the default stroke width to be used for vertex selections.\n     * @default {@link VERTEX_SELECTION_STROKEWIDTH}\n     * @since 0.14.0\n     */\n    selectionStrokeWidth: VERTEX_SELECTION_STROKEWIDTH,\n    /**\n     * Defines the default dashed state to be used for the vertex selection border.\n     * @default {@link VERTEX_SELECTION_DASHED}\n     * @since 0.14.0\n     */\n    selectionDashed: VERTEX_SELECTION_DASHED,\n};\nconst defaultVertexHandlerConfig = { ...VertexHandlerConfig };\n/**\n * Resets {@link VertexHandlerConfig} to default values.\n *\n * @experimental Subject to change or removal. maxGraph's global configuration may be modified in the future without prior notice.\n * @since 0.14.0\n * @category Configuration\n */\nexport const resetVertexHandlerConfig = () => {\n    shallowCopy(defaultVertexHandlerConfig, VertexHandlerConfig);\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcA;;;;;;;;AACA;AACA;;;AAQO,MAAM,oBAAoB;IAC7B,kBAAkB,8JAAA,CAAA,2BAAwB;IAC1C,aAAa;IACb,gBAAgB,8JAAA,CAAA,uBAAoB;IACpC,sBAAsB,8JAAA,CAAA,6BAA0B;IAChD,iBAAiB,8JAAA,CAAA,wBAAqB;AAC1C;AACA,MAAM,2BAA2B;IAAE,GAAG,iBAAiB;AAAC;AAQjD,MAAM,yBAAyB;IAClC,CAAA,GAAA,+JAAA,CAAA,cAAW,AAAD,EAAE,0BAA0B;AAC1C;AAQO,MAAM,eAAe;IACxB;;;KAGC,GACD,WAAW,8JAAA,CAAA,mBAAgB;IAC3B;;;KAGC,GACD,gBAAgB,8JAAA,CAAA,yBAAsB;IACtC;;;KAGC,GACD,WAAW,8JAAA,CAAA,oBAAiB;IAC5B;;;KAGC,GACD,MAAM,8JAAA,CAAA,cAAW;IACjB;;;KAGC,GACD,aAAa,8JAAA,CAAA,qBAAkB;AACnC;AACA,MAAM,sBAAsB;IAAE,GAAG,YAAY;AAAC;AAQvC,MAAM,oBAAoB;IAC7B,CAAA,GAAA,+JAAA,CAAA,cAAW,AAAD,EAAE,qBAAqB;AACrC;AAQO,MAAM,sBAAsB;IAC/B;;;KAGC,GACD,iBAAiB;IACjB;;;;KAIC,GACD,gBAAgB,8JAAA,CAAA,yBAAsB;IACtC;;;;KAIC,GACD,sBAAsB,8JAAA,CAAA,+BAA4B;IAClD;;;;KAIC,GACD,iBAAiB,8JAAA,CAAA,0BAAuB;AAC5C;AACA,MAAM,6BAA6B;IAAE,GAAG,mBAAmB;AAAC;AAQrD,MAAM,2BAA2B;IACpC,CAAA,GAAA,+JAAA,CAAA,cAAW,AAAD,EAAE,4BAA4B;AAC5C","ignoreList":[0]}},
    {"offset": {"line": 443, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 449, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/handler/EdgeHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellMarker from '../cell/CellMarker';\nimport Point from '../geometry/Point';\nimport { CURSOR, DEFAULT_HOTSPOT, DEFAULT_INVALID_COLOR, DEFAULT_VALID_COLOR, DIALECT, HIGHLIGHT_STROKEWIDTH, LOCKED_HANDLE_FILLCOLOR, NONE, OUTLINE_HIGHLIGHT_COLOR, OUTLINE_HIGHLIGHT_STROKEWIDTH, } from '../../util/Constants';\nimport { contains, findNearestSegment, intersects, ptSegDistSq, } from '../../util/mathUtils';\nimport { convertPoint, getOffset, setOpacity } from '../../util/styleUtils';\nimport EllipseShape from '../geometry/node/EllipseShape';\nimport ImageShape from '../geometry/node/ImageShape';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport ConnectionConstraint from '../other/ConnectionConstraint';\nimport InternalEvent from '../event/InternalEvent';\nimport ConstraintHandler from './ConstraintHandler';\nimport Rectangle from '../geometry/Rectangle';\nimport Client from '../../Client';\nimport EdgeStyle from '../style/EdgeStyle';\nimport { getClientX, getClientY, isAltDown, isMouseEvent, isShiftDown, } from '../../util/EventUtils';\nimport { equalPoints } from '../../util/arrayUtils';\nimport { EdgeHandlerConfig, HandleConfig } from './config';\n/**\n * Graph event handler that reconnects edges, modifies control points and the edge label location.\n *\n * Uses {@link CellMarker} for finding and highlighting new source and target vertices.\n *\n * This handler is automatically created in {@link Graph.createHandler} for each selected edge.\n *\n * Some elements of this handler and its subclasses can be configured using {@link EdgeHandlerConfig}.\n */\nclass EdgeHandler {\n    constructor(state) {\n        /**\n         * Holds the current validation error while a connection is being changed.\n         */\n        this.error = null;\n        /**\n         * Holds the {@link Shape}s that represent the points.\n         */\n        this.bends = [];\n        /**\n         * Specifies if cloning by control-drag is enabled.\n         * @default true\n         */\n        this.cloneEnabled = true;\n        /**\n         * Specifies if adding bends by shift-click is enabled.\n         *\n         * **Note**: This experimental feature is not recommended for production use.\n         * @default false\n         */\n        this.addEnabled = false;\n        /**\n         * Specifies if removing bends by shift-click is enabled.\n         *\n         * **Note**: This experimental feature is not recommended for production use.\n         * @default false\n         */\n        this.removeEnabled = false;\n        /**\n         * Specifies if removing bends by double click is enabled.\n         * @default false\n         */\n        this.dblClickRemoveEnabled = false;\n        /**\n         * Specifies if removing bends by dropping them on other bends is enabled.\n         * @default false\n         */\n        this.mergeRemoveEnabled = false;\n        /**\n         * Specifies if removing bends by creating straight segments should be enabled.\n         * If enabled, this can be overridden by holding down the alt key while moving.\n         * @default false\n         */\n        this.straightRemoveEnabled = false;\n        /**\n         * Specifies if virtual bends should be added in the center of each segment.\n         * These bends can then be used to add new waypoints.\n         * @default false\n         */\n        this.virtualBendsEnabled = false;\n        /**\n         * Opacity to be used for virtual bends (see {@link virtualBendsEnabled}).\n         * @default 20\n         */\n        this.virtualBendOpacity = 20;\n        /**\n         * Specifies if the parent should be highlighted if a child cell is selected.\n         * @default false\n         */\n        this.parentHighlightEnabled = false;\n        /**\n         * Specifies if bends should be added to the graph container.\n         * This is updated in {@link init} based on whether the edge or one of its terminals has an HTML label in the container.\n         */\n        this.preferHtml = false;\n        /**\n         * Specifies if the bounds of handles should be used for hit-detection in IE.\n         * @default true\n         */\n        this.allowHandleBoundsCheck = true;\n        /**\n         * Specifies if waypoints should snap to the routing centers of terminals.\n         * @default false\n         */\n        this.snapToTerminals = false;\n        /**\n         * Optional {@link Image} to be used as handles.\n         * @default null\n         */\n        this.handleImage = null;\n        this.labelHandleImage = null;\n        /**\n         * Optional tolerance for hit-detection in {@link getHandleForEvent}.\n         * @default 0\n         */\n        this.tolerance = 0;\n        /**\n         * Specifies if connections to the outline of a highlighted target should be\n         * enabled. This will allow to place the connection point along the outline of\n         * the highlighted target.\n         * @default false\n         */\n        this.outlineConnect = false;\n        /**\n         * Specifies if the label handle should be moved if it intersects with another\n         * handle. Uses {@link checkLabelHandle} for checking and moving.\n         * @default false\n         */\n        this.manageLabelHandle = false;\n        this.currentPoint = null;\n        this.parentHighlight = null;\n        this.index = null;\n        this.isSource = false;\n        this.isTarget = false;\n        this.isLabel = false;\n        this.points = [];\n        this.snapPoint = null;\n        this.abspoints = [];\n        this.startX = 0;\n        this.startY = 0;\n        this.outline = true;\n        this.active = true;\n        // `state.shape` must exists.\n        this.state = state;\n        this.graph = this.state.view.graph;\n        this.marker = this.createMarker();\n        this.constraintHandler = new ConstraintHandler(this.graph);\n        // Clones the original points from the cell\n        // and makes sure at least one point exists\n        this.points = [];\n        // Uses the absolute points of the state\n        // for the initial configuration and preview\n        this.abspoints = this.getSelectionPoints(this.state);\n        this.shape = this.createSelectionShape(this.abspoints);\n        this.shape.dialect =\n            this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n        this.shape.init(this.graph.getView().getOverlayPane());\n        this.shape.pointerEvents = false;\n        this.shape.setCursor(CURSOR.MOVABLE_EDGE);\n        InternalEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);\n        // Updates preferHtml\n        this.preferHtml =\n            this.state.text != null && this.state.text.node.parentNode === this.graph.container;\n        if (!this.preferHtml) {\n            // Checks source terminal\n            const sourceState = this.state.getVisibleTerminalState(true);\n            if (sourceState != null) {\n                this.preferHtml =\n                    sourceState.text != null &&\n                        sourceState.text.node.parentNode === this.graph.container;\n            }\n            if (!this.preferHtml) {\n                // Checks target terminal\n                const targetState = this.state.getVisibleTerminalState(false);\n                if (targetState != null) {\n                    this.preferHtml =\n                        targetState.text != null &&\n                            targetState.text.node.parentNode === this.graph.container;\n                }\n            }\n        }\n        const selectionHandler = this.graph.getPlugin('SelectionHandler');\n        // Creates bends for the non-routed absolute points\n        // or bends that don't correspond to points\n        if (selectionHandler &&\n            (this.graph.getSelectionCount() < selectionHandler.maxCells ||\n                selectionHandler.maxCells <= 0)) {\n            this.bends = this.createBends();\n            if (this.isVirtualBendsEnabled()) {\n                this.virtualBends = this.createVirtualBends();\n            }\n        }\n        // Adds a rectangular handle for the label position\n        this.label = new Point(this.state.absoluteOffset.x, this.state.absoluteOffset.y);\n        this.labelShape = this.createLabelHandleShape();\n        this.initBend(this.labelShape);\n        this.labelShape.setCursor(CURSOR.LABEL_HANDLE);\n        this.customHandles = this.createCustomHandles();\n        this.updateParentHighlight();\n        this.redraw();\n        // Handles escape keystrokes\n        this.escapeHandler = (sender, evt) => {\n            const dirty = this.index != null;\n            this.reset();\n            if (dirty) {\n                this.graph.cellRenderer.redraw(this.state, false, state.view.isRendering());\n            }\n        };\n        this.state.view.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);\n    }\n    /**\n     * Returns true if the parent highlight should be visible. This implementation\n     * always returns true.\n     */\n    isParentHighlightVisible() {\n        const parent = this.state.cell.getParent();\n        return parent ? !this.graph.isCellSelected(parent) : null;\n    }\n    /**\n     * Updates the highlight of the parent if {@link parentHighlightEnabled} is true.\n     */\n    updateParentHighlight() {\n        if (!this.isDestroyed()) {\n            const visible = this.isParentHighlightVisible();\n            const parent = this.state.cell.getParent();\n            const pstate = parent ? this.graph.view.getState(parent) : null;\n            if (this.parentHighlight) {\n                if (parent && parent.isVertex() && visible) {\n                    const b = this.parentHighlight.bounds;\n                    if (pstate &&\n                        b &&\n                        (b.x !== pstate.x ||\n                            b.y !== pstate.y ||\n                            b.width !== pstate.width ||\n                            b.height !== pstate.height)) {\n                        this.parentHighlight.bounds = Rectangle.fromRectangle(pstate);\n                        this.parentHighlight.redraw();\n                    }\n                }\n                else {\n                    if (pstate && pstate.parentHighlight === this.parentHighlight) {\n                        pstate.parentHighlight = null;\n                    }\n                    this.parentHighlight.destroy();\n                    this.parentHighlight = null;\n                }\n            }\n            else if (this.parentHighlightEnabled && visible) {\n                if (parent && parent.isVertex() && pstate && !pstate.parentHighlight) {\n                    this.parentHighlight = this.createParentHighlightShape(pstate);\n                    // VML dialect required here for event transparency in IE\n                    this.parentHighlight.dialect = DIALECT.SVG;\n                    this.parentHighlight.pointerEvents = false;\n                    if (pstate.style.rotation) {\n                        this.parentHighlight.rotation = pstate.style.rotation;\n                    }\n                    this.parentHighlight.init(this.graph.getView().getOverlayPane());\n                    this.parentHighlight.redraw();\n                    // Shows highlight once per parent\n                    pstate.parentHighlight = this.parentHighlight;\n                }\n            }\n        }\n    }\n    /**\n     * Returns an array of custom handles. This implementation returns an empty array.\n     */\n    createCustomHandles() {\n        return [];\n    }\n    /**\n     * Returns true if virtual bends should be added. This returns true if\n     * {@link virtualBendsEnabled} is true and the current style allows and\n     * renders custom waypoints.\n     */\n    isVirtualBendsEnabled(evt) {\n        return (this.virtualBendsEnabled &&\n            (this.state.style.edgeStyle == null ||\n                this.state.style.edgeStyle === NONE ||\n                this.state.style.noEdgeStyle) &&\n            this.state.style.shape !== 'arrow');\n    }\n    /**\n     * Returns true if the given cell allows new connections to be created. This implementation\n     * always returns true.\n     */\n    isCellEnabled(cell) {\n        return true;\n    }\n    /**\n     * Returns true if the given event is a trigger to add a new Point. This\n     * implementation returns true if shift is pressed.\n     */\n    isAddPointEvent(evt) {\n        return isShiftDown(evt);\n    }\n    /**\n     * Returns true if the given event is a trigger to remove a point. This\n     * implementation returns true if shift is pressed.\n     */\n    isRemovePointEvent(evt) {\n        return isShiftDown(evt);\n    }\n    /**\n     * Returns the list of points that defines the selection stroke.\n     */\n    getSelectionPoints(state) {\n        return state.absolutePoints;\n    }\n    /**\n     * Creates the shape used to draw the selection border.\n     */\n    createParentHighlightShape(bounds) {\n        const shape = new RectangleShape(Rectangle.fromRectangle(bounds), NONE, this.getSelectionColor());\n        shape.strokeWidth = this.getSelectionStrokeWidth();\n        shape.isDashed = this.isSelectionDashed();\n        return shape;\n    }\n    /**\n     * Creates the shape used to draw the selection border.\n     */\n    createSelectionShape(points) {\n        const c = this.state.shape.constructor;\n        const shape = new c();\n        shape.outline = true;\n        shape.apply(this.state);\n        shape.isDashed = this.isSelectionDashed();\n        shape.stroke = this.getSelectionColor();\n        shape.isShadow = false;\n        return shape;\n    }\n    /**\n     * Returns {@link EdgeHandlerConfig.selectionColor}.\n     */\n    getSelectionColor() {\n        return EdgeHandlerConfig.selectionColor;\n    }\n    /**\n     * Returns {@link EdgeHandlerConfig.selectionStrokeWidth}.\n     */\n    getSelectionStrokeWidth() {\n        return EdgeHandlerConfig.selectionStrokeWidth;\n    }\n    /**\n     * Returns {@link EdgeHandlerConfig.selectionDashed}.\n     */\n    isSelectionDashed() {\n        return EdgeHandlerConfig.selectionDashed;\n    }\n    /**\n     * Returns true if the given cell is connectable. This is a hook to\n     * disable floating connections. This implementation returns true.\n     */\n    isConnectableCell(cell) {\n        return true;\n    }\n    /**\n     * Creates and returns the {@link CellMarker} used in {@link marker}.\n     */\n    getCellAt(x, y) {\n        return !this.outlineConnect ? this.graph.getCellAt(x, y) : null;\n    }\n    /**\n     * Creates and returns the {@link CellMarker} used in {@link marker}.\n     */\n    createMarker() {\n        return new EdgeHandlerCellMarker(this.graph, this);\n    }\n    /**\n     * Returns the error message or an empty string if the connection for the\n     * given source, target pair is not valid. Otherwise, it returns null. This\n     * implementation uses {@link Graph#getEdgeValidationError}.\n     *\n     * @param source {@link Cell} that represents the source terminal.\n     * @param target {@link Cell} that represents the target terminal.\n     */\n    validateConnection(source, target) {\n        return this.graph.getEdgeValidationError(this.state.cell, source, target);\n    }\n    /**\n     * Creates and returns the bends used for modifying the edge. This is\n     * typically an array of {@link RectangleShape}.\n     */\n    createBends() {\n        const { cell } = this.state;\n        const bends = [];\n        for (let i = 0; i < this.abspoints.length; i += 1) {\n            if (this.isHandleVisible(i)) {\n                const source = i === 0;\n                const target = i === this.abspoints.length - 1;\n                const terminal = source || target;\n                if (terminal || this.graph.isCellBendable(cell)) {\n                    ((index) => {\n                        const bend = this.createHandleShape(index);\n                        this.initBend(bend, () => {\n                            if (this.dblClickRemoveEnabled) {\n                                this.removePoint(this.state, index);\n                            }\n                        });\n                        if (this.isHandleEnabled(i)) {\n                            bend.setCursor(terminal ? CURSOR.TERMINAL_HANDLE : CURSOR.BEND_HANDLE);\n                        }\n                        bends.push(bend);\n                        if (!terminal) {\n                            this.points.push(new Point(0, 0));\n                            bend.node.style.visibility = 'hidden';\n                        }\n                    })(i);\n                }\n            }\n        }\n        return bends;\n    }\n    /**\n     * Creates and returns the bends used for modifying the edge. This is\n     * typically an array of {@link RectangleShape}.\n     */\n    createVirtualBends() {\n        const { cell } = this.state;\n        const last = this.abspoints[0];\n        const bends = [];\n        if (this.graph.isCellBendable(cell)) {\n            for (let i = 1; i < this.abspoints.length; i += 1) {\n                ((bend) => {\n                    this.initBend(bend);\n                    bend.setCursor(CURSOR.VIRTUAL_BEND_HANDLE);\n                    bends.push(bend);\n                })(this.createHandleShape());\n            }\n        }\n        return bends;\n    }\n    /**\n     * Creates the shape used to display the given bend.\n     */\n    isHandleEnabled(index) {\n        return true;\n    }\n    /**\n     * Returns true if the handle at the given index is visible.\n     */\n    isHandleVisible(index) {\n        const source = this.state.getVisibleTerminalState(true);\n        const target = this.state.getVisibleTerminalState(false);\n        const geo = this.state.cell.getGeometry();\n        const edgeStyle = geo\n            ? this.graph.view.getEdgeStyle(this.state, geo.points || undefined, source, target)\n            : null;\n        return (edgeStyle !== EdgeStyle.EntityRelation ||\n            index === 0 ||\n            index === this.abspoints.length - 1);\n    }\n    /**\n     * Creates the shape used to display the given bend.\n     * Note that the index\n     * - may be `null` for special cases, such as when called from {@link ElbowEdgeHandler.createVirtualBend}.\n     * - is `null` for virtual handles.\n     *\n     * Only images and rectangles should be returned if support for HTML labels with not foreign objects is required.\n     */\n    createHandleShape(_index) {\n        if (this.handleImage) {\n            const shape = new ImageShape(new Rectangle(0, 0, this.handleImage.width, this.handleImage.height), this.handleImage.src);\n            // Allows HTML rendering of the images\n            shape.preserveImageAspect = false;\n            return shape;\n        }\n        let s = HandleConfig.size;\n        if (this.preferHtml) {\n            s -= 1;\n        }\n        const shapeConstructor = EdgeHandlerConfig.handleShape === 'circle' ? EllipseShape : RectangleShape;\n        return new shapeConstructor(new Rectangle(0, 0, s, s), HandleConfig.fillColor, HandleConfig.strokeColor);\n    }\n    /**\n     * Creates the shape used to display the label handle.\n     */\n    createLabelHandleShape() {\n        if (this.labelHandleImage) {\n            const shape = new ImageShape(new Rectangle(0, 0, this.labelHandleImage.width, this.labelHandleImage.height), this.labelHandleImage.src);\n            // Allows HTML rendering of the images\n            shape.preserveImageAspect = false;\n            return shape;\n        }\n        const s = HandleConfig.labelSize;\n        return new RectangleShape(new Rectangle(0, 0, s, s), HandleConfig.labelFillColor, HandleConfig.strokeColor);\n    }\n    /**\n     * Helper method to initialize the given bend.\n     *\n     * @param bend {@link Shape} that represents the bend to be initialized.\n     */\n    initBend(bend, dblClick) {\n        if (this.preferHtml) {\n            bend.dialect = DIALECT.STRICTHTML;\n            bend.init(this.graph.container);\n        }\n        else {\n            bend.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n            bend.init(this.graph.getView().getOverlayPane());\n        }\n        InternalEvent.redirectMouseEvents(bend.node, this.graph, this.state, null, null, null, dblClick);\n        if (Client.IS_TOUCH) {\n            bend.node.setAttribute('pointer-events', 'none');\n        }\n    }\n    /**\n     * Returns the index of the handle for the given event.\n     */\n    getHandleForEvent(me) {\n        let result = null;\n        // Connection highlight may consume events before they reach sizer handle\n        const tol = !isMouseEvent(me.getEvent()) ? this.tolerance : 1;\n        const hit = this.allowHandleBoundsCheck && tol > 0\n            ? new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol)\n            : null;\n        let minDistSq = Number.POSITIVE_INFINITY;\n        function checkShape(shape) {\n            if (shape &&\n                shape.bounds &&\n                shape.node &&\n                shape.node.style.display !== 'none' &&\n                shape.node.style.visibility !== 'hidden' &&\n                (me.isSource(shape) || (hit && intersects(shape.bounds, hit)))) {\n                const dx = me.getGraphX() - shape.bounds.getCenterX();\n                const dy = me.getGraphY() - shape.bounds.getCenterY();\n                const tmp = dx * dx + dy * dy;\n                if (tmp <= minDistSq) {\n                    minDistSq = tmp;\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (this.isCustomHandleEvent(me) && this.customHandles) {\n            // Inverse loop order to match display order\n            for (let i = this.customHandles.length - 1; i >= 0; i--) {\n                if (checkShape(this.customHandles[i].shape)) {\n                    // LATER: Return reference to active shape\n                    return InternalEvent.CUSTOM_HANDLE - i;\n                }\n            }\n        }\n        if (me.isSource(this.state.text) || checkShape(this.labelShape)) {\n            result = InternalEvent.LABEL_HANDLE;\n        }\n        for (let i = 0; i < this.bends.length; i += 1) {\n            if (checkShape(this.bends[i])) {\n                result = i;\n            }\n        }\n        if (this.virtualBends && this.isAddVirtualBendEvent(me)) {\n            for (let i = 0; i < this.virtualBends.length; i += 1) {\n                if (checkShape(this.virtualBends[i])) {\n                    result = InternalEvent.VIRTUAL_HANDLE - i;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Returns true if the given event allows virtual bends to be added. This\n     * implementation returns true.\n     */\n    isAddVirtualBendEvent(me) {\n        return true;\n    }\n    /**\n     * Returns true if the given event allows custom handles to be changed. This\n     * implementation returns true.\n     */\n    isCustomHandleEvent(me) {\n        return true;\n    }\n    /**\n     * Handles the event by checking if a special element of the handler\n     * was clicked, in which case the index parameter is non-null. The\n     * indices may be one of {@link InternalEvent.LABEL_HANDLE} or the number of the respective\n     * control point. The source and target points are used for reconnecting\n     * the edge.\n     */\n    mouseDown(sender, me) {\n        const handle = this.getHandleForEvent(me);\n        if (handle !== null && this.bends[handle]) {\n            const b = this.bends[handle].bounds;\n            if (b)\n                this.snapPoint = new Point(b.getCenterX(), b.getCenterY());\n        }\n        if (this.addEnabled && handle === null && this.isAddPointEvent(me.getEvent())) {\n            this.addPoint(this.state, me.getEvent());\n            me.consume();\n        }\n        else if (handle !== null && !me.isConsumed() && this.graph.isEnabled()) {\n            const cell = me.getCell();\n            if (this.removeEnabled && this.isRemovePointEvent(me.getEvent())) {\n                this.removePoint(this.state, handle);\n            }\n            else if (handle !== InternalEvent.LABEL_HANDLE ||\n                (cell && this.graph.isLabelMovable(cell))) {\n                if (this.virtualBends && handle <= InternalEvent.VIRTUAL_HANDLE) {\n                    setOpacity(this.virtualBends[InternalEvent.VIRTUAL_HANDLE - handle].node, 100);\n                }\n                this.start(me.getX(), me.getY(), handle);\n            }\n            me.consume();\n        }\n    }\n    /**\n     * Starts the handling of the mouse gesture.\n     */\n    start(x, y, index) {\n        this.startX = x;\n        this.startY = y;\n        this.isSource = this.bends.length === 0 ? false : index === 0;\n        this.isTarget = this.bends.length === 0 ? false : index === this.bends.length - 1;\n        this.isLabel = index === InternalEvent.LABEL_HANDLE;\n        if (this.isSource || this.isTarget) {\n            const { cell } = this.state;\n            const terminal = cell.getTerminal(this.isSource);\n            if ((terminal == null && this.graph.isTerminalPointMovable(cell, this.isSource)) ||\n                (terminal != null &&\n                    this.graph.isCellDisconnectable(cell, terminal, this.isSource))) {\n                this.index = index;\n            }\n        }\n        else {\n            this.index = index;\n        }\n        // Hides other custom handles\n        if (this.index !== null &&\n            this.index <= InternalEvent.CUSTOM_HANDLE &&\n            this.index > InternalEvent.VIRTUAL_HANDLE) {\n            if (this.customHandles != null) {\n                for (let i = 0; i < this.customHandles.length; i += 1) {\n                    if (i !== InternalEvent.CUSTOM_HANDLE - this.index) {\n                        this.customHandles[i].setVisible(false);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Returns a clone of the current preview state for the given point and terminal.\n     */\n    clonePreviewState(point, terminal) {\n        return this.state.clone();\n    }\n    /**\n     * Returns the tolerance for the guides. Default value is\n     * gridSize * scale / 2.\n     */\n    getSnapToTerminalTolerance() {\n        return (this.graph.getGridSize() * this.graph.getView().scale) / 2;\n    }\n    /**\n     * Hook for subclassers do show details while the handler is active.\n     */\n    updateHint(me, point) {\n        return;\n    }\n    /**\n     * Hooks for subclassers to hide details when the handler gets inactive.\n     */\n    removeHint() {\n        return;\n    }\n    /**\n     * Hook for rounding the unscaled width or height. This uses Math.round.\n     */\n    roundLength(length) {\n        return Math.round(length);\n    }\n    /**\n     * Returns true if {@link snapToTerminals} is true and if alt is not pressed.\n     */\n    isSnapToTerminalsEvent(me) {\n        return this.snapToTerminals && !isAltDown(me.getEvent());\n    }\n    /**\n     * Returns the point for the given event.\n     */\n    getPointForEvent(me) {\n        const view = this.graph.getView();\n        const { scale } = view;\n        const point = new Point(this.roundLength(me.getGraphX() / scale) * scale, this.roundLength(me.getGraphY() / scale) * scale);\n        const tt = this.getSnapToTerminalTolerance();\n        let overrideX = false;\n        let overrideY = false;\n        if (tt > 0 && this.isSnapToTerminalsEvent(me)) {\n            const snapToPoint = (pt) => {\n                if (pt) {\n                    const { x } = pt;\n                    if (Math.abs(point.x - x) < tt) {\n                        point.x = x;\n                        overrideX = true;\n                    }\n                    const { y } = pt;\n                    if (Math.abs(point.y - y) < tt) {\n                        point.y = y;\n                        overrideY = true;\n                    }\n                }\n            };\n            // Temporary function\n            const snapToTerminal = (terminal) => {\n                if (terminal) {\n                    snapToPoint(new Point(view.getRoutingCenterX(terminal), view.getRoutingCenterY(terminal)));\n                }\n            };\n            snapToTerminal(this.state.getVisibleTerminalState(true));\n            snapToTerminal(this.state.getVisibleTerminalState(false));\n            for (let i = 0; i < this.state.absolutePoints.length; i += 1) {\n                snapToPoint(this.state.absolutePoints[i]);\n            }\n        }\n        if (this.graph.isGridEnabledEvent(me.getEvent())) {\n            const tr = view.translate;\n            if (!overrideX) {\n                point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;\n            }\n            if (!overrideY) {\n                point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;\n            }\n        }\n        return point;\n    }\n    /**\n     * Updates the given preview state taking into account the state of the constraint handler.\n     */\n    getPreviewTerminalState(me) {\n        this.constraintHandler.update(me, this.isSource, true, me.isSource(this.marker.highlight.shape) ? null : this.currentPoint);\n        if (this.constraintHandler.currentFocus && this.constraintHandler.currentConstraint) {\n            // Handles special case where grid is large and connection point is at actual point in which\n            // case the outline is not followed as long as we're < gridSize / 2 away from that point\n            if (this.marker.highlight &&\n                this.marker.highlight.shape &&\n                this.marker.highlight.state &&\n                this.marker.highlight.state.cell === this.constraintHandler.currentFocus.cell) {\n                // Direct repaint needed if cell already highlighted\n                if (this.marker.highlight.shape.stroke !== 'transparent') {\n                    this.marker.highlight.shape.stroke = 'transparent';\n                    this.marker.highlight.repaint();\n                }\n            }\n            else {\n                this.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');\n            }\n            const other = this.graph.view.getTerminalPort(this.state, this.graph.view.getState(this.state.cell.getTerminal(!this.isSource)), !this.isSource);\n            const otherCell = other ? other.cell : null;\n            const source = this.isSource ? this.constraintHandler.currentFocus.cell : otherCell;\n            const target = this.isSource ? otherCell : this.constraintHandler.currentFocus.cell;\n            // Updates the error message of the handler\n            this.error = this.validateConnection(source, target);\n            let result = null;\n            if (this.error === null) {\n                result = this.constraintHandler.currentFocus;\n            }\n            if (this.error !== null || (result && !this.isCellEnabled(result.cell))) {\n                this.constraintHandler.reset();\n            }\n            return result;\n        }\n        if (!this.graph.isIgnoreTerminalEvent(me.getEvent())) {\n            this.marker.process(me);\n            const state = this.marker.getValidState();\n            if (state && !this.isCellEnabled(state.cell)) {\n                this.constraintHandler.reset();\n                this.marker.reset();\n            }\n            return this.marker.getValidState();\n        }\n        this.marker.reset();\n        return null;\n    }\n    /**\n     * Updates the given preview state taking into account the state of the constraint handler.\n     *\n     * @param pt {@link Point} that contains the current pointer position.\n     * @param me Optional {@link MouseEvent} that contains the current event.\n     */\n    getPreviewPoints(pt, me) {\n        const geometry = this.state.cell.getGeometry();\n        if (!geometry)\n            return null;\n        let points = (geometry.points || []).slice();\n        const point = new Point(pt.x, pt.y);\n        let result = null;\n        if (!this.isSource && !this.isTarget && this.index !== null) {\n            this.convertPoint(point, false);\n            // Adds point from virtual bend\n            if (this.index <= InternalEvent.VIRTUAL_HANDLE) {\n                points.splice(InternalEvent.VIRTUAL_HANDLE - this.index, 0, point);\n            }\n            // Removes point if dragged on terminal point\n            if (!this.isSource && !this.isTarget) {\n                for (let i = 0; i < this.bends.length; i += 1) {\n                    if (i !== this.index) {\n                        const bend = this.bends[i];\n                        if (bend && contains(bend.bounds, pt.x, pt.y)) {\n                            if (this.index <= InternalEvent.VIRTUAL_HANDLE) {\n                                points.splice(InternalEvent.VIRTUAL_HANDLE - this.index, 1);\n                            }\n                            else {\n                                points.splice(this.index - 1, 1);\n                            }\n                            result = points;\n                        }\n                    }\n                }\n                // Removes point if user tries to straighten a segment\n                if (!result && this.straightRemoveEnabled && (!me || !isAltDown(me.getEvent()))) {\n                    const tol = this.graph.getEventTolerance() * this.graph.getEventTolerance();\n                    const abs = this.state.absolutePoints.slice();\n                    abs[this.index] = pt;\n                    // Handes special case where removing waypoint affects tolerance (flickering)\n                    const src = this.state.getVisibleTerminalState(true);\n                    if (src != null) {\n                        const c = this.graph.getConnectionConstraint(this.state, src, true);\n                        // Checks if point is not fixed\n                        if (c == null || this.graph.getConnectionPoint(src, c) == null) {\n                            abs[0] = new Point(src.view.getRoutingCenterX(src), src.view.getRoutingCenterY(src));\n                        }\n                    }\n                    const trg = this.state.getVisibleTerminalState(false);\n                    if (trg != null) {\n                        const c = this.graph.getConnectionConstraint(this.state, trg, false);\n                        // Checks if point is not fixed\n                        if (c == null || this.graph.getConnectionPoint(trg, c) == null) {\n                            abs[abs.length - 1] = new Point(trg.view.getRoutingCenterX(trg), trg.view.getRoutingCenterY(trg));\n                        }\n                    }\n                    const checkRemove = (idx, tmp) => {\n                        if (idx > 0 &&\n                            idx < abs.length - 1 &&\n                            ptSegDistSq(abs[idx - 1].x, abs[idx - 1].y, abs[idx + 1].x, abs[idx + 1].y, tmp.x, tmp.y) < tol) {\n                            points.splice(idx - 1, 1);\n                            result = points;\n                        }\n                    };\n                    // LATER: Check if other points can be removed if a segment is made straight\n                    checkRemove(this.index, pt);\n                }\n            }\n            // Updates existing point\n            if (result == null && this.index > InternalEvent.VIRTUAL_HANDLE) {\n                points[this.index - 1] = point;\n            }\n        }\n        else if (this.graph.isResetEdgesOnConnect()) {\n            points = [];\n        }\n        return result != null ? result : points;\n    }\n    /**\n     * Returns true if {@link outlineConnect} is true and the source of the event is the outline shape\n     * or shift is pressed.\n     */\n    isOutlineConnectEvent(me) {\n        if (!this.currentPoint)\n            return false;\n        const offset = getOffset(this.graph.container);\n        const evt = me.getEvent();\n        const clientX = getClientX(evt);\n        const clientY = getClientY(evt);\n        const doc = document.documentElement;\n        const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n        const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n        const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;\n        const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;\n        return (this.outlineConnect &&\n            !isShiftDown(me.getEvent()) &&\n            (me.isSource(this.marker.highlight.shape) ||\n                (isAltDown(me.getEvent()) && me.getState() != null) ||\n                this.marker.highlight.isHighlightAt(clientX, clientY) ||\n                ((gridX !== clientX || gridY !== clientY) &&\n                    me.getState() == null &&\n                    this.marker.highlight.isHighlightAt(gridX, gridY))));\n    }\n    /**\n     * Updates the given preview state taking into account the state of the constraint handler.\n     */\n    updatePreviewState(edgeState, point, terminalState, me, outline = false) {\n        // Computes the points for the edge style and terminals\n        const sourceState = this.isSource\n            ? terminalState\n            : this.state.getVisibleTerminalState(true);\n        const targetState = this.isTarget\n            ? terminalState\n            : this.state.getVisibleTerminalState(false);\n        let sourceConstraint = this.graph.getConnectionConstraint(edgeState, sourceState, true);\n        let targetConstraint = this.graph.getConnectionConstraint(edgeState, targetState, false);\n        let constraint = this.constraintHandler.currentConstraint;\n        if (constraint == null && outline) {\n            if (terminalState != null) {\n                // Handles special case where mouse is on outline away from actual end point\n                // in which case the grid is ignored and mouse point is used instead\n                if (me.isSource(this.marker.highlight.shape)) {\n                    point = new Point(me.getGraphX(), me.getGraphY());\n                }\n                constraint = this.graph.getOutlineConstraint(point, terminalState, me);\n                this.constraintHandler.setFocus(me, terminalState, this.isSource);\n                this.constraintHandler.currentConstraint = constraint;\n                this.constraintHandler.currentPoint = point;\n            }\n            else {\n                constraint = new ConnectionConstraint(null);\n            }\n        }\n        if (this.outlineConnect &&\n            this.marker.highlight != null &&\n            this.marker.highlight.shape != null) {\n            const s = this.graph.view.scale;\n            if (this.constraintHandler.currentConstraint != null &&\n                this.constraintHandler.currentFocus != null) {\n                this.marker.highlight.shape.stroke = outline\n                    ? OUTLINE_HIGHLIGHT_COLOR\n                    : 'transparent';\n                this.marker.highlight.shape.strokeWidth = OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;\n                this.marker.highlight.repaint();\n            }\n            else if (this.marker.hasValidState()) {\n                const cell = me.getCell();\n                this.marker.highlight.shape.stroke =\n                    cell && cell.isConnectable() && this.marker.getValidState() !== me.getState()\n                        ? 'transparent'\n                        : DEFAULT_VALID_COLOR;\n                this.marker.highlight.shape.strokeWidth = HIGHLIGHT_STROKEWIDTH / s / s;\n                this.marker.highlight.repaint();\n            }\n        }\n        if (this.isSource) {\n            sourceConstraint = constraint;\n        }\n        else if (this.isTarget) {\n            targetConstraint = constraint;\n        }\n        if (this.isSource || this.isTarget) {\n            if (constraint != null && constraint.point != null) {\n                edgeState.style[this.isSource ? 'exitX' : 'entryX'] = constraint.point.x;\n                edgeState.style[this.isSource ? 'exitY' : 'entryY'] = constraint.point.y;\n            }\n            else {\n                delete edgeState.style[this.isSource ? 'exitX' : 'entryX'];\n                delete edgeState.style[this.isSource ? 'exitY' : 'entryY'];\n            }\n        }\n        edgeState.setVisibleTerminalState(sourceState, true);\n        edgeState.setVisibleTerminalState(targetState, false);\n        if (!this.isSource || sourceState != null) {\n            edgeState.view.updateFixedTerminalPoint(edgeState, sourceState, true, sourceConstraint);\n        }\n        if (!this.isTarget || targetState != null) {\n            edgeState.view.updateFixedTerminalPoint(edgeState, targetState, false, targetConstraint);\n        }\n        if ((this.isSource || this.isTarget) && terminalState == null) {\n            edgeState.setAbsoluteTerminalPoint(point, this.isSource);\n            if (this.marker.getMarkedState() == null) {\n                this.error = this.graph.isAllowDanglingEdges() ? null : '';\n            }\n        }\n        edgeState.view.updatePoints(edgeState, this.points, sourceState, targetState);\n        edgeState.view.updateFloatingTerminalPoints(edgeState, sourceState, targetState);\n    }\n    /**\n     * Handles the event by updating the preview.\n     */\n    mouseMove(sender, me) {\n        if (this.index != null && this.marker != null) {\n            this.currentPoint = this.getPointForEvent(me);\n            this.error = null;\n            // Uses the current point from the constraint handler if available\n            if (!this.graph.isIgnoreTerminalEvent(me.getEvent()) &&\n                isShiftDown(me.getEvent()) &&\n                this.snapPoint != null) {\n                if (Math.abs(this.snapPoint.x - this.currentPoint.x) <\n                    Math.abs(this.snapPoint.y - this.currentPoint.y)) {\n                    this.currentPoint.x = this.snapPoint.x;\n                }\n                else {\n                    this.currentPoint.y = this.snapPoint.y;\n                }\n            }\n            if (this.index <= InternalEvent.CUSTOM_HANDLE &&\n                this.index > InternalEvent.VIRTUAL_HANDLE) {\n                if (this.customHandles != null) {\n                    this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].processEvent(me);\n                    this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].positionChanged();\n                    if (this.shape != null && this.shape.node != null) {\n                        this.shape.node.style.display = 'none';\n                    }\n                }\n            }\n            else if (this.isLabel && this.label) {\n                this.label.x = this.currentPoint.x;\n                this.label.y = this.currentPoint.y;\n            }\n            else {\n                this.points = this.getPreviewPoints(this.currentPoint, me);\n                let terminalState = this.isSource || this.isTarget ? this.getPreviewTerminalState(me) : null;\n                if (this.constraintHandler.currentConstraint != null &&\n                    this.constraintHandler.currentFocus != null &&\n                    this.constraintHandler.currentPoint != null) {\n                    this.currentPoint = this.constraintHandler.currentPoint.clone();\n                }\n                else if (this.outlineConnect) {\n                    // Need to check outline before cloning terminal state\n                    const outline = this.isSource || this.isTarget ? this.isOutlineConnectEvent(me) : false;\n                    if (outline) {\n                        terminalState = this.marker.highlight.state;\n                    }\n                    else if (terminalState != null &&\n                        terminalState !== me.getState() &&\n                        me.getCell()?.isConnectable() &&\n                        this.marker.highlight.shape != null) {\n                        this.marker.highlight.shape.stroke = 'transparent';\n                        this.marker.highlight.repaint();\n                        terminalState = null;\n                    }\n                }\n                if (terminalState != null && !this.isCellEnabled(terminalState.cell)) {\n                    terminalState = null;\n                    this.marker.reset();\n                }\n                if (this.currentPoint) {\n                    const clone = this.clonePreviewState(this.currentPoint, terminalState != null ? terminalState.cell : null);\n                    this.updatePreviewState(clone, this.currentPoint, terminalState, me, this.outline);\n                    // Sets the color of the preview to valid or invalid, updates the\n                    // points of the preview and redraws\n                    const color = this.error == null ? this.marker.validColor : this.marker.invalidColor;\n                    this.setPreviewColor(color);\n                    this.abspoints = clone.absolutePoints;\n                    this.active = true;\n                    this.updateHint(me, this.currentPoint);\n                }\n            }\n            // This should go before calling isOutlineConnectEvent above. As a workaround\n            // we add an offset of gridSize to the hint to avoid problem with hit detection\n            // in highlight.isHighlightAt (which uses comonentFromPoint)\n            this.drawPreview();\n            InternalEvent.consume(me.getEvent());\n            me.consume();\n        }\n    }\n    /**\n     * Handles the event to applying the previewed changes on the edge by\n     * using {@link moveLabel}, {@link connect} or {@link changePoints}.\n     */\n    mouseUp(sender, me) {\n        // Workaround for wrong event source in Webkit\n        if (this.index != null && this.marker != null) {\n            if (this.shape != null && this.shape.node != null) {\n                this.shape.node.style.display = '';\n            }\n            let edge = this.state.cell;\n            const { index } = this;\n            this.index = null;\n            // Ignores event if mouse has not been moved\n            if (me.getX() !== this.startX || me.getY() !== this.startY) {\n                const clone = !this.graph.isIgnoreTerminalEvent(me.getEvent()) &&\n                    this.graph.isCloneEvent(me.getEvent()) &&\n                    this.cloneEnabled &&\n                    this.graph.isCellsCloneable();\n                // Displays the reason for not carriying out the change\n                // if there is an error message with non-zero length\n                if (this.error != null) {\n                    if (this.error.length > 0) {\n                        this.graph.validationAlert(this.error);\n                    }\n                }\n                else if (index <= InternalEvent.CUSTOM_HANDLE &&\n                    index > InternalEvent.VIRTUAL_HANDLE) {\n                    if (this.customHandles != null) {\n                        const model = this.graph.getDataModel();\n                        model.beginUpdate();\n                        try {\n                            this.customHandles[InternalEvent.CUSTOM_HANDLE - index].execute(me);\n                            if (this.shape != null && this.shape.node != null) {\n                                this.shape.apply(this.state);\n                                this.shape.redraw();\n                            }\n                        }\n                        finally {\n                            model.endUpdate();\n                        }\n                    }\n                }\n                else if (this.isLabel && this.label) {\n                    this.moveLabel(this.state, this.label.x, this.label.y);\n                }\n                else if (this.isSource || this.isTarget) {\n                    let terminal = null;\n                    if (this.constraintHandler.currentConstraint != null &&\n                        this.constraintHandler.currentFocus != null) {\n                        terminal = this.constraintHandler.currentFocus.cell;\n                    }\n                    if (!terminal &&\n                        this.marker.hasValidState() &&\n                        this.marker.highlight != null &&\n                        this.marker.highlight.shape != null &&\n                        this.marker.highlight.shape.stroke !== 'transparent' &&\n                        this.marker.highlight.shape.stroke !== 'white') {\n                        terminal = this.marker.validState.cell;\n                    }\n                    if (terminal) {\n                        const model = this.graph.getDataModel();\n                        const parent = edge.getParent();\n                        model.beginUpdate();\n                        try {\n                            // Clones and adds the cell\n                            if (clone) {\n                                let geo = edge.getGeometry();\n                                const cloned = this.graph.cloneCell(edge);\n                                model.add(parent, cloned, parent.getChildCount());\n                                if (geo != null) {\n                                    geo = geo.clone();\n                                    model.setGeometry(cloned, geo);\n                                }\n                                const other = edge.getTerminal(!this.isSource);\n                                this.graph.connectCell(cloned, other, !this.isSource);\n                                edge = cloned;\n                            }\n                            edge = this.connect(edge, terminal, this.isSource, clone, me);\n                        }\n                        finally {\n                            model.endUpdate();\n                        }\n                    }\n                    else if (this.graph.isAllowDanglingEdges()) {\n                        const pt = this.abspoints[this.isSource ? 0 : this.abspoints.length - 1];\n                        pt.x = this.roundLength(pt.x / this.graph.view.scale - this.graph.view.translate.x);\n                        pt.y = this.roundLength(pt.y / this.graph.view.scale - this.graph.view.translate.y);\n                        const parent = edge.getParent();\n                        const pstate = parent ? this.graph.getView().getState(parent) : null;\n                        if (pstate != null) {\n                            pt.x -= pstate.origin.x;\n                            pt.y -= pstate.origin.y;\n                        }\n                        pt.x -= this.graph.getPanDx() / this.graph.view.scale;\n                        pt.y -= this.graph.getPanDy() / this.graph.view.scale;\n                        // Destroys and recreates this handler\n                        edge = this.changeTerminalPoint(edge, pt, this.isSource, clone);\n                    }\n                }\n                else if (this.active) {\n                    edge = this.changePoints(edge, this.points, clone);\n                }\n                else {\n                    this.graph.getView().invalidate(this.state.cell);\n                    this.graph.getView().validate(this.state.cell);\n                }\n            }\n            else if (this.graph.isToggleEvent(me.getEvent())) {\n                this.graph.selectCellForEvent(this.state.cell, me.getEvent());\n            }\n            // Resets the preview color the state of the handler if this\n            // handler has not been recreated\n            if (this.marker != null) {\n                this.reset();\n                // Updates the selection if the edge has been cloned\n                if (edge !== this.state.cell) {\n                    this.graph.setSelectionCell(edge);\n                }\n            }\n            me.consume();\n        }\n    }\n    /**\n     * Resets the state of this handler.\n     */\n    reset() {\n        if (this.active) {\n            this.refresh();\n        }\n        this.error = null;\n        this.index = null;\n        this.points = [];\n        this.snapPoint = null;\n        this.isLabel = false;\n        this.isSource = false;\n        this.isTarget = false;\n        this.active = false;\n        if (this.marker) {\n            this.marker.reset();\n        }\n        this.constraintHandler.reset();\n        if (this.customHandles) {\n            for (let i = 0; i < this.customHandles.length; i += 1) {\n                this.customHandles[i].reset();\n            }\n        }\n        this.setPreviewColor(EdgeHandlerConfig.selectionColor);\n        this.removeHint();\n        this.redraw();\n    }\n    /**\n     * Sets the color of the preview to the given value.\n     */\n    setPreviewColor(color) {\n        this.shape.stroke = color;\n    }\n    /**\n     * Converts the given point in-place from screen to unscaled, untranslated\n     * graph coordinates and applies the grid. Returns the given, modified\n     * point instance.\n     *\n     * @param point {@link Point} to be converted.\n     * @param gridEnabled Boolean that specifies if the grid should be applied.\n     */\n    convertPoint(point, gridEnabled) {\n        const scale = this.graph.getView().getScale();\n        const tr = this.graph.getView().getTranslate();\n        if (gridEnabled) {\n            point.x = this.graph.snap(point.x);\n            point.y = this.graph.snap(point.y);\n        }\n        point.x = Math.round(point.x / scale - tr.x);\n        point.y = Math.round(point.y / scale - tr.y);\n        const parent = this.state.cell.getParent();\n        const pstate = parent ? this.graph.getView().getState(parent) : parent;\n        if (pstate) {\n            point.x -= pstate.origin.x;\n            point.y -= pstate.origin.y;\n        }\n        return point;\n    }\n    /**\n     * Changes the coordinates for the label of the given edge.\n     *\n     * @param edge {@link Cell} that represents the edge.\n     * @param x Integer that specifies the x-coordinate of the new location.\n     * @param y Integer that specifies the y-coordinate of the new location.\n     */\n    moveLabel(edgeState, x, y) {\n        const model = this.graph.getDataModel();\n        let geometry = edgeState.cell.getGeometry();\n        if (geometry != null) {\n            const { scale } = this.graph.getView();\n            geometry = geometry.clone();\n            if (geometry.relative) {\n                // Resets the relative location stored inside the geometry\n                let pt = this.graph.getView().getRelativePoint(edgeState, x, y);\n                geometry.x = Math.round(pt.x * 10000) / 10000;\n                geometry.y = Math.round(pt.y);\n                // Resets the offset inside the geometry to find the offset\n                // from the resulting point\n                geometry.offset = new Point(0, 0);\n                pt = this.graph.view.getPoint(edgeState, geometry);\n                geometry.offset = new Point(Math.round((x - pt.x) / scale), Math.round((y - pt.y) / scale));\n            }\n            else {\n                const points = edgeState.absolutePoints;\n                const p0 = points[0];\n                const pe = points[points.length - 1];\n                if (p0 != null && pe != null) {\n                    const cx = p0.x + (pe.x - p0.x) / 2;\n                    const cy = p0.y + (pe.y - p0.y) / 2;\n                    geometry.offset = new Point(Math.round((x - cx) / scale), Math.round((y - cy) / scale));\n                    geometry.x = 0;\n                    geometry.y = 0;\n                }\n            }\n            model.setGeometry(edgeState.cell, geometry);\n        }\n    }\n    /**\n     * Changes the terminal or terminal point of the given edge in the graph\n     * model.\n     *\n     * @param edge {@link Cell} that represents the edge to be reconnected.\n     * @param terminal {@link Cell} that represents the new terminal.\n     * @param isSource Boolean indicating if the new terminal is the source or\n     * target terminal.\n     * @param isClone Boolean indicating if the new connection should be a clone of\n     * the old edge.\n     * @param me {@link MouseEvent} that contains the mouse up event.\n     */\n    connect(edge, terminal, isSource, isClone, me) {\n        const parent = edge.getParent();\n        this.graph.batchUpdate(() => {\n            let constraint = this.constraintHandler.currentConstraint;\n            if (constraint == null) {\n                constraint = new ConnectionConstraint(null);\n            }\n            this.graph.connectCell(edge, terminal, isSource, constraint);\n        });\n        return edge;\n    }\n    /**\n     * Changes the terminal point of the given edge.\n     */\n    changeTerminalPoint(edge, point, isSource, clone) {\n        const model = this.graph.getDataModel();\n        model.batchUpdate(() => {\n            if (clone) {\n                const parent = edge.getParent();\n                const terminal = edge.getTerminal(!isSource);\n                edge = this.graph.cloneCell(edge);\n                model.add(parent, edge, parent.getChildCount());\n                model.setTerminal(edge, terminal, !isSource);\n            }\n            let geo = edge.getGeometry();\n            if (geo != null) {\n                geo = geo.clone();\n                geo.setTerminalPoint(point, isSource);\n                model.setGeometry(edge, geo);\n                this.graph.connectCell(edge, null, isSource, new ConnectionConstraint(null));\n            }\n        });\n        return edge;\n    }\n    /**\n     * Changes the control points of the given edge in the graph model.\n     */\n    changePoints(edge, points, clone) {\n        const model = this.graph.getDataModel();\n        model.batchUpdate(() => {\n            if (clone) {\n                const parent = edge.getParent();\n                const source = edge.getTerminal(true);\n                const target = edge.getTerminal(false);\n                edge = this.graph.cloneCell(edge);\n                model.add(parent, edge, parent.getChildCount());\n                model.setTerminal(edge, source, true);\n                model.setTerminal(edge, target, false);\n            }\n            let geo = edge.getGeometry();\n            if (geo != null) {\n                geo = geo.clone();\n                geo.points = points;\n                model.setGeometry(edge, geo);\n            }\n        });\n        return edge;\n    }\n    /**\n     * Adds a control point for the given state and event.\n     */\n    addPoint(state, evt) {\n        const pt = convertPoint(this.graph.container, getClientX(evt), getClientY(evt));\n        const gridEnabled = this.graph.isGridEnabledEvent(evt);\n        this.convertPoint(pt, gridEnabled);\n        this.addPointAt(state, pt.x, pt.y);\n        InternalEvent.consume(evt);\n    }\n    /**\n     * Adds a control point at the given point.\n     */\n    addPointAt(state, x, y) {\n        let geo = state.cell.getGeometry();\n        const pt = new Point(x, y);\n        if (geo != null) {\n            geo = geo.clone();\n            const t = this.graph.view.translate;\n            const s = this.graph.view.scale;\n            let offset = new Point(t.x * s, t.y * s);\n            const parent = this.state.cell.getParent();\n            if (parent && parent.isVertex()) {\n                const pState = this.graph.view.getState(parent);\n                if (pState)\n                    offset = new Point(pState.x, pState.y);\n            }\n            const index = findNearestSegment(state, pt.x * s + offset.x, pt.y * s + offset.y);\n            if (geo.points == null) {\n                geo.points = [pt];\n            }\n            else {\n                geo.points.splice(index, 0, pt);\n            }\n            this.graph.getDataModel().setGeometry(state.cell, geo);\n            this.refresh();\n            this.redraw();\n        }\n    }\n    /**\n     * Removes the control point at the given index from the given state.\n     */\n    removePoint(state, index) {\n        if (index > 0 && index < this.abspoints.length - 1) {\n            let geo = this.state.cell.getGeometry();\n            if (geo != null && geo.points != null) {\n                geo = geo.clone();\n                (geo.points || []).splice(index - 1, 1);\n                this.graph.getDataModel().setGeometry(state.cell, geo);\n                this.refresh();\n                this.redraw();\n            }\n        }\n    }\n    /**\n     * Returns the fillcolor for the handle at the given index.\n     */\n    getHandleFillColor(index) {\n        const isSource = index === 0;\n        const { cell } = this.state;\n        const terminal = cell.getTerminal(isSource);\n        let color = HandleConfig.fillColor;\n        if ((terminal != null && !this.graph.isCellDisconnectable(cell, terminal, isSource)) ||\n            (terminal == null && !this.graph.isTerminalPointMovable(cell, isSource))) {\n            color = LOCKED_HANDLE_FILLCOLOR;\n        }\n        else if (terminal != null &&\n            this.graph.isCellDisconnectable(cell, terminal, isSource)) {\n            color = EdgeHandlerConfig.connectFillColor;\n        }\n        return color;\n    }\n    /**\n     * Redraws the preview, and the bends- and label control points.\n     */\n    redraw(ignoreHandles) {\n        this.abspoints = this.state.absolutePoints.slice();\n        const g = this.state.cell.getGeometry();\n        if (g) {\n            const pts = g.points;\n            if (this.bends != null && this.bends.length > 0) {\n                if (pts != null) {\n                    if (this.points == null) {\n                        this.points = [];\n                    }\n                    for (let i = 1; i < this.bends.length - 1; i += 1) {\n                        if (this.bends[i] != null && this.abspoints[i] != null) {\n                            this.points[i - 1] = pts[i - 1];\n                        }\n                    }\n                }\n            }\n        }\n        this.drawPreview();\n        if (!ignoreHandles) {\n            this.redrawHandles();\n        }\n    }\n    /**\n     * Redraws the handles.\n     */\n    redrawHandles() {\n        const { cell } = this.state;\n        // Updates the handle for the label position\n        let b = this.labelShape.bounds;\n        this.label = new Point(this.state.absoluteOffset.x, this.state.absoluteOffset.y);\n        this.labelShape.bounds = new Rectangle(Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);\n        // Shows or hides the label handle depending on the label\n        const lab = this.graph.getLabel(cell);\n        this.labelShape.visible =\n            lab != null && lab.length > 0 && this.graph.isLabelMovable(cell);\n        if (this.bends != null && this.bends.length > 0) {\n            const n = this.abspoints.length - 1;\n            const p0 = this.abspoints[0];\n            const x0 = p0.x;\n            const y0 = p0.y;\n            b = this.bends[0].bounds;\n            this.bends[0].bounds = new Rectangle(Math.floor(x0 - b.width / 2), Math.floor(y0 - b.height / 2), b.width, b.height);\n            this.bends[0].fill = this.getHandleFillColor(0);\n            this.bends[0].redraw();\n            if (this.manageLabelHandle) {\n                this.checkLabelHandle(this.bends[0].bounds);\n            }\n            const pe = this.abspoints[n];\n            const xn = pe.x;\n            const yn = pe.y;\n            const bn = this.bends.length - 1;\n            b = this.bends[bn].bounds;\n            this.bends[bn].bounds = new Rectangle(Math.floor(xn - b.width / 2), Math.floor(yn - b.height / 2), b.width, b.height);\n            this.bends[bn].fill = this.getHandleFillColor(bn);\n            this.bends[bn].redraw();\n            if (this.manageLabelHandle) {\n                this.checkLabelHandle(this.bends[bn].bounds);\n            }\n            this.redrawInnerBends(p0, pe);\n        }\n        if (this.virtualBends && this.virtualBends.length > 0) {\n            let last = this.abspoints[0];\n            for (let i = 0; i < this.virtualBends.length; i += 1) {\n                if (this.virtualBends[i] != null && this.abspoints[i + 1] != null) {\n                    const pt = this.abspoints[i + 1];\n                    const b = this.virtualBends[i];\n                    const x = last.x + (pt.x - last.x) / 2;\n                    const y = last.y + (pt.y - last.y) / 2;\n                    if (b.bounds) {\n                        b.bounds = new Rectangle(Math.floor(x - b.bounds.width / 2), Math.floor(y - b.bounds.height / 2), b.bounds.width, b.bounds.height);\n                        b.redraw();\n                    }\n                    setOpacity(b.node, this.virtualBendOpacity);\n                    last = pt;\n                    if (this.manageLabelHandle) {\n                        this.checkLabelHandle(b.bounds);\n                    }\n                }\n            }\n        }\n        this.labelShape.redraw();\n        if (this.customHandles) {\n            for (let i = 0; i < this.customHandles.length; i += 1) {\n                const shape = this.customHandles[i].shape;\n                if (shape) {\n                    const temp = shape.node.style.display;\n                    this.customHandles[i].redraw();\n                    shape.node.style.display = temp;\n                    // Hides custom handles during text editing\n                    shape.node.style.visibility = this.isCustomHandleVisible(this.customHandles[i])\n                        ? ''\n                        : 'hidden';\n                }\n            }\n        }\n    }\n    /**\n     * Returns true if the given custom handle is visible.\n     */\n    isCustomHandleVisible(handle) {\n        return !this.graph.isEditing() && this.state.view.graph.getSelectionCount() === 1;\n    }\n    /**\n     * Shortcut to {@link hideSizers}.\n     */\n    setHandlesVisible(visible) {\n        for (let i = 0; i < this.bends.length; i += 1) {\n            this.bends[i].node.style.display = visible ? '' : 'none';\n        }\n        if (this.virtualBends) {\n            for (let i = 0; i < this.virtualBends.length; i += 1) {\n                this.virtualBends[i].node.style.display = visible ? '' : 'none';\n            }\n        }\n        this.labelShape.node.style.display = visible ? '' : 'none';\n        if (this.customHandles) {\n            for (let i = 0; i < this.customHandles.length; i += 1) {\n                this.customHandles[i].setVisible(visible);\n            }\n        }\n    }\n    /**\n     * Updates and redraws the inner bends.\n     *\n     * @param p0 {@link Point} that represents the location of the first point.\n     * @param pe {@link Point} that represents the location of the last point.\n     */\n    redrawInnerBends(p0, pe) {\n        for (let i = 1; i < this.bends.length - 1; i += 1) {\n            if (this.bends[i] != null) {\n                if (this.abspoints[i] != null) {\n                    const { x } = this.abspoints[i];\n                    const { y } = this.abspoints[i];\n                    const b = this.bends[i].bounds;\n                    this.bends[i].node.style.visibility = 'visible';\n                    this.bends[i].bounds = new Rectangle(Math.round(x - b.width / 2), Math.round(y - b.height / 2), b.width, b.height);\n                    if (this.manageLabelHandle) {\n                        this.checkLabelHandle(this.bends[i].bounds);\n                    }\n                    else if (this.handleImage == null &&\n                        this.labelShape.visible &&\n                        intersects(this.bends[i].bounds, this.labelShape.bounds)) {\n                        const w = HandleConfig.size + 3;\n                        const h = w;\n                        this.bends[i].bounds = new Rectangle(Math.round(x - w / 2), Math.round(y - h / 2), w, h);\n                    }\n                    this.bends[i].redraw();\n                }\n                else {\n                    this.bends[i].destroy();\n                }\n            }\n        }\n    }\n    /**\n     * Checks if the label handle intersects the given bounds and moves it if it\n     * intersects.\n     */\n    checkLabelHandle(b) {\n        const b2 = this.labelShape.bounds;\n        if (intersects(b, b2)) {\n            if (b.getCenterY() < b2.getCenterY()) {\n                b2.y = b.y + b.height;\n            }\n            else {\n                b2.y = b.y - b2.height;\n            }\n        }\n    }\n    /**\n     * Redraws the preview.\n     */\n    drawPreview() {\n        try {\n            if (this.isLabel) {\n                const b = this.labelShape.bounds;\n                const bounds = new Rectangle(Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);\n                if (!b.equals(bounds)) {\n                    this.labelShape.bounds = bounds;\n                    this.labelShape.redraw();\n                }\n            }\n            if (this.shape != null && !equalPoints(this.shape.points, this.abspoints)) {\n                this.shape.apply(this.state);\n                this.shape.points = this.abspoints.slice();\n                this.shape.scale = this.state.view.scale;\n                this.shape.isDashed = this.isSelectionDashed();\n                this.shape.stroke = this.getSelectionColor();\n                this.shape.strokeWidth =\n                    this.getSelectionStrokeWidth() / this.shape.scale / this.shape.scale;\n                this.shape.isShadow = false;\n                this.shape.redraw();\n            }\n            this.updateParentHighlight();\n        }\n        catch (e) {\n            // ignore\n        }\n    }\n    /**\n     * Refreshes the bends of this handler.\n     */\n    refresh() {\n        if (this.state != null) {\n            this.abspoints = this.getSelectionPoints(this.state);\n            this.points = [];\n            this.destroyBends(this.bends);\n            this.bends = this.createBends();\n            if (this.virtualBends) {\n                this.destroyBends(this.virtualBends);\n                this.virtualBends = this.createVirtualBends();\n            }\n            if (this.customHandles) {\n                this.destroyBends(this.customHandles);\n                this.customHandles = this.createCustomHandles();\n            }\n            // Puts label node on top of bends\n            if (this.labelShape != null &&\n                this.labelShape.node != null &&\n                this.labelShape.node.parentNode != null) {\n                this.labelShape.node.parentNode.appendChild(this.labelShape.node);\n            }\n        }\n    }\n    /**\n     * Returns true if {@link destroy} was called.\n     */\n    isDestroyed() {\n        return this.shape == null;\n    }\n    /**\n     * Destroys all elements in {@link bends}.\n     */\n    destroyBends(bends) {\n        if (bends != null) {\n            for (let i = 0; i < bends.length; i += 1) {\n                if (bends[i] != null) {\n                    bends[i].destroy();\n                }\n            }\n        }\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes. This does\n     * normally not need to be called as handlers are destroyed automatically\n     * when the corresponding cell is deselected.\n     */\n    onDestroy() {\n        this.state.view.graph.removeListener(this.escapeHandler);\n        this.marker.destroy();\n        // @ts-expect-error Can be null when destroyed.\n        this.marker = null;\n        this.shape.destroy();\n        // @ts-expect-error Can be null when destroyed.\n        this.shape = null;\n        if (this.parentHighlight) {\n            const parent = this.state.cell.getParent();\n            const pstate = parent ? this.graph.view.getState(parent) : null;\n            if (pstate && pstate.parentHighlight === this.parentHighlight) {\n                pstate.parentHighlight = null;\n            }\n            this.parentHighlight.destroy();\n            this.parentHighlight = null;\n        }\n        this.labelShape.destroy();\n        // @ts-expect-error Can be null when destroyed.\n        this.labelShape = null;\n        this.constraintHandler.onDestroy();\n        // @ts-expect-error Can be null when destroyed.\n        this.constraintHandler = null;\n        if (this.virtualBends) {\n            this.destroyBends(this.virtualBends);\n            this.virtualBends = [];\n        }\n        if (this.customHandles) {\n            this.destroyBends(this.customHandles);\n            this.customHandles = [];\n        }\n        this.destroyBends(this.bends);\n        this.bends = [];\n        this.removeHint();\n    }\n}\nclass EdgeHandlerCellMarker extends CellMarker {\n    constructor(graph, edgeHandler, validColor = DEFAULT_VALID_COLOR, invalidColor = DEFAULT_INVALID_COLOR, hotspot = DEFAULT_HOTSPOT) {\n        super(graph, validColor, invalidColor, hotspot);\n        // Only returns edges if they are connectable and never returns\n        // the edge that is currently being modified\n        this.getCell = (me) => {\n            let cell = super.getCell(me);\n            // Checks for cell at preview point (with grid)\n            if ((cell === this.edgeHandler.state.cell || !cell) &&\n                this.edgeHandler.currentPoint) {\n                cell = this.edgeHandler.graph.getCellAt(this.edgeHandler.currentPoint.x, this.edgeHandler.currentPoint.y);\n            }\n            // Uses connectable parent vertex if one exists\n            if (cell && !cell.isConnectable()) {\n                const parent = cell.getParent();\n                if (parent && parent.isVertex() && parent.isConnectable()) {\n                    cell = parent;\n                }\n            }\n            if (cell) {\n                if ((this.graph.isSwimlane(cell) &&\n                    this.edgeHandler.currentPoint &&\n                    this.graph.hitsSwimlaneContent(cell, this.edgeHandler.currentPoint.x, this.edgeHandler.currentPoint.y)) ||\n                    !this.edgeHandler.isConnectableCell(cell) ||\n                    cell === this.edgeHandler.state.cell ||\n                    (cell && !this.edgeHandler.graph.connectableEdges && cell.isEdge()) ||\n                    this.edgeHandler.state.cell.isAncestor(cell)) {\n                    cell = null;\n                }\n            }\n            if (cell && !cell.isConnectable()) {\n                cell = null;\n            }\n            return cell;\n        };\n        // Sets the highlight color according to validateConnection\n        this.isValidState = (state) => {\n            const cell = this.edgeHandler.state.cell.getTerminal(!this.edgeHandler.isSource);\n            const cellState = this.edgeHandler.graph.view.getState(cell);\n            const other = this.edgeHandler.graph.view.getTerminalPort(state, cellState, !this.edgeHandler.isSource);\n            const otherCell = other ? other.cell : null;\n            const source = this.edgeHandler.isSource ? state.cell : otherCell;\n            const target = this.edgeHandler.isSource ? otherCell : state.cell;\n            // Updates the error message of the handler\n            this.edgeHandler.error = this.edgeHandler.validateConnection(source, target);\n            return !this.edgeHandler.error;\n        };\n        this.edgeHandler = edgeHandler;\n    }\n}\nexport default EdgeHandler;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2014, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2020, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/handler/ElbowEdgeHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EdgeHandler from './EdgeHandler';\nimport { CURSOR, EDGESTYLE, ELBOW } from '../../util/Constants';\nimport InternalEvent from '../event/InternalEvent';\nimport Point from '../geometry/Point';\nimport Translations from '../../util/Translations';\nimport Rectangle from '../geometry/Rectangle';\nimport { intersects } from '../../util/mathUtils';\nimport Client from '../../Client';\nimport { isConsumed } from '../../util/EventUtils';\nimport { HandleConfig } from './config';\n/**\n * Graph event handler that reconnects edges and modifies control points and\n * the edge label location. Uses {@link CellMarker} for finding and\n * highlighting new source and target vertices. This handler is automatically\n * created in {@link Graph.createHandler}. It extends {@link EdgeHandler}.\n *\n * Constructor: mxEdgeHandler\n *\n * Constructs an edge handler for the specified {@link CellState}.\n *\n * @param state {@link CellState} of the cell to be modified.\n */\nclass ElbowEdgeHandler extends EdgeHandler {\n    constructor(state) {\n        super(state);\n        /**\n         * Specifies if a double click on the middle handle should call {@link Graph#flipEdge}.\n         * @default true\n         */\n        this.flipEnabled = true;\n        /**\n         * Specifies the resource key for the tooltip to be displayed on the single\n         * control point for routed edges. If the resource for this key does not\n         * exist then the value is used as the error message.\n         * @default 'doubleClickOrientation'.\n         */\n        this.doubleClickOrientationResource = Client.language !== 'none' ? 'doubleClickOrientation' : '';\n    }\n    /**\n     * Overrides {@link EdgeHandler.createBends} to create custom bends.\n     */\n    createBends() {\n        const bends = [];\n        // Source\n        let bend = this.createHandleShape(0);\n        this.initBend(bend);\n        bend.setCursor(CURSOR.TERMINAL_HANDLE);\n        bends.push(bend);\n        // Virtual\n        bends.push(this.createVirtualBend((evt) => {\n            if (!isConsumed(evt) && this.flipEnabled) {\n                this.graph.flipEdge(this.state.cell);\n                InternalEvent.consume(evt);\n            }\n        }));\n        this.points.push(new Point(0, 0));\n        // Target\n        bend = this.createHandleShape(2);\n        this.initBend(bend);\n        bend.setCursor(CURSOR.TERMINAL_HANDLE);\n        bends.push(bend);\n        return bends;\n    }\n    /**\n     * Creates a virtual bend that supports double-clicking and calls {@link Graph#flipEdge}.\n     */\n    createVirtualBend(dblClickHandler) {\n        const bend = this.createHandleShape();\n        this.initBend(bend, dblClickHandler);\n        bend.setCursor(this.getCursorForBend());\n        if (!this.graph.isCellBendable(this.state.cell)) {\n            bend.node.style.display = 'none';\n        }\n        return bend;\n    }\n    /**\n     * Returns the cursor to be used for the bend.\n     */\n    getCursorForBend() {\n        return this.state.style.edgeStyle === EDGESTYLE.TOPTOBOTTOM ||\n            (this.state.style.edgeStyle === EDGESTYLE.ELBOW &&\n                this.state.style.elbow === ELBOW.VERTICAL)\n            ? 'row-resize'\n            : 'col-resize';\n    }\n    /**\n     * Returns the tooltip for the given node.\n     */\n    getTooltipForNode(node) {\n        let tip = null;\n        if (this.bends != null &&\n            this.bends[1] != null &&\n            (node === this.bends[1].node || node.parentNode === this.bends[1].node)) {\n            tip = this.doubleClickOrientationResource;\n            tip = Translations.get(tip) || tip; // translate\n        }\n        return tip;\n    }\n    /**\n     * Converts the given point in-place from screen to unscaled, untranslated\n     * graph coordinates and applies the grid.\n     *\n     * @param point {@link Point} to be converted.\n     * @param gridEnabled Boolean that specifies if the grid should be applied.\n     */\n    convertPoint(point, gridEnabled) {\n        const scale = this.graph.getView().getScale();\n        const tr = this.graph.getView().getTranslate();\n        const { origin } = this.state;\n        if (gridEnabled) {\n            point.x = this.graph.snap(point.x);\n            point.y = this.graph.snap(point.y);\n        }\n        point.x = Math.round(point.x / scale - tr.x - origin.x);\n        point.y = Math.round(point.y / scale - tr.y - origin.y);\n        return point;\n    }\n    /**\n     * Updates and redraws the inner bends.\n     *\n     * @param p0 {@link Point} that represents the location of the first point.\n     * @param pe {@link Point} that represents the location of the last point.\n     */\n    redrawInnerBends(p0, pe) {\n        const g = this.state.cell.getGeometry();\n        const pts = this.state.absolutePoints;\n        let pt = null;\n        // Keeps the virtual bend on the edge shape\n        if (pts.length > 1) {\n            p0 = pts[1];\n            pe = pts[pts.length - 2];\n        }\n        else if (g.points != null && g.points.length > 0) {\n            pt = pts[0];\n        }\n        if (pt == null) {\n            pt = new Point(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);\n        }\n        else {\n            pt = new Point(this.graph.getView().scale *\n                (pt.x + this.graph.getView().translate.x + this.state.origin.x), this.graph.getView().scale *\n                (pt.y + this.graph.getView().translate.y + this.state.origin.y));\n        }\n        // Makes handle slightly bigger if the yellow  label handle\n        // exists and intersects this green handle\n        const b = this.bends[1].bounds;\n        let w = b.width;\n        let h = b.height;\n        let bounds = new Rectangle(Math.round(pt.x - w / 2), Math.round(pt.y - h / 2), w, h);\n        if (this.manageLabelHandle) {\n            this.checkLabelHandle(bounds);\n        }\n        else if (this.handleImage == null &&\n            this.labelShape.visible &&\n            this.labelShape.bounds &&\n            intersects(bounds, this.labelShape.bounds)) {\n            w = HandleConfig.size + 3;\n            h = w;\n            bounds = new Rectangle(Math.floor(pt.x - w / 2), Math.floor(pt.y - h / 2), w, h);\n        }\n        this.bends[1].bounds = bounds;\n        this.bends[1].redraw();\n        if (this.manageLabelHandle) {\n            this.checkLabelHandle(this.bends[1].bounds);\n        }\n    }\n}\nexport default ElbowEdgeHandler;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2194, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2200, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/handler/EdgeSegmentHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport { CURSOR } from '../../util/Constants';\nimport Rectangle from '../geometry/Rectangle';\nimport { contains } from '../../util/mathUtils';\nimport { setOpacity } from '../../util/styleUtils';\nimport ElbowEdgeHandler from './ElbowEdgeHandler';\nclass EdgeSegmentHandler extends ElbowEdgeHandler {\n    constructor(state) {\n        super(state);\n        this.points = [];\n    }\n    /**\n     * Returns the current absolute points.\n     */\n    getCurrentPoints() {\n        let pts = this.state.absolutePoints;\n        // Special case for straight edges where we add a virtual middle handle for moving the edge\n        const tol = Math.max(1, this.graph.view.scale);\n        if ((pts.length === 2 && pts[0] && pts[1]) ||\n            (pts.length === 3 &&\n                pts[0] &&\n                pts[1] &&\n                pts[2] &&\n                ((Math.abs(pts[0].x - pts[1].x) < tol && Math.abs(pts[1].x - pts[2].x) < tol) ||\n                    (Math.abs(pts[0].y - pts[1].y) < tol && Math.abs(pts[1].y - pts[2].y) < tol)))) {\n            const cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;\n            const cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;\n            pts = [pts[0], new Point(cx, cy), new Point(cx, cy), pts[pts.length - 1]];\n        }\n        return pts;\n    }\n    /**\n     * Updates the given preview state taking into account the state of the constraint handler.\n     */\n    getPreviewPoints(point) {\n        if (this.isSource || this.isTarget) {\n            return super.getPreviewPoints(point);\n        }\n        const pts = this.getCurrentPoints();\n        let last = this.convertPoint(pts[0].clone(), false);\n        point = this.convertPoint(point.clone(), false);\n        let result = [];\n        for (let i = 1; i < pts.length; i += 1) {\n            const pt = this.convertPoint(pts[i].clone(), false);\n            if (i === this.index) {\n                if (Math.round(last.x - pt.x) === 0) {\n                    last.x = point.x;\n                    pt.x = point.x;\n                }\n                if (Math.round(last.y - pt.y) === 0) {\n                    last.y = point.y;\n                    pt.y = point.y;\n                }\n            }\n            if (i < pts.length - 1) {\n                result.push(pt);\n            }\n            last = pt;\n        }\n        // Replaces single point that intersects with source or target\n        if (result.length === 1) {\n            const source = this.state.getVisibleTerminalState(true);\n            const target = this.state.getVisibleTerminalState(false);\n            const scale = this.state.view.getScale();\n            const tr = this.state.view.getTranslate();\n            const x = result[0].x * scale + tr.x;\n            const y = result[0].y * scale + tr.y;\n            if ((source != null && contains(source, x, y)) ||\n                (target != null && contains(target, x, y))) {\n                result = [point, point];\n            }\n        }\n        return result;\n    }\n    /**\n     * Overridden to perform optimization of the edge style result.\n     */\n    updatePreviewState(edge, point, terminalState, me) {\n        super.updatePreviewState(edge, point, terminalState, me);\n        // Checks and corrects preview by running edge style again\n        if (!this.isSource && !this.isTarget) {\n            point = this.convertPoint(point.clone(), false);\n            const pts = edge.absolutePoints;\n            let pt0 = pts[0];\n            let pt1 = pts[1];\n            let result = [];\n            for (let i = 2; i < pts.length; i += 1) {\n                const pt2 = pts[i];\n                // Merges adjacent segments only if more than 2 to allow for straight edges\n                if ((Math.round(pt0.x - pt1.x) !== 0 || Math.round(pt1.x - pt2.x) !== 0) &&\n                    (Math.round(pt0.y - pt1.y) !== 0 || Math.round(pt1.y - pt2.y) !== 0)) {\n                    result.push(this.convertPoint(pt1.clone(), false));\n                }\n                pt0 = pt1;\n                pt1 = pt2;\n            }\n            const source = this.state.getVisibleTerminalState(true);\n            const target = this.state.getVisibleTerminalState(false);\n            const rpts = this.state.absolutePoints;\n            const end = pts[pts.length - 1];\n            // A straight line is represented by 3 handles\n            if (result.length === 0 &&\n                pts[0] &&\n                end &&\n                (Math.round(pts[0].x - end.x) === 0 || Math.round(pts[0].y - end.y) === 0)) {\n                result = [point, point];\n            }\n            // Handles special case of transitions from straight vertical to routed\n            else if (pts.length === 5 &&\n                result.length === 2 &&\n                source != null &&\n                target != null &&\n                rpts != null &&\n                Math.round(rpts[0].x - rpts[rpts.length - 1].x) === 0) {\n                const view = this.graph.getView();\n                const scale = view.getScale();\n                const tr = view.getTranslate();\n                let y0 = view.getRoutingCenterY(source) / scale - tr.y;\n                // Use fixed connection point y-coordinate if one exists\n                const sc = this.graph.getConnectionConstraint(edge, source, true);\n                if (sc != null) {\n                    const pt = this.graph.getConnectionPoint(source, sc);\n                    if (pt != null) {\n                        this.convertPoint(pt, false);\n                        y0 = pt.y;\n                    }\n                }\n                let ye = view.getRoutingCenterY(target) / scale - tr.y;\n                // Use fixed connection point y-coordinate if one exists\n                const tc = this.graph.getConnectionConstraint(edge, target, false);\n                if (tc) {\n                    const pt = this.graph.getConnectionPoint(target, tc);\n                    if (pt != null) {\n                        this.convertPoint(pt, false);\n                        ye = pt.y;\n                    }\n                }\n                result = [new Point(point.x, y0), new Point(point.x, ye)];\n            }\n            this.points = result;\n            // LATER: Check if points and result are different\n            edge.view.updateFixedTerminalPoints(edge, source, target);\n            edge.view.updatePoints(edge, this.points, source, target);\n            edge.view.updateFloatingTerminalPoints(edge, source, target);\n        }\n    }\n    /**\n     * Overriden to merge edge segments.\n     */\n    connect(edge, terminal, isSource, isClone, me) {\n        const model = this.graph.getDataModel();\n        let geo = edge.getGeometry();\n        let result = null;\n        // Merges adjacent edge segments\n        if (geo != null && geo.points != null && geo.points.length > 0) {\n            const pts = this.abspoints;\n            let pt0 = pts[0];\n            let pt1 = pts[1];\n            result = [];\n            for (let i = 2; i < pts.length; i += 1) {\n                const pt2 = pts[i];\n                // Merges adjacent segments only if more than 2 to allow for straight edges\n                if (pt0 &&\n                    pt1 &&\n                    pt2 &&\n                    (Math.round(pt0.x - pt1.x) !== 0 || Math.round(pt1.x - pt2.x) !== 0) &&\n                    (Math.round(pt0.y - pt1.y) !== 0 || Math.round(pt1.y - pt2.y) !== 0)) {\n                    result.push(this.convertPoint(pt1.clone(), false));\n                }\n                pt0 = pt1;\n                pt1 = pt2;\n            }\n        }\n        this.graph.batchUpdate(() => {\n            if (result != null) {\n                geo = edge.getGeometry();\n                if (geo != null) {\n                    geo = geo.clone();\n                    geo.points = result;\n                    model.setGeometry(edge, geo);\n                }\n            }\n            edge = super.connect(edge, terminal, isSource, isClone, me);\n        });\n        return edge;\n    }\n    /**\n     * Returns no tooltips.\n     */\n    getTooltipForNode(node) {\n        return null;\n    }\n    /**\n     * Adds custom bends for the center of each segment.\n     */\n    start(x, y, index) {\n        super.start(x, y, index);\n        if (this.bends != null &&\n            this.bends[index] != null &&\n            !this.isSource &&\n            !this.isTarget) {\n            setOpacity(this.bends[index].node, 100);\n        }\n    }\n    /**\n     * Adds custom bends for the center of each segment.\n     */\n    createBends() {\n        const bends = [];\n        // Source\n        let bend = this.createHandleShape(0);\n        this.initBend(bend);\n        bend.setCursor(CURSOR.TERMINAL_HANDLE);\n        bends.push(bend);\n        const pts = this.getCurrentPoints();\n        // Waypoints (segment handles)\n        if (this.graph.isCellBendable(this.state.cell)) {\n            if (this.points == null) {\n                this.points = [];\n            }\n            for (let i = 0; i < pts.length - 1; i += 1) {\n                bend = this.createVirtualBend();\n                bends.push(bend);\n                let horizontal = Math.round(pts[i].x - pts[i + 1].x) === 0;\n                // Special case where dy is 0 as well\n                if (Math.round(pts[i].y - pts[i + 1].y) === 0 && i < pts.length - 2) {\n                    horizontal = Math.round(pts[i].x - pts[i + 2].x) === 0;\n                }\n                bend.setCursor(horizontal ? 'col-resize' : 'row-resize');\n                this.points.push(new Point(0, 0));\n            }\n        }\n        // Target\n        bend = this.createHandleShape(pts.length);\n        this.initBend(bend);\n        bend.setCursor(CURSOR.TERMINAL_HANDLE);\n        bends.push(bend);\n        return bends;\n    }\n    /**\n     * Overridden to invoke <refresh> before the redraw.\n     */\n    redraw() {\n        this.refresh();\n        super.redraw();\n    }\n    /**\n     * Updates the position of the custom bends.\n     */\n    redrawInnerBends(p0, pe) {\n        if (this.graph.isCellBendable(this.state.cell)) {\n            const pts = this.getCurrentPoints();\n            if (pts != null && pts.length > 1) {\n                let straight = false;\n                // Puts handle in the center of straight edges\n                if (pts.length === 4 &&\n                    pts[0] &&\n                    pts[1] &&\n                    pts[2] &&\n                    pts[3] &&\n                    Math.round(pts[1].x - pts[2].x) === 0 &&\n                    Math.round(pts[1].y - pts[2].y) === 0) {\n                    straight = true;\n                    if (Math.round(pts[0].y - pts[pts.length - 1].y) === 0) {\n                        const cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;\n                        pts[1] = new Point(cx, pts[1].y);\n                        pts[2] = new Point(cx, pts[2].y);\n                    }\n                    else {\n                        const cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;\n                        pts[1] = new Point(pts[1].x, cy);\n                        pts[2] = new Point(pts[2].x, cy);\n                    }\n                }\n                for (let i = 0; i < pts.length - 1; i += 1) {\n                    if (this.bends[i + 1] != null) {\n                        p0 = pts[i];\n                        pe = pts[i + 1];\n                        const pt = new Point(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);\n                        const b = this.bends[i + 1].bounds;\n                        this.bends[i + 1].bounds = new Rectangle(Math.floor(pt.x - b.width / 2), Math.floor(pt.y - b.height / 2), b.width, b.height);\n                        this.bends[i + 1].redraw();\n                        if (this.manageLabelHandle) {\n                            this.checkLabelHandle(this.bends[i + 1].bounds);\n                        }\n                    }\n                }\n                if (straight) {\n                    setOpacity(this.bends[1].node, this.virtualBendOpacity);\n                    setOpacity(this.bends[3].node, this.virtualBendOpacity);\n                }\n            }\n        }\n    }\n}\nexport default EdgeSegmentHandler;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2494, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2500, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/handler/VertexHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport { CURSOR, DIALECT, NONE } from '../../util/Constants';\nimport InternalEvent from '../event/InternalEvent';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport ImageShape from '../geometry/node/ImageShape';\nimport EllipseShape from '../geometry/node/EllipseShape';\nimport Point from '../geometry/Point';\nimport { getRotatedPoint, intersects, mod, toRadians } from '../../util/mathUtils';\nimport Client from '../../Client';\nimport { isMouseEvent, isShiftDown } from '../../util/EventUtils';\nimport { HandleConfig, VertexHandlerConfig } from './config';\n/**\n * Event handler for resizing cells.\n *\n * This handler is automatically created in {@link Graph#createHandler}.\n *\n * Some elements of this handler and its subclasses can be configured using {@link EdgeHandlerConfig}.\n */\nclass VertexHandler {\n    /**\n     * Specifies if a rotation handle should be visible.\n     *\n     * This implementation returns {@link VertexHandlerConfig.rotationEnabled}.\n     * @since 0.12.0\n     */\n    isRotationEnabled() {\n        return VertexHandlerConfig.rotationEnabled;\n    }\n    /**\n     * Constructs an event handler that allows to resize vertices and groups.\n     *\n     * @param state {@link CellState} of the cell to be resized.\n     */\n    constructor(state) {\n        this.sizers = [];\n        /**\n         * Specifies if only one sizer handle at the bottom, right corner should be used.\n         * @default false\n         */\n        this.singleSizer = false;\n        /**\n         * Holds the index of the current handle.\n         */\n        this.index = null;\n        /**\n         * Specifies if the bounds of handles should be used for hit-detection in IE or if {@link tolerance} > 0.\n         * @default true\n         */\n        this.allowHandleBoundsCheck = true;\n        /**\n         * Optional {@link Image} to be used as handles.\n         * @default null\n         */\n        this.handleImage = null;\n        /**\n         * If handles are currently visible.\n         * @default true\n         */\n        this.handlesVisible = true;\n        /**\n         * Optional tolerance for hit-detection in {@link getHandleForEvent}.\n         * @default 0\n         */\n        this.tolerance = 0;\n        /**\n         * Specifies if the parent should be highlighted if a child cell is selected.\n         * @default false\n         */\n        this.parentHighlightEnabled = false;\n        /**\n         * Specifies if rotation steps should be \"rasterized\" depending on the distance to the handle.\n         * @default true\n         */\n        this.rotationRaster = true;\n        /**\n         * Specifies the cursor for the rotation handle.\n         * @default 'crosshair'.\n         */\n        this.rotationCursor = 'crosshair';\n        /**\n         * Specifies if resize should change the cell in-place. This is an experimental\n         * feature for non-touch devices.\n         * @default false\n         */\n        this.livePreview = false;\n        /**\n         * Specifies if the live preview should be moved to the front.\n         * @default false\n         */\n        this.movePreviewToFront = false;\n        /**\n         * Specifies if sizers should be hidden and spaced if the vertex is small.\n         * @default false\n         */\n        this.manageSizers = false;\n        /**\n         * Specifies if the size of groups should be constrained by the children.\n         * @default false\n         */\n        this.constrainGroupByChildren = false;\n        /**\n         * Vertical spacing for rotation icon.\n         * @default -16\n         */\n        this.rotationHandleVSpacing = -16;\n        /**\n         * The horizontal offset for the handles. This is updated in {@link redrawHandles}\n         * if {@link manageSizers} is `true` and the sizers are offset horizontally.\n         */\n        this.horizontalOffset = 0;\n        /**\n         * The horizontal offset for the handles. This is updated in <redrawHandles>\n         * if {@link manageSizers} is true and the sizers are offset vertically.\n         */\n        this.verticalOffset = 0;\n        this.minBounds = null;\n        this.x0 = 0;\n        this.y0 = 0;\n        this.customHandles = [];\n        this.inTolerance = false;\n        this.startX = 0;\n        this.startY = 0;\n        this.rotationShape = null;\n        this.currentAlpha = 100;\n        this.startAngle = 0;\n        this.startDist = 0;\n        this.ghostPreview = null;\n        this.livePreviewActive = false;\n        this.childOffsetX = 0;\n        this.childOffsetY = 0;\n        this.parentState = null;\n        this.parentHighlight = null;\n        this.unscaledBounds = null;\n        this.preview = null;\n        this.labelShape = null;\n        this.edgeHandlers = [];\n        this.EMPTY_POINT = new Point();\n        this.state = state;\n        this.graph = this.state.view.graph;\n        this.selectionBounds = this.getSelectionBounds(this.state);\n        this.bounds = new Rectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n        this.selectionBorder = this.createSelectionShape(this.bounds);\n        // VML dialect required here for event transparency in IE\n        this.selectionBorder.dialect = DIALECT.SVG;\n        this.selectionBorder.pointerEvents = false;\n        this.selectionBorder.rotation = this.state.style.rotation ?? 0;\n        this.selectionBorder.init(this.graph.getView().getOverlayPane());\n        InternalEvent.redirectMouseEvents(this.selectionBorder.node, this.graph, this.state);\n        if (this.graph.isCellMovable(this.state.cell)) {\n            this.selectionBorder.setCursor(CURSOR.MOVABLE_VERTEX);\n        }\n        const selectionHandler = this.graph.getPlugin('SelectionHandler');\n        // Adds the sizer handles\n        if (selectionHandler &&\n            (selectionHandler.maxCells <= 0 ||\n                this.graph.getSelectionCount() < selectionHandler.maxCells)) {\n            const resizable = this.graph.isCellResizable(this.state.cell);\n            this.sizers = [];\n            if (resizable ||\n                (this.graph.isLabelMovable(this.state.cell) &&\n                    this.state.width >= 2 &&\n                    this.state.height >= 2)) {\n                let i = 0;\n                if (resizable) {\n                    if (!this.singleSizer) {\n                        this.sizers.push(this.createSizer('nw-resize', i++));\n                        this.sizers.push(this.createSizer('n-resize', i++));\n                        this.sizers.push(this.createSizer('ne-resize', i++));\n                        this.sizers.push(this.createSizer('w-resize', i++));\n                        this.sizers.push(this.createSizer('e-resize', i++));\n                        this.sizers.push(this.createSizer('sw-resize', i++));\n                        this.sizers.push(this.createSizer('s-resize', i++));\n                    }\n                    this.sizers.push(this.createSizer('se-resize', i++));\n                }\n                const geo = this.state.cell.getGeometry();\n                if (geo != null &&\n                    !geo.relative &&\n                    //!this.graph.isSwimlane(this.state.cell) &&      disable for now\n                    this.graph.isLabelMovable(this.state.cell)) {\n                    // Marks this as the label handle for getHandleForEvent\n                    this.labelShape = this.createSizer(CURSOR.LABEL_HANDLE, InternalEvent.LABEL_HANDLE, HandleConfig.labelSize, HandleConfig.labelFillColor);\n                    this.sizers.push(this.labelShape);\n                }\n            }\n            else if (this.graph.isCellMovable(this.state.cell) &&\n                !this.graph.isCellResizable(this.state.cell) &&\n                this.state.width < 2 &&\n                this.state.height < 2) {\n                this.labelShape = this.createSizer(CURSOR.MOVABLE_VERTEX, InternalEvent.LABEL_HANDLE, undefined, HandleConfig.labelFillColor);\n                this.sizers.push(this.labelShape);\n            }\n        }\n        // Adds the rotation handler\n        if (this.isRotationHandleVisible()) {\n            this.rotationShape = this.createSizer(this.rotationCursor, InternalEvent.ROTATION_HANDLE, HandleConfig.size + 3, HandleConfig.fillColor);\n            this.sizers.push(this.rotationShape);\n        }\n        this.customHandles = this.createCustomHandles();\n        this.redraw();\n        if (this.constrainGroupByChildren) {\n            this.updateMinBounds();\n        }\n        // Handles escape keystrokes\n        this.escapeHandler = (_sender, _evt) => {\n            if (this.livePreview && this.index != null) {\n                // Redraws the live preview\n                this.state.view.graph.cellRenderer.redraw(this.state, true);\n                // Redraws connected edges\n                this.state.view.invalidate(this.state.cell);\n                this.state.invalid = false;\n                this.state.view.validate();\n            }\n            this.reset();\n        };\n        this.state.view.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);\n    }\n    /**\n     * Returns `true` if the rotation handle should be showing.\n     */\n    isRotationHandleVisible() {\n        const selectionHandler = this.graph.getPlugin('SelectionHandler');\n        const selectionHandlerCheck = selectionHandler\n            ? selectionHandler.maxCells <= 0 ||\n                this.graph.getSelectionCount() < selectionHandler.maxCells\n            : true;\n        return (this.graph.isEnabled() &&\n            this.isRotationEnabled() &&\n            this.graph.isCellRotatable(this.state.cell) &&\n            selectionHandlerCheck);\n    }\n    /**\n     * Returns `true` if the aspect ratio if the cell should be maintained.\n     */\n    isConstrainedEvent(me) {\n        return isShiftDown(me.getEvent()) || this.state.style.aspect === 'fixed';\n    }\n    /**\n     * Returns `true` if the center of the vertex should be maintained during the resize.\n     */\n    isCenteredEvent(state, me) {\n        return false;\n    }\n    /**\n     * Returns an array of custom handles.\n     *\n     * This implementation returns an empty array.\n     */\n    createCustomHandles() {\n        return [];\n    }\n    /**\n     * Initializes the shapes required for this vertex handler.\n     */\n    updateMinBounds() {\n        const children = this.graph.getChildCells(this.state.cell);\n        if (children.length > 0) {\n            this.minBounds = this.graph.view.getBounds(children);\n            if (this.minBounds) {\n                const s = this.state.view.scale;\n                const t = this.state.view.translate;\n                this.minBounds.x -= this.state.x;\n                this.minBounds.y -= this.state.y;\n                this.minBounds.x /= s;\n                this.minBounds.y /= s;\n                this.minBounds.width /= s;\n                this.minBounds.height /= s;\n                this.x0 = this.state.x / s - t.x;\n                this.y0 = this.state.y / s - t.y;\n            }\n        }\n    }\n    /**\n     * Returns the Rectangle that defines the bounds of the selection border.\n     */\n    getSelectionBounds(state) {\n        return new Rectangle(Math.round(state.x), Math.round(state.y), Math.round(state.width), Math.round(state.height));\n    }\n    /**\n     * Creates the shape used to draw the selection border.\n     */\n    createParentHighlightShape(bounds) {\n        return this.createSelectionShape(bounds);\n    }\n    /**\n     * Creates the shape used to draw the selection border.\n     */\n    createSelectionShape(bounds) {\n        const shape = new RectangleShape(Rectangle.fromRectangle(bounds), NONE, this.getSelectionColor());\n        shape.strokeWidth = this.getSelectionStrokeWidth();\n        shape.isDashed = this.isSelectionDashed();\n        return shape;\n    }\n    /**\n     * Returns {@link VertexHandlerConfig.selectionColor}.\n     */\n    getSelectionColor() {\n        return VertexHandlerConfig.selectionColor;\n    }\n    /**\n     * Returns {@link VertexHandlerConfig.selectionStrokeWidth}.\n     */\n    getSelectionStrokeWidth() {\n        return VertexHandlerConfig.selectionStrokeWidth;\n    }\n    /**\n     * Returns {@link VertexHandlerConfig.selectionDashed}.\n     */\n    isSelectionDashed() {\n        return VertexHandlerConfig.selectionDashed;\n    }\n    /**\n     * Creates a sizer handle for the specified cursor and index and returns\n     * the new {@link RectangleShape} that represents the handle.\n     */\n    createSizer(cursor, index, size = HandleConfig.size, fillColor = HandleConfig.fillColor) {\n        const bounds = new Rectangle(0, 0, size, size);\n        const sizer = this.createSizerShape(bounds, index, fillColor);\n        if (sizer.bounds &&\n            sizer.isHtmlAllowed() &&\n            this.state.text &&\n            this.state.text.node.parentNode === this.graph.container) {\n            sizer.bounds.height -= 1;\n            sizer.bounds.width -= 1;\n            sizer.dialect = DIALECT.STRICTHTML;\n            sizer.init(this.graph.container);\n        }\n        else {\n            sizer.dialect =\n                this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n            sizer.init(this.graph.getView().getOverlayPane());\n        }\n        InternalEvent.redirectMouseEvents(sizer.node, this.graph, this.state);\n        if (this.graph.isEnabled()) {\n            sizer.setCursor(cursor);\n        }\n        if (!this.isSizerVisible(index)) {\n            sizer.visible = false;\n        }\n        return sizer;\n    }\n    /**\n     * Returns `true` if the sizer for the given index is visible.\n     *\n     * This implementation returns `true` for all given indices.\n     */\n    isSizerVisible(_index) {\n        return true;\n    }\n    /**\n     * Creates the shape used for the sizer handle for the specified bounds an\n     * index. Only images and rectangles should be returned if support for HTML\n     * labels with not foreign objects is required.\n     */\n    createSizerShape(bounds, index, fillColor = HandleConfig.fillColor) {\n        if (this.handleImage) {\n            bounds = new Rectangle(bounds.x, bounds.y, this.handleImage.width, this.handleImage.height);\n            const shape = new ImageShape(bounds, this.handleImage.src);\n            // Allows HTML rendering of the images\n            shape.preserveImageAspect = false;\n            return shape;\n        }\n        const strokeColor = HandleConfig.strokeColor;\n        if (index === InternalEvent.ROTATION_HANDLE) {\n            return new EllipseShape(bounds, fillColor, strokeColor);\n        }\n        return new RectangleShape(bounds, fillColor, strokeColor);\n    }\n    /**\n     * Helper method to create an {@link Rectangle} around the given center point\n     * with a width and height of 2*s or 6, if no s is given.\n     */\n    moveSizerTo(shape, x, y) {\n        if (shape && shape.bounds) {\n            shape.bounds.x = Math.floor(x - shape.bounds.width / 2);\n            shape.bounds.y = Math.floor(y - shape.bounds.height / 2);\n            // Fixes visible inactive handles in VML\n            if (shape.node && shape.node.style.display !== 'none') {\n                shape.redraw();\n            }\n        }\n    }\n    /**\n     * Returns the index of the handle for the given event. This returns the index\n     * of the sizer from where the event originated or {@link InternalEvent.LABEL_HANDLE}.\n     */\n    getHandleForEvent(me) {\n        // Connection highlight may consume events before they reach sizer handle\n        const tol = !isMouseEvent(me.getEvent()) ? this.tolerance : 1;\n        const hit = this.allowHandleBoundsCheck && tol > 0\n            ? new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol)\n            : null;\n        const checkShape = (shape) => {\n            const st = shape && shape.constructor !== ImageShape && this.allowHandleBoundsCheck\n                ? shape.strokeWidth + shape.svgStrokeTolerance\n                : null;\n            const real = st\n                ? new Rectangle(me.getGraphX() - Math.floor(st / 2), me.getGraphY() - Math.floor(st / 2), st, st)\n                : hit;\n            return (shape &&\n                shape.bounds &&\n                (me.isSource(shape) ||\n                    (real &&\n                        intersects(shape.bounds, real) &&\n                        shape.node.style.display !== 'none' &&\n                        shape.node.style.visibility !== 'hidden')));\n        };\n        if (checkShape(this.rotationShape)) {\n            return InternalEvent.ROTATION_HANDLE;\n        }\n        if (checkShape(this.labelShape)) {\n            return InternalEvent.LABEL_HANDLE;\n        }\n        for (let i = 0; i < this.sizers.length; i += 1) {\n            if (checkShape(this.sizers[i])) {\n                return i;\n            }\n        }\n        if (this.customHandles != null && this.isCustomHandleEvent(me)) {\n            // Inverse loop order to match display order\n            for (let i = this.customHandles.length - 1; i >= 0; i--) {\n                if (checkShape(this.customHandles[i].shape)) {\n                    // LATER: Return reference to active shape\n                    return InternalEvent.CUSTOM_HANDLE - i;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns `true` if the given event allows custom handles to be changed.\n     *\n     * This implementation returns `true`.\n     */\n    isCustomHandleEvent(me) {\n        return true;\n    }\n    /**\n     * Handles the event if a handle has been clicked. By consuming the\n     * event all subsequent events of the gesture are redirected to this\n     * handler.\n     */\n    mouseDown(sender, me) {\n        if (!me.isConsumed() && this.graph.isEnabled()) {\n            const handle = this.getHandleForEvent(me);\n            if (handle) {\n                this.start(me.getGraphX(), me.getGraphY(), handle);\n                me.consume();\n            }\n        }\n    }\n    /**\n     * Called if {@link livePreview} is enabled to check if a border should be painted.\n     *\n     * This implementation returns `true` if the shape is transparent.\n     */\n    isLivePreviewBorder() {\n        return (this.state.shape &&\n            this.state.shape.fill === NONE &&\n            this.state.shape.stroke === NONE);\n    }\n    /**\n     * Starts the handling of the mouse gesture.\n     */\n    start(x, y, index) {\n        this.livePreviewActive = this.livePreview && this.state.cell.getChildCount() === 0;\n        this.inTolerance = true;\n        this.childOffsetX = 0;\n        this.childOffsetY = 0;\n        this.index = index;\n        this.startX = x;\n        this.startY = y;\n        if (this.index <= InternalEvent.CUSTOM_HANDLE && this.isGhostPreview()) {\n            this.ghostPreview = this.createGhostPreview();\n        }\n        else {\n            // Saves reference to parent state\n            const { model } = this.state.view.graph;\n            const parent = this.state.cell.getParent();\n            if (this.state.view.currentRoot !== parent &&\n                parent &&\n                (parent.isVertex() || parent.isEdge())) {\n                this.parentState = this.state.view.graph.view.getState(parent);\n            }\n            // Creates a preview that can be on top of any HTML label\n            this.selectionBorder.node.style.display =\n                index === InternalEvent.ROTATION_HANDLE ? 'inline' : 'none';\n            // Creates the border that represents the new bounds\n            if (!this.livePreviewActive || this.isLivePreviewBorder()) {\n                this.preview = this.createSelectionShape(this.bounds);\n                if (!(Client.IS_SVG && Number(this.state.style.rotation || '0') !== 0) &&\n                    this.state.text != null &&\n                    this.state.text.node.parentNode === this.graph.container) {\n                    this.preview.dialect = DIALECT.STRICTHTML;\n                    this.preview.init(this.graph.container);\n                }\n                else {\n                    this.preview.dialect = DIALECT.SVG;\n                    this.preview.init(this.graph.view.getOverlayPane());\n                }\n            }\n            if (index === InternalEvent.ROTATION_HANDLE) {\n                // With the rotation handle in a corner, need the angle and distance\n                const pos = this.getRotationHandlePosition();\n                const dx = pos.x - this.state.getCenterX();\n                const dy = pos.y - this.state.getCenterY();\n                this.startAngle = dx !== 0 ? (Math.atan(dy / dx) * 180) / Math.PI + 90 : 0;\n                this.startDist = Math.sqrt(dx * dx + dy * dy);\n            }\n            // Prepares the handles for live preview\n            if (this.livePreviewActive) {\n                this.hideSizers();\n                if (index === InternalEvent.ROTATION_HANDLE && this.rotationShape) {\n                    this.rotationShape.node.style.display = '';\n                }\n                else if (index === InternalEvent.LABEL_HANDLE && this.labelShape) {\n                    this.labelShape.node.style.display = '';\n                }\n                else if (this.sizers[index]) {\n                    this.sizers[index].node.style.display = '';\n                }\n                else if (index <= InternalEvent.CUSTOM_HANDLE) {\n                    this.customHandles[InternalEvent.CUSTOM_HANDLE - index].setVisible(true);\n                }\n                // Gets the array of connected edge handlers for redrawing\n                const edges = this.state.cell.getEdges();\n                this.edgeHandlers = [];\n                const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n                for (let i = 0; i < edges.length; i += 1) {\n                    const handler = selectionCellsHandler?.getHandler(edges[i]);\n                    if (handler) {\n                        this.edgeHandlers.push(handler);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Starts the handling of the mouse gesture.\n     */\n    createGhostPreview() {\n        const shape = this.graph.cellRenderer.createShape(this.state);\n        shape.init(this.graph.view.getOverlayPane());\n        shape.scale = this.state.view.scale;\n        shape.bounds = this.bounds;\n        shape.outline = true;\n        return shape;\n    }\n    /**\n     * Shortcut to {@link hideSizers}.\n     */\n    setHandlesVisible(visible) {\n        this.handlesVisible = visible;\n        for (let i = 0; i < this.sizers.length; i += 1) {\n            this.sizers[i].node.style.display = visible ? '' : 'none';\n        }\n        for (let i = 0; i < this.customHandles.length; i += 1) {\n            this.customHandles[i].setVisible(visible);\n        }\n    }\n    /**\n     * Hides all sizers except.\n     *\n     * Starts the handling of the mouse gesture.\n     */\n    hideSizers() {\n        this.setHandlesVisible(false);\n    }\n    /**\n     * Checks if the coordinates for the given event are within the\n     * {@link Graph#tolerance}. If the event is a mouse event then the tolerance is\n     * ignored.\n     */\n    checkTolerance(me) {\n        if (this.inTolerance && this.startX !== null && this.startY !== null) {\n            if (isMouseEvent(me.getEvent()) ||\n                Math.abs(me.getGraphX() - this.startX) > this.graph.getEventTolerance() ||\n                Math.abs(me.getGraphY() - this.startY) > this.graph.getEventTolerance()) {\n                this.inTolerance = false;\n            }\n        }\n    }\n    /**\n     * Hook for subclasses do show details while the handler is active.\n     */\n    updateHint(me) {\n        return;\n    }\n    /**\n     * Hooks for subclasses to hide details when the handler gets inactive.\n     */\n    removeHint() {\n        return;\n    }\n    /**\n     * Hook for rounding the angle. This uses {@link Math.round}.\n     */\n    roundAngle(angle) {\n        return Math.round(angle * 10) / 10;\n    }\n    /**\n     * Hook for rounding the unscaled width or height. This uses {@link Math.round}.\n     */\n    roundLength(length) {\n        return Math.round(length * 100) / 100;\n    }\n    /**\n     * Handles the event by updating the preview.\n     */\n    mouseMove(sender, me) {\n        if (!me.isConsumed() && this.index != null) {\n            // Checks tolerance for ignoring single clicks\n            this.checkTolerance(me);\n            if (!this.inTolerance) {\n                if (this.index <= InternalEvent.CUSTOM_HANDLE) {\n                    if (this.customHandles != null) {\n                        this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].processEvent(me);\n                        this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].active = true;\n                        if (this.ghostPreview != null) {\n                            this.ghostPreview.apply(this.state);\n                            this.ghostPreview.strokeWidth =\n                                this.getSelectionStrokeWidth() /\n                                    this.ghostPreview.scale /\n                                    this.ghostPreview.scale;\n                            this.ghostPreview.isDashed = this.isSelectionDashed();\n                            this.ghostPreview.stroke = this.getSelectionColor();\n                            this.ghostPreview.redraw();\n                            if (this.selectionBounds != null) {\n                                this.selectionBorder.node.style.display = 'none';\n                            }\n                        }\n                        else {\n                            if (this.movePreviewToFront) {\n                                this.moveToFront();\n                            }\n                            this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].positionChanged();\n                        }\n                    }\n                }\n                else if (this.index === InternalEvent.LABEL_HANDLE) {\n                    this.moveLabel(me);\n                }\n                else {\n                    if (this.index === InternalEvent.ROTATION_HANDLE) {\n                        this.rotateVertex(me);\n                    }\n                    else {\n                        this.resizeVertex(me);\n                    }\n                    this.updateHint(me);\n                }\n            }\n            me.consume();\n        }\n        // Workaround for disabling the connect highlight when over handle\n        else if (!this.graph.isMouseDown && this.getHandleForEvent(me)) {\n            me.consume(false);\n        }\n    }\n    /**\n     * Returns `true` if a ghost preview should be used for custom handles.\n     */\n    isGhostPreview() {\n        return this.state.cell.getChildCount() > 0;\n    }\n    /**\n     * Moves the vertex.\n     */\n    moveLabel(me) {\n        const point = new Point(me.getGraphX(), me.getGraphY());\n        const tr = this.graph.view.translate;\n        const { scale } = this.graph.view;\n        if (this.graph.isGridEnabledEvent(me.getEvent())) {\n            point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;\n            point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;\n        }\n        const index = this.rotationShape ? this.sizers.length - 2 : this.sizers.length - 1;\n        this.moveSizerTo(this.sizers[index], point.x, point.y);\n    }\n    /**\n     * Rotates the vertex.\n     */\n    rotateVertex(me) {\n        const point = new Point(me.getGraphX(), me.getGraphY());\n        let dx = this.state.x + this.state.width / 2 - point.x;\n        let dy = this.state.y + this.state.height / 2 - point.y;\n        this.currentAlpha =\n            dx !== 0 ? (Math.atan(dy / dx) * 180) / Math.PI + 90 : dy < 0 ? 180 : 0;\n        if (dx > 0) {\n            this.currentAlpha -= 180;\n        }\n        this.currentAlpha -= this.startAngle;\n        // Rotation raster\n        if (this.rotationRaster && this.graph.isGridEnabledEvent(me.getEvent())) {\n            let raster;\n            dx = point.x - this.state.getCenterX();\n            dy = point.y - this.state.getCenterY();\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist - this.startDist < 2) {\n                raster = 15;\n            }\n            else if (dist - this.startDist < 25) {\n                raster = 5;\n            }\n            else {\n                raster = 1;\n            }\n            this.currentAlpha = Math.round(this.currentAlpha / raster) * raster;\n        }\n        else {\n            this.currentAlpha = this.roundAngle(this.currentAlpha);\n        }\n        this.selectionBorder.rotation = this.currentAlpha;\n        this.selectionBorder.redraw();\n        if (this.livePreviewActive) {\n            this.redrawHandles();\n        }\n    }\n    /**\n     * Resizes the vertex.\n     */\n    resizeVertex(me) {\n        const ct = new Point(this.state.getCenterX(), this.state.getCenterY());\n        const alpha = toRadians(this.state.style.rotation ?? 0);\n        const point = new Point(me.getGraphX(), me.getGraphY());\n        const tr = this.graph.view.translate;\n        const { scale } = this.graph.view;\n        let cos = Math.cos(-alpha);\n        let sin = Math.sin(-alpha);\n        let dx = point.x - this.startX;\n        let dy = point.y - this.startY;\n        // Rotates vector for mouse gesture\n        const tx = cos * dx - sin * dy;\n        const ty = sin * dx + cos * dy;\n        dx = tx;\n        dy = ty;\n        const geo = this.state.cell.getGeometry();\n        if (geo && this.index !== null) {\n            this.unscaledBounds = this.union(geo, dx / scale, dy / scale, this.index, this.graph.isGridEnabledEvent(me.getEvent()), 1, new Point(0, 0), this.isConstrainedEvent(me), this.isCenteredEvent(this.state, me));\n        }\n        // Keeps vertex within maximum graph or parent bounds\n        if (geo && !geo.relative) {\n            let max = this.graph.getMaximumGraphBounds();\n            // Handles child cells\n            if (max != null && this.parentState != null) {\n                max = Rectangle.fromRectangle(max);\n                max.x -= (this.parentState.x - tr.x * scale) / scale;\n                max.y -= (this.parentState.y - tr.y * scale) / scale;\n            }\n            if (this.graph.isConstrainChild(this.state.cell)) {\n                let tmp = this.graph.getCellContainmentArea(this.state.cell);\n                if (tmp != null) {\n                    const overlap = this.graph.getOverlap(this.state.cell);\n                    if (overlap > 0) {\n                        tmp = Rectangle.fromRectangle(tmp);\n                        tmp.x -= tmp.width * overlap;\n                        tmp.y -= tmp.height * overlap;\n                        tmp.width += 2 * tmp.width * overlap;\n                        tmp.height += 2 * tmp.height * overlap;\n                    }\n                    if (!max) {\n                        max = tmp;\n                    }\n                    else {\n                        max = Rectangle.fromRectangle(max);\n                        max.intersect(tmp);\n                    }\n                }\n            }\n            if (max && this.unscaledBounds) {\n                if (this.unscaledBounds.x < max.x) {\n                    this.unscaledBounds.width -= max.x - this.unscaledBounds.x;\n                    this.unscaledBounds.x = max.x;\n                }\n                if (this.unscaledBounds.y < max.y) {\n                    this.unscaledBounds.height -= max.y - this.unscaledBounds.y;\n                    this.unscaledBounds.y = max.y;\n                }\n                if (this.unscaledBounds.x + this.unscaledBounds.width > max.x + max.width) {\n                    this.unscaledBounds.width -=\n                        this.unscaledBounds.x + this.unscaledBounds.width - max.x - max.width;\n                }\n                if (this.unscaledBounds.y + this.unscaledBounds.height > max.y + max.height) {\n                    this.unscaledBounds.height -=\n                        this.unscaledBounds.y + this.unscaledBounds.height - max.y - max.height;\n                }\n            }\n        }\n        if (this.unscaledBounds) {\n            const old = this.bounds;\n            this.bounds = new Rectangle((this.parentState ? this.parentState.x : tr.x * scale) +\n                this.unscaledBounds.x * scale, (this.parentState ? this.parentState.y : tr.y * scale) +\n                this.unscaledBounds.y * scale, this.unscaledBounds.width * scale, this.unscaledBounds.height * scale);\n            if (geo && geo.relative && this.parentState) {\n                this.bounds.x += this.state.x - this.parentState.x;\n                this.bounds.y += this.state.y - this.parentState.y;\n            }\n            cos = Math.cos(alpha);\n            sin = Math.sin(alpha);\n            const c2 = new Point(this.bounds.getCenterX(), this.bounds.getCenterY());\n            dx = c2.x - ct.x;\n            dy = c2.y - ct.y;\n            const dx2 = cos * dx - sin * dy;\n            const dy2 = sin * dx + cos * dy;\n            const dx3 = dx2 - dx;\n            const dy3 = dy2 - dy;\n            const dx4 = this.bounds.x - this.state.x;\n            const dy4 = this.bounds.y - this.state.y;\n            const dx5 = cos * dx4 - sin * dy4;\n            const dy5 = sin * dx4 + cos * dy4;\n            this.bounds.x += dx3;\n            this.bounds.y += dy3;\n            // Rounds unscaled bounds to int\n            this.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + dx3 / scale);\n            this.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + dy3 / scale);\n            this.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);\n            this.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);\n            // Shifts the children according to parent offset\n            if (!this.state.cell.isCollapsed() && (dx3 !== 0 || dy3 !== 0)) {\n                this.childOffsetX = this.state.x - this.bounds.x + dx5;\n                this.childOffsetY = this.state.y - this.bounds.y + dy5;\n            }\n            else {\n                this.childOffsetX = 0;\n                this.childOffsetY = 0;\n            }\n            if (!old.equals(this.bounds)) {\n                if (this.livePreviewActive) {\n                    this.updateLivePreview(me);\n                }\n                if (this.preview != null) {\n                    this.drawPreview();\n                }\n                else {\n                    this.updateParentHighlight();\n                }\n            }\n        }\n    }\n    /**\n     * Repaints the live preview.\n     */\n    updateLivePreview(me) {\n        // TODO: Apply child offset to children in live preview\n        const { scale } = this.graph.view;\n        const tr = this.graph.view.translate;\n        // Saves current state\n        const tempState = this.state.clone();\n        // Temporarily changes size and origin\n        this.state.x = this.bounds.x;\n        this.state.y = this.bounds.y;\n        this.state.origin = new Point(this.state.x / scale - tr.x, this.state.y / scale - tr.y);\n        this.state.width = this.bounds.width;\n        this.state.height = this.bounds.height;\n        // Redraws cell and handles\n        let off = this.state.absoluteOffset;\n        off = new Point(off.x, off.y);\n        // Required to store and reset absolute offset for updating label position\n        this.state.absoluteOffset.x = 0;\n        this.state.absoluteOffset.y = 0;\n        const geo = this.state.cell.getGeometry();\n        if (geo != null) {\n            const offset = geo.offset || this.EMPTY_POINT;\n            if (offset != null && !geo.relative) {\n                this.state.absoluteOffset.x = this.state.view.scale * offset.x;\n                this.state.absoluteOffset.y = this.state.view.scale * offset.y;\n            }\n            this.state.view.updateVertexLabelOffset(this.state);\n        }\n        // Draws the live preview\n        this.state.view.graph.cellRenderer.redraw(this.state, true);\n        // Redraws connected edges TODO: Include child edges\n        this.state.view.invalidate(this.state.cell);\n        this.state.invalid = false;\n        this.state.view.validate();\n        this.redrawHandles();\n        // Moves live preview to front\n        if (this.movePreviewToFront) {\n            this.moveToFront();\n        }\n        // Hides folding icon\n        if (this.state.control != null && this.state.control.node != null) {\n            this.state.control.node.style.visibility = 'hidden';\n        }\n        // Restores current state\n        this.state.setState(tempState);\n    }\n    /**\n     * Handles the event by applying the changes to the geometry.\n     */\n    moveToFront() {\n        if ((this.state.text && this.state.text.node && this.state.text.node.nextSibling) ||\n            (this.state.shape &&\n                this.state.shape.node &&\n                this.state.shape.node.nextSibling &&\n                (!this.state.text || this.state.shape.node.nextSibling !== this.state.text.node))) {\n            if (this.state.shape && this.state.shape.node && this.state.shape.node.parentNode) {\n                this.state.shape.node.parentNode.appendChild(this.state.shape.node);\n            }\n            if (this.state.text && this.state.text.node && this.state.text.node.parentNode) {\n                this.state.text.node.parentNode.appendChild(this.state.text.node);\n            }\n        }\n    }\n    /**\n     * Handles the event by applying the changes to the geometry.\n     */\n    mouseUp(sender, me) {\n        if (this.index != null && this.state != null) {\n            const point = new Point(me.getGraphX(), me.getGraphY());\n            const { index } = this;\n            this.index = null;\n            if (this.ghostPreview == null) {\n                // Required to restore order in case of no change\n                this.state.view.invalidate(this.state.cell, false, false);\n                this.state.view.validate();\n            }\n            this.graph.batchUpdate(() => {\n                if (index <= InternalEvent.CUSTOM_HANDLE) {\n                    if (this.customHandles != null) {\n                        // Creates style before changing cell state\n                        const style = this.state.view.graph.getCellStyle(this.state.cell);\n                        this.customHandles[InternalEvent.CUSTOM_HANDLE - index].active = false;\n                        this.customHandles[InternalEvent.CUSTOM_HANDLE - index].execute(me);\n                        // Sets style and apply on shape to force repaint and\n                        // check if execute has removed custom handles\n                        if (this.customHandles != null &&\n                            this.customHandles[InternalEvent.CUSTOM_HANDLE - index] != null) {\n                            this.state.style = style;\n                            this.customHandles[InternalEvent.CUSTOM_HANDLE - index].positionChanged();\n                        }\n                    }\n                }\n                else if (index === InternalEvent.ROTATION_HANDLE) {\n                    if (this.currentAlpha != null) {\n                        const delta = this.currentAlpha - (this.state.style.rotation ?? 0);\n                        if (delta !== 0) {\n                            this.rotateCell(this.state.cell, delta);\n                        }\n                    }\n                    else {\n                        this.rotateClick();\n                    }\n                }\n                else {\n                    const gridEnabled = this.graph.isGridEnabledEvent(me.getEvent());\n                    const alpha = toRadians(this.state.style.rotation ?? 0);\n                    const cos = Math.cos(-alpha);\n                    const sin = Math.sin(-alpha);\n                    let dx = point.x - this.startX;\n                    let dy = point.y - this.startY;\n                    // Rotates vector for mouse gesture\n                    const tx = cos * dx - sin * dy;\n                    const ty = sin * dx + cos * dy;\n                    dx = tx;\n                    dy = ty;\n                    const s = this.graph.view.scale;\n                    const recurse = this.isRecursiveResize(this.state, me);\n                    this.resizeCell(this.state.cell, this.roundLength(dx / s), this.roundLength(dy / s), index, gridEnabled, this.isConstrainedEvent(me), recurse);\n                }\n            });\n            me.consume();\n            this.reset();\n            this.redrawHandles();\n        }\n    }\n    /**\n     * Returns the `recursiveResize` status of the given state.\n     * @param state the given {@link CellState}. This implementation takes the value of this state.\n     * @param me the mouse event.\n     */\n    isRecursiveResize(state, me) {\n        return this.graph.isRecursiveResize(this.state);\n    }\n    /**\n     * Hook for subclasses to implement a single click on the rotation handle.\n     * This code is executed as part of the model transaction.\n     *\n     * This implementation is empty.\n     */\n    rotateClick() {\n        return;\n    }\n    /**\n     * Rotates the given cell and its children by the given angle in degrees.\n     *\n     * @param cell {@link Cell} to be rotated.\n     * @param angle Angle in degrees.\n     * @param parent if set, consider the parent in the rotation computation.\n     */\n    rotateCell(cell, angle, parent) {\n        if (angle !== 0) {\n            const model = this.graph.getDataModel();\n            if (cell.isVertex() || cell.isEdge()) {\n                if (!cell.isEdge()) {\n                    const style = this.graph.getCurrentCellStyle(cell);\n                    const total = (style.rotation || 0) + angle;\n                    this.graph.setCellStyles('rotation', total, [cell]);\n                }\n                let geo = cell.getGeometry();\n                if (geo && parent) {\n                    const pgeo = parent.getGeometry();\n                    if (pgeo != null && !parent.isEdge()) {\n                        geo = geo.clone();\n                        geo.rotate(angle, new Point(pgeo.width / 2, pgeo.height / 2));\n                        model.setGeometry(cell, geo);\n                    }\n                    if ((cell.isVertex() && !geo.relative) || cell.isEdge()) {\n                        // Recursive rotation\n                        const childCount = cell.getChildCount();\n                        for (let i = 0; i < childCount; i += 1) {\n                            this.rotateCell(cell.getChildAt(i), angle, cell);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Resets the state of this handler.\n     */\n    reset() {\n        if (this.index !== null && this.sizers[this.index].node.style.display === 'none') {\n            this.sizers[this.index].node.style.display = '';\n        }\n        this.index = null;\n        // TODO: Reset and redraw cell states for live preview\n        if (this.preview) {\n            this.preview.destroy();\n            this.preview = null;\n        }\n        if (this.ghostPreview) {\n            this.ghostPreview.destroy();\n            this.ghostPreview = null;\n        }\n        if (this.livePreviewActive) {\n            for (let i = 0; i < this.sizers.length; i += 1) {\n                this.sizers[i].node.style.display = '';\n            }\n            // Shows folding icon\n            if (this.state.control && this.state.control.node) {\n                this.state.control.node.style.visibility = '';\n            }\n        }\n        for (let i = 0; i < this.customHandles.length; i += 1) {\n            if (this.customHandles[i].active) {\n                this.customHandles[i].active = false;\n                this.customHandles[i].reset();\n            }\n            else {\n                this.customHandles[i].setVisible(true);\n            }\n        }\n        // Checks if handler has been destroyed\n        this.selectionBorder.node.style.display = 'inline';\n        this.selectionBounds = this.getSelectionBounds(this.state);\n        this.bounds = new Rectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n        this.drawPreview();\n        this.removeHint();\n        this.redrawHandles();\n        this.edgeHandlers = [];\n        this.handlesVisible = true;\n        this.unscaledBounds = null;\n    }\n    /**\n     * Uses the given vector to change the bounds of the given cell\n     * in the graph using {@link Graph#resizeCell}.\n     */\n    resizeCell(cell, dx, dy, index, gridEnabled, constrained, recurse) {\n        let geo = cell.getGeometry();\n        if (geo) {\n            if (index === InternalEvent.LABEL_HANDLE &&\n                this.labelShape &&\n                this.labelShape.bounds) {\n                const alpha = -toRadians(this.state.style.rotation ?? 0);\n                const cos = Math.cos(alpha);\n                const sin = Math.sin(alpha);\n                const { scale } = this.graph.view;\n                const pt = getRotatedPoint(new Point(Math.round((this.labelShape.bounds.getCenterX() - this.startX) / scale), Math.round((this.labelShape.bounds.getCenterY() - this.startY) / scale)), cos, sin);\n                geo = geo.clone();\n                if (geo.offset == null) {\n                    geo.offset = pt;\n                }\n                else {\n                    geo.offset.x += pt.x;\n                    geo.offset.y += pt.y;\n                }\n                this.graph.model.setGeometry(cell, geo);\n            }\n            else if (this.unscaledBounds) {\n                const { scale } = this.graph.view;\n                if (this.childOffsetX !== 0 || this.childOffsetY !== 0) {\n                    this.moveChildren(cell, Math.round(this.childOffsetX / scale), Math.round(this.childOffsetY / scale));\n                }\n                this.graph.resizeCell(cell, this.unscaledBounds, recurse);\n            }\n        }\n    }\n    /**\n     * Moves the children of the given cell by the given vector.\n     */\n    moveChildren(cell, dx, dy) {\n        const model = this.graph.getDataModel();\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = cell.getChildAt(i);\n            let geo = child.getGeometry();\n            if (geo != null) {\n                geo = geo.clone();\n                geo.translate(dx, dy);\n                model.setGeometry(child, geo);\n            }\n        }\n    }\n    /**\n     * Returns the union of the given bounds and location for the specified\n     * handle index.\n     *\n     * To override this to limit the size of vertex via a minWidth/-Height style,\n     * the following code can be used.\n     *\n     * ```javascript\n     * let vertexHandlerUnion = union;\n     * union = (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)=>\n     * {\n     *   let result = vertexHandlerUnion.apply(this, arguments);\n     *\n     *   result.width = Math.max(result.width, mxUtils.getNumber(this.state.style, 'minWidth', 0));\n     *   result.height = Math.max(result.height, mxUtils.getNumber(this.state.style, 'minHeight', 0));\n     *\n     *   return result;\n     * };\n     * ```\n     *\n     * The minWidth/-Height style can then be used as follows:\n     *\n     * ```javascript\n     * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'minWidth=100;minHeight=100;');\n     * ```\n     *\n     * To override this to update the height for a wrapped text if the width of a vertex is\n     * changed, the following can be used.\n     *\n     * ```javascript\n     * let mxVertexHandlerUnion = union;\n     * union = (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)=>\n     * {\n     *   let result = mxVertexHandlerUnion.apply(this, arguments);\n     *   let s = this.state;\n     *\n     *   if (this.graph.isHtmlLabel(s.cell) && (index == 3 || index == 4) &&\n     *       s.text != null && s.style.whiteSpace == 'wrap')\n     *   {\n     *     let label = this.graph.getLabel(s.cell);\n     *     let fontSize = mxUtils.getNumber(s.style, 'fontSize', mxConstants.DEFAULT_FONTSIZE);\n     *     let ww = result.width / s.view.scale - s.text.spacingRight - s.text.spacingLeft\n     *\n     *     result.height = mxUtils.getSizeForString(label, fontSize, s.style.fontFamily, ww).height;\n     *   }\n     *\n     *   return result;\n     * };\n     * ```\n     */\n    union(bounds, dx, dy, index, gridEnabled, scale, tr, constrained, centered) {\n        gridEnabled = gridEnabled && this.graph.isGridEnabled();\n        if (this.singleSizer) {\n            let x = bounds.x + bounds.width + dx;\n            let y = bounds.y + bounds.height + dy;\n            if (gridEnabled) {\n                x = this.graph.snap(x / scale) * scale;\n                y = this.graph.snap(y / scale) * scale;\n            }\n            const rect = new Rectangle(bounds.x, bounds.y, 0, 0);\n            rect.add(new Rectangle(x, y, 0, 0));\n            return rect;\n        }\n        const w0 = bounds.width;\n        const h0 = bounds.height;\n        let left = bounds.x - tr.x * scale;\n        let right = left + w0;\n        let top = bounds.y - tr.y * scale;\n        let bottom = top + h0;\n        const cx = left + w0 / 2;\n        const cy = top + h0 / 2;\n        if (index > 4 /* Bottom Row */) {\n            bottom += dy;\n            if (gridEnabled) {\n                bottom = this.graph.snap(bottom / scale) * scale;\n            }\n            else {\n                bottom = Math.round(bottom / scale) * scale;\n            }\n        }\n        else if (index < 3 /* Top Row */) {\n            top += dy;\n            if (gridEnabled) {\n                top = this.graph.snap(top / scale) * scale;\n            }\n            else {\n                top = Math.round(top / scale) * scale;\n            }\n        }\n        if (index === 0 || index === 3 || index === 5 /* Left */) {\n            left += dx;\n            if (gridEnabled) {\n                left = this.graph.snap(left / scale) * scale;\n            }\n            else {\n                left = Math.round(left / scale) * scale;\n            }\n        }\n        else if (index === 2 || index === 4 || index === 7 /* Right */) {\n            right += dx;\n            if (gridEnabled) {\n                right = this.graph.snap(right / scale) * scale;\n            }\n            else {\n                right = Math.round(right / scale) * scale;\n            }\n        }\n        let width = right - left;\n        let height = bottom - top;\n        if (constrained) {\n            const geo = this.state.cell.getGeometry();\n            if (geo != null) {\n                const aspect = geo.width / geo.height;\n                if (index === 1 || index === 2 || index === 7 || index === 6) {\n                    width = height * aspect;\n                }\n                else {\n                    height = width / aspect;\n                }\n                if (index === 0) {\n                    left = right - width;\n                    top = bottom - height;\n                }\n            }\n        }\n        if (centered) {\n            width += width - w0;\n            height += height - h0;\n            const cdx = cx - (left + width / 2);\n            const cdy = cy - (top + height / 2);\n            left += cdx;\n            top += cdy;\n            right += cdx;\n            bottom += cdy;\n        }\n        // Flips over left side\n        if (width < 0) {\n            left += width;\n            width = Math.abs(width);\n        }\n        // Flips over top side\n        if (height < 0) {\n            top += height;\n            height = Math.abs(height);\n        }\n        const result = new Rectangle(left + tr.x * scale, top + tr.y * scale, width, height);\n        if (this.minBounds != null) {\n            result.width = Math.max(result.width, this.minBounds.x * scale +\n                this.minBounds.width * scale +\n                Math.max(0, this.x0 * scale - result.x));\n            result.height = Math.max(result.height, this.minBounds.y * scale +\n                this.minBounds.height * scale +\n                Math.max(0, this.y0 * scale - result.y));\n        }\n        return result;\n    }\n    /**\n     * Redraws the handles and the preview.\n     */\n    redraw(ignoreHandles) {\n        this.selectionBounds = this.getSelectionBounds(this.state);\n        this.bounds = new Rectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n        this.drawPreview();\n        if (!ignoreHandles) {\n            this.redrawHandles();\n        }\n    }\n    /**\n     * Returns the padding to be used for drawing handles for the current <bounds>.\n     */\n    getHandlePadding() {\n        // KNOWN: Tolerance depends on event type (eg. 0 for mouse events)\n        const result = new Point(0, 0);\n        let tol = this.tolerance;\n        if (this.sizers.length > 0 &&\n            this.sizers[0].bounds &&\n            (this.bounds.width < 2 * this.sizers[0].bounds.width + 2 * tol ||\n                this.bounds.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {\n            tol /= 2;\n            result.x = this.sizers[0].bounds.width + tol;\n            result.y = this.sizers[0].bounds.height + tol;\n        }\n        return result;\n    }\n    /**\n     * Returns the bounds used to paint the resize handles.\n     */\n    getSizerBounds() {\n        return this.bounds;\n    }\n    /**\n     * Redraws the handles. To hide certain handles the following code can be used.\n     *\n     * ```javascript\n     * redrawHandles()\n     * {\n     *   mxVertexHandlerRedrawHandles.apply(this, arguments);\n     *\n     *   if (this.sizers != null && this.sizers.length > 7)\n     *   {\n     *     this.sizers[1].node.style.display = 'none';\n     *     this.sizers[6].node.style.display = 'none';\n     *   }\n     * };\n     * ```\n     */\n    redrawHandles() {\n        let s = this.getSizerBounds();\n        const tol = this.tolerance;\n        this.horizontalOffset = 0;\n        this.verticalOffset = 0;\n        for (let i = 0; i < this.customHandles.length; i += 1) {\n            const shape = this.customHandles[i].shape;\n            if (shape) {\n                const temp = shape.node.style.display;\n                this.customHandles[i].redraw();\n                shape.node.style.display = temp;\n                // Hides custom handles during text editing\n                shape.node.style.visibility =\n                    this.handlesVisible && this.isCustomHandleVisible(this.customHandles[i])\n                        ? ''\n                        : 'hidden';\n            }\n        }\n        if (this.sizers.length > 0 && this.sizers[0]) {\n            if (this.index === null && this.manageSizers && this.sizers.length >= 8) {\n                // KNOWN: Tolerance depends on event type (eg. 0 for mouse events)\n                const padding = this.getHandlePadding();\n                this.horizontalOffset = padding.x;\n                this.verticalOffset = padding.y;\n                if (this.horizontalOffset !== 0 || this.verticalOffset !== 0) {\n                    s = new Rectangle(s.x, s.y, s.width, s.height);\n                    s.x -= this.horizontalOffset / 2;\n                    s.width += this.horizontalOffset;\n                    s.y -= this.verticalOffset / 2;\n                    s.height += this.verticalOffset;\n                }\n                if (this.sizers.length >= 8) {\n                    if (this.sizers[0].bounds &&\n                        (s.width < 2 * this.sizers[0].bounds.width + 2 * tol ||\n                            s.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {\n                        this.sizers[0].node.style.display = 'none';\n                        this.sizers[2].node.style.display = 'none';\n                        this.sizers[5].node.style.display = 'none';\n                        this.sizers[7].node.style.display = 'none';\n                    }\n                    else if (this.handlesVisible) {\n                        this.sizers[0].node.style.display = '';\n                        this.sizers[2].node.style.display = '';\n                        this.sizers[5].node.style.display = '';\n                        this.sizers[7].node.style.display = '';\n                    }\n                }\n            }\n            const r = s.x + s.width;\n            const b = s.y + s.height;\n            if (this.singleSizer) {\n                this.moveSizerTo(this.sizers[0], r, b);\n            }\n            else {\n                const cx = s.x + s.width / 2;\n                const cy = s.y + s.height / 2;\n                if (this.sizers.length >= 8) {\n                    const crs = [\n                        'nw-resize',\n                        'n-resize',\n                        'ne-resize',\n                        'e-resize',\n                        'se-resize',\n                        's-resize',\n                        'sw-resize',\n                        'w-resize',\n                    ];\n                    const alpha = toRadians(this.state.style.rotation ?? 0);\n                    const cos = Math.cos(alpha);\n                    const sin = Math.sin(alpha);\n                    const da = Math.round((alpha * 4) / Math.PI);\n                    const ct = new Point(s.getCenterX(), s.getCenterY());\n                    let pt = getRotatedPoint(new Point(s.x, s.y), cos, sin, ct);\n                    this.moveSizerTo(this.sizers[0], pt.x, pt.y);\n                    this.sizers[0].setCursor(crs[mod(0 + da, crs.length)]);\n                    pt.x = cx;\n                    pt.y = s.y;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[1], pt.x, pt.y);\n                    this.sizers[1].setCursor(crs[mod(1 + da, crs.length)]);\n                    pt.x = r;\n                    pt.y = s.y;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[2], pt.x, pt.y);\n                    this.sizers[2].setCursor(crs[mod(2 + da, crs.length)]);\n                    pt.x = s.x;\n                    pt.y = cy;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[3], pt.x, pt.y);\n                    this.sizers[3].setCursor(crs[mod(7 + da, crs.length)]);\n                    pt.x = r;\n                    pt.y = cy;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[4], pt.x, pt.y);\n                    this.sizers[4].setCursor(crs[mod(3 + da, crs.length)]);\n                    pt.x = s.x;\n                    pt.y = b;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[5], pt.x, pt.y);\n                    this.sizers[5].setCursor(crs[mod(6 + da, crs.length)]);\n                    pt.x = cx;\n                    pt.y = b;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[6], pt.x, pt.y);\n                    this.sizers[6].setCursor(crs[mod(5 + da, crs.length)]);\n                    pt.x = r;\n                    pt.y = b;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[7], pt.x, pt.y);\n                    this.sizers[7].setCursor(crs[mod(4 + da, crs.length)]);\n                    pt.x = cx + this.state.absoluteOffset.x;\n                    pt.y = cy + this.state.absoluteOffset.y;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[8], pt.x, pt.y);\n                }\n                else if (this.state.width >= 2 && this.state.height >= 2) {\n                    this.moveSizerTo(this.sizers[0], cx + this.state.absoluteOffset.x, cy + this.state.absoluteOffset.y);\n                }\n                else {\n                    this.moveSizerTo(this.sizers[0], this.state.x, this.state.y);\n                }\n            }\n        }\n        if (this.rotationShape) {\n            const alpha = toRadians(this.currentAlpha);\n            const cos = Math.cos(alpha);\n            const sin = Math.sin(alpha);\n            const ct = new Point(this.state.getCenterX(), this.state.getCenterY());\n            const pt = getRotatedPoint(this.getRotationHandlePosition(), cos, sin, ct);\n            if (this.rotationShape.node != null) {\n                this.moveSizerTo(this.rotationShape, pt.x, pt.y);\n                // Hides rotation handle during text editing\n                this.rotationShape.node.style.visibility =\n                    this.state.view.graph.isEditing() || !this.handlesVisible ? 'hidden' : '';\n            }\n        }\n        if (this.selectionBorder != null) {\n            this.selectionBorder.rotation = this.state.style.rotation ?? 0;\n        }\n        if (this.edgeHandlers != null) {\n            for (let i = 0; i < this.edgeHandlers.length; i += 1) {\n                this.edgeHandlers[i].redraw();\n            }\n        }\n    }\n    /**\n     * Returns true if the given custom handle is visible.\n     */\n    isCustomHandleVisible(handle) {\n        return (!this.graph.isEditing() && this.state.view.graph.getSelectionCount() === 1);\n    }\n    /**\n     * Returns an {@link Point} that defines the rotation handle position.\n     */\n    getRotationHandlePosition() {\n        return new Point(this.bounds.x + this.bounds.width / 2, this.bounds.y + this.rotationHandleVSpacing);\n    }\n    /**\n     * Returns `true` if the parent highlight should be visible.\n     *\n     * This implementation always returns `true`.\n     */\n    isParentHighlightVisible() {\n        const parent = this.state.cell.getParent();\n        return parent ? !this.graph.isCellSelected(parent) : false;\n    }\n    /**\n     * Updates the highlight of the parent if {@link parentHighlightEnabled} is `true`.\n     */\n    updateParentHighlight() {\n        if (!this.isDestroyed()) {\n            const visible = this.isParentHighlightVisible();\n            const parent = this.state.cell.getParent();\n            const pstate = parent ? this.graph.view.getState(parent) : null;\n            if (this.parentHighlight) {\n                if (parent && parent.isVertex() && visible) {\n                    const b = this.parentHighlight.bounds;\n                    if (pstate &&\n                        b &&\n                        (b.x !== pstate.x ||\n                            b.y !== pstate.y ||\n                            b.width !== pstate.width ||\n                            b.height !== pstate.height)) {\n                        this.parentHighlight.bounds = Rectangle.fromRectangle(pstate);\n                        this.parentHighlight.redraw();\n                    }\n                }\n                else {\n                    if (pstate != null && pstate.parentHighlight === this.parentHighlight) {\n                        pstate.parentHighlight = null;\n                    }\n                    this.parentHighlight.destroy();\n                    this.parentHighlight = null;\n                }\n            }\n            else if (this.parentHighlightEnabled && visible) {\n                if (parent &&\n                    parent.isVertex() &&\n                    pstate != null &&\n                    pstate.parentHighlight == null) {\n                    this.parentHighlight = this.createParentHighlightShape(pstate);\n                    // VML dialect required here for event transparency in IE\n                    this.parentHighlight.dialect = DIALECT.SVG;\n                    this.parentHighlight.pointerEvents = false;\n                    this.parentHighlight.rotation = pstate.style.rotation ?? 0;\n                    this.parentHighlight.init(this.graph.getView().getOverlayPane());\n                    this.parentHighlight.redraw();\n                    // Shows highlight once per parent\n                    pstate.parentHighlight = this.parentHighlight;\n                }\n            }\n        }\n    }\n    /**\n     * Redraws the preview.\n     */\n    drawPreview() {\n        if (this.preview != null) {\n            this.preview.bounds = this.bounds;\n            if (this.preview.node.parentNode === this.graph.container) {\n                this.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1);\n                this.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1);\n            }\n            this.preview.rotation = this.state.style.rotation ?? 0;\n            this.preview.redraw();\n        }\n        this.selectionBorder.bounds = this.getSelectionBorderBounds();\n        this.selectionBorder.redraw();\n        this.updateParentHighlight();\n    }\n    /**\n     * Returns the bounds for the selection border.\n     */\n    getSelectionBorderBounds() {\n        return this.bounds;\n    }\n    /**\n     * Returns `true` if this handler was destroyed or not initialized.\n     */\n    isDestroyed() {\n        return this.selectionBorder == null;\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    onDestroy() {\n        this.state.view.graph.removeListener(this.escapeHandler);\n        this.escapeHandler = () => {\n            return;\n        };\n        if (this.preview) {\n            this.preview.destroy();\n            this.preview = null;\n        }\n        if (this.parentHighlight) {\n            const parent = this.state.cell.getParent();\n            const pstate = parent ? this.graph.view.getState(parent) : null;\n            if (pstate && pstate.parentHighlight === this.parentHighlight) {\n                pstate.parentHighlight = null;\n            }\n            this.parentHighlight.destroy();\n            this.parentHighlight = null;\n        }\n        if (this.ghostPreview) {\n            this.ghostPreview.destroy();\n            this.ghostPreview = null;\n        }\n        if (this.selectionBorder) {\n            this.selectionBorder.destroy();\n        }\n        this.labelShape = null;\n        this.removeHint();\n        for (let i = 0; i < this.sizers.length; i += 1) {\n            this.sizers[i].destroy();\n        }\n        this.sizers = [];\n        for (let i = 0; i < this.customHandles.length; i += 1) {\n            this.customHandles[i].destroy();\n        }\n        this.customHandles = [];\n    }\n}\nexport default VertexHandler;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3946, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3952, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/handler/CellEditorHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { getValue } from '../../util/Utils';\nimport { getAlignmentAsPoint, setPrefixedStyle } from '../../util/styleUtils';\nimport Rectangle from '../geometry/Rectangle';\nimport InternalEvent from '../event/InternalEvent';\nimport Client from '../../Client';\nimport { ABSOLUTE_LINE_HEIGHT, ALIGN, DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, DEFAULT_TEXT_DIRECTION, DIALECT, FONT, LINE_HEIGHT, NONE, WORD_WRAP, } from '../../util/Constants';\nimport TextShape from '../geometry/node/TextShape';\nimport { clearSelection, extractTextWithWhitespace, isNode } from '../../util/domUtils';\nimport { getStringValue, htmlEntities, replaceTrailingNewlines, } from '../../util/StringUtils';\nimport { getSource, isConsumed, isControlDown, isMetaDown, isShiftDown, } from '../../util/EventUtils';\n/**\n * In-place editor for the graph. To control this editor, use\n * {@link Graph#invokesStopCellEditing}, {@link Graph#enterStopsCellEditing} and\n * {@link Graph#escapeEnabled}. If {@link Graph#enterStopsCellEditing} is true then\n * ctrl-enter or shift-enter can be used to create a linefeed. The F2 and\n * escape keys can always be used to stop editing.\n *\n * To customize the location of the textbox in the graph, override\n * <getEditorBounds> as follows:\n *\n * ```javascript\n * graph.cellEditor.getEditorBounds = (state)=>\n * {\n *   let result = getEditorBounds.apply(this, arguments);\n *\n *   if (this.graph.getDataModel().isEdge(state.cell))\n *   {\n *     result.x = state.getCenterX() - result.width / 2;\n *     result.y = state.getCenterY() - result.height / 2;\n *   }\n *\n *   return result;\n * };\n * ```\n *\n * Note that this hook is only called if <autoSize> is false. If <autoSize> is true,\n * then {@link Shape#getLabelBounds} is used to compute the current bounds of the textbox.\n *\n * The textarea uses the mxCellEditor CSS class. You can modify this class in\n * your custom CSS. Note: You should modify the CSS after loading the client\n * in the page.\n *\n * Example:\n *\n * To only allow numeric input in the in-place editor, use the following code.\n *\n * ```javascript\n * let text = graph.cellEditor.textarea;\n *\n * mxEvent.addListener(text, 'keydown', function (evt)\n * {\n *   if (!(evt.keyCode >= 48 && evt.keyCode <= 57) &&\n *       !(evt.keyCode >= 96 && evt.keyCode <= 105))\n *   {\n *     mxEvent.consume(evt);\n *   }\n * });\n * ```\n *\n * Placeholder:\n *\n * To implement a placeholder for cells without a label, use the\n * <emptyLabelText> variable.\n *\n * Resize in Chrome:\n *\n * Resize of the textarea is disabled by default. If you want to enable\n * this feature extend <init> and set this.textarea.style.resize = ''.\n *\n * To start editing on a key press event, the container of the graph\n * should have focus or a focusable parent should be used to add the\n * key press handler as follows.\n *\n * ```javascript\n * mxEvent.addListener(graph.container, 'keypress', mxUtils.bind(this, (evt)=>\n * {\n *   if (!graph.isEditing() && !graph.isSelectionEmpty() && evt.which !== 0 &&\n *       !mxEvent.isAltDown(evt) && !mxEvent.isControlDown(evt) && !mxEvent.isMetaDown(evt))\n *   {\n *     graph.startEditing();\n *\n *     if (Client.IS_FF)\n *     {\n *       graph.cellEditor.textarea.value = String.fromCharCode(evt.which);\n *     }\n *   }\n * }));\n * ```\n *\n * To allow focus for a DIV, and hence to receive key press events, some browsers\n * require it to have a valid tabindex attribute. In this case the following\n * code may be used to keep the container focused.\n *\n * ```javascript\n * let graphFireMouseEvent = graph.fireMouseEvent;\n * graph.fireMouseEvent = (evtName, me, sender)=>\n * {\n *   if (evtName == mxEvent.MOUSE_DOWN)\n *   {\n *     this.container.focus();\n *   }\n *\n *   graphFireMouseEvent.apply(this, arguments);\n * };\n * ```\n *\n * @category Plugin\n */\nclass CellEditorHandler {\n    constructor(graph) {\n        this.clearOnChange = false;\n        this.bounds = null;\n        this.resizeThread = null;\n        this.textDirection = null;\n        /**\n         * Holds the DIV that is used for text editing. Note that this may be null before the first\n         * edit. Instantiated in <init>.\n         */\n        this.textarea = null;\n        /**\n         * Reference to the <Cell> that is currently being edited.\n         */\n        // editingCell: mxCell;\n        this.editingCell = null;\n        /**\n         * Reference to the event that was used to start editing.\n         */\n        // trigger: MouseEvent;\n        this.trigger = null;\n        /**\n         * Specifies if the label has been modified.\n         */\n        // modified: boolean;\n        this.modified = false;\n        /**\n         * Specifies if the textarea should be resized while the text is being edited.\n         * Default is true.\n         */\n        // autoSize: boolean;\n        this.autoSize = true;\n        /**\n         * Specifies if the text should be selected when editing starts. Default is\n         * true.\n         */\n        // selectText: boolean;\n        this.selectText = true;\n        /**\n         * Text to be displayed for empty labels. Default is '' or '<br>' in Firefox as\n         * a workaround for the missing cursor bug for empty content editable. This can\n         * be set to eg. \"[Type Here]\" to easier visualize editing of empty labels. The\n         * value is only displayed before the first keystroke and is never used as the\n         * actual editing value.\n         */\n        // emptyLabelText: '<br>' | '';\n        this.emptyLabelText = Client.IS_FF ? '<br>' : '';\n        /**\n         * If true, pressing the escape key will stop editing and not accept the new\n         * value. Change this to false to accept the new value on escape, and cancel\n         * editing on Shift+Escape instead. Default is true.\n         */\n        // escapeCancelsEditing: boolean;\n        this.escapeCancelsEditing = true;\n        /**\n         * Reference to the label DOM node that has been hidden.\n         */\n        // textNode: string;\n        this.textNode = null;\n        /**\n         * Specifies the zIndex for the textarea. Default is 5.\n         */\n        // zIndex: number;\n        this.zIndex = 5;\n        /**\n         * Defines the minimum width and height to be used in <resize>. Default is 0x20px.\n         */\n        // minResize: mxRectangle;\n        this.minResize = new Rectangle(0, 20);\n        /**\n         * Correction factor for word wrapping width. Default is 2 in quirks, 0 in IE\n         * 11 and 1 in all other browsers and modes.\n         */\n        // wordWrapPadding: 2 | 1 | 0;\n        this.wordWrapPadding = 0;\n        /**\n         * If <focusLost> should be called if <textarea> loses the focus. Default is false.\n         */\n        // blurEnabled: boolean;\n        this.blurEnabled = false;\n        /**\n         * Holds the initial editing value to check if the current value was modified.\n         */\n        // initialValue: string;\n        this.initialValue = null;\n        /**\n         * Holds the current temporary horizontal alignment for the cell style. If this\n         * is modified then the current text alignment is changed and the cell style is\n         * updated when the value is applied.\n         */\n        this.align = null;\n        this.graph = graph;\n        // Stops editing after zoom changes\n        this.zoomHandler = () => {\n            if (this.graph.isEditing()) {\n                this.resize();\n            }\n        };\n        // Handling of deleted cells while editing\n        this.changeHandler = (sender) => {\n            if (this.editingCell && !this.graph.getView().getState(this.editingCell, false)) {\n                this.stopEditing(true);\n            }\n        };\n        this.graph.getView().addListener(InternalEvent.SCALE, this.zoomHandler);\n        this.graph.getView().addListener(InternalEvent.SCALE_AND_TRANSLATE, this.zoomHandler);\n        this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.changeHandler);\n    }\n    /**\n     * Creates the <textarea> and installs the event listeners. The key handler\n     * updates the {@link odified} state.\n     */\n    init() {\n        this.textarea = document.createElement('div');\n        this.textarea.className = 'mxCellEditor mxPlainTextEditor';\n        this.textarea.contentEditable = String(true);\n        // Workaround for selection outside of DIV if height is 0\n        if (Client.IS_GC) {\n            this.textarea.style.minHeight = '1em';\n        }\n        this.textarea.style.position = 'absolute';\n        this.installListeners(this.textarea);\n    }\n    /**\n     * Called in <stopEditing> if cancel is false to invoke {@link Graph#labelChanged}.\n     */\n    // applyValue(state: CellState, value: string): void;\n    applyValue(state, value) {\n        this.graph.labelChanged(state.cell, value, this.trigger);\n    }\n    /**\n     * Sets the temporary horizontal alignment for the current editing session.\n     */\n    setAlign(align) {\n        if (this.textarea) {\n            this.textarea.style.textAlign = align;\n        }\n        this.align = align;\n        this.resize();\n    }\n    /**\n     * Gets the initial editing value for the given cell.\n     */\n    getInitialValue(state, trigger) {\n        let result = htmlEntities(this.graph.getEditingValue(state.cell, trigger), false);\n        result = replaceTrailingNewlines(result, '<div><br></div>');\n        return result.replace(/\\n/g, '<br>');\n    }\n    /**\n     * Returns the current editing value.\n     */\n    getCurrentValue(state) {\n        if (!this.textarea)\n            return null;\n        return extractTextWithWhitespace(Array.from(this.textarea.childNodes));\n    }\n    /**\n     * Returns true if <escapeCancelsEditing> is true and shift, control and meta\n     * are not pressed.\n     */\n    // isCancelEditingKeyEvent(evt: Event): boolean;\n    isCancelEditingKeyEvent(evt) {\n        return (this.escapeCancelsEditing ||\n            isShiftDown(evt) ||\n            isControlDown(evt) ||\n            isMetaDown(evt));\n    }\n    /**\n     * Installs listeners for focus, change and standard key event handling.\n     */\n    // installListeners(elt: Element): void;\n    installListeners(elt) {\n        // Applies value if text is dragged\n        // LATER: Gesture mouse events ignored for starting move\n        InternalEvent.addListener(elt, 'dragstart', (evt) => {\n            this.graph.stopEditing(false);\n            InternalEvent.consume(evt);\n        });\n        // Applies value if focus is lost\n        InternalEvent.addListener(elt, 'blur', (evt) => {\n            if (this.blurEnabled) {\n                this.focusLost();\n            }\n        });\n        // Updates modified state and handles placeholder text\n        InternalEvent.addListener(elt, 'keydown', (evt) => {\n            if (!isConsumed(evt)) {\n                if (this.isStopEditingEvent(evt)) {\n                    this.graph.stopEditing(false);\n                    InternalEvent.consume(evt);\n                }\n                else if (evt.keyCode === 27 /* Escape */) {\n                    this.graph.stopEditing(this.isCancelEditingKeyEvent(evt));\n                    InternalEvent.consume(evt);\n                }\n            }\n        });\n        // Keypress only fires if printable key was pressed and handles removing the empty placeholder\n        const keypressHandler = (evt) => {\n            if (this.editingCell != null) {\n                // Clears the initial empty label on the first keystroke\n                // and workaround for FF which fires keypress for delete and backspace\n                if (this.clearOnChange &&\n                    elt.innerHTML === this.getEmptyLabelText() &&\n                    (!Client.IS_FF ||\n                        (evt.keyCode !== 8 /* Backspace */ && evt.keyCode !== 46)) /* Delete */) {\n                    this.clearOnChange = false;\n                    elt.innerHTML = '';\n                }\n            }\n        };\n        InternalEvent.addListener(elt, 'keypress', keypressHandler);\n        InternalEvent.addListener(elt, 'paste', keypressHandler);\n        // Handler for updating the empty label text value after a change\n        const keyupHandler = (evt) => {\n            if (this.editingCell != null) {\n                // Uses an optional text value for sempty labels which is cleared\n                // when the first keystroke appears. This makes it easier to see\n                // that a label is being edited even if the label is empty.\n                // In Safari and FF, an empty text is represented by <BR> which isn't enough to force a valid size\n                const textarea = this.textarea;\n                if (textarea.innerHTML.length === 0 || textarea.innerHTML === '<br>') {\n                    textarea.innerHTML = this.getEmptyLabelText();\n                    this.clearOnChange = textarea.innerHTML.length > 0;\n                }\n                else {\n                    this.clearOnChange = false;\n                }\n            }\n        };\n        InternalEvent.addListener(elt, 'input', keyupHandler);\n        InternalEvent.addListener(elt, 'cut', keyupHandler);\n        InternalEvent.addListener(elt, 'paste', keyupHandler);\n        // Adds automatic resizing of the textbox while typing using input, keyup and/or DOM change events\n        const evtName = 'input';\n        const resizeHandler = (evt) => {\n            if (this.editingCell != null && this.autoSize && !isConsumed(evt)) {\n                // Asynchronous is needed for keydown and shows better results for input events overall\n                // (ie non-blocking and cases where the offsetWidth/-Height was wrong at this time)\n                if (this.resizeThread != null) {\n                    window.clearTimeout(this.resizeThread);\n                }\n                this.resizeThread = window.setTimeout(() => {\n                    this.resizeThread = null;\n                    this.resize();\n                }, 0);\n            }\n        };\n        InternalEvent.addListener(elt, evtName, resizeHandler);\n        InternalEvent.addListener(window, 'resize', resizeHandler);\n        InternalEvent.addListener(elt, 'cut', resizeHandler);\n        InternalEvent.addListener(elt, 'paste', resizeHandler);\n    }\n    /**\n     * Returns true if the given keydown event should stop cell editing. This\n     * returns true if F2 is pressed of if {@link Graph#enterStopsCellEditing} is true\n     * and enter is pressed without control or shift.\n     */\n    isStopEditingEvent(evt) {\n        return (evt.keyCode === 113 /* F2 */ ||\n            (this.graph.isEnterStopsCellEditing() &&\n                evt.keyCode === 13 /* Enter */ &&\n                !isControlDown(evt) &&\n                !isShiftDown(evt)));\n    }\n    /**\n     * Returns true if this editor is the source for the given native event.\n     */\n    isEventSource(evt) {\n        return getSource(evt) === this.textarea;\n    }\n    /**\n     * Returns {@link odified}.\n     */\n    resize() {\n        const state = this.editingCell\n            ? this.graph.getView().getState(this.editingCell)\n            : null;\n        if (!state) {\n            this.stopEditing(true);\n        }\n        else if (this.textarea != null) {\n            const isEdge = state.cell.isEdge();\n            const { scale } = this.graph.getView();\n            let m = null;\n            if (!this.autoSize || state.style.overflow === 'fill') {\n                // Specifies the bounds of the editor box\n                this.bounds = this.getEditorBounds(state);\n                this.textarea.style.width = `${Math.round(this.bounds.width / scale)}px`;\n                this.textarea.style.height = `${Math.round(this.bounds.height / scale)}px`;\n                // FIXME: Offset when scaled\n                this.textarea.style.left = `${Math.max(0, Math.round(this.bounds.x + 1))}px`;\n                this.textarea.style.top = `${Math.max(0, Math.round(this.bounds.y + 1))}px`;\n                // Installs native word wrapping and avoids word wrap for empty label placeholder\n                if (this.graph.isWrapping(state.cell) &&\n                    (this.bounds.width >= 2 || this.bounds.height >= 2) &&\n                    this.textarea.innerHTML !== this.getEmptyLabelText()) {\n                    this.textarea.style.wordWrap = WORD_WRAP;\n                    this.textarea.style.whiteSpace = 'normal';\n                    if (state.style.overflow !== 'fill') {\n                        this.textarea.style.width = `${Math.round(this.bounds.width / scale) + this.wordWrapPadding}px`;\n                    }\n                }\n                else {\n                    this.textarea.style.whiteSpace = 'nowrap';\n                    if (state.style.overflow !== 'fill') {\n                        this.textarea.style.width = '';\n                    }\n                }\n            }\n            else {\n                const lw = getValue(state.style, 'labelWidth', null);\n                m = state.text != null && this.align == null ? state.text.margin : null;\n                if (m == null) {\n                    m = getAlignmentAsPoint(this.align || getValue(state.style, 'align', ALIGN.CENTER), getValue(state.style, 'verticalAlign', ALIGN.MIDDLE));\n                }\n                if (isEdge) {\n                    this.bounds = new Rectangle(state.absoluteOffset.x, state.absoluteOffset.y, 0, 0);\n                    if (lw != null) {\n                        const tmp = (parseFloat(lw) + 2) * scale;\n                        this.bounds.width = tmp;\n                        this.bounds.x += m.x * tmp;\n                    }\n                }\n                else {\n                    let bounds = Rectangle.fromRectangle(state);\n                    let hpos = getValue(state.style, 'labelPosition', ALIGN.CENTER);\n                    let vpos = getValue(state.style, 'verticalLabelPosition', ALIGN.MIDDLE);\n                    bounds =\n                        state.shape != null && hpos === 'center' && vpos === 'middle'\n                            ? state.shape.getLabelBounds(bounds)\n                            : bounds;\n                    if (lw != null) {\n                        bounds.width = parseFloat(lw) * scale;\n                    }\n                    if (!state.view.graph.cellRenderer.legacySpacing ||\n                        state.style.overflow !== 'width') {\n                        // @ts-ignore\n                        const dummy = new TextShape(); // FIXME!!!! ===================================================================================================\n                        const spacing = (state.style.spacing ?? 2) * scale;\n                        const spacingTop = ((state.style.spacingTop ?? 0) + dummy.baseSpacingTop) * scale + spacing;\n                        const spacingRight = ((state.style.spacingRight ?? 0) + dummy.baseSpacingRight) * scale +\n                            spacing;\n                        const spacingBottom = ((state.style.spacingBottom ?? 0) + dummy.baseSpacingBottom) * scale +\n                            spacing;\n                        const spacingLeft = ((state.style.spacingLeft ?? 0) + dummy.baseSpacingLeft) * scale + spacing;\n                        hpos =\n                            state.style.labelPosition != null ? state.style.labelPosition : 'center';\n                        vpos =\n                            state.style.verticalLabelPosition != null\n                                ? state.style.verticalLabelPosition\n                                : 'middle';\n                        bounds = new Rectangle(bounds.x + spacingLeft, bounds.y + spacingTop, bounds.width -\n                            (hpos === ALIGN.CENTER && lw == null ? spacingLeft + spacingRight : 0), bounds.height - (vpos === ALIGN.MIDDLE ? spacingTop + spacingBottom : 0));\n                    }\n                    this.bounds = new Rectangle(bounds.x + state.absoluteOffset.x, bounds.y + state.absoluteOffset.y, bounds.width, bounds.height);\n                }\n                // Needed for word wrap inside text blocks with oversize lines to match the final result where\n                // the width of the longest line is used as the reference for text alignment in the cell\n                // TODO: Fix word wrapping preview for edge labels in helloworld.html\n                if (this.graph.isWrapping(state.cell) &&\n                    (this.bounds.width >= 2 || this.bounds.height >= 2) &&\n                    this.textarea.innerHTML !== this.getEmptyLabelText()) {\n                    this.textarea.style.wordWrap = WORD_WRAP;\n                    this.textarea.style.whiteSpace = 'normal';\n                    // Forces automatic reflow if text is removed from an oversize label and normal word wrap\n                    const tmp = Math.round(this.bounds.width / scale) + this.wordWrapPadding;\n                    if (this.textarea.style.position !== 'relative') {\n                        this.textarea.style.width = `${tmp}px`;\n                        if (this.textarea.scrollWidth > tmp) {\n                            this.textarea.style.width = `${this.textarea.scrollWidth}px`;\n                        }\n                    }\n                    else {\n                        this.textarea.style.maxWidth = `${tmp}px`;\n                    }\n                }\n                else {\n                    // KNOWN: Trailing cursor in IE9 quirks mode is not visible\n                    this.textarea.style.whiteSpace = 'nowrap';\n                    this.textarea.style.width = '';\n                }\n                const ow = this.textarea.scrollWidth;\n                const oh = this.textarea.scrollHeight;\n                // TODO: Update CSS width and height if smaller than minResize or remove minResize\n                // if (this.minResize != null)\n                // {\n                //  ow = Math.max(ow, this.minResize.width);\n                //  oh = Math.max(oh, this.minResize.height);\n                // }\n                // LATER: Keep in visible area, add fine tuning for pixel precision\n                this.textarea.style.left = `${Math.max(0, Math.round(this.bounds.x - m.x * (this.bounds.width - 2)) + 1)}px`;\n                this.textarea.style.top = `${Math.max(0, Math.round(this.bounds.y - m.y * (this.bounds.height - 4) + (m.y === -1 ? 3 : 0)) + 1)}px`;\n            }\n            setPrefixedStyle(this.textarea.style, 'transformOrigin', '0px 0px');\n            setPrefixedStyle(this.textarea.style, 'transform', `scale(${scale},${scale})${m == null ? '' : ` translate(${m.x * 100}%,${m.y * 100}%)`}`);\n        }\n    }\n    /**\n     * Called if the textarea has lost focus.\n     */\n    focusLost() {\n        this.stopEditing(!this.graph.isInvokesStopCellEditing());\n    }\n    /**\n     * Returns the background color for the in-place editor. This implementation\n     * always returns NONE.\n     */\n    getBackgroundColor(state) {\n        return NONE;\n    }\n    /**\n     * Starts the editor for the given cell.\n     *\n     * @param cell <Cell> to start editing.\n     * @param trigger Optional mouse event that triggered the editor.\n     */\n    startEditing(cell, trigger = null) {\n        this.stopEditing(true);\n        this.align = null;\n        // Creates new textarea instance\n        if (this.textarea == null) {\n            this.init();\n        }\n        const tooltipHandler = this.graph.getPlugin('TooltipHandler');\n        tooltipHandler?.hideTooltip();\n        const state = this.graph.getView().getState(cell);\n        if (state) {\n            // Configures the style of the in-place editor\n            const { scale } = this.graph.getView();\n            const size = state.style.fontSize ?? DEFAULT_FONTSIZE;\n            const family = state.style.fontFamily ?? DEFAULT_FONTFAMILY;\n            const color = state.style.fontColor ?? 'black';\n            const align = state.style.align ?? ALIGN.LEFT;\n            const bold = (state.style.fontStyle || 0) & FONT.BOLD;\n            const italic = (state.style.fontStyle || 0) & FONT.ITALIC;\n            const txtDecor = [];\n            if ((state.style.fontStyle || 0) & FONT.UNDERLINE) {\n                txtDecor.push('underline');\n            }\n            if ((state.style.fontStyle || 0) & FONT.STRIKETHROUGH) {\n                txtDecor.push('line-through');\n            }\n            const textarea = this.textarea;\n            textarea.style.lineHeight = ABSOLUTE_LINE_HEIGHT\n                ? `${Math.round(size * LINE_HEIGHT)}px`\n                : String(LINE_HEIGHT);\n            textarea.style.backgroundColor = this.getBackgroundColor(state) || 'transparent';\n            textarea.style.textDecoration = txtDecor.join(' ');\n            textarea.style.fontWeight = bold ? 'bold' : 'normal';\n            textarea.style.fontStyle = italic ? 'italic' : '';\n            textarea.style.fontSize = `${Math.round(size)}px`;\n            textarea.style.zIndex = String(this.zIndex);\n            textarea.style.fontFamily = family;\n            textarea.style.textAlign = align;\n            textarea.style.outline = 'none';\n            textarea.style.color = color;\n            let dir = (this.textDirection =\n                state.style.textDirection ?? DEFAULT_TEXT_DIRECTION);\n            if (dir === 'auto') {\n                if (state.text !== null &&\n                    state.text.dialect !== DIALECT.STRICTHTML &&\n                    !isNode(state.text.value)) {\n                    dir = state.text.getAutoDirection();\n                }\n            }\n            if (dir === 'ltr' || dir === 'rtl') {\n                textarea.setAttribute('dir', dir);\n            }\n            else {\n                textarea.removeAttribute('dir');\n            }\n            // Sets the initial editing value\n            textarea.innerHTML = this.getInitialValue(state, trigger) || '';\n            this.initialValue = textarea.innerHTML;\n            // Uses an optional text value for empty labels which is cleared\n            // when the first keystroke appears. This makes it easier to see\n            // that a label is being edited even if the label is empty.\n            if (textarea.innerHTML.length === 0 || textarea.innerHTML === '<br>') {\n                textarea.innerHTML = this.getEmptyLabelText();\n                this.clearOnChange = true;\n            }\n            else {\n                this.clearOnChange = textarea.innerHTML === this.getEmptyLabelText();\n            }\n            // @ts-ignore\n            this.graph.container.appendChild(textarea);\n            // Update this after firing all potential events that could update the cleanOnChange flag\n            this.editingCell = cell;\n            this.trigger = trigger;\n            this.textNode = null;\n            if (state.text !== null && this.isHideLabel(state)) {\n                this.textNode = state.text.node;\n                this.textNode.style.visibility = 'hidden';\n            }\n            // Workaround for initial offsetHeight not ready for heading in markup\n            if (this.autoSize && (state.cell.isEdge() || state.style.overflow !== 'fill')) {\n                window.setTimeout(() => {\n                    this.resize();\n                }, 0);\n            }\n            this.resize();\n            // Workaround for NS_ERROR_FAILURE in FF\n            try {\n                // Prefers blinking cursor over no selected text if empty\n                textarea.focus();\n                if (this.isSelectText() &&\n                    textarea.innerHTML.length > 0 &&\n                    (textarea.innerHTML !== this.getEmptyLabelText() || !this.clearOnChange)) {\n                    document.execCommand('selectAll', false);\n                }\n            }\n            catch (e) {\n                // ignore\n            }\n        }\n    }\n    /**\n     * Returns <selectText>.\n     */\n    isSelectText() {\n        return this.selectText;\n    }\n    /**\n    clearSelection() {\n      const selection = window.getSelection();\n  \n      if (selection) {\n        if (selection.empty) {\n          selection.empty();\n        } else if (selection.removeAllRanges) {\n          selection.removeAllRanges();\n        }\n      }\n    }\n  \n    /**\n     * Stops the editor and applies the value if cancel is false.\n     */\n    stopEditing(cancel = false) {\n        if (this.editingCell) {\n            if (this.textNode) {\n                this.textNode.style.visibility = 'visible';\n                this.textNode = null;\n            }\n            const state = !cancel ? this.graph.view.getState(this.editingCell) : null;\n            const textarea = this.textarea;\n            const initial = this.initialValue;\n            this.initialValue = null;\n            this.editingCell = null;\n            this.bounds = null;\n            textarea.blur();\n            clearSelection();\n            if (textarea.parentNode) {\n                textarea.parentNode.removeChild(textarea);\n            }\n            if (this.clearOnChange && textarea.innerHTML === this.getEmptyLabelText()) {\n                textarea.innerHTML = '';\n                this.clearOnChange = false;\n            }\n            if (state && (textarea.innerHTML !== initial || this.align !== null)) {\n                this.prepareTextarea();\n                const value = this.getCurrentValue(state);\n                this.graph.batchUpdate(() => {\n                    if (value !== null) {\n                        this.applyValue(state, value);\n                    }\n                    if (this.align !== null) {\n                        this.graph.setCellStyles('align', this.align, [state.cell]);\n                    }\n                });\n            }\n            this.trigger = null;\n            // Forces new instance on next edit for undo history reset\n            if (this.textarea)\n                InternalEvent.release(this.textarea);\n            this.textarea = null;\n            this.align = null;\n        }\n    }\n    /**\n     * Prepares the textarea for getting its value in <stopEditing>.\n     * This implementation removes the extra trailing linefeed in Firefox.\n     */\n    prepareTextarea() {\n        const textarea = this.textarea;\n        if (textarea.lastChild && textarea.lastChild.nodeName === 'BR') {\n            textarea.removeChild(textarea.lastChild);\n        }\n    }\n    /**\n     * Returns true if the label should be hidden while the cell is being\n     * edited.\n     */\n    isHideLabel(state = null) {\n        return true;\n    }\n    /**\n     * Returns the minimum width and height for editing the given state.\n     */\n    getMinimumSize(state) {\n        const { scale } = this.graph.getView();\n        const textarea = this.textarea;\n        return new Rectangle(0, 0, state.text === null ? 30 : state.text.size * scale + 20, textarea.style.textAlign === 'left' ? 120 : 40);\n    }\n    /**\n     * Returns the {@link Rectangle} that defines the bounds of the editor.\n     */\n    getEditorBounds(state) {\n        const isEdge = state.cell.isEdge();\n        const { scale } = this.graph.getView();\n        const minSize = this.getMinimumSize(state);\n        const minWidth = minSize.width;\n        const minHeight = minSize.height;\n        let result = null;\n        if (!isEdge &&\n            state.view.graph.cellRenderer.legacySpacing &&\n            state.style.overflow === 'fill') {\n            result = state.shape.getLabelBounds(Rectangle.fromRectangle(state));\n        }\n        else {\n            // @ts-ignore\n            const dummy = new TextShape(); // FIXME!!!! ===================================================================================================\n            const spacing = (state.style.spacing ?? 0) * scale;\n            const spacingTop = ((state.style.spacingTop ?? 0) + dummy.baseSpacingTop) * scale + spacing;\n            const spacingRight = ((state.style.spacingRight ?? 0) + dummy.baseSpacingRight) * scale + spacing;\n            const spacingBottom = ((state.style.spacingBottom ?? 0) + dummy.baseSpacingBottom) * scale + spacing;\n            const spacingLeft = ((state.style.spacingLeft ?? 0) + dummy.baseSpacingLeft) * scale + spacing;\n            result = new Rectangle(state.x, state.y, Math.max(minWidth, state.width - spacingLeft - spacingRight), Math.max(minHeight, state.height - spacingTop - spacingBottom));\n            const hpos = state.style.labelPosition != null ? state.style.labelPosition : 'center';\n            const vpos = state.style.verticalLabelPosition != null\n                ? state.style.verticalLabelPosition\n                : 'middle';\n            result =\n                state.shape != null && hpos === 'center' && vpos === 'middle'\n                    ? state.shape.getLabelBounds(result)\n                    : result;\n            if (isEdge) {\n                result.x = state.absoluteOffset.x;\n                result.y = state.absoluteOffset.y;\n                if (state.text != null && state.text.boundingBox != null) {\n                    // Workaround for label containing just spaces in which case\n                    // the bounding box location contains negative numbers\n                    if (state.text.boundingBox.x > 0) {\n                        result.x = state.text.boundingBox.x;\n                    }\n                    if (state.text.boundingBox.y > 0) {\n                        result.y = state.text.boundingBox.y;\n                    }\n                }\n            }\n            else if (state.text != null && state.text.boundingBox != null) {\n                result.x = Math.min(result.x, state.text.boundingBox.x);\n                result.y = Math.min(result.y, state.text.boundingBox.y);\n            }\n            result.x += spacingLeft;\n            result.y += spacingTop;\n            if (state.text != null && state.text.boundingBox != null) {\n                if (!isEdge) {\n                    result.width = Math.max(result.width, state.text.boundingBox.width);\n                    result.height = Math.max(result.height, state.text.boundingBox.height);\n                }\n                else {\n                    result.width = Math.max(minWidth, state.text.boundingBox.width);\n                    result.height = Math.max(minHeight, state.text.boundingBox.height);\n                }\n            }\n            // Applies the horizontal and vertical label positions\n            if (state.cell.isVertex()) {\n                const horizontal = (getStringValue(state.style, 'labelPosition', ALIGN.CENTER));\n                if (horizontal === 'left') {\n                    result.x -= state.width;\n                }\n                else if (horizontal === 'right') {\n                    result.x += state.width;\n                }\n                const vertical = state.style.verticalLabelPosition != null\n                    ? state.style.verticalLabelPosition\n                    : 'middle';\n                if (vertical === 'top') {\n                    result.y -= state.height;\n                }\n                else if (vertical === 'bottom') {\n                    result.y += state.height;\n                }\n            }\n        }\n        return new Rectangle(Math.round(result.x), Math.round(result.y), Math.round(result.width), Math.round(result.height));\n    }\n    /**\n     * Returns the initial label value to be used of the label of the given\n     * cell is empty. This label is displayed and cleared on the first keystroke.\n     * This implementation returns <emptyLabelText>.\n     *\n     * @param cell <Cell> for which a text for an empty editing box should be\n     * returned.\n     */\n    getEmptyLabelText(cell = null) {\n        return this.emptyLabelText ?? '';\n    }\n    /**\n     * Returns the cell that is currently being edited or null if no cell is\n     * being edited.\n     */\n    getEditingCell() {\n        return this.editingCell;\n    }\n    /**\n     * Destroys the editor and removes all associated resources.\n     */\n    onDestroy() {\n        if (this.textarea) {\n            InternalEvent.release(this.textarea);\n            if (this.textarea.parentNode) {\n                this.textarea.parentNode.removeChild(this.textarea);\n            }\n            this.textarea = null;\n        }\n        this.graph.getDataModel().removeListener(this.changeHandler);\n        this.graph.getView().removeListener(this.zoomHandler);\n    }\n}\nCellEditorHandler.pluginId = 'CellEditorHandler';\nexport default CellEditorHandler;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4716, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4722, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/handler/TooltipHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalEvent from '../event/InternalEvent';\nimport { fit, getScrollOrigin } from '../../util/styleUtils';\nimport { TOOLTIP_VERTICAL_OFFSET } from '../../util/Constants';\nimport { getSource, isMouseEvent } from '../../util/EventUtils';\nimport { isNode } from '../../util/domUtils';\n/**\n * Graph event handler that displays tooltips.\n *\n * {@link Graph#getTooltip} is used to get the tooltip for a cell or handle.\n *\n * This handler is generally enabled using {@link Graph#setTooltips}.\n *\n * @category Plugin\n */\nclass TooltipHandler {\n    /**\n     * Constructs an event handler that displays tooltips.\n     *\n     * @param graph Reference to the enclosing {@link Graph}.\n     */\n    constructor(graph) {\n        /**\n         * Specifies the zIndex for the tooltip and its shadow.\n         * @default 10005\n         */\n        this.zIndex = 10005;\n        /**\n         * Delay to show the tooltip in milliseconds.\n         * @default 500\n         */\n        this.delay = 500;\n        /**\n         * Specifies if touch and pen events should be ignored.\n         * @default true\n         */\n        this.ignoreTouchEvents = true;\n        /**\n         * Specifies if the tooltip should be hidden if the mouse is moved over the current cell.\n         * @default false\n         */\n        this.hideOnHover = false;\n        /**\n         * `true` if this handler was destroyed using {@link onDestroy}.\n         */\n        this.destroyed = false;\n        this.lastX = 0;\n        this.lastY = 0;\n        this.state = null;\n        this.stateSource = false;\n        this.thread = null;\n        /**\n         * Specifies if events are handled.\n         * @default false\n         */\n        this.enabled = false;\n        this.graph = graph;\n        this.graph.addMouseListener(this);\n        this.div = document.createElement('div');\n        this.div.className = 'mxTooltip';\n        this.div.style.visibility = 'hidden';\n        document.body.appendChild(this.div);\n        InternalEvent.addGestureListeners(this.div, (evt) => {\n            const source = getSource(evt);\n            // @ts-ignore nodeName may exist\n            if (source && source.nodeName !== 'A') {\n                this.hideTooltip();\n            }\n        });\n        // Hides tooltips and resets tooltip timer if mouse leaves container\n        InternalEvent.addListener(this.graph.getContainer(), 'mouseleave', (evt) => {\n            if (this.div !== evt.relatedTarget) {\n                this.hide();\n            }\n        });\n    }\n    /**\n     * Returns `true` if events are handled.\n     *\n     * This implementation returns {@link enabled}.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling.\n     *\n     * This implementation updates {@link enabled}.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Returns {@link hideOnHover}.\n     */\n    isHideOnHover() {\n        return this.hideOnHover;\n    }\n    /**\n     * Sets <hideOnHover>.\n     */\n    setHideOnHover(value) {\n        this.hideOnHover = value;\n    }\n    /**\n     * Returns the <CellState> to be used for showing a tooltip for this event.\n     */\n    getStateForEvent(me) {\n        return me.getState();\n    }\n    /**\n     * Handles the event by initiating a rubberband selection. By consuming the\n     * event all subsequent events of the gesture are redirected to this\n     * handler.\n     */\n    mouseDown(sender, me) {\n        this.reset(me, false);\n        this.hideTooltip();\n    }\n    /**\n     * Handles the event by updating the rubberband selection.\n     */\n    mouseMove(sender, me) {\n        if (me.getX() !== this.lastX || me.getY() !== this.lastY) {\n            this.reset(me, true);\n            const state = this.getStateForEvent(me);\n            if (this.isHideOnHover() ||\n                state !== this.state ||\n                (me.getSource() !== this.node &&\n                    (!this.stateSource ||\n                        (state != null &&\n                            this.stateSource ===\n                                (me.isSource(state.shape) || !me.isSource(state.text)))))) {\n                this.hideTooltip();\n            }\n        }\n        this.lastX = me.getX();\n        this.lastY = me.getY();\n    }\n    /**\n     * Handles the event by resetting the tooltip timer or hiding the existing\n     * tooltip.\n     */\n    mouseUp(sender, me) {\n        this.reset(me, true);\n        this.hideTooltip();\n    }\n    /**\n     * Resets the timer.\n     */\n    resetTimer() {\n        if (this.thread) {\n            window.clearTimeout(this.thread);\n            this.thread = null;\n        }\n    }\n    /**\n     * Resets and/or restarts the timer to trigger the display of the tooltip.\n     */\n    reset(me, restart, state = null) {\n        if (!this.ignoreTouchEvents || isMouseEvent(me.getEvent())) {\n            this.resetTimer();\n            state = state ?? this.getStateForEvent(me);\n            if (restart &&\n                this.isEnabled() &&\n                state &&\n                this.div.style.visibility === 'hidden') {\n                const node = me.getSource();\n                const x = me.getX();\n                const y = me.getY();\n                const stateSource = me.isSource(state.shape) || me.isSource(state.text);\n                const popupMenuHandler = this.graph.getPlugin('PopupMenuHandler');\n                this.thread = window.setTimeout(() => {\n                    if (state &&\n                        node &&\n                        !this.graph.isEditing() &&\n                        popupMenuHandler &&\n                        !popupMenuHandler.isMenuShowing() &&\n                        !this.graph.isMouseDown) {\n                        // Uses information from inside event cause using the event at\n                        // this (delayed) point in time is not possible in IE as it no\n                        // longer contains the required information (member not found)\n                        const tip = this.graph.getTooltip(state, node, x, y);\n                        this.show(tip, x, y);\n                        this.state = state;\n                        this.node = node;\n                        this.stateSource = stateSource;\n                    }\n                }, this.delay);\n            }\n        }\n    }\n    /**\n     * Hides the tooltip and resets the timer.\n     */\n    hide() {\n        this.resetTimer();\n        this.hideTooltip();\n    }\n    /**\n     * Hides the tooltip.\n     */\n    hideTooltip() {\n        this.div.style.visibility = 'hidden';\n        this.div.innerHTML = '';\n    }\n    /**\n     * Shows the tooltip for the specified cell and optional index at the\n     * specified location (with a vertical offset of 10 pixels).\n     */\n    show(tip, x, y) {\n        if (!this.destroyed && tip && tip !== '') {\n            const origin = getScrollOrigin();\n            this.div.style.zIndex = String(this.zIndex);\n            this.div.style.left = `${x + origin.x}px`;\n            this.div.style.top = `${y + TOOLTIP_VERTICAL_OFFSET + origin.y}px`;\n            if (!isNode(tip)) {\n                this.div.innerHTML = tip.replace(/\\n/g, '<br>');\n            }\n            else {\n                this.div.innerHTML = '';\n                this.div.appendChild(tip);\n            }\n            this.div.style.visibility = '';\n            fit(this.div);\n        }\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    onDestroy() {\n        if (!this.destroyed) {\n            this.graph.removeMouseListener(this);\n            InternalEvent.release(this.div);\n            if (this.div.parentNode) {\n                this.div.parentNode.removeChild(this.div);\n            }\n            this.destroyed = true;\n        }\n    }\n}\nTooltipHandler.pluginId = 'TooltipHandler';\nexport default TooltipHandler;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AACA;AAGA;AAFA;AACA;AAEA;;;;;;AACA;;;;;;;;CAQC,GACD,MAAM;IACF;;;;KAIC,GACD,YAAY,KAAK,CAAE;QACf;;;SAGC,GACD,IAAI,CAAC,MAAM,GAAG;QACd;;;SAGC,GACD,IAAI,CAAC,KAAK,GAAG;QACb;;;SAGC,GACD,IAAI,CAAC,iBAAiB,GAAG;QACzB;;;SAGC,GACD,IAAI,CAAC,WAAW,GAAG;QACnB;;SAEC,GACD,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,MAAM,GAAG;QACd;;;SAGC,GACD,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,IAAI;QAChC,IAAI,CAAC,GAAG,GAAG,SAAS,aAAa,CAAC;QAClC,IAAI,CAAC,GAAG,CAAC,SAAS,GAAG;QACrB,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,UAAU,GAAG;QAC5B,SAAS,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG;QAClC,2KAAA,CAAA,UAAa,CAAC,mBAAmB,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;YACzC,MAAM,SAAS,CAAA,GAAA,+JAAA,CAAA,YAAS,AAAD,EAAE;YACzB,gCAAgC;YAChC,IAAI,UAAU,OAAO,QAAQ,KAAK,KAAK;gBACnC,IAAI,CAAC,WAAW;YACpB;QACJ;QACA,oEAAoE;QACpE,2KAAA,CAAA,UAAa,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,YAAY,IAAI,cAAc,CAAC;YAChE,IAAI,IAAI,CAAC,GAAG,KAAK,IAAI,aAAa,EAAE;gBAChC,IAAI,CAAC,IAAI;YACb;QACJ;IACJ;IACA;;;;KAIC,GACD,YAAY;QACR,OAAO,IAAI,CAAC,OAAO;IACvB;IACA;;;;KAIC,GACD,WAAW,OAAO,EAAE;QAChB,IAAI,CAAC,OAAO,GAAG;IACnB;IACA;;KAEC,GACD,gBAAgB;QACZ,OAAO,IAAI,CAAC,WAAW;IAC3B;IACA;;KAEC,GACD,eAAe,KAAK,EAAE;QAClB,IAAI,CAAC,WAAW,GAAG;IACvB;IACA;;KAEC,GACD,iBAAiB,EAAE,EAAE;QACjB,OAAO,GAAG,QAAQ;IACtB;IACA;;;;KAIC,GACD,UAAU,MAAM,EAAE,EAAE,EAAE;QAClB,IAAI,CAAC,KAAK,CAAC,IAAI;QACf,IAAI,CAAC,WAAW;IACpB;IACA;;KAEC,GACD,UAAU,MAAM,EAAE,EAAE,EAAE;QAClB,IAAI,GAAG,IAAI,OAAO,IAAI,CAAC,KAAK,IAAI,GAAG,IAAI,OAAO,IAAI,CAAC,KAAK,EAAE;YACtD,IAAI,CAAC,KAAK,CAAC,IAAI;YACf,MAAM,QAAQ,IAAI,CAAC,gBAAgB,CAAC;YACpC,IAAI,IAAI,CAAC,aAAa,MAClB,UAAU,IAAI,CAAC,KAAK,IACnB,GAAG,SAAS,OAAO,IAAI,CAAC,IAAI,IACzB,CAAC,CAAC,IAAI,CAAC,WAAW,IACb,SAAS,QACN,IAAI,CAAC,WAAW,KACZ,CAAC,GAAG,QAAQ,CAAC,MAAM,KAAK,KAAK,CAAC,GAAG,QAAQ,CAAC,MAAM,IAAI,CAAC,CAAE,GAAI;gBAC3E,IAAI,CAAC,WAAW;YACpB;QACJ;QACA,IAAI,CAAC,KAAK,GAAG,GAAG,IAAI;QACpB,IAAI,CAAC,KAAK,GAAG,GAAG,IAAI;IACxB;IACA;;;KAGC,GACD,QAAQ,MAAM,EAAE,EAAE,EAAE;QAChB,IAAI,CAAC,KAAK,CAAC,IAAI;QACf,IAAI,CAAC,WAAW;IACpB;IACA;;KAEC,GACD,aAAa;QACT,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,OAAO,YAAY,CAAC,IAAI,CAAC,MAAM;YAC/B,IAAI,CAAC,MAAM,GAAG;QAClB;IACJ;IACA;;KAEC,GACD,MAAM,EAAE,EAAE,OAAO,EAAE,QAAQ,IAAI,EAAE;QAC7B,IAAI,CAAC,IAAI,CAAC,iBAAiB,IAAI,CAAA,GAAA,+JAAA,CAAA,eAAY,AAAD,EAAE,GAAG,QAAQ,KAAK;YACxD,IAAI,CAAC,UAAU;YACf,QAAQ,SAAS,IAAI,CAAC,gBAAgB,CAAC;YACvC,IAAI,WACA,IAAI,CAAC,SAAS,MACd,SACA,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,UAAU,KAAK,UAAU;gBACxC,MAAM,OAAO,GAAG,SAAS;gBACzB,MAAM,IAAI,GAAG,IAAI;gBACjB,MAAM,IAAI,GAAG,IAAI;gBACjB,MAAM,cAAc,GAAG,QAAQ,CAAC,MAAM,KAAK,KAAK,GAAG,QAAQ,CAAC,MAAM,IAAI;gBACtE,MAAM,mBAAmB,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC;gBAC9C,IAAI,CAAC,MAAM,GAAG,OAAO,UAAU,CAAC;oBAC5B,IAAI,SACA,QACA,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,MACrB,oBACA,CAAC,iBAAiB,aAAa,MAC/B,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE;wBACzB,8DAA8D;wBAC9D,8DAA8D;wBAC9D,8DAA8D;wBAC9D,MAAM,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,OAAO,MAAM,GAAG;wBAClD,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG;wBAClB,IAAI,CAAC,KAAK,GAAG;wBACb,IAAI,CAAC,IAAI,GAAG;wBACZ,IAAI,CAAC,WAAW,GAAG;oBACvB;gBACJ,GAAG,IAAI,CAAC,KAAK;YACjB;QACJ;IACJ;IACA;;KAEC,GACD,OAAO;QACH,IAAI,CAAC,UAAU;QACf,IAAI,CAAC,WAAW;IACpB;IACA;;KAEC,GACD,cAAc;QACV,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,UAAU,GAAG;QAC5B,IAAI,CAAC,GAAG,CAAC,SAAS,GAAG;IACzB;IACA;;;KAGC,GACD,KAAK,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE;QACZ,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,OAAO,QAAQ,IAAI;YACtC,MAAM,SAAS,CAAA,GAAA,+JAAA,CAAA,kBAAe,AAAD;YAC7B,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,GAAG,OAAO,IAAI,CAAC,MAAM;YAC1C,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,GAAG,GAAG,IAAI,OAAO,CAAC,CAAC,EAAE,CAAC;YACzC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,IAAI,8JAAA,CAAA,0BAAuB,GAAG,OAAO,CAAC,CAAC,EAAE,CAAC;YAClE,IAAI,CAAC,CAAA,GAAA,6JAAA,CAAA,SAAM,AAAD,EAAE,MAAM;gBACd,IAAI,CAAC,GAAG,CAAC,SAAS,GAAG,IAAI,OAAO,CAAC,OAAO;YAC5C,OACK;gBACD,IAAI,CAAC,GAAG,CAAC,SAAS,GAAG;gBACrB,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC;YACzB;YACA,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,UAAU,GAAG;YAC5B,CAAA,GAAA,+JAAA,CAAA,MAAG,AAAD,EAAE,IAAI,CAAC,GAAG;QAChB;IACJ;IACA;;KAEC,GACD,YAAY;QACR,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACjB,IAAI,CAAC,KAAK,CAAC,mBAAmB,CAAC,IAAI;YACnC,2KAAA,CAAA,UAAa,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG;YAC9B,IAAI,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE;gBACrB,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG;YAC5C;YACA,IAAI,CAAC,SAAS,GAAG;QACrB;IACJ;AACJ;AACA,eAAe,QAAQ,GAAG;uCACX","ignoreList":[0]}},
    {"offset": {"line": 4951, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4957, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/handler/SelectionCellsHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from '../event/EventSource';\nimport Dictionary from '../../util/Dictionary';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { sortCells } from '../../util/styleUtils';\n/**\n * An event handler that manages cell handlers and invokes their mouse event\n * processing functions.\n *\n * Group: Events\n *\n * Event: mxEvent.ADD\n *\n * Fires if a cell has been added to the selection. The <code>state</code>\n * property contains the <CellState> that has been added.\n *\n * Event: mxEvent.REMOVE\n *\n * Fires if a cell has been remove from the selection. The <code>state</code>\n * property contains the <CellState> that has been removed.\n *\n * @category Plugin\n */\nclass SelectionCellsHandler extends EventSource {\n    constructor(graph) {\n        super();\n        /**\n         * Specifies if events are handled. Default is true.\n         */\n        this.enabled = true;\n        /**\n         * Defines the maximum number of handlers to paint individually. Default is 100.\n         */\n        this.maxHandlers = 100;\n        this.graph = graph;\n        this.handlers = new Dictionary();\n        this.graph.addMouseListener(this);\n        this.refreshHandler = (sender, evt) => {\n            if (this.isEnabled()) {\n                this.refresh();\n            }\n        };\n        this.graph.getSelectionModel().addListener(InternalEvent.CHANGE, this.refreshHandler);\n        this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.refreshHandler);\n        this.graph.getView().addListener(InternalEvent.SCALE, this.refreshHandler);\n        this.graph.getView().addListener(InternalEvent.TRANSLATE, this.refreshHandler);\n        this.graph\n            .getView()\n            .addListener(InternalEvent.SCALE_AND_TRANSLATE, this.refreshHandler);\n        this.graph.getView().addListener(InternalEvent.DOWN, this.refreshHandler);\n        this.graph.getView().addListener(InternalEvent.UP, this.refreshHandler);\n    }\n    /**\n     * Returns <enabled>.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Sets <enabled>.\n     */\n    setEnabled(value) {\n        this.enabled = value;\n    }\n    /**\n     * Returns the handler for the given cell.\n     */\n    getHandler(cell) {\n        return this.handlers.get(cell);\n    }\n    /**\n     * Returns true if the given cell has a handler.\n     */\n    isHandled(cell) {\n        return !!this.getHandler(cell);\n    }\n    /**\n     * Resets all handlers.\n     */\n    reset() {\n        this.handlers.visit((key, handler) => {\n            handler.reset.apply(handler);\n        });\n    }\n    /**\n     * Reloads or updates all handlers.\n     */\n    getHandledSelectionCells() {\n        return this.graph.getSelectionCells();\n    }\n    /**\n     * Reloads or updates all handlers.\n     */\n    refresh() {\n        // Removes all existing handlers\n        const oldHandlers = this.handlers;\n        this.handlers = new Dictionary();\n        // Creates handles for all selection cells\n        const tmp = sortCells(this.getHandledSelectionCells(), false);\n        // Destroys or updates old handlers\n        for (let i = 0; i < tmp.length; i += 1) {\n            const state = this.graph.view.getState(tmp[i]);\n            if (state) {\n                let handler = oldHandlers.remove(tmp[i]);\n                if (handler) {\n                    if (handler.state !== state) {\n                        handler.onDestroy();\n                        handler = null;\n                    }\n                    else if (!this.isHandlerActive(handler)) {\n                        // @ts-ignore refresh may exist\n                        if (handler.refresh)\n                            handler.refresh();\n                        handler.redraw();\n                    }\n                }\n                if (handler) {\n                    this.handlers.put(tmp[i], handler);\n                }\n            }\n        }\n        // Destroys unused handlers\n        oldHandlers.visit((key, handler) => {\n            this.fireEvent(new EventObject(InternalEvent.REMOVE, { state: handler.state }));\n            handler.onDestroy();\n        });\n        // Creates new handlers and updates parent highlight on existing handlers\n        for (let i = 0; i < tmp.length; i += 1) {\n            const state = this.graph.view.getState(tmp[i]);\n            if (state) {\n                let handler = this.handlers.get(tmp[i]);\n                if (!handler) {\n                    handler = this.graph.createHandler(state);\n                    this.fireEvent(new EventObject(InternalEvent.ADD, { state }));\n                    this.handlers.put(tmp[i], handler);\n                }\n                else {\n                    handler.updateParentHighlight();\n                }\n            }\n        }\n    }\n    /**\n     * Returns true if the given handler is active and should not be redrawn.\n     */\n    isHandlerActive(handler) {\n        return handler.index !== null;\n    }\n    /**\n     * Updates the handler for the given shape if one exists.\n     */\n    updateHandler(state) {\n        let handler = this.handlers.remove(state.cell);\n        if (handler) {\n            // Transfers the current state to the new handler\n            const { index } = handler;\n            const x = handler.startX;\n            const y = handler.startY;\n            handler.onDestroy();\n            handler = this.graph.createHandler(state);\n            if (handler) {\n                this.handlers.put(state.cell, handler);\n                if (index !== null) {\n                    handler.start(x, y, index);\n                }\n            }\n        }\n    }\n    /**\n     * Redirects the given event to the handlers.\n     */\n    mouseDown(sender, me) {\n        if (this.graph.isEnabled() && this.isEnabled()) {\n            this.handlers.visit((key, handler) => {\n                handler.mouseDown(sender, me);\n            });\n        }\n    }\n    /**\n     * Redirects the given event to the handlers.\n     */\n    mouseMove(sender, me) {\n        if (this.graph.isEnabled() && this.isEnabled()) {\n            this.handlers.visit((key, handler) => {\n                handler.mouseMove(sender, me);\n            });\n        }\n    }\n    /**\n     * Redirects the given event to the handlers.\n     */\n    mouseUp(sender, me) {\n        if (this.graph.isEnabled() && this.isEnabled()) {\n            this.handlers.visit((key, handler) => {\n                handler.mouseUp(sender, me);\n            });\n        }\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    onDestroy() {\n        this.graph.removeMouseListener(this);\n        this.graph.removeListener(this.refreshHandler);\n        this.graph.getDataModel().removeListener(this.refreshHandler);\n        this.graph.getView().removeListener(this.refreshHandler);\n    }\n}\nSelectionCellsHandler.pluginId = 'SelectionCellsHandler';\nexport default SelectionCellsHandler;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AAEA;AAEA;AACA;AAFA;AAFA;;;;;;AAKA;;;;;;;;;;;;;;;;;CAiBC,GACD,MAAM,8BAA8B,yKAAA,CAAA,UAAW;IAC3C,YAAY,KAAK,CAAE;QACf,KAAK;QACL;;SAEC,GACD,IAAI,CAAC,OAAO,GAAG;QACf;;SAEC,GACD,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,QAAQ,GAAG,IAAI,+JAAA,CAAA,UAAU;QAC9B,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,IAAI;QAChC,IAAI,CAAC,cAAc,GAAG,CAAC,QAAQ;YAC3B,IAAI,IAAI,CAAC,SAAS,IAAI;gBAClB,IAAI,CAAC,OAAO;YAChB;QACJ;QACA,IAAI,CAAC,KAAK,CAAC,iBAAiB,GAAG,WAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,MAAM,EAAE,IAAI,CAAC,cAAc;QACpF,IAAI,CAAC,KAAK,CAAC,YAAY,GAAG,WAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,MAAM,EAAE,IAAI,CAAC,cAAc;QAC/E,IAAI,CAAC,KAAK,CAAC,OAAO,GAAG,WAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,KAAK,EAAE,IAAI,CAAC,cAAc;QACzE,IAAI,CAAC,KAAK,CAAC,OAAO,GAAG,WAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,SAAS,EAAE,IAAI,CAAC,cAAc;QAC7E,IAAI,CAAC,KAAK,CACL,OAAO,GACP,WAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,mBAAmB,EAAE,IAAI,CAAC,cAAc;QACvE,IAAI,CAAC,KAAK,CAAC,OAAO,GAAG,WAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,IAAI,EAAE,IAAI,CAAC,cAAc;QACxE,IAAI,CAAC,KAAK,CAAC,OAAO,GAAG,WAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,EAAE,EAAE,IAAI,CAAC,cAAc;IAC1E;IACA;;KAEC,GACD,YAAY;QACR,OAAO,IAAI,CAAC,OAAO;IACvB;IACA;;KAEC,GACD,WAAW,KAAK,EAAE;QACd,IAAI,CAAC,OAAO,GAAG;IACnB;IACA;;KAEC,GACD,WAAW,IAAI,EAAE;QACb,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC;IAC7B;IACA;;KAEC,GACD,UAAU,IAAI,EAAE;QACZ,OAAO,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC;IAC7B;IACA;;KAEC,GACD,QAAQ;QACJ,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,KAAK;YACtB,QAAQ,KAAK,CAAC,KAAK,CAAC;QACxB;IACJ;IACA;;KAEC,GACD,2BAA2B;QACvB,OAAO,IAAI,CAAC,KAAK,CAAC,iBAAiB;IACvC;IACA;;KAEC,GACD,UAAU;QACN,gCAAgC;QAChC,MAAM,cAAc,IAAI,CAAC,QAAQ;QACjC,IAAI,CAAC,QAAQ,GAAG,IAAI,+JAAA,CAAA,UAAU;QAC9B,0CAA0C;QAC1C,MAAM,MAAM,CAAA,GAAA,+JAAA,CAAA,YAAS,AAAD,EAAE,IAAI,CAAC,wBAAwB,IAAI;QACvD,mCAAmC;QACnC,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,KAAK,EAAG;YACpC,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;YAC7C,IAAI,OAAO;gBACP,IAAI,UAAU,YAAY,MAAM,CAAC,GAAG,CAAC,EAAE;gBACvC,IAAI,SAAS;oBACT,IAAI,QAAQ,KAAK,KAAK,OAAO;wBACzB,QAAQ,SAAS;wBACjB,UAAU;oBACd,OACK,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU;wBACrC,+BAA+B;wBAC/B,IAAI,QAAQ,OAAO,EACf,QAAQ,OAAO;wBACnB,QAAQ,MAAM;oBAClB;gBACJ;gBACA,IAAI,SAAS;oBACT,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,EAAE;gBAC9B;YACJ;QACJ;QACA,2BAA2B;QAC3B,YAAY,KAAK,CAAC,CAAC,KAAK;YACpB,IAAI,CAAC,SAAS,CAAC,IAAI,yKAAA,CAAA,UAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,MAAM,EAAE;gBAAE,OAAO,QAAQ,KAAK;YAAC;YAC5E,QAAQ,SAAS;QACrB;QACA,yEAAyE;QACzE,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,KAAK,EAAG;YACpC,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;YAC7C,IAAI,OAAO;gBACP,IAAI,UAAU,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBACtC,IAAI,CAAC,SAAS;oBACV,UAAU,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC;oBACnC,IAAI,CAAC,SAAS,CAAC,IAAI,yKAAA,CAAA,UAAW,CAAC,2KAAA,CAAA,UAAa,CAAC,GAAG,EAAE;wBAAE;oBAAM;oBAC1D,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,EAAE;gBAC9B,OACK;oBACD,QAAQ,qBAAqB;gBACjC;YACJ;QACJ;IACJ;IACA;;KAEC,GACD,gBAAgB,OAAO,EAAE;QACrB,OAAO,QAAQ,KAAK,KAAK;IAC7B;IACA;;KAEC,GACD,cAAc,KAAK,EAAE;QACjB,IAAI,UAAU,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,IAAI;QAC7C,IAAI,SAAS;YACT,iDAAiD;YACjD,MAAM,EAAE,KAAK,EAAE,GAAG;YAClB,MAAM,IAAI,QAAQ,MAAM;YACxB,MAAM,IAAI,QAAQ,MAAM;YACxB,QAAQ,SAAS;YACjB,UAAU,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC;YACnC,IAAI,SAAS;gBACT,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,IAAI,EAAE;gBAC9B,IAAI,UAAU,MAAM;oBAChB,QAAQ,KAAK,CAAC,GAAG,GAAG;gBACxB;YACJ;QACJ;IACJ;IACA;;KAEC,GACD,UAAU,MAAM,EAAE,EAAE,EAAE;QAClB,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,MAAM,IAAI,CAAC,SAAS,IAAI;YAC5C,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,KAAK;gBACtB,QAAQ,SAAS,CAAC,QAAQ;YAC9B;QACJ;IACJ;IACA;;KAEC,GACD,UAAU,MAAM,EAAE,EAAE,EAAE;QAClB,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,MAAM,IAAI,CAAC,SAAS,IAAI;YAC5C,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,KAAK;gBACtB,QAAQ,SAAS,CAAC,QAAQ;YAC9B;QACJ;IACJ;IACA;;KAEC,GACD,QAAQ,MAAM,EAAE,EAAE,EAAE;QAChB,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,MAAM,IAAI,CAAC,SAAS,IAAI;YAC5C,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,KAAK;gBACtB,QAAQ,OAAO,CAAC,QAAQ;YAC5B;QACJ;IACJ;IACA;;KAEC,GACD,YAAY;QACR,IAAI,CAAC,KAAK,CAAC,mBAAmB,CAAC,IAAI;QACnC,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc;QAC7C,IAAI,CAAC,KAAK,CAAC,YAAY,GAAG,cAAc,CAAC,IAAI,CAAC,cAAc;QAC5D,IAAI,CAAC,KAAK,CAAC,OAAO,GAAG,cAAc,CAAC,IAAI,CAAC,cAAc;IAC3D;AACJ;AACA,sBAAsB,QAAQ,GAAG;uCAClB","ignoreList":[0]}},
    {"offset": {"line": 5174, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5180, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/handler/PopupMenuHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport MaxPopupMenu from '../../gui/MaxPopupMenu';\nimport InternalEvent from '../event/InternalEvent';\nimport { getScrollOrigin } from '../../util/styleUtils';\nimport { getMainEvent, isMultiTouchEvent } from '../../util/EventUtils';\n/**\n * Event handler that creates popupmenus.\n *\n * Relates to {@link MaxPopupMenu}.\n *\n * @category Plugin\n */\nclass PopupMenuHandler extends MaxPopupMenu {\n    constructor(graph) {\n        super();\n        this.inTolerance = false;\n        this.popupTrigger = false;\n        /**\n         * Specifies if cells should be selected if a popupmenu is displayed for\n         * them. Default is true.\n         */\n        this.selectOnPopup = true;\n        /**\n         * Specifies if cells should be deselected if a popupmenu is displayed for\n         * the diagram background. Default is true.\n         */\n        this.clearSelectionOnBackground = true;\n        /**\n         * X-coordinate of the mouse down event.\n         */\n        this.triggerX = null;\n        /**\n         * Y-coordinate of the mouse down event.\n         */\n        this.triggerY = null;\n        /**\n         * Screen X-coordinate of the mouse down event.\n         */\n        this.screenX = null;\n        /**\n         * Screen Y-coordinate of the mouse down event.\n         */\n        this.screenY = null;\n        this.graph = graph;\n        this.graph.addMouseListener(this);\n        // Does not show menu if any touch gestures take place after the trigger\n        this.gestureHandler = (sender, eo) => {\n            this.inTolerance = false;\n        };\n        this.graph.addListener(InternalEvent.GESTURE, this.gestureHandler);\n        this.init();\n    }\n    /**\n     * Initializes the shapes required for this vertex handler.\n     */\n    init() {\n        // Hides the tooltip if the mouse is over the context menu\n        InternalEvent.addGestureListeners(this.div, (evt) => {\n            const tooltipHandler = this.graph.getPlugin('TooltipHandler');\n            tooltipHandler?.hide();\n        });\n    }\n    /**\n     * Hook for returning if a cell should be selected for a given {@link MouseEvent}.\n     * This implementation returns <selectOnPopup>.\n     */\n    isSelectOnPopup(me) {\n        return this.selectOnPopup;\n    }\n    /**\n     * Handles the event by initiating the panning. By consuming the event all\n     * subsequent events of the gesture are redirected to this handler.\n     */\n    mouseDown(sender, me) {\n        if (this.isEnabled() && !isMultiTouchEvent(me.getEvent())) {\n            // Hides the popupmenu if is is being displayed\n            this.hideMenu();\n            this.triggerX = me.getGraphX();\n            this.triggerY = me.getGraphY();\n            this.screenX = getMainEvent(me.getEvent()).screenX;\n            this.screenY = getMainEvent(me.getEvent()).screenY;\n            this.popupTrigger = this.isPopupTrigger(me);\n            this.inTolerance = true;\n        }\n    }\n    /**\n     * Handles the event by updating the panning on the graph.\n     */\n    mouseMove(sender, me) {\n        // Popup trigger may change on mouseUp so ignore it\n        if (this.inTolerance && this.screenX != null && this.screenY != null) {\n            if (Math.abs(getMainEvent(me.getEvent()).screenX - this.screenX) >\n                this.graph.getEventTolerance() ||\n                Math.abs(getMainEvent(me.getEvent()).screenY - this.screenY) >\n                    this.graph.getEventTolerance()) {\n                this.inTolerance = false;\n            }\n        }\n    }\n    /**\n     * Handles the event by setting the translation on the view or showing the\n     * popupmenu.\n     */\n    mouseUp(sender, me) {\n        if (this.popupTrigger &&\n            this.inTolerance &&\n            this.triggerX != null &&\n            this.triggerY != null) {\n            const cell = this.getCellForPopupEvent(me);\n            // Selects the cell for which the context menu is being displayed\n            if (this.graph.isEnabled() &&\n                this.isSelectOnPopup(me) &&\n                cell != null &&\n                !this.graph.isCellSelected(cell)) {\n                this.graph.setSelectionCell(cell);\n            }\n            else if (this.clearSelectionOnBackground && cell == null) {\n                this.graph.clearSelection();\n            }\n            // Hides the tooltip if there is one\n            const tooltipHandler = this.graph.getPlugin('TooltipHandler');\n            tooltipHandler?.hide();\n            // Menu is shifted by 1 pixel so that the mouse up event\n            // is routed via the underlying shape instead of the DIV\n            const origin = getScrollOrigin();\n            this.popup(me.getX() + origin.x + 1, me.getY() + origin.y + 1, cell, me.getEvent());\n            me.consume();\n        }\n        this.popupTrigger = false;\n        this.inTolerance = false;\n    }\n    /**\n     * Hook to return the cell for the mouse up popup trigger handling.\n     */\n    getCellForPopupEvent(me) {\n        return me.getCell();\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    onDestroy() {\n        this.graph.removeMouseListener(this);\n        this.graph.removeListener(this.gestureHandler);\n        // Supercall\n        super.destroy();\n    }\n}\nPopupMenuHandler.pluginId = 'PopupMenuHandler';\nexport default PopupMenuHandler;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5327, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5333, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/handler/ConnectionHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2016, JGraph Ltd\nCopyright (c) 2006-2016, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Geometry from '../geometry/Geometry';\nimport Cell from '../cell/Cell';\nimport Point from '../geometry/Point';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { CURSOR, DEFAULT_HOTSPOT, DEFAULT_INVALID_COLOR, DEFAULT_VALID_COLOR, DIALECT, HIGHLIGHT_STROKEWIDTH, INVALID_COLOR, NONE, OUTLINE_HIGHLIGHT_COLOR, OUTLINE_HIGHLIGHT_STROKEWIDTH, TOOLTIP_VERTICAL_OFFSET, VALID_COLOR, } from '../../util/Constants';\nimport { getRotatedPoint, toRadians } from '../../util/mathUtils';\nimport { convertPoint, getOffset } from '../../util/styleUtils';\nimport InternalMouseEvent from '../event/InternalMouseEvent';\nimport ImageShape from '../geometry/node/ImageShape';\nimport CellMarker from '../cell/CellMarker';\nimport ConstraintHandler from './ConstraintHandler';\nimport PolylineShape from '../geometry/edge/PolylineShape';\nimport EventSource from '../event/EventSource';\nimport Rectangle from '../geometry/Rectangle';\nimport { GlobalConfig } from '../../util/config';\nimport { getClientX, getClientY, isAltDown, isConsumed, isShiftDown, } from '../../util/EventUtils';\n/**\n * Graph event handler that creates new connections.\n * Uses {@link CellMarker} for finding and highlighting the source and target vertices and {@link factoryMethod} to create the edge instance.\n *\n * This handler is enabled using {@link Graph.setConnectable}.\n *\n * Example:\n *\n * ```javascript\n * new ConnectionHandler(graph, (source, target, style)=>\n * {\n *   edge = new Cell('', new Geometry());\n *   edge.setEdge(true);\n *   edge.setStyle(style);\n *   edge.geometry.relative = true;\n *   return edge;\n * });\n * ```\n *\n * Here is an alternative solution that just sets a specific user object for new edges by overriding {@link insertEdge}.\n *\n * ```javascript\n * originalConnectionHandlerInsertEdge = connectionHandler.insertEdge;\n * connectionHandler.insertEdge = (parent, id, value, source, target, style) => {\n *   value = 'Test';\n *   return originalConnectionHandlerInsertEdge.apply(this, arguments);\n * };\n * ```\n *\n * ### Using images to trigger connections\n *\n * This handler uses {@link CellMarker} to find the source and target cell for\n * the new connection and creates a new edge using {@link connect}. The new edge is\n * created using {@link createEdge} which in turn uses {@link factoryMethod} or creates a\n * new default edge.\n *\n * The handler uses a \"highlight-paradigm\" for indicating if a cell is being\n * used as a source or target terminal, as seen in other diagramming products.\n * In order to allow both, moving and connecting cells at the same time,\n * {@link DEFAULT_HOTSPOT} is used in the handler to determine the hotspot\n * of a cell, that is, the region of the cell which is used to trigger a new\n * connection. The constant is a value between 0 and 1 that specifies the\n * amount of the width and height around the center to be used for the hotspot\n * of a cell and its default value is 0.5. In addition,\n * {@link MIN_HOTSPOT_SIZE} defines the minimum number of pixels for the\n * width and height of the hotspot.\n *\n * This solution, while standards compliant, may be somewhat confusing because\n * there is no visual indicator for the hotspot and the highlight is seen to\n * switch on and off while the mouse is being moved in and out. Furthermore,\n * this paradigm does not allow to create different connections depending on\n * the highlighted hotspot as there is only one hotspot per cell, and it\n * normally does not allow cells to be moved and connected at the same time as\n * there is no clear indication of the connectable area of the cell.\n *\n * To come across these issues, the handle has an additional {@link createIcons} hook\n * with a default implementation that allows to create one icon to be used to\n * trigger new connections. If this icon is specified, then new connections can\n * only be created if the image is clicked while the cell is being highlighted.\n * The {@link createIcons} hook may be overridden to create more than one\n * {@link ImageShape} for creating new connections, but the default implementation\n * supports one image and is used as follows:\n *\n * In order to display the \"connect image\" whenever the mouse is over the cell, an DEFAULT_HOTSPOT of 1 should be used:\n *\n * ```javascript\n * mxConstants.DEFAULT_HOTSPOT = 1;\n * ```\n *\n * In order to avoid confusion with the highlighting, the highlight color should not be used with a connect image:\n *\n * ```javascript\n * mxConstants.HIGHLIGHT_COLOR = null;\n * ```\n *\n * To install the image, the connectImage field of the ConnectionHandler must be assigned a new {@link Image} instance:\n *\n * ```javascript\n * connectImage = new ImageBox('images/green-dot.gif', 14, 14);\n * ```\n *\n * This will use the green-dot.gif with a width and height of 14 pixels as the\n * image to trigger new connections. In createIcons the icon field of the\n * handler will be set in order to remember the icon that has been clicked for\n * creating the new connection. This field will be available under selectedIcon\n * in the connect method, which may be overridden to take the icon that\n * triggered the new connection into account. This is useful if more than one\n * icon may be used to create a connection.\n *\n * ### Events\n *\n * #### InternalEvent.START\n *\n * Fires when a new connection is being created by the user. The `state`\n * property contains the state of the source cell.\n *\n * #### InternalEvent.CONNECT\n *\n * Fires between begin- and endUpdate in {@link connect}. The `cell`\n * property contains the inserted edge, the `event` and `target`\n * properties contain the respective arguments that were passed to {@link connect} (where\n * target corresponds to the dropTarget argument). Finally, the `terminal`\n * property corresponds to the target argument in {@link connect} or the clone of the source\n * terminal if {@link createTarget} is enabled.\n *\n * Note that the target is the cell under the mouse where the mouse button was released.\n * Depending on the logic in the handler, this doesn't necessarily have to be the target\n * of the inserted edge. To print the source, target or any optional ports IDs that the\n * edge is connected to, the following code can be used. To get more details about the\n * actual connection point, {@link Graph.getConnectionConstraint} can be used. To resolve\n * the port IDs, use <Transactions.getCell>.\n *\n * ```javascript\n * graph.getPlugin('ConnectionHandler')?.addListener(mxEvent.CONNECT, (sender, evt) => {\n *   const edge = evt.getProperty('cell');\n *   const source = graph.getDataModel().getTerminal(edge, true);\n *   const target = graph.getDataModel().getTerminal(edge, false);\n *\n *   const style = graph.getCellStyle(edge);\n *   const sourcePortId = style.sourcePort;\n *   const targetPortId = style.targetPort;\n *\n *   GlobalConfig.logger.show();\n *   GlobalConfig.logger.debug('connect', edge, source.id, target.id, sourcePortId, targetPortId);\n * });\n * ```\n *\n * #### InternalEvent.RESET\n *\n * Fires when the {@link reset} method is invoked.\n *\n * @category Plugin\n */\nclass ConnectionHandler extends EventSource {\n    /**\n     * Constructs an event handler that connects vertices using the specified\n     * factory method to create the new edges.\n     *\n     * @param graph Reference to the enclosing {@link Graph}.\n     * @param factoryMethod Optional function to create the edge. The function takes\n     * the source and target {@link Cell} as the first and second argument and an\n     * optional cell style from the preview as the third argument. It returns\n     * the {@link Cell} that represents the new edge.\n     */\n    constructor(graph, factoryMethod = null) {\n        super();\n        this.previous = null;\n        this.iconState = null;\n        this.icons = [];\n        this.cell = null;\n        this.currentPoint = null;\n        this.sourceConstraint = null;\n        this.shape = null;\n        this.icon = null;\n        this.originalPoint = null;\n        this.currentState = null;\n        this.selectedIcon = null;\n        this.waypoints = [];\n        /**\n         * Function that is used for creating new edges. The function takes the\n         * source and target {@link Cell} as the first and second argument and returns\n         * a new {@link Cell} that represents the edge. This is used in {@link createEdge}.\n         */\n        this.factoryMethod = null;\n        /**\n         * Specifies if icons should be displayed inside the graph container instead\n         * of the overlay pane. This is used for HTML labels on vertices which hide\n         * the connect icon. This has precedence over {@link moveIconBack} when set\n         * to true.\n         * @default `false`\n         */\n        this.moveIconFront = false;\n        /**\n         * Specifies if icons should be moved to the back of the overlay pane. This can\n         * be set to true if the icons of the connection handler conflict with other\n         * handles, such as the vertex label move handle. Default is false.\n         */\n        this.moveIconBack = false;\n        /**\n         * {@link Image} that is used to trigger the creation of a new connection.\n         * This is used in {@link createIcons}.\n         * @default null\n         */\n        this.connectImage = null;\n        /**\n         * Specifies if the connect icon should be centered on the target state\n         * while connections are being previewed. Default is false.\n         */\n        this.targetConnectImage = false;\n        /**\n         * Specifies if events are handled. Default is false.\n         */\n        this.enabled = false;\n        /**\n         * Specifies if new edges should be selected. Default is true.\n         */\n        this.select = true;\n        /**\n         * Specifies if <createTargetVertex> should be called if no target was under the\n         * mouse for the new connection. Setting this to true means the connection\n         * will be drawn as valid if no target is under the mouse, and\n         * <createTargetVertex> will be called before the connection is created between\n         * the source cell and the newly created vertex in <createTargetVertex>, which\n         * can be overridden to create a new target. Default is false.\n         */\n        this.createTarget = false;\n        /**\n         * Holds the current validation error while connections are being created.\n         */\n        this.error = null;\n        /**\n         * Specifies if single clicks should add waypoints on the new edge. Default is\n         * false.\n         */\n        this.waypointsEnabled = false;\n        /**\n         * Specifies if the connection handler should ignore the state of the mouse\n         * button when highlighting the source. Default is false, that is, the\n         * handler only highlights the source if no button is being pressed.\n         */\n        this.ignoreMouseDown = false;\n        /**\n         * Holds the {@link Point} where the mouseDown took place while the handler is\n         * active.\n         */\n        this.first = null;\n        /**\n         * Holds the offset for connect icons during connection preview.\n         * Default is mxPoint(0, {@link Constants#TOOLTIP_VERTICAL_OFFSET}).\n         * Note that placing the icon under the mouse pointer with an\n         * offset of (0,0) will affect hit detection.\n         */\n        this.connectIconOffset = new Point(0, TOOLTIP_VERTICAL_OFFSET);\n        /**\n         * Optional <CellState> that represents the preview edge while the\n         * handler is active. This is created in <createEdgeState>.\n         */\n        this.edgeState = null;\n        /**\n         * Counts the number of mouseDown events since the start. The initial mouse\n         * down event counts as 1.\n         */\n        this.mouseDownCounter = 0;\n        /**\n         * Switch to enable moving the preview away from the mousepointer. This is required in browsers\n         * where the preview cannot be made transparent to events and if the built-in hit detection on\n         * the HTML elements in the page should be used.\n         * @default false\n         */\n        this.movePreviewAway = false;\n        /**\n         * Specifies if connections to the outline of a highlighted target should be\n         * enabled. This will allow to place the connection point along the outline of\n         * the highlighted target.\n         * @default false\n         */\n        this.outlineConnect = false;\n        /**\n         * Specifies if the actual shape of the edge state should be used for the preview.\n         * Default is false. (Ignored if no edge state is created in <createEdgeState>.)\n         */\n        this.livePreview = false;\n        /**\n         * Specifies the cursor to be used while the handler is active. Default is null.\n         */\n        this.cursor = null;\n        /**\n         * Specifies if new edges should be inserted before the source vertex in the\n         * cell hierarchy. Default is false for backwards compatibility.\n         */\n        this.insertBeforeSource = false;\n        this.graph = graph;\n        this.factoryMethod = factoryMethod;\n        this.graph.addMouseListener(this);\n        this.marker = this.createMarker();\n        this.constraintHandler = new ConstraintHandler(this.graph);\n        // Redraws the icons if the graph changes\n        this.changeHandler = (sender) => {\n            if (this.iconState) {\n                this.iconState = this.graph.getView().getState(this.iconState.cell);\n            }\n            if (this.iconState) {\n                this.redrawIcons(this.icons, this.iconState);\n                this.constraintHandler.reset();\n            }\n            else if (this.previous && !this.graph.view.getState(this.previous.cell)) {\n                this.reset();\n            }\n        };\n        this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.changeHandler);\n        this.graph.getView().addListener(InternalEvent.SCALE, this.changeHandler);\n        this.graph.getView().addListener(InternalEvent.TRANSLATE, this.changeHandler);\n        this.graph\n            .getView()\n            .addListener(InternalEvent.SCALE_AND_TRANSLATE, this.changeHandler);\n        // Removes the icon if we step into/up or start editing\n        this.drillHandler = (sender) => {\n            this.reset();\n        };\n        this.graph.addListener(InternalEvent.START_EDITING, this.drillHandler);\n        this.graph.getView().addListener(InternalEvent.DOWN, this.drillHandler);\n        this.graph.getView().addListener(InternalEvent.UP, this.drillHandler);\n        // Handles escape keystrokes\n        this.escapeHandler = () => {\n            this.reset();\n        };\n        this.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);\n    }\n    /**\n     * Returns true if events are handled. This implementation\n     * returns <enabled>.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling. This implementation\n     * updates <enabled>.\n     *\n     * @param enabled Boolean that specifies the new enabled state.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Returns <insertBeforeSource> for non-loops and false for loops.\n     *\n     * @param edge <Cell> that represents the edge to be inserted.\n     * @param source <Cell> that represents the source terminal.\n     * @param target <Cell> that represents the target terminal.\n     * @param evt Mousedown event of the connect gesture.\n     * @param dropTarget <Cell> that represents the cell under the mouse when it was\n     * released.\n     */\n    isInsertBefore(edge, source, target, evt, dropTarget) {\n        return this.insertBeforeSource && source !== target;\n    }\n    /**\n     * Returns <createTarget>.\n     *\n     * @param evt Current active native pointer event.\n     */\n    isCreateTarget(evt) {\n        return this.createTarget;\n    }\n    /**\n     * Sets <createTarget>.\n     */\n    setCreateTarget(value) {\n        this.createTarget = value;\n    }\n    /**\n     * Creates the preview shape for new connections.\n     */\n    createShape() {\n        // Creates the edge preview\n        const shape = this.livePreview && this.edgeState\n            ? this.graph.cellRenderer.createShape(this.edgeState)\n            : new PolylineShape([], INVALID_COLOR);\n        if (shape && shape.node) {\n            shape.dialect = DIALECT.SVG;\n            shape.scale = this.graph.view.scale;\n            shape.pointerEvents = false;\n            shape.isDashed = true;\n            shape.init(this.graph.getView().getOverlayPane());\n            InternalEvent.redirectMouseEvents(shape.node, this.graph, null);\n        }\n        return shape;\n    }\n    /**\n     * Returns true if the given cell is connectable. This is a hook to\n     * disable floating connections. This implementation returns true.\n     */\n    isConnectableCell(cell) {\n        return true;\n    }\n    /**\n     * Creates and returns the {@link CellMarker} used in {@link arker}.\n     */\n    createMarker() {\n        return new ConnectionHandlerCellMarker(this.graph, this);\n    }\n    /**\n     * Starts a new connection for the given state and coordinates.\n     */\n    start(state, x, y, edgeState) {\n        this.previous = state;\n        this.first = new Point(x, y);\n        this.edgeState = edgeState ?? this.createEdgeState();\n        // Marks the source state\n        this.marker.currentColor = this.marker.validColor;\n        this.marker.markedState = state;\n        this.marker.mark();\n        this.fireEvent(new EventObject(InternalEvent.START, { state: this.previous }));\n    }\n    /**\n     * Returns true if the source terminal has been clicked and a new\n     * connection is currently being previewed.\n     */\n    isConnecting() {\n        return !!this.first && !!this.shape;\n    }\n    /**\n     * Returns {@link Graph#isValidSource} for the given source terminal.\n     *\n     * @param cell <Cell> that represents the source terminal.\n     * @param me {@link MouseEvent} that is associated with this call.\n     */\n    isValidSource(cell, me) {\n        return this.graph.isValidSource(cell);\n    }\n    /**\n     * Returns true. The call to {@link Graph#isValidTarget} is implicit by calling\n     * {@link Graph#getEdgeValidationError} in <validateConnection>. This is an\n     * additional hook for disabling certain targets in this specific handler.\n     *\n     * @param cell <Cell> that represents the target terminal.\n     */\n    isValidTarget(cell) {\n        return true;\n    }\n    /**\n     * Returns the error message or an empty string if the connection for the\n     * given source target pair is not valid. Otherwise it returns null. This\n     * implementation uses {@link Graph#getEdgeValidationError}.\n     *\n     * @param source <Cell> that represents the source terminal.\n     * @param target <Cell> that represents the target terminal.\n     */\n    validateConnection(source, target) {\n        if (!this.isValidTarget(target)) {\n            return '';\n        }\n        return this.graph.getEdgeValidationError(null, source, target);\n    }\n    /**\n     * Hook to return the {@link Image} used for the connection icon of the given\n     * {@link CellState}. This implementation returns {@link connectImage}.\n     *\n     * @param state {@link CellState} whose connect image should be returned.\n     */\n    getConnectImage(state) {\n        return this.connectImage;\n    }\n    /**\n     * Returns true if the state has a HTML label in the graph's container, otherwise\n     * it returns {@link oveIconFront}.\n     *\n     * @param state <CellState> whose connect icons should be returned.\n     */\n    isMoveIconToFrontForState(state) {\n        if (state.text && state.text.node.parentNode === this.graph.container) {\n            return true;\n        }\n        return this.moveIconFront;\n    }\n    /**\n     * Creates the array {@link ImageShape}s that represent the connect icons for\n     * the given {@link CellState}.\n     *\n     * @param state {@link CellState} whose connect icons should be returned.\n     */\n    createIcons(state) {\n        const image = this.getConnectImage(state);\n        if (image) {\n            this.iconState = state;\n            const icons = [];\n            // Cannot use HTML for the connect icons because the icon receives all\n            // mouse move events in IE, must use VML and SVG instead even if the\n            // connect-icon appears behind the selection border and the selection\n            // border consumes the events before the icon gets a chance\n            const bounds = new Rectangle(0, 0, image.width, image.height);\n            const icon = new ImageShape(bounds, image.src, undefined, undefined, 0);\n            icon.preserveImageAspect = false;\n            if (this.isMoveIconToFrontForState(state)) {\n                icon.dialect = DIALECT.STRICTHTML;\n                icon.init(this.graph.container);\n            }\n            else {\n                icon.dialect = DIALECT.SVG;\n                icon.init(this.graph.getView().getOverlayPane());\n                // Move the icon back in the overlay pane\n                if (this.moveIconBack && icon.node.parentNode && icon.node.previousSibling) {\n                    icon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);\n                }\n            }\n            icon.node.style.cursor = CURSOR.CONNECT;\n            // Events transparency\n            const getState = () => {\n                return this.currentState ?? state;\n            };\n            // Updates the local icon before firing the mouse down event.\n            const mouseDown = (evt) => {\n                if (!isConsumed(evt)) {\n                    this.icon = icon;\n                    this.graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, getState()));\n                }\n            };\n            InternalEvent.redirectMouseEvents(icon.node, this.graph, getState, mouseDown);\n            icons.push(icon);\n            this.redrawIcons(icons, this.iconState);\n            return icons;\n        }\n        return [];\n    }\n    /**\n     * Redraws the given array of {@link ImageShapes}.\n     *\n     * @param icons Array of {@link ImageShapes} to be redrawn.\n     */\n    redrawIcons(icons, state) {\n        if (icons[0] && icons[0].bounds) {\n            const pos = this.getIconPosition(icons[0], state);\n            icons[0].bounds.x = pos.x;\n            icons[0].bounds.y = pos.y;\n            icons[0].redraw();\n        }\n    }\n    // TODO: Document me! ===========================================================================================================\n    getIconPosition(icon, state) {\n        const { scale } = this.graph.getView();\n        let cx = state.getCenterX();\n        let cy = state.getCenterY();\n        if (this.graph.isSwimlane(state.cell)) {\n            const size = this.graph.getStartSize(state.cell);\n            cx = size.width !== 0 ? state.x + (size.width * scale) / 2 : cx;\n            cy = size.height !== 0 ? state.y + (size.height * scale) / 2 : cy;\n            const alpha = toRadians(state.style.rotation ?? 0);\n            if (alpha !== 0) {\n                const cos = Math.cos(alpha);\n                const sin = Math.sin(alpha);\n                const ct = new Point(state.getCenterX(), state.getCenterY());\n                const pt = getRotatedPoint(new Point(cx, cy), cos, sin, ct);\n                cx = pt.x;\n                cy = pt.y;\n            }\n        }\n        return new Point(cx - icon.bounds.width / 2, cy - icon.bounds.height / 2);\n    }\n    /**\n     * Destroys the connect icons and resets the respective state.\n     */\n    destroyIcons() {\n        for (let i = 0; i < this.icons.length; i += 1) {\n            this.icons[i].destroy();\n        }\n        this.icons = [];\n        this.icon = null;\n        this.selectedIcon = null;\n        this.iconState = null;\n    }\n    /**\n     * Returns true if the given mouse down event should start this handler. The\n     * This implementation returns true if the event does not force marquee\n     * selection, and the currentConstraint and currentFocus of the\n     * <constraintHandler> are not null, or <previous> and <error> are not null and\n     * <icons> is null or <icons> and <icon> are not null.\n     */\n    isStartEvent(me) {\n        return ((this.constraintHandler.currentFocus !== null &&\n            this.constraintHandler.currentConstraint !== null) ||\n            (this.previous !== null &&\n                this.error === null &&\n                (this.icons.length === 0 || this.icon !== null)));\n    }\n    /**\n     * Handles the event by initiating a new connection.\n     */\n    mouseDown(sender, me) {\n        this.mouseDownCounter += 1;\n        if (this.isEnabled() &&\n            this.graph.isEnabled() &&\n            !me.isConsumed() &&\n            !this.isConnecting() &&\n            this.isStartEvent(me)) {\n            if (this.constraintHandler.currentConstraint &&\n                this.constraintHandler.currentFocus &&\n                this.constraintHandler.currentPoint) {\n                this.sourceConstraint = this.constraintHandler.currentConstraint;\n                this.previous = this.constraintHandler.currentFocus;\n                this.first = this.constraintHandler.currentPoint.clone();\n            }\n            else {\n                // Stores the location of the initial mousedown\n                this.first = new Point(me.getGraphX(), me.getGraphY());\n            }\n            this.edgeState = this.createEdgeState(me);\n            this.mouseDownCounter = 1;\n            if (this.waypointsEnabled && !this.shape) {\n                this.waypoints = [];\n                this.shape = this.createShape();\n                if (this.edgeState) {\n                    this.shape.apply(this.edgeState);\n                }\n            }\n            // Stores the starting point in the geometry of the preview\n            if (!this.previous && this.edgeState && this.edgeState.cell.geometry) {\n                const pt = this.graph.getPointForEvent(me.getEvent());\n                this.edgeState.cell.geometry.setTerminalPoint(pt, true);\n            }\n            this.fireEvent(new EventObject(InternalEvent.START, { state: this.previous }));\n            me.consume();\n        }\n        this.selectedIcon = this.icon;\n        this.icon = null;\n    }\n    /**\n     * Returns true if a tap on the given source state should immediately start\n     * connecting. This implementation returns true if the state is not movable\n     * in the graph.\n     */\n    isImmediateConnectSource(state) {\n        return !this.graph.isCellMovable(state.cell);\n    }\n    /**\n     * Hook to return an <CellState> which may be used during the preview.\n     * This implementation returns null.\n     *\n     * Use the following code to create a preview for an existing edge style:\n     *\n     * ```javascript\n     * graph.getPlugin('ConnectionHandler').createEdgeState(me)\n     * {\n     *   var edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=elbowEdgeStyle');\n     *\n     *   return new CellState(this.graph.view, edge, this.graph.getCellStyle(edge));\n     * };\n     * ```\n     */\n    createEdgeState(me) {\n        return null;\n    }\n    /**\n     * Returns true if <outlineConnect> is true and the source of the event is the outline shape\n     * or shift is pressed.\n     */\n    isOutlineConnectEvent(me) {\n        if (!this.currentPoint)\n            return false;\n        const offset = getOffset(this.graph.container);\n        const evt = me.getEvent();\n        const clientX = getClientX(evt);\n        const clientY = getClientY(evt);\n        const doc = document.documentElement;\n        const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n        const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n        const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;\n        const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;\n        return (this.outlineConnect &&\n            !isShiftDown(me.getEvent()) &&\n            (me.isSource(this.marker.highlight.shape) ||\n                (isAltDown(me.getEvent()) && me.getState() != null) ||\n                this.marker.highlight.isHighlightAt(clientX, clientY) ||\n                ((gridX !== clientX || gridY !== clientY) &&\n                    me.getState() == null &&\n                    this.marker.highlight.isHighlightAt(gridX, gridY))));\n    }\n    /**\n     * Updates the current state for a given mouse move event by using\n     * the {@link arker}.\n     */\n    updateCurrentState(me, point) {\n        this.constraintHandler.update(me, !this.first, false, !this.first || me.isSource(this.marker.highlight.shape) ? null : point);\n        if (this.constraintHandler.currentFocus != null &&\n            this.constraintHandler.currentConstraint != null) {\n            // Handles special case where grid is large and connection point is at actual point in which\n            // case the outline is not followed as long as we're < gridSize / 2 away from that point\n            if (this.marker.highlight &&\n                this.marker.highlight.state &&\n                this.marker.highlight.state.cell === this.constraintHandler.currentFocus.cell &&\n                this.marker.highlight.shape) {\n                // Direct repaint needed if cell already highlighted\n                if (this.marker.highlight.shape.stroke !== 'transparent') {\n                    this.marker.highlight.shape.stroke = 'transparent';\n                    this.marker.highlight.repaint();\n                }\n            }\n            else {\n                this.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');\n            }\n            // Updates validation state\n            if (this.previous) {\n                this.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell);\n                if (!this.error) {\n                    this.currentState = this.constraintHandler.currentFocus;\n                }\n                if (this.error ||\n                    (this.currentState && !this.isCellEnabled(this.currentState.cell))) {\n                    this.constraintHandler.reset();\n                }\n            }\n        }\n        else {\n            if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {\n                this.marker.reset();\n                this.currentState = null;\n            }\n            else {\n                this.marker.process(me);\n                this.currentState = this.marker.getValidState();\n            }\n            if (this.currentState != null && !this.isCellEnabled(this.currentState.cell)) {\n                this.constraintHandler.reset();\n                this.marker.reset();\n                this.currentState = null;\n            }\n            const outline = this.isOutlineConnectEvent(me);\n            if (this.currentState != null && outline) {\n                // Handles special case where mouse is on outline away from actual end point\n                // in which case the grid is ignored and mouse point is used instead\n                if (me.isSource(this.marker.highlight.shape)) {\n                    point = new Point(me.getGraphX(), me.getGraphY());\n                }\n                const constraint = this.graph.getOutlineConstraint(point, this.currentState, me);\n                this.constraintHandler.setFocus(me, this.currentState, false);\n                this.constraintHandler.currentConstraint = constraint;\n                this.constraintHandler.currentPoint = point;\n            }\n            if (this.outlineConnect) {\n                if (this.marker.highlight != null && this.marker.highlight.shape != null) {\n                    const s = this.graph.view.scale;\n                    if (this.constraintHandler.currentConstraint != null &&\n                        this.constraintHandler.currentFocus != null) {\n                        this.marker.highlight.shape.stroke = OUTLINE_HIGHLIGHT_COLOR;\n                        this.marker.highlight.shape.strokeWidth =\n                            OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;\n                        this.marker.highlight.repaint();\n                    }\n                    else if (this.marker.hasValidState()) {\n                        const cell = me.getCell();\n                        // Handles special case where actual end point of edge and current mouse point\n                        // are not equal (due to grid snapping) and there is no hit on shape or highlight\n                        // but ignores cases where parent is used for non-connectable child cells\n                        if (cell &&\n                            cell.isConnectable() &&\n                            this.marker.getValidState() !== me.getState()) {\n                            this.marker.highlight.shape.stroke = 'transparent';\n                            this.currentState = null;\n                        }\n                        else {\n                            this.marker.highlight.shape.stroke = DEFAULT_VALID_COLOR;\n                        }\n                        this.marker.highlight.shape.strokeWidth = HIGHLIGHT_STROKEWIDTH / s / s;\n                        this.marker.highlight.repaint();\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Returns true if the given cell does not allow new connections to be created.\n     */\n    isCellEnabled(cell) {\n        return true;\n    }\n    /**\n     * Converts the given point from screen coordinates to model coordinates.\n     */\n    convertWaypoint(point) {\n        const scale = this.graph.getView().getScale();\n        const tr = this.graph.getView().getTranslate();\n        point.x = point.x / scale - tr.x;\n        point.y = point.y / scale - tr.y;\n    }\n    /**\n     * Called to snap the given point to the current preview. This snaps to the\n     * first point of the preview if alt is not pressed.\n     */\n    snapToPreview(me, point) {\n        if (!isAltDown(me.getEvent()) && this.previous) {\n            const tol = (this.graph.getGridSize() * this.graph.view.scale) / 2;\n            const tmp = this.sourceConstraint && this.first\n                ? this.first\n                : new Point(this.previous.getCenterX(), this.previous.getCenterY());\n            if (Math.abs(tmp.x - me.getGraphX()) < tol) {\n                point.x = tmp.x;\n            }\n            if (Math.abs(tmp.y - me.getGraphY()) < tol) {\n                point.y = tmp.y;\n            }\n        }\n    }\n    /**\n     * Handles the event by updating the preview edge or by highlighting\n     * a possible source or target terminal.\n     */\n    mouseMove(sender, me) {\n        if (!me.isConsumed() &&\n            (this.ignoreMouseDown || this.first || !this.graph.isMouseDown)) {\n            // Handles special case when handler is disabled during highlight\n            if (!this.isEnabled() && this.currentState) {\n                this.destroyIcons();\n                this.currentState = null;\n            }\n            const view = this.graph.getView();\n            const { scale } = view;\n            const tr = view.translate;\n            let point = new Point(me.getGraphX(), me.getGraphY());\n            this.error = null;\n            if (this.graph.isGridEnabledEvent(me.getEvent())) {\n                point = new Point((this.graph.snap(point.x / scale - tr.x) + tr.x) * scale, (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale);\n            }\n            this.snapToPreview(me, point);\n            this.currentPoint = point;\n            if ((this.first || (this.isEnabled() && this.graph.isEnabled())) &&\n                (this.shape ||\n                    !this.first ||\n                    Math.abs(me.getGraphX() - this.first.x) > this.graph.getEventTolerance() ||\n                    Math.abs(me.getGraphY() - this.first.y) > this.graph.getEventTolerance())) {\n                this.updateCurrentState(me, point);\n            }\n            if (this.first) {\n                let constraint = null;\n                let current = point;\n                // Uses the current point from the constraint handler if available\n                if (this.constraintHandler.currentConstraint &&\n                    this.constraintHandler.currentFocus &&\n                    this.constraintHandler.currentPoint) {\n                    constraint = this.constraintHandler.currentConstraint;\n                    current = this.constraintHandler.currentPoint.clone();\n                }\n                else if (this.previous &&\n                    !this.graph.isIgnoreTerminalEvent(me.getEvent()) &&\n                    isShiftDown(me.getEvent())) {\n                    if (Math.abs(this.previous.getCenterX() - point.x) <\n                        Math.abs(this.previous.getCenterY() - point.y)) {\n                        point.x = this.previous.getCenterX();\n                    }\n                    else {\n                        point.y = this.previous.getCenterY();\n                    }\n                }\n                let pt2 = this.first;\n                // Moves the connect icon with the mouse\n                if (this.selectedIcon && this.selectedIcon.bounds) {\n                    const w = this.selectedIcon.bounds.width;\n                    const h = this.selectedIcon.bounds.height;\n                    if (this.currentState && this.targetConnectImage) {\n                        const pos = this.getIconPosition(this.selectedIcon, this.currentState);\n                        this.selectedIcon.bounds.x = pos.x;\n                        this.selectedIcon.bounds.y = pos.y;\n                    }\n                    else {\n                        const bounds = new Rectangle(me.getGraphX() + this.connectIconOffset.x, me.getGraphY() + this.connectIconOffset.y, w, h);\n                        this.selectedIcon.bounds = bounds;\n                    }\n                    this.selectedIcon.redraw();\n                }\n                // Uses edge state to compute the terminal points\n                if (this.edgeState) {\n                    this.updateEdgeState(current, constraint);\n                    current =\n                        this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1];\n                    pt2 = this.edgeState.absolutePoints[0];\n                }\n                else {\n                    if (this.currentState) {\n                        if (!this.constraintHandler.currentConstraint) {\n                            const tmp = this.getTargetPerimeterPoint(this.currentState, me);\n                            if (tmp != null) {\n                                current = tmp;\n                            }\n                        }\n                    }\n                    // Computes the source perimeter point\n                    if (!this.sourceConstraint && this.previous) {\n                        const next = this.waypoints.length > 0 ? this.waypoints[0] : current;\n                        const tmp = this.getSourcePerimeterPoint(this.previous, next, me);\n                        if (tmp) {\n                            pt2 = tmp;\n                        }\n                    }\n                }\n                // Makes sure the cell under the mousepointer can be detected\n                // by moving the preview shape away from the mouse. This\n                // makes sure the preview shape does not prevent the detection\n                // of the cell under the mousepointer even for slow gestures.\n                if (!this.currentState && this.movePreviewAway && current) {\n                    let tmp = pt2;\n                    if (this.edgeState && this.edgeState.absolutePoints.length >= 2) {\n                        const tmp2 = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2];\n                        if (tmp2) {\n                            tmp = tmp2;\n                        }\n                    }\n                    if (tmp) {\n                        const dx = current.x - tmp.x;\n                        const dy = current.y - tmp.y;\n                        const len = Math.sqrt(dx * dx + dy * dy);\n                        if (len === 0) {\n                            return;\n                        }\n                        // Stores old point to reuse when creating edge\n                        this.originalPoint = current.clone();\n                        current.x -= (dx * 4) / len;\n                        current.y -= (dy * 4) / len;\n                    }\n                }\n                else {\n                    this.originalPoint = null;\n                }\n                // Creates the preview shape (lazy)\n                if (!this.shape) {\n                    const dx = Math.abs(me.getGraphX() - this.first.x);\n                    const dy = Math.abs(me.getGraphY() - this.first.y);\n                    if (dx > this.graph.getEventTolerance() ||\n                        dy > this.graph.getEventTolerance()) {\n                        this.shape = this.createShape();\n                        if (this.edgeState) {\n                            this.shape.apply(this.edgeState);\n                        }\n                        // Revalidates current connection\n                        this.updateCurrentState(me, point);\n                    }\n                }\n                // Updates the points in the preview edge\n                if (this.shape) {\n                    if (this.edgeState) {\n                        this.shape.points = this.edgeState.absolutePoints;\n                    }\n                    else {\n                        let pts = [pt2];\n                        if (this.waypoints.length > 0) {\n                            pts = pts.concat(this.waypoints);\n                        }\n                        pts.push(current);\n                        this.shape.points = pts;\n                    }\n                    this.drawPreview();\n                }\n                // Makes sure endpoint of edge is visible during connect\n                if (this.cursor) {\n                    this.graph.container.style.cursor = this.cursor;\n                }\n                InternalEvent.consume(me.getEvent());\n                me.consume();\n            }\n            else if (!this.isEnabled() || !this.graph.isEnabled()) {\n                this.constraintHandler.reset();\n            }\n            else if (this.previous !== this.currentState && !this.edgeState) {\n                this.destroyIcons();\n                // Sets the cursor on the current shape\n                if (this.currentState &&\n                    !this.error &&\n                    !this.constraintHandler.currentConstraint) {\n                    this.icons = this.createIcons(this.currentState);\n                    if (this.icons.length === 0) {\n                        this.currentState.setCursor(CURSOR.CONNECT);\n                        me.consume();\n                    }\n                }\n                this.previous = this.currentState;\n            }\n            else if (this.previous === this.currentState &&\n                this.currentState != null &&\n                this.icons.length === 0 &&\n                !this.graph.isMouseDown) {\n                // Makes sure that no cursors are changed\n                me.consume();\n            }\n            if (!this.graph.isMouseDown && this.currentState != null && this.icons != null) {\n                let hitsIcon = false;\n                const target = me.getSource();\n                for (let i = 0; i < this.icons.length && !hitsIcon; i += 1) {\n                    hitsIcon =\n                        target === this.icons[i].node ||\n                            // @ts-ignore parentNode should exist.\n                            (!!target && target.parentNode === this.icons[i].node);\n                }\n                if (!hitsIcon) {\n                    this.updateIcons(this.currentState, this.icons, me);\n                }\n            }\n        }\n        else {\n            this.constraintHandler.reset();\n        }\n    }\n    /**\n     * Updates <edgeState>.\n     */\n    updateEdgeState(current, constraint) {\n        if (!this.edgeState)\n            return;\n        // TODO: Use generic method for writing constraint to style\n        if (this.sourceConstraint && this.sourceConstraint.point) {\n            this.edgeState.style.exitX = this.sourceConstraint.point.x;\n            this.edgeState.style.exitY = this.sourceConstraint.point.y;\n        }\n        if (constraint && constraint.point) {\n            this.edgeState.style.entryX = constraint.point.x;\n            this.edgeState.style.entryY = constraint.point.y;\n        }\n        else {\n            this.edgeState.style.entryX = 0;\n            this.edgeState.style.entryY = 0;\n        }\n        this.edgeState.absolutePoints = [null, this.currentState != null ? null : current];\n        if (this.sourceConstraint) {\n            this.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, true, this.sourceConstraint);\n        }\n        if (this.currentState != null) {\n            if (constraint == null) {\n                constraint = this.graph.getConnectionConstraint(this.edgeState, this.previous, false);\n            }\n            this.edgeState.setAbsoluteTerminalPoint(null, false);\n            this.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, false, constraint);\n        }\n        // Scales and translates the waypoints to the model\n        const realPoints = [];\n        for (let i = 0; i < this.waypoints.length; i += 1) {\n            const pt = this.waypoints[i].clone();\n            this.convertWaypoint(pt);\n            realPoints[i] = pt;\n        }\n        this.graph.view.updatePoints(this.edgeState, realPoints, this.previous, this.currentState);\n        this.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);\n    }\n    /**\n     * Returns the perimeter point for the given target state.\n     *\n     * @param state <CellState> that represents the target cell state.\n     * @param _me {@link MouseEvent} that represents the mouse move.\n     */\n    getTargetPerimeterPoint(state, _me) {\n        let result = null;\n        const { view } = state;\n        const targetPerimeter = view.getPerimeterFunction(state);\n        if (targetPerimeter && this.previous && this.edgeState) {\n            const next = this.waypoints.length > 0\n                ? this.waypoints[this.waypoints.length - 1]\n                : new Point(this.previous.getCenterX(), this.previous.getCenterY());\n            const tmp = targetPerimeter(view.getPerimeterBounds(state), this.edgeState, next, false);\n            if (tmp) {\n                result = tmp;\n            }\n        }\n        else {\n            result = new Point(state.getCenterX(), state.getCenterY());\n        }\n        return result;\n    }\n    /**\n     * Hook to update the icon position(s) based on a mouseOver event. This is\n     * an empty implementation.\n     *\n     * @param state <CellState> that represents the target cell state.\n     * @param next {@link Point} that represents the next point along the previewed edge.\n     * @param me {@link MouseEvent} that represents the mouse move.\n     */\n    getSourcePerimeterPoint(state, next, me) {\n        let result = null;\n        const { view } = state;\n        const sourcePerimeter = view.getPerimeterFunction(state);\n        const c = new Point(state.getCenterX(), state.getCenterY());\n        if (sourcePerimeter) {\n            const theta = state.style.rotation ?? 0;\n            const rad = -theta * (Math.PI / 180);\n            if (theta !== 0) {\n                next = getRotatedPoint(new Point(next.x, next.y), Math.cos(rad), Math.sin(rad), c);\n            }\n            let tmp = sourcePerimeter(view.getPerimeterBounds(state), state, next, false);\n            if (tmp) {\n                if (theta !== 0) {\n                    tmp = getRotatedPoint(new Point(tmp.x, tmp.y), Math.cos(-rad), Math.sin(-rad), c);\n                }\n                result = tmp;\n            }\n        }\n        else {\n            result = c;\n        }\n        return result;\n    }\n    /**\n     * Hook to update the icon position(s) based on a mouseOver event. This is\n     * an empty implementation.\n     *\n     * @param state <CellState> under the mouse.\n     * @param icons Array of currently displayed icons.\n     * @param me {@link MouseEvent} that contains the mouse event.\n     */\n    updateIcons(state, icons, me) {\n        // empty\n    }\n    /**\n     * Returns true if the given mouse up event should stop this handler. The\n     * connection will be created if <error> is null. Note that this is only\n     * called if <waypointsEnabled> is true. This implemtation returns true\n     * if there is a cell state in the given event.\n     */\n    isStopEvent(me) {\n        return !!me.getState();\n    }\n    /**\n     * Adds the waypoint for the given event to <waypoints>.\n     */\n    addWaypointForEvent(me) {\n        if (!this.first)\n            return;\n        let point = convertPoint(this.graph.container, me.getX(), me.getY());\n        const dx = Math.abs(point.x - this.first.x);\n        const dy = Math.abs(point.y - this.first.y);\n        const addPoint = this.waypoints.length > 0 ||\n            (this.mouseDownCounter > 1 &&\n                (dx > this.graph.getEventTolerance() || dy > this.graph.getEventTolerance()));\n        if (addPoint) {\n            const { scale } = this.graph.view;\n            point = new Point(this.graph.snap(me.getGraphX() / scale) * scale, this.graph.snap(me.getGraphY() / scale) * scale);\n            this.waypoints.push(point);\n        }\n    }\n    /**\n     * Returns true if the connection for the given constraints is valid. This\n     * implementation returns true if the constraints are not pointing to the\n     * same fixed connection point.\n     */\n    checkConstraints(c1, c2) {\n        return (!c1 ||\n            !c2 ||\n            !c1.point ||\n            !c2.point ||\n            !c1.point.equals(c2.point) ||\n            c1.dx !== c2.dx ||\n            c1.dy !== c2.dy ||\n            c1.perimeter !== c2.perimeter);\n    }\n    /**\n     * Handles the event by inserting the new connection.\n     */\n    mouseUp(sender, me) {\n        if (!me.isConsumed() && this.isConnecting()) {\n            if (this.waypointsEnabled && !this.isStopEvent(me)) {\n                this.addWaypointForEvent(me);\n                me.consume();\n                return;\n            }\n            const c1 = this.sourceConstraint;\n            const c2 = this.constraintHandler.currentConstraint;\n            const source = this.previous ? this.previous.cell : null;\n            let target = null;\n            if (this.constraintHandler.currentConstraint &&\n                this.constraintHandler.currentFocus) {\n                target = this.constraintHandler.currentFocus.cell;\n            }\n            if (!target && this.currentState) {\n                target = this.currentState.cell;\n            }\n            // Inserts the edge if no validation error exists and if constraints differ\n            if (!this.error &&\n                (!source || !target || source !== target || this.checkConstraints(c1, c2))) {\n                this.connect(source, target, me.getEvent(), me.getCell());\n            }\n            else {\n                // Selects the source terminal for self-references\n                if (this.previous != null &&\n                    this.marker.validState != null &&\n                    this.previous.cell === this.marker.validState.cell) {\n                    this.graph.selectCellForEvent(this.marker.validState.cell, me.getEvent());\n                }\n                // Displays the error message if it is not an empty string,\n                // for empty error messages, the event is silently dropped\n                if (this.error != null && this.error.length > 0) {\n                    this.graph.validationAlert(this.error);\n                }\n            }\n            // Redraws the connect icons and resets the handler state\n            this.destroyIcons();\n            me.consume();\n        }\n        if (this.first != null) {\n            this.reset();\n        }\n    }\n    /**\n     * Resets the state of this handler.\n     */\n    reset() {\n        if (this.shape != null) {\n            this.shape.destroy();\n            this.shape = null;\n        }\n        // Resets the cursor on the container\n        if (this.cursor != null && this.graph.container != null) {\n            this.graph.container.style.cursor = '';\n        }\n        this.destroyIcons();\n        this.marker.reset();\n        this.constraintHandler.reset();\n        this.originalPoint = null;\n        this.currentPoint = null;\n        this.edgeState = null;\n        this.previous = null;\n        this.error = null;\n        this.sourceConstraint = null;\n        this.mouseDownCounter = 0;\n        this.first = null;\n        this.fireEvent(new EventObject(InternalEvent.RESET));\n    }\n    /**\n     * Redraws the preview edge using the color and width returned by\n     * <getEdgeColor> and <getEdgeWidth>.\n     */\n    drawPreview() {\n        this.updatePreview(this.error === null);\n        if (this.shape)\n            this.shape.redraw();\n    }\n    /**\n     * Returns the color used to draw the preview edge. This returns green if\n     * there is no edge validation error and red otherwise.\n     *\n     * @param valid Boolean indicating if the color for a valid edge should be\n     * returned.\n     */\n    updatePreview(valid) {\n        if (this.shape) {\n            this.shape.strokeWidth = this.getEdgeWidth(valid);\n            this.shape.stroke = this.getEdgeColor(valid);\n        }\n    }\n    /**\n     * Returns the color used to draw the preview edge. This returns green if\n     * there is no edge validation error and red otherwise.\n     *\n     * @param valid Boolean indicating if the color for a valid edge should be\n     * returned.\n     */\n    getEdgeColor(valid) {\n        return valid ? VALID_COLOR : INVALID_COLOR;\n    }\n    /**\n     * Returns the width used to draw the preview edge. This returns 3 if\n     * there is no edge validation error and 1 otherwise.\n     *\n     * @param valid Boolean indicating if the width for a valid edge should be\n     * returned.\n     */\n    getEdgeWidth(valid) {\n        return valid ? 3 : 1;\n    }\n    /**\n     * Connects the given source and target using a new edge. This\n     * implementation uses <createEdge> to create the edge.\n     *\n     * @param source <Cell> that represents the source terminal.\n     * @param target <Cell> that represents the target terminal.\n     * @param evt Mousedown event of the connect gesture.\n     * @param dropTarget <Cell> that represents the cell under the mouse when it was\n     * released.\n     */\n    connect(source, target, evt, dropTarget = null) {\n        if (target || this.isCreateTarget(evt) || this.graph.isAllowDanglingEdges()) {\n            // Uses the common parent of source and target or\n            // the default parent to insert the edge\n            const model = this.graph.getDataModel();\n            let terminalInserted = false;\n            let edge = null;\n            model.beginUpdate();\n            try {\n                if (source &&\n                    !target &&\n                    !this.graph.isIgnoreTerminalEvent(evt) &&\n                    this.isCreateTarget(evt)) {\n                    target = this.createTargetVertex(evt, source);\n                    if (target) {\n                        dropTarget = this.graph.getDropTarget([target], evt, dropTarget);\n                        terminalInserted = true;\n                        // Disables edges as drop targets if the target cell was created\n                        // FIXME: Should not shift if vertex was aligned (same in Java)\n                        if (dropTarget == null || !dropTarget.isEdge()) {\n                            const pstate = dropTarget\n                                ? this.graph.getView().getState(dropTarget)\n                                : null;\n                            if (pstate) {\n                                const tmp = target.getGeometry();\n                                if (tmp) {\n                                    tmp.x -= pstate.origin.x;\n                                    tmp.y -= pstate.origin.y;\n                                }\n                            }\n                        }\n                        else {\n                            dropTarget = this.graph.getDefaultParent();\n                        }\n                        this.graph.addCell(target, dropTarget);\n                    }\n                }\n                let parent = this.graph.getDefaultParent();\n                if (source &&\n                    target &&\n                    source.getParent() === target.getParent() &&\n                    source.getParent()?.getParent() !== model.getRoot()) {\n                    parent = source.getParent();\n                    if (source.geometry &&\n                        source.geometry.relative &&\n                        target.geometry &&\n                        target.geometry.relative) {\n                        parent = parent.getParent();\n                    }\n                }\n                // Uses the value of the preview edge state for inserting\n                // the new edge into the graph\n                let value = null;\n                let style = {};\n                if (this.edgeState?.cell) {\n                    value = this.edgeState.cell.value;\n                    style = this.edgeState.cell.style ?? {};\n                }\n                edge = this.insertEdge(parent, '', value, source, target, style);\n                if (edge && source) {\n                    // Updates the connection constraints\n                    this.graph.setConnectionConstraint(edge, source, true, this.sourceConstraint);\n                    this.graph.setConnectionConstraint(edge, target, false, this.constraintHandler.currentConstraint);\n                    // Uses geometry of the preview edge state\n                    if (this.edgeState?.cell?.geometry) {\n                        model.setGeometry(edge, this.edgeState.cell.geometry);\n                    }\n                    parent = source.getParent();\n                    // Inserts edge before source\n                    if (this.isInsertBefore(edge, source, target, evt, dropTarget)) {\n                        const index = null;\n                        let tmp = source;\n                        while (tmp &&\n                            tmp.parent != null &&\n                            tmp.geometry != null &&\n                            tmp.geometry.relative &&\n                            tmp.parent !== edge.parent) {\n                            tmp = tmp.getParent();\n                        }\n                        if (tmp != null && tmp.parent != null && tmp.parent === edge.parent) {\n                            model.add(parent, edge, tmp.parent.getIndex(tmp));\n                        }\n                    }\n                    // Makes sure the edge has a non-null, relative geometry\n                    let geo = edge.getGeometry();\n                    if (geo == null) {\n                        geo = new Geometry();\n                        geo.relative = true;\n                        model.setGeometry(edge, geo);\n                    }\n                    // Uses scaled waypoints in geometry\n                    if (this.waypoints.length > 0) {\n                        const s = this.graph.view.scale;\n                        const tr = this.graph.view.translate;\n                        geo.points = [];\n                        for (let i = 0; i < this.waypoints.length; i += 1) {\n                            const pt = this.waypoints[i];\n                            geo.points.push(new Point(pt.x / s - tr.x, pt.y / s - tr.y));\n                        }\n                    }\n                    if (!target && this.currentPoint) {\n                        const t = this.graph.view.translate;\n                        const s = this.graph.view.scale;\n                        const pt = this.originalPoint != null\n                            ? new Point(this.originalPoint.x / s - t.x, this.originalPoint.y / s - t.y)\n                            : new Point(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);\n                        pt.x -= this.graph.getPanDx() / this.graph.view.scale;\n                        pt.y -= this.graph.getPanDy() / this.graph.view.scale;\n                        geo.setTerminalPoint(pt, false);\n                    }\n                    this.fireEvent(new EventObject(InternalEvent.CONNECT, 'cell', edge, 'terminal', target, 'event', evt, 'target', dropTarget, 'terminalInserted', terminalInserted));\n                }\n            }\n            catch (e) {\n                GlobalConfig.logger.show();\n                const errorMessage = `Error in ConnectionHandler: ${e instanceof Error ? e.message + '\\n' + e.stack : 'unknown cause'}`;\n                GlobalConfig.logger.debug(errorMessage);\n            }\n            finally {\n                model.endUpdate();\n            }\n            if (this.select) {\n                this.selectCells(edge, terminalInserted ? target : null);\n            }\n        }\n    }\n    /**\n     * Selects the given edge after adding a new connection. The target argument\n     * contains the target vertex if one has been inserted.\n     */\n    selectCells(edge, target) {\n        this.graph.setSelectionCell(edge);\n    }\n    /**\n     * Creates, inserts and returns the new edge for the given parameters. This\n     * implementation does only use <createEdge> if <factoryMethod> is defined,\n     * otherwise {@link Graph#insertEdge} will be used.\n     */\n    insertEdge(parent, id, value, source, target, style) {\n        if (!this.factoryMethod) {\n            return this.graph.insertEdge(parent, id, value, source, target, style);\n        }\n        let edge = this.createEdge(value, source, target, style);\n        edge = this.graph.addEdge(edge, parent, source, target);\n        return edge;\n    }\n    /**\n     * Hook method for creating new vertices on the fly if no target was\n     * under the mouse. This is only called if <createTarget> is true and\n     * returns null.\n     *\n     * @param evt Mousedown event of the connect gesture.\n     * @param source <Cell> that represents the source terminal.\n     */\n    createTargetVertex(evt, source) {\n        // Uses the first non-relative source\n        let geo = source.getGeometry();\n        while (geo && geo.relative) {\n            source = source.getParent();\n            geo = source.getGeometry();\n        }\n        const clone = this.graph.cloneCell(source);\n        geo = clone.getGeometry();\n        if (geo && this.currentPoint) {\n            const t = this.graph.view.translate;\n            const s = this.graph.view.scale;\n            const point = new Point(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);\n            geo.x = Math.round(point.x - geo.width / 2 - this.graph.getPanDx() / s);\n            geo.y = Math.round(point.y - geo.height / 2 - this.graph.getPanDy() / s);\n            // Aligns with source if within certain tolerance\n            const tol = this.getAlignmentTolerance();\n            if (tol > 0) {\n                const sourceState = this.graph.view.getState(source);\n                if (sourceState != null) {\n                    const x = sourceState.x / s - t.x;\n                    const y = sourceState.y / s - t.y;\n                    if (Math.abs(x - geo.x) <= tol) {\n                        geo.x = Math.round(x);\n                    }\n                    if (Math.abs(y - geo.y) <= tol) {\n                        geo.y = Math.round(y);\n                    }\n                }\n            }\n        }\n        return clone;\n    }\n    /**\n     * Returns the tolerance for aligning new targets to sources. This returns the grid size / 2.\n     */\n    getAlignmentTolerance(evt) {\n        return this.graph.isGridEnabled()\n            ? this.graph.getGridSize() / 2\n            : this.graph.getSnapTolerance();\n    }\n    /**\n     * Creates and returns a new edge using <factoryMethod> if one exists. If\n     * no factory method is defined, then a new default edge is returned. The\n     * source and target arguments are informal, the actual connection is\n     * setup later by the caller of this function.\n     *\n     * @param value Value to be used for creating the edge.\n     * @param source <Cell> that represents the source terminal.\n     * @param target <Cell> that represents the target terminal.\n     * @param style Optional style from the preview edge.\n     */\n    createEdge(value, source, target, style = {}) {\n        let edge = null;\n        // Creates a new edge using the factoryMethod\n        if (this.factoryMethod != null) {\n            edge = this.factoryMethod(source, target, style);\n        }\n        if (edge == null) {\n            edge = new Cell(value || '');\n            edge.setEdge(true);\n            edge.setStyle(style);\n            const geo = new Geometry();\n            geo.relative = true;\n            edge.setGeometry(geo);\n        }\n        return edge;\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes. This should be\n     * called on all instances. It is called automatically for the built-in\n     * instance created for each {@link Graph}.\n     */\n    onDestroy() {\n        this.graph.removeMouseListener(this);\n        if (this.shape) {\n            this.shape.destroy();\n            this.shape = null;\n        }\n        if (this.marker) {\n            this.marker.destroy();\n            // @ts-expect-error this.marker is null when it is destroyed.\n            this.marker = null;\n        }\n        if (this.constraintHandler) {\n            this.constraintHandler.onDestroy();\n        }\n        if (this.changeHandler) {\n            this.graph.getDataModel().removeListener(this.changeHandler);\n            this.graph.getView().removeListener(this.changeHandler);\n        }\n        if (this.drillHandler) {\n            this.graph.removeListener(this.drillHandler);\n            this.graph.getView().removeListener(this.drillHandler);\n        }\n        if (this.escapeHandler) {\n            this.graph.removeListener(this.escapeHandler);\n        }\n    }\n}\nConnectionHandler.pluginId = 'ConnectionHandler';\nclass ConnectionHandlerCellMarker extends CellMarker {\n    constructor(graph, connectionHandler, validColor = DEFAULT_VALID_COLOR, invalidColor = DEFAULT_INVALID_COLOR, hotspot = DEFAULT_HOTSPOT) {\n        super(graph, validColor, invalidColor, hotspot);\n        this.hotspotEnabled = true;\n        this.connectionHandler = connectionHandler;\n    }\n    // Overrides to return cell at location only if valid (so that\n    // there is no highlight for invalid cells)\n    getCell(me) {\n        let cell = super.getCell(me);\n        this.connectionHandler.error = null;\n        // Checks for cell at preview point (with grid)\n        if (!cell && this.connectionHandler.currentPoint) {\n            cell = this.connectionHandler.graph.getCellAt(this.connectionHandler.currentPoint.x, this.connectionHandler.currentPoint.y);\n        }\n        // Uses connectable parent vertex if one exists\n        if (cell && !cell.isConnectable() && this.connectionHandler.cell) {\n            const parent = this.connectionHandler.cell.getParent();\n            if (parent && parent.isVertex() && parent.isConnectable()) {\n                cell = parent;\n            }\n        }\n        if (cell) {\n            if ((this.connectionHandler.graph.isSwimlane(cell) &&\n                this.connectionHandler.currentPoint != null &&\n                this.connectionHandler.graph.hitsSwimlaneContent(cell, this.connectionHandler.currentPoint.x, this.connectionHandler.currentPoint.y)) ||\n                !this.connectionHandler.isConnectableCell(cell)) {\n                cell = null;\n            }\n        }\n        if (cell) {\n            if (this.connectionHandler.isConnecting()) {\n                if (this.connectionHandler.previous) {\n                    this.connectionHandler.error = this.connectionHandler.validateConnection(this.connectionHandler.previous.cell, cell);\n                    if (this.connectionHandler.error !== null &&\n                        this.connectionHandler.error.length === 0) {\n                        cell = null;\n                        // Enables create target inside groups\n                        if (this.connectionHandler.isCreateTarget(me.getEvent())) {\n                            this.connectionHandler.error = null;\n                        }\n                    }\n                }\n            }\n            else if (!this.connectionHandler.isValidSource(cell, me)) {\n                cell = null;\n            }\n        }\n        else if (this.connectionHandler.isConnecting() &&\n            !this.connectionHandler.isCreateTarget(me.getEvent()) &&\n            !this.connectionHandler.graph.isAllowDanglingEdges()) {\n            this.connectionHandler.error = '';\n        }\n        return cell;\n    }\n    // Sets the highlight color according to validateConnection\n    isValidState(state) {\n        if (this.connectionHandler.isConnecting()) {\n            return !this.connectionHandler.error;\n        }\n        return super.isValidState(state);\n    }\n    // Overrides to use marker color only in highlight mode or for\n    // target selection\n    getMarkerColor(evt, state, isValid) {\n        return !this.connectionHandler.connectImage || this.connectionHandler.isConnecting()\n            ? super.getMarkerColor(evt, state, isValid)\n            : NONE;\n    }\n    // Overrides to use hotspot only for source selection otherwise\n    // intersects always returns true when over a cell\n    intersects(state, evt) {\n        if (this.connectionHandler.connectImage || this.connectionHandler.isConnecting()) {\n            return true;\n        }\n        return super.intersects(state, evt);\n    }\n}\nexport default ConnectionHandler;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6788, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6794, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/handler/SelectionHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../../Client';\nimport InternalEvent from '../event/InternalEvent';\nimport { contains, getRotatedPoint, isNumeric, toRadians } from '../../util/mathUtils';\nimport { convertPoint } from '../../util/styleUtils';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport mxGuide from '../other/Guide';\nimport Point from '../geometry/Point';\nimport { CURSOR, DIALECT, DROP_TARGET_COLOR, INVALID_CONNECT_TARGET_COLOR, NONE, VALID_COLOR, } from '../../util/Constants';\nimport Dictionary from '../../util/Dictionary';\nimport CellHighlight from '../cell/CellHighlight';\nimport Rectangle from '../geometry/Rectangle';\nimport { getClientX, getClientY, isAltDown, isMultiTouchEvent, } from '../../util/EventUtils';\n/**\n * Graph event handler that handles selection. Individual cells are handled\n * separately using {@link VertexHandler} or one of the edge handlers. These\n * handlers are created using {@link Graph#createHandler} in\n * {@link GraphSelectionModel#cellAdded}.\n *\n * To avoid the container to scroll a moved cell into view, set {@link scrollOnMove} to `false`.\n *\n * @category Plugin\n */\nclass SelectionHandler {\n    /**\n     * Constructs an event handler that creates handles for the selection cells.\n     *\n     * @param graph Reference to the enclosing {@link Graph}.\n     */\n    constructor(graph) {\n        this.refreshThread = null;\n        /**\n         * Defines the maximum number of cells to paint subhandles\n         * for. Default is 50 for Firefox and 20 for IE. Set this\n         * to 0 if you want an unlimited number of handles to be\n         * displayed. This is only recommended if the number of\n         * cells in the graph is limited to a small number, eg.\n         * 500.\n         */\n        this.maxCells = 50;\n        /**\n         * Specifies if events are handled. Default is true.\n         */\n        this.enabled = true;\n        /**\n         * Specifies if drop targets under the mouse should be enabled. Default is\n         * true.\n         */\n        this.highlightEnabled = true;\n        /**\n         * Specifies if cloning by control-drag is enabled. Default is true.\n         */\n        this.cloneEnabled = true;\n        /**\n         * Specifies if moving is enabled. Default is true.\n         */\n        this.moveEnabled = true;\n        /**\n         * Specifies if other cells should be used for snapping the right, center or\n         * left side of the current selection. Default is false.\n         */\n        this.guidesEnabled = false;\n        /**\n         * Whether the handles of the selection are currently visible.\n         */\n        this.handlesVisible = true;\n        /**\n         * Holds the {@link Guide} instance that is used for alignment.\n         */\n        this.guide = null;\n        /**\n         * Stores the x-coordinate of the current mouse move.\n         */\n        this.currentDx = 0;\n        /**\n         * Stores the y-coordinate of the current mouse move.\n         */\n        this.currentDy = 0;\n        /**\n         * Specifies if a move cursor should be shown if the mouse is over a movable\n         * cell. Default is true.\n         */\n        this.updateCursor = true;\n        /**\n         * Specifies if selecting is enabled. Default is true.\n         */\n        this.selectEnabled = true;\n        /**\n         * Specifies if cells may be moved out of their parents. Default is true.\n         */\n        this.removeCellsFromParent = true;\n        /**\n         * If empty parents should be removed from the model after all child cells\n         * have been moved out. Default is true.\n         */\n        this.removeEmptyParents = false;\n        /**\n         * Specifies if drop events are interpreted as new connections if no other\n         * drop action is defined. Default is false.\n         */\n        this.connectOnDrop = false;\n        /**\n         * Specifies if the view should be scrolled so that a moved cell is visible.\n         * @default true\n         */\n        this.scrollOnMove = true;\n        /**\n         * Specifies the minimum number of pixels for the width and height of a\n         * selection border. Default is 6.\n         */\n        this.minimumSize = 6;\n        /**\n         * Specifies the color of the preview shape. Default is black.\n         */\n        this.previewColor = 'black';\n        /**\n         * Specifies if the graph container should be used for preview. If this is used\n         * then drop target detection relies entirely on {@link Graph#getCellAt} because\n         * the HTML preview does not \"let events through\". Default is false.\n         */\n        this.htmlPreview = false;\n        /**\n         * Reference to the {@link Shape} that represents the preview.\n         */\n        this.shape = null;\n        /**\n         * Specifies if the grid should be scaled. Default is false.\n         */\n        this.scaleGrid = false;\n        /**\n         * Specifies if the bounding box should allow for rotation. Default is true.\n         */\n        this.rotationEnabled = true;\n        /**\n         * Maximum number of cells for which live preview should be used.  Default is 0 which means no live preview.\n         */\n        this.maxLivePreview = 0;\n        /**\n         * Variable allowLivePreview\n         *\n         * If live preview is allowed on this system.  Default is true for systems with SVG support.\n         */\n        this.allowLivePreview = Client.IS_SVG;\n        this.cell = null;\n        this.delayedSelection = false;\n        this.first = null;\n        this.cells = null;\n        this.bounds = null;\n        this.pBounds = null;\n        this.allCells = new Dictionary();\n        this.cellWasClicked = false;\n        this.cloning = false;\n        this.cellCount = 0;\n        this.target = null;\n        this.suspended = false;\n        this.livePreviewActive = false;\n        this.livePreviewUsed = false;\n        this.highlight = null;\n        this.graph = graph;\n        this.graph.addMouseListener(this);\n        // Repaints the handler after autoscroll\n        this.panHandler = () => {\n            if (!this.suspended) {\n                this.updatePreview();\n                this.updateHint();\n            }\n        };\n        this.graph.addListener(InternalEvent.PAN, this.panHandler);\n        // Handles escape keystrokes\n        this.escapeHandler = (sender, evt) => {\n            this.reset();\n        };\n        this.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);\n        // Updates the preview box for remote changes\n        this.refreshHandler = (sender, evt) => {\n            // Merges multiple pending calls\n            if (this.refreshThread) {\n                window.clearTimeout(this.refreshThread);\n            }\n            // Waits for the states and handlers to be updated\n            this.refreshThread = window.setTimeout(() => {\n                this.refreshThread = null;\n                if (this.first && !this.suspended && this.cells) {\n                    // Updates preview with no translate to compute bounding box\n                    const dx = this.currentDx;\n                    const dy = this.currentDy;\n                    this.currentDx = 0;\n                    this.currentDy = 0;\n                    this.updatePreview();\n                    this.bounds = this.graph.getView().getBounds(this.cells);\n                    this.pBounds = this.getPreviewBounds(this.cells);\n                    if (this.pBounds == null && !this.livePreviewUsed) {\n                        this.reset();\n                    }\n                    else {\n                        // Restores translate and updates preview\n                        this.currentDx = dx;\n                        this.currentDy = dy;\n                        this.updatePreview();\n                        this.updateHint();\n                        if (this.livePreviewUsed) {\n                            const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n                            // Forces update to ignore last visible state\n                            this.setHandlesVisibleForCells(selectionCellsHandler?.getHandledSelectionCells() ?? [], false, true);\n                            this.updatePreview();\n                        }\n                    }\n                }\n            }, 0);\n        };\n        this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.refreshHandler);\n        this.graph.addListener(InternalEvent.REFRESH, this.refreshHandler);\n        this.keyHandler = (e) => {\n            if (this.graph.container != null &&\n                this.graph.container.style.visibility !== 'hidden' &&\n                this.first != null &&\n                !this.suspended) {\n                const clone = this.graph.isCloneEvent(e) &&\n                    this.graph.isCellsCloneable() &&\n                    this.isCloneEnabled();\n                if (clone !== this.cloning) {\n                    this.cloning = clone;\n                    this.checkPreview();\n                    this.updatePreview();\n                }\n            }\n        };\n        if (typeof document !== 'undefined') {\n            InternalEvent.addListener(document, 'keydown', this.keyHandler);\n            InternalEvent.addListener(document, 'keyup', this.keyHandler);\n        }\n    }\n    /**\n     * Returns <enabled>.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Sets <enabled>.\n     */\n    setEnabled(value) {\n        this.enabled = value;\n    }\n    /**\n     * Returns <cloneEnabled>.\n     */\n    isCloneEnabled() {\n        return this.cloneEnabled;\n    }\n    /**\n     * Sets <cloneEnabled>.\n     *\n     * @param value Boolean that specifies the new clone enabled state.\n     */\n    setCloneEnabled(value) {\n        this.cloneEnabled = value;\n    }\n    /**\n     * Returns {@link oveEnabled}.\n     */\n    isMoveEnabled() {\n        return this.moveEnabled;\n    }\n    /**\n     * Sets {@link oveEnabled}.\n     */\n    setMoveEnabled(value) {\n        this.moveEnabled = value;\n    }\n    /**\n     * Returns <selectEnabled>.\n     */\n    isSelectEnabled() {\n        return this.selectEnabled;\n    }\n    /**\n     * Sets <selectEnabled>.\n     */\n    setSelectEnabled(value) {\n        this.selectEnabled = value;\n    }\n    /**\n     * Returns <removeCellsFromParent>.\n     */\n    isRemoveCellsFromParent() {\n        return this.removeCellsFromParent;\n    }\n    /**\n     * Sets <removeCellsFromParent>.\n     */\n    setRemoveCellsFromParent(value) {\n        this.removeCellsFromParent = value;\n    }\n    /**\n     * Returns true if the given cell and parent should propagate\n     * selection state to the parent.\n     */\n    isPropagateSelectionCell(cell, immediate, me) {\n        const parent = cell.getParent();\n        if (immediate) {\n            const geo = cell.isEdge() ? null : cell.getGeometry();\n            return ((!this.graph.isSiblingSelected(cell) && geo && geo.relative) ||\n                !this.graph.isSwimlane(parent));\n        }\n        return ((!this.graph.isToggleEvent(me.getEvent()) ||\n            (!this.graph.isSiblingSelected(cell) &&\n                !this.graph.isCellSelected(cell) &&\n                !this.graph.isSwimlane(parent)) ||\n            this.graph.isCellSelected(parent)) &&\n            (this.graph.isToggleEvent(me.getEvent()) || !this.graph.isCellSelected(parent)));\n    }\n    /**\n     * Hook to return initial cell for the given event.\n     */\n    getInitialCellForEvent(me) {\n        let state = me.getState();\n        if ((!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) &&\n            state &&\n            !this.graph.isCellSelected(state.cell)) {\n            let parent = state.cell.getParent();\n            let next = parent ? this.graph.view.getState(parent) : null;\n            while (next &&\n                !this.graph.isCellSelected(next.cell) &&\n                (next.cell.isVertex() || next.cell.isEdge()) &&\n                this.isPropagateSelectionCell(state.cell, true, me)) {\n                state = next;\n                parent = state.cell.getParent();\n                next = parent ? this.graph.view.getState(parent) : null;\n            }\n        }\n        return state ? state.cell : null;\n    }\n    /**\n     * Hook to return true for delayed selections.\n     */\n    isDelayedSelection(cell, me) {\n        let c = cell;\n        const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n        if (!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) {\n            while (c) {\n                if (selectionCellsHandler?.isHandled(c)) {\n                    const cellEditorHandler = this.graph.getPlugin('CellEditorHandler');\n                    return cellEditorHandler?.getEditingCell() !== c;\n                }\n                c = c.getParent();\n            }\n        }\n        return this.graph.isToggleEvent(me.getEvent()) && !isAltDown(me.getEvent());\n    }\n    /**\n     * Implements the delayed selection for the given mouse event.\n     */\n    selectDelayed(me) {\n        const popupMenuHandler = this.graph.getPlugin('PopupMenuHandler');\n        if (!popupMenuHandler || !popupMenuHandler.isPopupTrigger(me)) {\n            let cell = me.getCell();\n            if (cell === null) {\n                cell = this.cell;\n            }\n            if (cell)\n                this.selectCellForEvent(cell, me);\n        }\n    }\n    /**\n     * Selects the given cell for the given {@link MouseEvent}.\n     */\n    selectCellForEvent(cell, me) {\n        const state = this.graph.view.getState(cell);\n        if (state) {\n            if (me.isSource(state.control)) {\n                this.graph.selectCellForEvent(cell, me.getEvent());\n            }\n            else {\n                if (!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) {\n                    let parent = cell.getParent();\n                    while (parent &&\n                        this.graph.view.getState(parent) &&\n                        (parent.isVertex() || parent.isEdge()) &&\n                        this.isPropagateSelectionCell(cell, false, me)) {\n                        cell = parent;\n                        parent = cell.getParent();\n                    }\n                }\n                this.graph.selectCellForEvent(cell, me.getEvent());\n            }\n        }\n        return cell;\n    }\n    /**\n     * Consumes the given mouse event. NOTE: This may be used to enable click\n     * events for links in labels on iOS as follows as consuming the initial\n     * touchStart disables firing the subsequent click evnent on the link.\n     *\n     * <code>\n     * consumeMouseEvent(evtName, me)\n     * {\n     *   var source = mxEvent.getSource(me.getEvent());\n     *\n     *   if (!mxEvent.isTouchEvent(me.getEvent()) || source.nodeName != 'A')\n     *   {\n     *     me.consume();\n     *   }\n     * }\n     * </code>\n     */\n    consumeMouseEvent(evtName, me) {\n        me.consume();\n    }\n    /**\n     * Handles the event by selecing the given cell and creating a handle for\n     * it. By consuming the event all subsequent events of the gesture are\n     * redirected to this handler.\n     */\n    mouseDown(sender, me) {\n        if (!me.isConsumed() &&\n            this.isEnabled() &&\n            this.graph.isEnabled() &&\n            me.getState() &&\n            !isMultiTouchEvent(me.getEvent())) {\n            const cell = this.getInitialCellForEvent(me);\n            if (cell) {\n                this.delayedSelection = this.isDelayedSelection(cell, me);\n                this.cell = null;\n                if (this.isSelectEnabled() && !this.delayedSelection) {\n                    this.graph.selectCellForEvent(cell, me.getEvent());\n                }\n                if (this.isMoveEnabled()) {\n                    const geo = cell.getGeometry();\n                    if (geo &&\n                        this.graph.isCellMovable(cell) &&\n                        (!cell.isEdge() ||\n                            this.graph.getSelectionCount() > 1 ||\n                            (geo.points && geo.points.length > 0) ||\n                            !cell.getTerminal(true) ||\n                            !cell.getTerminal(false) ||\n                            this.graph.isAllowDanglingEdges() ||\n                            (this.graph.isCloneEvent(me.getEvent()) && this.graph.isCellsCloneable()))) {\n                        this.start(cell, me.getX(), me.getY());\n                    }\n                    else if (this.delayedSelection) {\n                        this.cell = cell;\n                    }\n                    this.cellWasClicked = true;\n                    this.consumeMouseEvent(InternalEvent.MOUSE_DOWN, me);\n                }\n            }\n        }\n    }\n    /**\n     * Creates an array of cell states which should be used as guides.\n     */\n    getGuideStates() {\n        const parent = this.graph.getDefaultParent();\n        const filter = (cell) => {\n            const geo = cell.getGeometry();\n            return (!!this.graph.view.getState(cell) && cell.isVertex() && !!geo && !geo.relative);\n        };\n        return this.graph.view.getCellStates(parent.filterDescendants(filter));\n    }\n    /**\n     * Returns the cells to be modified by this handler. This implementation\n     * returns all selection cells that are movable, or the given initial cell if\n     * the given cell is not selected and movable. This handles the case of moving\n     * unselectable or unselected cells.\n     *\n     * @param initialCell <Cell> that triggered this handler.\n     */\n    getCells(initialCell) {\n        if (!this.delayedSelection && this.graph.isCellMovable(initialCell)) {\n            return [initialCell];\n        }\n        return this.graph.getMovableCells(this.graph.getSelectionCells());\n    }\n    /**\n     * Returns the {@link Rectangle} used as the preview bounds for\n     * moving the given cells.\n     */\n    getPreviewBounds(cells) {\n        const bounds = this.getBoundingBox(cells);\n        if (bounds) {\n            // Corrects width and height\n            bounds.width = Math.max(0, bounds.width - 1);\n            bounds.height = Math.max(0, bounds.height - 1);\n            if (bounds.width < this.minimumSize) {\n                const dx = this.minimumSize - bounds.width;\n                bounds.x -= dx / 2;\n                bounds.width = this.minimumSize;\n            }\n            else {\n                bounds.x = Math.round(bounds.x);\n                bounds.width = Math.ceil(bounds.width);\n            }\n            if (bounds.height < this.minimumSize) {\n                const dy = this.minimumSize - bounds.height;\n                bounds.y -= dy / 2;\n                bounds.height = this.minimumSize;\n            }\n            else {\n                bounds.y = Math.round(bounds.y);\n                bounds.height = Math.ceil(bounds.height);\n            }\n        }\n        return bounds;\n    }\n    /**\n     * Returns the union of the {@link CellStates} for the given array of {@link Cells}.\n     * For vertices, this method uses the bounding box of the corresponding shape\n     * if one exists. The bounding box of the corresponding text label and all\n     * controls and overlays are ignored. See also: {@link GraphView#getBounds} and\n     * {@link Graph#getBoundingBox}.\n     *\n     * @param cells Array of {@link Cells} whose bounding box should be returned.\n     */\n    getBoundingBox(cells) {\n        let result = null;\n        if (cells.length > 0) {\n            for (let i = 0; i < cells.length; i += 1) {\n                if (cells[i].isVertex() || cells[i].isEdge()) {\n                    const state = this.graph.view.getState(cells[i]);\n                    if (state) {\n                        let bbox = null;\n                        if (cells[i].isVertex() && state.shape && state.shape.boundingBox) {\n                            bbox = state.shape.boundingBox;\n                        }\n                        if (bbox) {\n                            if (!result) {\n                                result = Rectangle.fromRectangle(bbox);\n                            }\n                            else {\n                                result.add(bbox);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Creates the shape used to draw the preview for the given bounds.\n     */\n    createPreviewShape(bounds) {\n        const shape = new RectangleShape(bounds, NONE, this.previewColor);\n        shape.isDashed = true;\n        if (this.htmlPreview) {\n            shape.dialect = DIALECT.STRICTHTML;\n            shape.init(this.graph.container);\n        }\n        else {\n            // Makes sure to use either VML or SVG shapes in order to implement\n            // event-transparency on the background area of the rectangle since\n            // HTML shapes do not let mouseevents through even when transparent\n            shape.dialect = DIALECT.SVG;\n            shape.init(this.graph.getView().getOverlayPane());\n            shape.pointerEvents = false;\n            // Workaround for artifacts on iOS\n            if (Client.IS_IOS) {\n                shape.getSvgScreenOffset = () => {\n                    return 0;\n                };\n            }\n        }\n        return shape;\n    }\n    createGuide() {\n        return new mxGuide(this.graph, this.getGuideStates());\n    }\n    /**\n     * Starts the handling of the mouse gesture.\n     */\n    start(cell, x, y, cells) {\n        this.cell = cell;\n        this.first = convertPoint(this.graph.container, x, y);\n        this.cells = cells ? cells : this.getCells(this.cell);\n        this.bounds = this.graph.getView().getBounds(this.cells);\n        this.pBounds = this.getPreviewBounds(this.cells);\n        this.cloning = false;\n        this.cellCount = 0;\n        for (let i = 0; i < this.cells.length; i += 1) {\n            this.cellCount += this.addStates(this.cells[i], this.allCells);\n        }\n        if (this.guidesEnabled) {\n            this.guide = this.createGuide();\n            const parent = cell.getParent();\n            const ignore = parent.getChildCount() < 2;\n            // Uses connected states as guides\n            const connected = new Dictionary();\n            const opps = this.graph.getOpposites(this.graph.getEdges(this.cell), this.cell);\n            for (let i = 0; i < opps.length; i += 1) {\n                const state = this.graph.view.getState(opps[i]);\n                if (state && !connected.get(state)) {\n                    connected.put(state, true);\n                }\n            }\n            this.guide.isStateIgnored = (state) => {\n                const p = state.cell.getParent();\n                return (!!state.cell &&\n                    ((!this.cloning && !!this.isCellMoving(state.cell)) ||\n                        (state.cell !== (this.target || parent) &&\n                            !ignore &&\n                            !connected.get(state) &&\n                            (!this.target || this.target.getChildCount() >= 2) &&\n                            p !== (this.target || parent))));\n            };\n        }\n    }\n    /**\n     * Adds the states for the given cell recursively to the given dictionary.\n     * @param cell\n     * @param dict\n     */\n    addStates(cell, dict) {\n        const state = this.graph.view.getState(cell);\n        let count = 0;\n        if (state && !dict.get(cell)) {\n            dict.put(cell, state);\n            count++;\n            const childCount = cell.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                count += this.addStates(cell.getChildAt(i), dict);\n            }\n        }\n        return count;\n    }\n    /**\n     * Returns true if the given cell is currently being moved.\n     */\n    isCellMoving(cell) {\n        return this.allCells.get(cell);\n    }\n    /**\n     * Returns true if the guides should be used for the given {@link MouseEvent}.\n     * This implementation returns {@link Guide#isEnabledForEvent}.\n     */\n    useGuidesForEvent(me) {\n        return this.guide\n            ? this.guide.isEnabledForEvent(me.getEvent()) &&\n                !this.graph.isConstrainedEvent(me.getEvent())\n            : true;\n    }\n    /**\n     * Snaps the given vector to the grid and returns the given mxPoint instance.\n     */\n    snap(vector) {\n        const scale = this.scaleGrid ? this.graph.view.scale : 1;\n        vector.x = this.graph.snap(vector.x / scale) * scale;\n        vector.y = this.graph.snap(vector.y / scale) * scale;\n        return vector;\n    }\n    /**\n     * Returns an {@link Point} that represents the vector for moving the cells\n     * for the given {@link MouseEvent}.\n     */\n    getDelta(me) {\n        const point = convertPoint(this.graph.container, me.getX(), me.getY());\n        if (!this.first)\n            return new Point();\n        return new Point(point.x - this.first.x - this.graph.getPanDx(), point.y - this.first.y - this.graph.getPanDy());\n    }\n    /**\n     * Hook for subclassers do show details while the handler is active.\n     */\n    updateHint(me) {\n        return;\n    }\n    /**\n     * Hooks for subclassers to hide details when the handler gets inactive.\n     */\n    removeHint() {\n        return;\n    }\n    /**\n     * Hook for rounding the unscaled vector. This uses Math.round.\n     */\n    roundLength(length) {\n        return Math.round(length * 100) / 100;\n    }\n    /**\n     * Returns true if the given cell is a valid drop target.\n     */\n    isValidDropTarget(target, me) {\n        return this.cell ? this.cell.getParent() !== target : false;\n    }\n    /**\n     * Updates the preview if cloning state has changed.\n     */\n    checkPreview() {\n        if (this.livePreviewActive && this.cloning) {\n            this.resetLivePreview();\n            this.livePreviewActive = false;\n        }\n        else if (this.maxLivePreview >= this.cellCount &&\n            !this.livePreviewActive &&\n            this.allowLivePreview) {\n            if (!this.cloning || !this.livePreviewActive) {\n                this.livePreviewActive = true;\n                this.livePreviewUsed = true;\n            }\n        }\n        else if (!this.livePreviewUsed && !this.shape && this.bounds) {\n            this.shape = this.createPreviewShape(this.bounds);\n        }\n    }\n    /**\n     * Handles the event by highlighting possible drop targets and updating the\n     * preview.\n     */\n    mouseMove(sender, me) {\n        const { graph } = this;\n        if (!me.isConsumed() &&\n            graph.isMouseDown &&\n            this.cell &&\n            this.first &&\n            this.bounds &&\n            !this.suspended) {\n            // Stops moving if a multi touch event is received\n            if (isMultiTouchEvent(me.getEvent())) {\n                this.reset();\n                return;\n            }\n            let delta = this.getDelta(me);\n            const tol = graph.getEventTolerance();\n            if (this.shape ||\n                this.livePreviewActive ||\n                Math.abs(delta.x) > tol ||\n                Math.abs(delta.y) > tol) {\n                // Highlight is used for highlighting drop targets\n                if (!this.highlight) {\n                    this.highlight = new CellHighlight(this.graph, DROP_TARGET_COLOR, 3);\n                }\n                const clone = graph.isCloneEvent(me.getEvent()) &&\n                    graph.isCellsCloneable() &&\n                    this.isCloneEnabled();\n                const gridEnabled = graph.isGridEnabledEvent(me.getEvent());\n                const cell = me.getCell();\n                let hideGuide = true;\n                let target = null;\n                this.cloning = clone;\n                if (graph.isDropEnabled() && this.highlightEnabled && this.cells) {\n                    // Contains a call to getCellAt to find the cell under the mouse\n                    target = graph.getDropTarget(this.cells, me.getEvent(), cell, clone);\n                }\n                let state = target ? graph.getView().getState(target) : null;\n                let highlight = false;\n                if (state && (clone || (target && this.isValidDropTarget(target, me)))) {\n                    if (this.target !== target) {\n                        this.target = target;\n                        this.setHighlightColor(DROP_TARGET_COLOR);\n                    }\n                    highlight = true;\n                }\n                else {\n                    this.target = null;\n                    if (this.connectOnDrop &&\n                        cell &&\n                        this.cells &&\n                        this.cells.length === 1 &&\n                        cell.isVertex() &&\n                        cell.isConnectable()) {\n                        state = graph.getView().getState(cell);\n                        if (state) {\n                            const error = graph.getEdgeValidationError(null, this.cell, cell);\n                            const color = error === null ? VALID_COLOR : INVALID_CONNECT_TARGET_COLOR;\n                            this.setHighlightColor(color);\n                            highlight = true;\n                        }\n                    }\n                }\n                if (state && highlight) {\n                    this.highlight.highlight(state);\n                }\n                else {\n                    this.highlight.hide();\n                }\n                if (this.guide && this.useGuidesForEvent(me)) {\n                    delta = this.guide.move(this.bounds, delta, gridEnabled, clone);\n                    hideGuide = false;\n                }\n                else {\n                    delta = this.graph.snapDelta(delta, this.bounds, !gridEnabled, false, false);\n                }\n                if (this.guide && hideGuide) {\n                    this.guide.hide();\n                }\n                // Constrained movement if shift key is pressed\n                if (graph.isConstrainedEvent(me.getEvent())) {\n                    if (Math.abs(delta.x) > Math.abs(delta.y)) {\n                        delta.y = 0;\n                    }\n                    else {\n                        delta.x = 0;\n                    }\n                }\n                this.checkPreview();\n                if (this.currentDx !== delta.x || this.currentDy !== delta.y) {\n                    this.currentDx = delta.x;\n                    this.currentDy = delta.y;\n                    this.updatePreview();\n                }\n            }\n            this.updateHint(me);\n            this.consumeMouseEvent(InternalEvent.MOUSE_MOVE, me);\n            // Cancels the bubbling of events to the container so\n            // that the droptarget is not reset due to an mouseMove\n            // fired on the container with no associated state.\n            InternalEvent.consume(me.getEvent());\n        }\n        else if ((this.isMoveEnabled() || this.isCloneEnabled()) &&\n            this.updateCursor &&\n            !me.isConsumed() &&\n            (me.getState() || me.sourceState) &&\n            !graph.isMouseDown) {\n            let cursor = graph.getCursorForMouseEvent(me);\n            const cell = me.getCell();\n            if (!cursor && cell && graph.isEnabled() && graph.isCellMovable(cell)) {\n                if (cell.isEdge()) {\n                    cursor = CURSOR.MOVABLE_EDGE;\n                }\n                else {\n                    cursor = CURSOR.MOVABLE_VERTEX;\n                }\n            }\n            // Sets the cursor on the original source state under the mouse\n            // instead of the event source state which can be the parent\n            if (cursor && me.sourceState) {\n                me.sourceState.setCursor(cursor);\n            }\n        }\n    }\n    /**\n     * Updates the bounds of the preview shape.\n     */\n    updatePreview(remote = false) {\n        if (this.livePreviewUsed && !remote) {\n            if (this.cells) {\n                const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n                this.setHandlesVisibleForCells(selectionCellsHandler?.getHandledSelectionCells() ?? [], false);\n                this.updateLivePreview(this.currentDx, this.currentDy);\n            }\n        }\n        else {\n            this.updatePreviewShape();\n        }\n    }\n    /**\n     * Updates the bounds of the preview shape.\n     */\n    updatePreviewShape() {\n        if (this.shape && this.pBounds) {\n            this.shape.bounds = new Rectangle(Math.round(this.pBounds.x + this.currentDx), Math.round(this.pBounds.y + this.currentDy), this.pBounds.width, this.pBounds.height);\n            this.shape.redraw();\n        }\n    }\n    /**\n     * Updates the bounds of the preview shape.\n     */\n    updateLivePreview(dx, dy) {\n        if (!this.suspended) {\n            const states = [];\n            if (this.allCells) {\n                this.allCells.visit((key, state) => {\n                    const realState = state ? this.graph.view.getState(state.cell) : null;\n                    // Checks if cell was removed or replaced\n                    if (realState !== state && state) {\n                        state.destroy();\n                        if (realState) {\n                            this.allCells.put(state.cell, realState);\n                        }\n                        else {\n                            this.allCells.remove(state.cell);\n                        }\n                        state = realState;\n                    }\n                    if (state) {\n                        // Saves current state\n                        const tempState = state.clone();\n                        states.push([state, tempState]);\n                        // Makes transparent for events to detect drop targets\n                        if (state.shape) {\n                            if (state.shape.originalPointerEvents === null) {\n                                state.shape.originalPointerEvents = state.shape.pointerEvents;\n                            }\n                            state.shape.pointerEvents = false;\n                            if (state.text) {\n                                if (state.text.originalPointerEvents === null) {\n                                    state.text.originalPointerEvents = state.text.pointerEvents;\n                                }\n                                state.text.pointerEvents = false;\n                            }\n                        }\n                        // Temporarily changes position\n                        if (state.cell.isVertex()) {\n                            state.x += dx;\n                            state.y += dy;\n                            // Draws the live preview\n                            if (!this.cloning) {\n                                state.view.graph.cellRenderer.redraw(state, true);\n                                // Forces redraw of connected edges after all states\n                                // have been updated but avoids update of state\n                                state.view.invalidate(state.cell);\n                                state.invalid = false;\n                                // Hides folding icon\n                                if (state.control && state.control.node) {\n                                    state.control.node.style.visibility = 'hidden';\n                                }\n                            }\n                            // Clone live preview may use text bounds\n                            else if (state.text) {\n                                state.text.updateBoundingBox();\n                                // Fixes preview box for edge labels\n                                if (state.text.boundingBox) {\n                                    state.text.boundingBox.x += dx;\n                                    state.text.boundingBox.y += dy;\n                                }\n                                if (state.text.unrotatedBoundingBox) {\n                                    state.text.unrotatedBoundingBox.x += dx;\n                                    state.text.unrotatedBoundingBox.y += dy;\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            // Resets the handler if everything was removed\n            if (states.length === 0) {\n                this.reset();\n            }\n            else {\n                // Redraws connected edges\n                const s = this.graph.view.scale;\n                for (let i = 0; i < states.length; i += 1) {\n                    const state = states[i][0];\n                    if (state.cell.isEdge()) {\n                        const geometry = state.cell.getGeometry();\n                        const points = [];\n                        if (geometry && geometry.points) {\n                            for (let j = 0; j < geometry.points.length; j++) {\n                                if (geometry.points[j]) {\n                                    points.push(new Point(geometry.points[j].x + dx / s, geometry.points[j].y + dy / s));\n                                }\n                            }\n                        }\n                        let source = state.visibleSourceState;\n                        let target = state.visibleTargetState;\n                        const pts = states[i][1].absolutePoints;\n                        if (source == null || !this.isCellMoving(source.cell)) {\n                            const pt0 = pts[0];\n                            if (pt0) {\n                                state.setAbsoluteTerminalPoint(new Point(pt0.x + dx, pt0.y + dy), true);\n                                source = null;\n                            }\n                        }\n                        else {\n                            state.view.updateFixedTerminalPoint(state, source, true, this.graph.getConnectionConstraint(state, source, true));\n                        }\n                        if (target == null || !this.isCellMoving(target.cell)) {\n                            const ptn = pts[pts.length - 1];\n                            if (ptn) {\n                                state.setAbsoluteTerminalPoint(new Point(ptn.x + dx, ptn.y + dy), false);\n                                target = null;\n                            }\n                        }\n                        else {\n                            state.view.updateFixedTerminalPoint(state, target, false, this.graph.getConnectionConstraint(state, target, false));\n                        }\n                        state.view.updatePoints(state, points, source, target);\n                        state.view.updateFloatingTerminalPoints(state, source, target);\n                        state.view.updateEdgeLabelOffset(state);\n                        state.invalid = false;\n                        // Draws the live preview but avoids update of state\n                        if (!this.cloning) {\n                            state.view.graph.cellRenderer.redraw(state, true);\n                        }\n                    }\n                }\n                this.graph.view.validate();\n                this.redrawHandles(states);\n                this.resetPreviewStates(states);\n            }\n        }\n    }\n    /**\n     * Redraws the preview shape for the given states array.\n     */\n    redrawHandles(states) {\n        const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n        for (let i = 0; i < states.length; i += 1) {\n            const handler = selectionCellsHandler?.getHandler(states[i][0].cell);\n            handler?.redraw(true);\n        }\n    }\n    /**\n     * Resets the given preview states array.\n     */\n    resetPreviewStates(states) {\n        for (let i = 0; i < states.length; i += 1) {\n            states[i][0].setState(states[i][1]);\n        }\n    }\n    /**\n     * Suspends the livew preview.\n     */\n    suspend() {\n        if (!this.suspended) {\n            if (this.livePreviewUsed) {\n                this.updateLivePreview(0, 0);\n            }\n            if (this.shape) {\n                this.shape.node.style.visibility = 'hidden';\n            }\n            if (this.guide) {\n                this.guide.setVisible(false);\n            }\n            this.suspended = true;\n        }\n    }\n    /**\n     * Suspends the livew preview.\n     */\n    resume() {\n        if (this.suspended) {\n            this.suspended = false;\n            if (this.livePreviewUsed) {\n                this.livePreviewActive = true;\n            }\n            if (this.shape) {\n                this.shape.node.style.visibility = 'visible';\n            }\n            if (this.guide) {\n                this.guide.setVisible(true);\n            }\n        }\n    }\n    /**\n     * Resets the livew preview.\n     */\n    resetLivePreview() {\n        this.allCells.visit((key, state) => {\n            // Restores event handling\n            if (state.shape && state.shape.originalPointerEvents !== null) {\n                state.shape.pointerEvents = state.shape.originalPointerEvents;\n                state.shape.originalPointerEvents = null;\n                // Forces repaint even if not moved to update pointer events\n                state.shape.bounds = null;\n                if (state.text && state.text.originalPointerEvents !== null) {\n                    state.text.pointerEvents = state.text.originalPointerEvents;\n                    state.text.originalPointerEvents = null;\n                }\n            }\n            // Shows folding icon\n            if (state.control &&\n                state.control.node &&\n                state.control.node.style.visibility === 'hidden') {\n                state.control.node.style.visibility = '';\n            }\n            // Fixes preview box for edge labels\n            if (!this.cloning) {\n                if (state.text) {\n                    state.text.updateBoundingBox();\n                }\n            }\n            // Forces repaint of connected edges\n            state.view.invalidate(state.cell);\n        });\n        // Repaints all invalid states\n        this.graph.view.validate();\n    }\n    /**\n     * Sets wether the handles attached to the given cells are visible.\n     *\n     * @param cells Array of {@link Cells}.\n     * @param visible Boolean that specifies if the handles should be visible.\n     * @param force Forces an update of the handler regardless of the last used value.\n     */\n    setHandlesVisibleForCells(cells, visible, force = false) {\n        if (force || this.handlesVisible !== visible) {\n            this.handlesVisible = visible;\n            const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n            for (let i = 0; i < cells.length; i += 1) {\n                const handler = selectionCellsHandler?.getHandler(cells[i]);\n                if (handler) {\n                    handler.setHandlesVisible(visible);\n                    if (visible) {\n                        handler.redraw();\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Sets the color of the rectangle used to highlight drop targets.\n     *\n     * @param color String that represents the new highlight color.\n     */\n    setHighlightColor(color) {\n        if (this.highlight) {\n            this.highlight.setHighlightColor(color);\n        }\n    }\n    /**\n     * Handles the event by applying the changes to the selection cells.\n     */\n    mouseUp(sender, me) {\n        if (!me.isConsumed()) {\n            if (this.livePreviewUsed) {\n                this.resetLivePreview();\n            }\n            if (this.cell &&\n                this.first &&\n                (this.shape || this.livePreviewUsed) &&\n                isNumeric(this.currentDx) &&\n                isNumeric(this.currentDy)) {\n                const { graph } = this;\n                const cell = me.getCell();\n                if (this.connectOnDrop &&\n                    !this.target &&\n                    cell &&\n                    cell.isVertex() &&\n                    cell.isConnectable() &&\n                    graph.isEdgeValid(null, this.cell, cell)) {\n                    const connectionHandler = graph.getPlugin('ConnectionHandler');\n                    connectionHandler?.connect(this.cell, cell, me.getEvent());\n                }\n                else {\n                    const clone = graph.isCloneEvent(me.getEvent()) &&\n                        graph.isCellsCloneable() &&\n                        this.isCloneEnabled();\n                    const { scale } = graph.getView();\n                    const dx = this.roundLength(this.currentDx / scale);\n                    const dy = this.roundLength(this.currentDy / scale);\n                    const target = this.target;\n                    if (target &&\n                        graph.isSplitEnabled() &&\n                        this.cells &&\n                        graph.isSplitTarget(target, this.cells, me.getEvent())) {\n                        graph.splitEdge(target, this.cells, null, dx, dy, me.getGraphX(), me.getGraphY());\n                    }\n                    else if (this.cells) {\n                        this.moveCells(this.cells, dx, dy, clone, this.target, me.getEvent());\n                    }\n                }\n            }\n            else if (this.isSelectEnabled() && this.delayedSelection && this.cell != null) {\n                this.selectDelayed(me);\n            }\n        }\n        // Consumes the event if a cell was initially clicked\n        if (this.cellWasClicked) {\n            this.consumeMouseEvent(InternalEvent.MOUSE_UP, me);\n        }\n        this.reset();\n    }\n    /**\n     * Resets the state of this handler.\n     */\n    reset() {\n        if (this.livePreviewUsed) {\n            this.resetLivePreview();\n            const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n            this.setHandlesVisibleForCells(selectionCellsHandler?.getHandledSelectionCells() ?? [], true);\n        }\n        this.destroyShapes();\n        this.removeHint();\n        this.delayedSelection = false;\n        this.livePreviewActive = false;\n        this.livePreviewUsed = false;\n        this.cellWasClicked = false;\n        this.suspended = false;\n        this.currentDx = 0;\n        this.currentDy = 0;\n        this.cellCount = 0;\n        this.cloning = false;\n        this.allCells.clear();\n        this.pBounds = null;\n        this.target = null;\n        this.first = null;\n        this.cells = null;\n        this.cell = null;\n    }\n    /**\n     * Returns true if the given cells should be removed from the parent for the specified\n     * mousereleased event.\n     */\n    shouldRemoveCellsFromParent(parent, cells, evt) {\n        if (parent.isVertex()) {\n            const pState = this.graph.getView().getState(parent);\n            if (pState) {\n                let pt = convertPoint(this.graph.container, getClientX(evt), getClientY(evt));\n                const alpha = toRadians(pState.style.rotation ?? 0);\n                if (alpha !== 0) {\n                    const cos = Math.cos(-alpha);\n                    const sin = Math.sin(-alpha);\n                    const cx = new Point(pState.getCenterX(), pState.getCenterY());\n                    pt = getRotatedPoint(pt, cos, sin, cx);\n                }\n                return !contains(pState, pt.x, pt.y);\n            }\n        }\n        return false;\n    }\n    /**\n     * Moves the given cells by the specified amount.\n     */\n    moveCells(cells, dx, dy, clone, target, evt) {\n        if (!this.cell)\n            return;\n        if (clone) {\n            cells = this.graph.getCloneableCells(cells);\n        }\n        // Removes cells from parent\n        const parent = this.cell.getParent();\n        if (!target &&\n            parent &&\n            this.isRemoveCellsFromParent() &&\n            this.shouldRemoveCellsFromParent(parent, cells, evt)) {\n            target = this.graph.getDefaultParent();\n        }\n        // Cloning into locked cells is not allowed\n        clone = !!clone && !this.graph.isCellLocked(target || this.graph.getDefaultParent());\n        this.graph.batchUpdate(() => {\n            const parents = [];\n            // Removes parent if all child cells are removed\n            if (!clone && target && this.removeEmptyParents) {\n                // Collects all non-selected parents\n                const dict = new Dictionary();\n                for (let i = 0; i < cells.length; i += 1) {\n                    dict.put(cells[i], true);\n                }\n                // LATER: Recurse up the cell hierarchy\n                for (let i = 0; i < cells.length; i += 1) {\n                    const par = cells[i].getParent();\n                    if (par && !dict.get(par)) {\n                        dict.put(par, true);\n                        parents.push(par);\n                    }\n                }\n            }\n            // Passes all selected cells in order to correctly clone or move into\n            // the target cell. The method checks for each cell if its movable.\n            cells = this.graph.moveCells(cells, dx, dy, clone, target, evt);\n            // Removes parent if all child cells are removed\n            const temp = [];\n            for (let i = 0; i < parents.length; i += 1) {\n                if (this.shouldRemoveParent(parents[i])) {\n                    temp.push(parents[i]);\n                }\n            }\n            this.graph.removeCells(temp, false);\n        });\n        // Selects the new cells if cells have been cloned\n        if (clone) {\n            this.graph.setSelectionCells(cells);\n        }\n        if (this.isSelectEnabled() && this.scrollOnMove) {\n            this.graph.scrollCellToVisible(cells[0]);\n        }\n    }\n    /**\n     * Returns true if the given parent should be removed after removal of child cells.\n     */\n    shouldRemoveParent(parent) {\n        const state = this.graph.view.getState(parent);\n        return (state != null &&\n            (state.cell.isEdge() || state.cell.isVertex()) &&\n            this.graph.isCellDeletable(state.cell) &&\n            state.cell.getChildCount() === 0 &&\n            state.isTransparentState());\n    }\n    /**\n     * Destroy the preview and highlight shapes.\n     */\n    destroyShapes() {\n        // Destroys the preview dashed rectangle\n        if (this.shape) {\n            this.shape.destroy();\n            this.shape = null;\n        }\n        if (this.guide) {\n            this.guide.destroy();\n            this.guide = null;\n        }\n        // Destroys the drop target highlight\n        if (this.highlight) {\n            this.highlight.destroy();\n            this.highlight = null;\n        }\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    onDestroy() {\n        this.graph.removeMouseListener(this);\n        this.graph.removeListener(this.panHandler);\n        this.graph.removeListener(this.escapeHandler);\n        this.graph.getDataModel().removeListener(this.refreshHandler);\n        this.graph.removeListener(this.refreshHandler);\n        InternalEvent.removeListener(document, 'keydown', this.keyHandler);\n        InternalEvent.removeListener(document, 'keyup', this.keyHandler);\n        this.destroyShapes();\n        this.removeHint();\n    }\n}\nSelectionHandler.pluginId = 'SelectionHandler';\nexport default SelectionHandler;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7945, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7951, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/handler/PanningHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from '../event/EventSource';\nimport { hasScrollbars } from '../../util/styleUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { isConsumed, isControlDown, isLeftMouseButton, isMultiTouchEvent, isPopupTrigger, isShiftDown, } from '../../util/EventUtils';\nimport PanningManager from '../other/PanningManager';\n/**\n * Event handler that pans and creates popupmenus. To use the left\n * mouse button for panning without interfering with cell moving and\n * resizing, use <isUseLeftButton> and <isIgnoreCell>. For grid size\n * steps while panning, use <useGrid>.\n *\n * When registered in the {@link Graph.constructor} plugins list, it can be enabled using {@link Graph.setPanning}.\n *\n * Event: mxEvent.PAN_START\n *\n * Fires when the panning handler changes its <active> state to true. The\n * <code>event</code> property contains the corresponding {@link MouseEvent}.\n *\n * Event: mxEvent.PAN\n *\n * Fires while handle is processing events. The <code>event</code> property contains\n * the corresponding {@link MouseEvent}.\n *\n * Event: mxEvent.PAN_END\n *\n * Fires when the panning handler changes its <active> state to false. The\n * <code>event</code> property contains the corresponding {@link MouseEvent}.\n *\n * @category Plugin\n */\nclass PanningHandler extends EventSource {\n    constructor(graph) {\n        super();\n        this.getPanningManager = () => this.panningManager;\n        /**\n         * Specifies if panning should be active for the left mouse button.\n         * Setting this to true may conflict with {@link Rubberband}. Default is false.\n         */\n        this.useLeftButtonForPanning = false;\n        /**\n         * Specifies if {@link Event#isPopupTrigger} should also be used for panning.\n         */\n        this.usePopupTrigger = true;\n        /**\n         * Specifies if panning should be active even if there is a cell under the\n         * mousepointer. Default is false.\n         */\n        this.ignoreCell = false;\n        /**\n         * Specifies if the panning should be previewed. Default is true.\n         */\n        this.previewEnabled = true;\n        /**\n         * Specifies if the panning steps should be aligned to the grid size.\n         * Default is false.\n         */\n        this.useGrid = false;\n        /**\n         * Specifies if panning should be enabled. Default is false.\n         */\n        this.panningEnabled = false;\n        /**\n         * Specifies if pinch gestures should be handled as zoom. Default is true.\n         */\n        this.pinchEnabled = true;\n        this.initialScale = 0;\n        /**\n         * Specifies the maximum scale. Default is 8.\n         */\n        this.maxScale = 8;\n        /**\n         * Specifies the minimum scale. Default is 0.01.\n         */\n        this.minScale = 0.01;\n        /**\n         * Holds the current horizontal offset.\n         */\n        this.dx = 0;\n        /**\n         * Holds the current vertical offset.\n         */\n        this.dy = 0;\n        /**\n         * Holds the x-coordinate of the start point.\n         */\n        this.startX = 0;\n        /**\n         * Holds the y-coordinate of the start point.\n         */\n        this.startY = 0;\n        this.dx0 = 0;\n        this.dy0 = 0;\n        this.panningTrigger = false;\n        this.active = false;\n        this.mouseDownEvent = null;\n        this.graph = graph;\n        this.graph.addMouseListener(this);\n        // Handles force panning event\n        this.forcePanningHandler = (sender, eo) => {\n            const evtName = eo.getProperty('eventName');\n            const me = eo.getProperty('event');\n            if (evtName === InternalEvent.MOUSE_DOWN && this.isForcePanningEvent(me)) {\n                this.start(me);\n                this.active = true;\n                this.fireEvent(new EventObject(InternalEvent.PAN_START, { event: me }));\n                me.consume();\n            }\n        };\n        this.graph.addListener(InternalEvent.FIRE_MOUSE_EVENT, this.forcePanningHandler);\n        // Handles pinch gestures\n        this.gestureHandler = (sender, eo) => {\n            if (this.isPinchEnabled()) {\n                const evt = eo.getProperty('event');\n                if (!isConsumed(evt) && evt.type === 'gesturestart') {\n                    this.initialScale = this.graph.view.scale;\n                    // Forces start of panning when pinch gesture starts\n                    if (!this.active && this.mouseDownEvent) {\n                        this.start(this.mouseDownEvent);\n                        this.mouseDownEvent = null;\n                    }\n                }\n                else if (evt.type === 'gestureend' && this.initialScale !== 0) {\n                    this.initialScale = 0;\n                }\n                if (this.initialScale !== 0) {\n                    this.zoomGraph(evt);\n                }\n            }\n        };\n        this.graph.addListener(InternalEvent.GESTURE, this.gestureHandler);\n        this.mouseUpListener = () => {\n            if (this.active) {\n                this.reset();\n            }\n        };\n        // Stops scrolling on every mouseup anywhere in the document\n        InternalEvent.addListener(document, 'mouseup', this.mouseUpListener);\n        this.panningManager = new PanningManager(graph);\n    }\n    /**\n     * Returns true if the handler is currently active.\n     */\n    isActive() {\n        return this.active || this.initialScale !== null;\n    }\n    /**\n     * Returns <panningEnabled>.\n     */\n    isPanningEnabled() {\n        return this.panningEnabled;\n    }\n    /**\n     * Sets <panningEnabled>.\n     */\n    setPanningEnabled(value) {\n        this.panningEnabled = value;\n    }\n    /**\n     * Returns <pinchEnabled>.\n     */\n    isPinchEnabled() {\n        return this.pinchEnabled;\n    }\n    /**\n     * Sets <pinchEnabled>.\n     */\n    setPinchEnabled(value) {\n        this.pinchEnabled = value;\n    }\n    /**\n     * Returns true if the given event is a panning trigger for the optional\n     * given cell. This returns true if control-shift is pressed or if\n     * <usePopupTrigger> is true and the event is a popup trigger.\n     */\n    isPanningTrigger(me) {\n        const evt = me.getEvent();\n        return ((this.useLeftButtonForPanning && !me.getState() && isLeftMouseButton(evt)) ||\n            (isControlDown(evt) && isShiftDown(evt)) ||\n            (this.usePopupTrigger && isPopupTrigger(evt)));\n    }\n    /**\n     * Returns true if the given {@link MouseEvent} should start panning. This\n     * implementation always returns true if <ignoreCell> is true or for\n     * multi touch events.\n     */\n    isForcePanningEvent(me) {\n        return this.ignoreCell || isMultiTouchEvent(me.getEvent());\n    }\n    /**\n     * Handles the event by initiating the panning. By consuming the event all\n     * subsequent events of the gesture are redirected to this handler.\n     */\n    mouseDown(sender, me) {\n        this.mouseDownEvent = me;\n        if (!me.isConsumed() &&\n            this.isPanningEnabled() &&\n            !this.active &&\n            this.isPanningTrigger(me)) {\n            this.start(me);\n            this.consumePanningTrigger(me);\n        }\n    }\n    /**\n     * Starts panning at the given event.\n     */\n    start(me) {\n        this.dx0 = -this.graph.container.scrollLeft;\n        this.dy0 = -this.graph.container.scrollTop;\n        // Stores the location of the trigger event\n        this.startX = me.getX();\n        this.startY = me.getY();\n        this.dx = 0;\n        this.dy = 0;\n        this.panningTrigger = true;\n    }\n    /**\n     * Consumes the given {@link MouseEvent} if it was a panning trigger in\n     * {@link ouseDown}. The default is to invoke {@link MouseEvent#consume}. Note that this\n     * will block any further event processing. If you haven't disabled built-in\n     * context menus and require immediate selection of the cell on mouseDown in\n     * Safari and/or on the Mac, then use the following code:\n     *\n     * ```javascript\n     * consumePanningTrigger(me)\n     * {\n     *   if (me.evt.preventDefault)\n     *   {\n     *     me.evt.preventDefault();\n     *   }\n     *\n     *   // Stops event processing in IE\n     *   me.evt.returnValue = false;\n     *\n     *   // Sets local consumed state\n     *   if (!Client.IS_SF && !Client.IS_MAC)\n     *   {\n     *     me.consumed = true;\n     *   }\n     * };\n     * ```\n     */\n    consumePanningTrigger(me) {\n        me.consume();\n    }\n    /**\n     * Handles the event by updating the panning on the graph.\n     */\n    mouseMove(sender, me) {\n        this.dx = me.getX() - this.startX;\n        this.dy = me.getY() - this.startY;\n        if (this.active) {\n            if (this.previewEnabled) {\n                // Applies the grid to the panning steps\n                if (this.useGrid) {\n                    this.dx = this.graph.snap(this.dx);\n                    this.dy = this.graph.snap(this.dy);\n                }\n                this.graph.panGraph(this.dx + this.dx0, this.dy + this.dy0);\n            }\n            this.fireEvent(new EventObject(InternalEvent.PAN, { event: me }));\n        }\n        else if (this.panningTrigger) {\n            const tmp = this.active;\n            // Panning is activated only if the mouse is moved\n            // beyond the graph tolerance\n            this.active =\n                Math.abs(this.dx) > this.graph.getSnapTolerance() ||\n                    Math.abs(this.dy) > this.graph.getSnapTolerance();\n            if (!tmp && this.active) {\n                this.fireEvent(new EventObject(InternalEvent.PAN_START, { event: me }));\n            }\n        }\n        if (this.active || this.panningTrigger) {\n            me.consume();\n        }\n    }\n    /**\n     * Handles the event by setting the translation on the view or showing the\n     * popupmenu.\n     */\n    mouseUp(sender, me) {\n        if (this.active) {\n            if (this.dx !== 0 && this.dy !== 0) {\n                // Ignores if scrollbars have been used for panning\n                if (!this.graph.isUseScrollbarsForPanning() ||\n                    !hasScrollbars(this.graph.container)) {\n                    const { scale } = this.graph.getView();\n                    const t = this.graph.getView().translate;\n                    this.graph.panGraph(0, 0);\n                    this.panGraph(t.x + this.dx / scale, t.y + this.dy / scale);\n                }\n                me.consume();\n            }\n            this.fireEvent(new EventObject(InternalEvent.PAN_END, { event: me }));\n        }\n        this.reset();\n    }\n    /**\n     * Zooms the graph to the given value and consumed the event if needed.\n     */\n    zoomGraph(evt) {\n        // @ts-ignore evt may have scale property\n        let value = Math.round(this.initialScale * evt.scale * 100) / 100;\n        value = Math.max(this.minScale, value);\n        value = Math.min(this.maxScale, value);\n        if (this.graph.view.scale !== value) {\n            this.graph.zoomTo(value);\n            InternalEvent.consume(evt);\n        }\n    }\n    /**\n     * Handles the event by setting the translation on the view or showing the\n     * popupmenu.\n     */\n    reset() {\n        this.panningTrigger = false;\n        this.mouseDownEvent = null;\n        this.active = false;\n        this.dx = 0;\n        this.dy = 0;\n    }\n    /**\n     * Pans <graph> by the given amount.\n     */\n    panGraph(dx, dy) {\n        this.graph.getView().setTranslate(dx, dy);\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    onDestroy() {\n        this.graph.removeMouseListener(this);\n        this.graph.removeListener(this.forcePanningHandler);\n        this.graph.removeListener(this.gestureHandler);\n        InternalEvent.removeListener(document, 'mouseup', this.mouseUpListener);\n    }\n}\nPanningHandler.pluginId = 'PanningHandler';\nexport default PanningHandler;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8284, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}