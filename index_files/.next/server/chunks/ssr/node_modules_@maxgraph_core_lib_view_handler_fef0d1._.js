module.exports = {

"[project]/node_modules/@maxgraph/core/lib/view/handler/ConstraintHandler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$image$2f$ImageBox$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/image/ImageBox.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/ImageShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/RectangleShape.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
/**
 * Handles constraints on connection targets. This class is in charge of
 * showing fixed points when the mouse is over a vertex and handles constraints
 * to establish new connections.
 *
 * @class ConstraintHandler
 */ class ConstraintHandler {
    constructor(graph){
        /**
         * {@link Image} to be used as the image for fixed connection points.
         */ this.pointImage = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$image$2f$ImageBox$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].imageBasePath}/point.gif`, 5, 5);
        this.currentFocus = null;
        this.currentFocusArea = null;
        this.focusIcons = [];
        this.constraints = null;
        this.currentConstraint = null;
        this.focusHighlight = null;
        this.focusPoints = [];
        this.currentPoint = null;
        /**
         * Specifies if events are handled. Default is true.
         */ this.enabled = true;
        /**
         * Specifies the color for the highlight. Default is {@link DEFAULT_VALID_COLOR}.
         */ this.highlightColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_VALID_COLOR"];
        this.mouseleaveHandler = null;
        this.graph = graph;
        // Adds a graph model listener to update the current focus on changes
        this.resetHandler = ()=>{
            if (this.currentFocus && !this.graph.view.getState(this.currentFocus.cell)) {
                this.reset();
            } else {
                this.redraw();
            }
        };
        this.graph.model.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, this.resetHandler);
        this.graph.view.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SCALE_AND_TRANSLATE, this.resetHandler);
        this.graph.view.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].TRANSLATE, this.resetHandler);
        this.graph.view.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SCALE, this.resetHandler);
        this.graph.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ROOT, this.resetHandler);
    }
    /**
     * Returns true if events are handled. This implementation
     * returns {@link enabled}.
     */ isEnabled() {
        return this.enabled;
    }
    /**
     * Enables or disables event handling. This implementation
     * updates {@link enabled}.
     *
     * @param {boolean} enabled - Boolean that specifies the new enabled state.
     */ setEnabled(enabled) {
        this.enabled = enabled;
    }
    /**
     * Resets the state of this handler.
     */ reset() {
        for(let i = 0; i < this.focusIcons.length; i += 1){
            this.focusIcons[i].destroy();
        }
        this.focusIcons = [];
        if (this.focusHighlight) {
            this.focusHighlight.destroy();
            this.focusHighlight = null;
        }
        this.currentConstraint = null;
        this.currentFocusArea = null;
        this.currentPoint = null;
        this.currentFocus = null;
        this.focusPoints = [];
    }
    /**
     * Returns the tolerance to be used for intersecting connection points. This
     * implementation returns {@link mxGraph.tolerance}.
     *
     * @param me {@link mxMouseEvent} whose tolerance should be returned.
     */ getTolerance(me) {
        return this.graph.getEventTolerance();
    }
    /**
     * Returns the tolerance to be used for intersecting connection points.
     */ getImageForConstraint(state, constraint, point) {
        return this.pointImage;
    }
    /**
     * Returns true if the given {@link mxMouseEvent} should be ignored in {@link update}. This
     * implementation always returns false.
     */ isEventIgnored(me, source = false) {
        return false;
    }
    /**
     * Returns true if the given state should be ignored. This always returns false.
     */ isStateIgnored(state, source = false) {
        return false;
    }
    /**
     * Destroys the {@link focusIcons} if they exist.
     */ destroyIcons() {
        for(let i = 0; i < this.focusIcons.length; i += 1){
            this.focusIcons[i].destroy();
        }
        this.focusIcons = [];
        this.focusPoints = [];
    }
    /**
     * Destroys the {@link focusHighlight} if one exists.
     */ destroyFocusHighlight() {
        if (this.focusHighlight) {
            this.focusHighlight.destroy();
            this.focusHighlight = null;
        }
    }
    /**
     * Returns true if the current focused state should not be changed for the given event.
     * This returns true if shift and alt are pressed.
     */ isKeepFocusEvent(me) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isShiftDown"])(me.getEvent());
    }
    /**
     * Returns the cell for the given event.
     */ getCellForEvent(me, point) {
        let cell = me.getCell();
        // Gets cell under actual point if different from event location
        if (!cell && point && (me.getGraphX() !== point.x || me.getGraphY() !== point.y)) {
            cell = this.graph.getCellAt(point.x, point.y);
        }
        // Uses connectable parent vertex if one exists
        if (cell && !cell.isConnectable()) {
            const parent = cell.getParent();
            if (parent && parent.isVertex() && parent.isConnectable()) {
                cell = parent;
            }
        }
        if (cell) {
            return this.graph.isCellLocked(cell) ? null : cell;
        } else {
            return null;
        }
    }
    /**
     * Updates the state of this handler based on the given {@link mxMouseEvent}.
     * Source is a boolean indicating if the cell is a source or target.
     */ update(me, source, existingEdge, point) {
        if (this.isEnabled() && !this.isEventIgnored(me)) {
            // Lazy installation of mouseleave handler
            if (!this.mouseleaveHandler && this.graph.container) {
                this.mouseleaveHandler = ()=>{
                    this.reset();
                };
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(this.graph.container, 'mouseleave', this.resetHandler);
            }
            const tol = this.getTolerance(me);
            const x = point ? point.x : me.getGraphX();
            const y = point ? point.y : me.getGraphY();
            const grid = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](x - tol, y - tol, 2 * tol, 2 * tol);
            const mouse = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol);
            const state = this.graph.view.getState(this.getCellForEvent(me, point));
            // Keeps focus icons visible while over vertex bounds and no other cell under mouse or shift is pressed
            if (!this.isKeepFocusEvent(me) && (!this.currentFocusArea || !this.currentFocus || state || !this.currentFocus.cell.isVertex() || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersects"])(this.currentFocusArea, mouse)) && state !== this.currentFocus) {
                this.currentFocusArea = null;
                this.currentFocus = null;
                this.setFocus(me, state, source);
            }
            this.currentConstraint = null;
            this.currentPoint = null;
            let minDistSq = null;
            let tmp;
            if (this.focusIcons.length > 0 && this.constraints && (!state || this.currentFocus === state)) {
                const cx = mouse.getCenterX();
                const cy = mouse.getCenterY();
                for(let i = 0; i < this.focusIcons.length; i += 1){
                    const dx = cx - this.focusIcons[i].bounds.getCenterX();
                    const dy = cy - this.focusIcons[i].bounds.getCenterY();
                    tmp = dx * dx + dy * dy;
                    if ((this.intersects(this.focusIcons[i], mouse, source, existingEdge) || point && this.intersects(this.focusIcons[i], grid, source, existingEdge)) && (minDistSq === null || tmp < minDistSq)) {
                        this.currentConstraint = this.constraints[i];
                        this.currentPoint = this.focusPoints[i];
                        minDistSq = tmp;
                        tmp = this.focusIcons[i].bounds.clone();
                        tmp.grow(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HIGHLIGHT_SIZE"] + 1);
                        tmp.width -= 1;
                        tmp.height -= 1;
                        if (!this.focusHighlight) {
                            const hl = this.createHighlightShape();
                            hl.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG;
                            hl.pointerEvents = false;
                            hl.init(this.graph.getView().getOverlayPane());
                            this.focusHighlight = hl;
                            const getState = ()=>{
                                return this.currentFocus ? this.currentFocus : state;
                            };
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].redirectMouseEvents(hl.node, this.graph, getState);
                        }
                        this.focusHighlight.bounds = tmp;
                        this.focusHighlight.redraw();
                    }
                }
            }
            if (!this.currentConstraint) {
                this.destroyFocusHighlight();
            }
        } else {
            this.currentConstraint = null;
            this.currentFocus = null;
            this.currentPoint = null;
        }
    }
    /**
     * Transfers the focus to the given state as a source or target terminal. If
     * the handler is not enabled then the outline is painted, but the constraints
     * are ignored.
     */ redraw() {
        if (this.currentFocus && this.constraints && this.focusIcons.length > 0) {
            const state = this.graph.view.getState(this.currentFocus.cell);
            this.currentFocus = state;
            this.currentFocusArea = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](state.x, state.y, state.width, state.height);
            for(let i = 0; i < this.constraints.length; i += 1){
                const cp = this.graph.getConnectionPoint(state, this.constraints[i]);
                const img = this.getImageForConstraint(state, this.constraints[i], cp);
                const bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);
                this.focusIcons[i].bounds = bounds;
                this.focusIcons[i].redraw();
                this.currentFocusArea.add(this.focusIcons[i].bounds);
                this.focusPoints[i] = cp;
            }
        }
    }
    /**
     * Transfers the focus to the given state as a source or target terminal. If
     * the handler is not enabled then the outline is painted, but the constraints
     * are ignored.
     */ setFocus(me, state, source) {
        this.constraints = state && !this.isStateIgnored(state, source) && state.cell.isConnectable() ? this.isEnabled() ? this.graph.getAllConnectionConstraints(state, source) ?? [] : [] : null;
        // Only uses cells which have constraints
        if (this.constraints && state) {
            this.currentFocus = state;
            this.currentFocusArea = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](state.x, state.y, state.width, state.height);
            for(let i = 0; i < this.focusIcons.length; i += 1){
                this.focusIcons[i].destroy();
            }
            this.focusIcons = [];
            this.focusPoints = [];
            for(let i = 0; i < this.constraints.length; i += 1){
                const cp = this.graph.getConnectionPoint(state, this.constraints[i]);
                const img = this.getImageForConstraint(state, this.constraints[i], cp);
                const { src } = img;
                const bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);
                const icon = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](bounds, src);
                icon.dialect = this.graph.dialect !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].MIXEDHTML : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG;
                icon.preserveImageAspect = false;
                icon.init(this.graph.getView().getDecoratorPane());
                // Move the icon behind all other overlays
                if (icon.node.previousSibling) {
                    icon.node.parentNode?.insertBefore(icon.node, icon.node.parentNode.firstChild);
                }
                const getState = ()=>{
                    return this.currentFocus ? this.currentFocus : state;
                };
                icon.redraw();
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].redirectMouseEvents(icon.node, this.graph, getState);
                this.currentFocusArea.add(icon.bounds);
                this.focusIcons.push(icon);
                this.focusPoints.push(cp);
            }
            this.currentFocusArea.grow(this.getTolerance(me));
        } else {
            this.destroyIcons();
            this.destroyFocusHighlight();
        }
    }
    /**
     * Create the shape used to paint the highlight.
     *
     * Returns true if the given icon intersects the given point.
     */ createHighlightShape() {
        const hl = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](), this.highlightColor, this.highlightColor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HIGHLIGHT_STROKEWIDTH"]);
        hl.opacity = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HIGHLIGHT_OPACITY"];
        return hl;
    }
    /**
     * Returns true if the given icon intersects the given rectangle.
     */ intersects(icon, mouse, source, existingEdge) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersects"])(icon.bounds, mouse);
    }
    /**
     * Destroy this handler.
     */ onDestroy() {
        this.reset();
        this.graph.model.removeListener(this.resetHandler);
        this.graph.view.removeListener(this.resetHandler);
        this.graph.removeListener(this.resetHandler);
        if (this.mouseleaveHandler && this.graph.container) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].removeListener(this.graph.container, 'mouseleave', this.mouseleaveHandler);
            this.mouseleaveHandler = null;
        }
    }
}
const __TURBOPACK__default__export__ = ConstraintHandler;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/handler/config.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2024-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "EdgeHandlerConfig": (()=>EdgeHandlerConfig),
    "HandleConfig": (()=>HandleConfig),
    "VertexHandlerConfig": (()=>VertexHandlerConfig),
    "resetEdgeHandlerConfig": (()=>resetEdgeHandlerConfig),
    "resetHandleConfig": (()=>resetHandleConfig),
    "resetVertexHandlerConfig": (()=>resetVertexHandlerConfig)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cloneUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/cloneUtils.js [app-ssr] (ecmascript)");
;
;
const EdgeHandlerConfig = {
    connectFillColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CONNECT_HANDLE_FILLCOLOR"],
    handleShape: 'square',
    selectionColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EDGE_SELECTION_COLOR"],
    selectionStrokeWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EDGE_SELECTION_STROKEWIDTH"],
    selectionDashed: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EDGE_SELECTION_DASHED"]
};
const defaultEdgeHandlerConfig = {
    ...EdgeHandlerConfig
};
const resetEdgeHandlerConfig = ()=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cloneUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shallowCopy"])(defaultEdgeHandlerConfig, EdgeHandlerConfig);
};
const HandleConfig = {
    /**
     * Defines the default color to be used for the handle fill color. Use `none` for no color.
     * @default {@link HANDLE_FILLCOLOR}
     */ fillColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HANDLE_FILLCOLOR"],
    /**
     * Defines the color to be used for the label handle fill color. Use `none` for no color.
     * @default {@link LABEL_HANDLE_FILLCOLOR}
     */ labelFillColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LABEL_HANDLE_FILLCOLOR"],
    /**
     * Defines the default size for label handles.
     * @default {@link LABEL_HANDLE_SIZE}
     */ labelSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LABEL_HANDLE_SIZE"],
    /**
     * Defines the default size for handles.
     * @default {@link HANDLE_SIZE}
     */ size: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HANDLE_SIZE"],
    /**
     * Defines the default color to be used for the handle stroke color. Use `none` for no color.
     * @default {@link HANDLE_STROKECOLOR}
     */ strokeColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HANDLE_STROKECOLOR"]
};
const defaultHandleConfig = {
    ...HandleConfig
};
const resetHandleConfig = ()=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cloneUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shallowCopy"])(defaultHandleConfig, HandleConfig);
};
const VertexHandlerConfig = {
    /**
     * Enable rotation handle
     * @default false
     */ rotationEnabled: false,
    /**
     * Defines the default color to be used for the selection border of vertices. Use `none` for no color.
     * @default {@link VERTEX_SELECTION_COLOR}
     * @since 0.14.0
     */ selectionColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VERTEX_SELECTION_COLOR"],
    /**
     * Defines the default stroke width to be used for vertex selections.
     * @default {@link VERTEX_SELECTION_STROKEWIDTH}
     * @since 0.14.0
     */ selectionStrokeWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VERTEX_SELECTION_STROKEWIDTH"],
    /**
     * Defines the default dashed state to be used for the vertex selection border.
     * @default {@link VERTEX_SELECTION_DASHED}
     * @since 0.14.0
     */ selectionDashed: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VERTEX_SELECTION_DASHED"]
};
const defaultVertexHandlerConfig = {
    ...VertexHandlerConfig
};
const resetVertexHandlerConfig = ()=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cloneUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shallowCopy"])(defaultVertexHandlerConfig, VertexHandlerConfig);
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/handler/EdgeHandler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$ConstraintHandler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/ConstraintHandler.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/RectangleShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/EdgeStyle.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$EllipseShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/EllipseShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/ImageShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$other$2f$ConnectionConstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/other/ConnectionConstraint.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$arrayUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/arrayUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellMarker$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/CellMarker.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * Graph event handler that reconnects edges, modifies control points and the edge label location.
 *
 * Uses {@link CellMarker} for finding and highlighting new source and target vertices.
 *
 * This handler is automatically created in {@link Graph.createHandler} for each selected edge.
 *
 * Some elements of this handler and its subclasses can be configured using {@link EdgeHandlerConfig}.
 */ class EdgeHandler {
    constructor(state){
        /**
         * Holds the current validation error while a connection is being changed.
         */ this.error = null;
        /**
         * Holds the {@link Shape}s that represent the points.
         */ this.bends = [];
        /**
         * Specifies if cloning by control-drag is enabled.
         * @default true
         */ this.cloneEnabled = true;
        /**
         * Specifies if adding bends by shift-click is enabled.
         *
         * **Note**: This experimental feature is not recommended for production use.
         * @default false
         */ this.addEnabled = false;
        /**
         * Specifies if removing bends by shift-click is enabled.
         *
         * **Note**: This experimental feature is not recommended for production use.
         * @default false
         */ this.removeEnabled = false;
        /**
         * Specifies if removing bends by double click is enabled.
         * @default false
         */ this.dblClickRemoveEnabled = false;
        /**
         * Specifies if removing bends by dropping them on other bends is enabled.
         * @default false
         */ this.mergeRemoveEnabled = false;
        /**
         * Specifies if removing bends by creating straight segments should be enabled.
         * If enabled, this can be overridden by holding down the alt key while moving.
         * @default false
         */ this.straightRemoveEnabled = false;
        /**
         * Specifies if virtual bends should be added in the center of each segment.
         * These bends can then be used to add new waypoints.
         * @default false
         */ this.virtualBendsEnabled = false;
        /**
         * Opacity to be used for virtual bends (see {@link virtualBendsEnabled}).
         * @default 20
         */ this.virtualBendOpacity = 20;
        /**
         * Specifies if the parent should be highlighted if a child cell is selected.
         * @default false
         */ this.parentHighlightEnabled = false;
        /**
         * Specifies if bends should be added to the graph container.
         * This is updated in {@link init} based on whether the edge or one of its terminals has an HTML label in the container.
         */ this.preferHtml = false;
        /**
         * Specifies if the bounds of handles should be used for hit-detection in IE.
         * @default true
         */ this.allowHandleBoundsCheck = true;
        /**
         * Specifies if waypoints should snap to the routing centers of terminals.
         * @default false
         */ this.snapToTerminals = false;
        /**
         * Optional {@link Image} to be used as handles.
         * @default null
         */ this.handleImage = null;
        this.labelHandleImage = null;
        /**
         * Optional tolerance for hit-detection in {@link getHandleForEvent}.
         * @default 0
         */ this.tolerance = 0;
        /**
         * Specifies if connections to the outline of a highlighted target should be
         * enabled. This will allow to place the connection point along the outline of
         * the highlighted target.
         * @default false
         */ this.outlineConnect = false;
        /**
         * Specifies if the label handle should be moved if it intersects with another
         * handle. Uses {@link checkLabelHandle} for checking and moving.
         * @default false
         */ this.manageLabelHandle = false;
        this.currentPoint = null;
        this.parentHighlight = null;
        this.index = null;
        this.isSource = false;
        this.isTarget = false;
        this.isLabel = false;
        this.points = [];
        this.snapPoint = null;
        this.abspoints = [];
        this.startX = 0;
        this.startY = 0;
        this.outline = true;
        this.active = true;
        // `state.shape` must exists.
        this.state = state;
        this.graph = this.state.view.graph;
        this.marker = this.createMarker();
        this.constraintHandler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$ConstraintHandler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.graph);
        // Clones the original points from the cell
        // and makes sure at least one point exists
        this.points = [];
        // Uses the absolute points of the state
        // for the initial configuration and preview
        this.abspoints = this.getSelectionPoints(this.state);
        this.shape = this.createSelectionShape(this.abspoints);
        this.shape.dialect = this.graph.dialect !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].MIXEDHTML : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG;
        this.shape.init(this.graph.getView().getOverlayPane());
        this.shape.pointerEvents = false;
        this.shape.setCursor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CURSOR"].MOVABLE_EDGE);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].redirectMouseEvents(this.shape.node, this.graph, this.state);
        // Updates preferHtml
        this.preferHtml = this.state.text != null && this.state.text.node.parentNode === this.graph.container;
        if (!this.preferHtml) {
            // Checks source terminal
            const sourceState = this.state.getVisibleTerminalState(true);
            if (sourceState != null) {
                this.preferHtml = sourceState.text != null && sourceState.text.node.parentNode === this.graph.container;
            }
            if (!this.preferHtml) {
                // Checks target terminal
                const targetState = this.state.getVisibleTerminalState(false);
                if (targetState != null) {
                    this.preferHtml = targetState.text != null && targetState.text.node.parentNode === this.graph.container;
                }
            }
        }
        const selectionHandler = this.graph.getPlugin('SelectionHandler');
        // Creates bends for the non-routed absolute points
        // or bends that don't correspond to points
        if (selectionHandler && (this.graph.getSelectionCount() < selectionHandler.maxCells || selectionHandler.maxCells <= 0)) {
            this.bends = this.createBends();
            if (this.isVirtualBendsEnabled()) {
                this.virtualBends = this.createVirtualBends();
            }
        }
        // Adds a rectangular handle for the label position
        this.label = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.state.absoluteOffset.x, this.state.absoluteOffset.y);
        this.labelShape = this.createLabelHandleShape();
        this.initBend(this.labelShape);
        this.labelShape.setCursor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CURSOR"].LABEL_HANDLE);
        this.customHandles = this.createCustomHandles();
        this.updateParentHighlight();
        this.redraw();
        // Handles escape keystrokes
        this.escapeHandler = (sender, evt)=>{
            const dirty = this.index != null;
            this.reset();
            if (dirty) {
                this.graph.cellRenderer.redraw(this.state, false, state.view.isRendering());
            }
        };
        this.state.view.graph.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ESCAPE, this.escapeHandler);
    }
    /**
     * Returns true if the parent highlight should be visible. This implementation
     * always returns true.
     */ isParentHighlightVisible() {
        const parent = this.state.cell.getParent();
        return parent ? !this.graph.isCellSelected(parent) : null;
    }
    /**
     * Updates the highlight of the parent if {@link parentHighlightEnabled} is true.
     */ updateParentHighlight() {
        if (!this.isDestroyed()) {
            const visible = this.isParentHighlightVisible();
            const parent = this.state.cell.getParent();
            const pstate = parent ? this.graph.view.getState(parent) : null;
            if (this.parentHighlight) {
                if (parent && parent.isVertex() && visible) {
                    const b = this.parentHighlight.bounds;
                    if (pstate && b && (b.x !== pstate.x || b.y !== pstate.y || b.width !== pstate.width || b.height !== pstate.height)) {
                        this.parentHighlight.bounds = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].fromRectangle(pstate);
                        this.parentHighlight.redraw();
                    }
                } else {
                    if (pstate && pstate.parentHighlight === this.parentHighlight) {
                        pstate.parentHighlight = null;
                    }
                    this.parentHighlight.destroy();
                    this.parentHighlight = null;
                }
            } else if (this.parentHighlightEnabled && visible) {
                if (parent && parent.isVertex() && pstate && !pstate.parentHighlight) {
                    this.parentHighlight = this.createParentHighlightShape(pstate);
                    // VML dialect required here for event transparency in IE
                    this.parentHighlight.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG;
                    this.parentHighlight.pointerEvents = false;
                    if (pstate.style.rotation) {
                        this.parentHighlight.rotation = pstate.style.rotation;
                    }
                    this.parentHighlight.init(this.graph.getView().getOverlayPane());
                    this.parentHighlight.redraw();
                    // Shows highlight once per parent
                    pstate.parentHighlight = this.parentHighlight;
                }
            }
        }
    }
    /**
     * Returns an array of custom handles. This implementation returns an empty array.
     */ createCustomHandles() {
        return [];
    }
    /**
     * Returns true if virtual bends should be added. This returns true if
     * {@link virtualBendsEnabled} is true and the current style allows and
     * renders custom waypoints.
     */ isVirtualBendsEnabled(evt) {
        return this.virtualBendsEnabled && (this.state.style.edgeStyle == null || this.state.style.edgeStyle === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"] || this.state.style.noEdgeStyle) && this.state.style.shape !== 'arrow';
    }
    /**
     * Returns true if the given cell allows new connections to be created. This implementation
     * always returns true.
     */ isCellEnabled(cell) {
        return true;
    }
    /**
     * Returns true if the given event is a trigger to add a new Point. This
     * implementation returns true if shift is pressed.
     */ isAddPointEvent(evt) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isShiftDown"])(evt);
    }
    /**
     * Returns true if the given event is a trigger to remove a point. This
     * implementation returns true if shift is pressed.
     */ isRemovePointEvent(evt) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isShiftDown"])(evt);
    }
    /**
     * Returns the list of points that defines the selection stroke.
     */ getSelectionPoints(state) {
        return state.absolutePoints;
    }
    /**
     * Creates the shape used to draw the selection border.
     */ createParentHighlightShape(bounds) {
        const shape = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].fromRectangle(bounds), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"], this.getSelectionColor());
        shape.strokeWidth = this.getSelectionStrokeWidth();
        shape.isDashed = this.isSelectionDashed();
        return shape;
    }
    /**
     * Creates the shape used to draw the selection border.
     */ createSelectionShape(points) {
        const c = this.state.shape.constructor;
        const shape = new c();
        shape.outline = true;
        shape.apply(this.state);
        shape.isDashed = this.isSelectionDashed();
        shape.stroke = this.getSelectionColor();
        shape.isShadow = false;
        return shape;
    }
    /**
     * Returns {@link EdgeHandlerConfig.selectionColor}.
     */ getSelectionColor() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EdgeHandlerConfig"].selectionColor;
    }
    /**
     * Returns {@link EdgeHandlerConfig.selectionStrokeWidth}.
     */ getSelectionStrokeWidth() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EdgeHandlerConfig"].selectionStrokeWidth;
    }
    /**
     * Returns {@link EdgeHandlerConfig.selectionDashed}.
     */ isSelectionDashed() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EdgeHandlerConfig"].selectionDashed;
    }
    /**
     * Returns true if the given cell is connectable. This is a hook to
     * disable floating connections. This implementation returns true.
     */ isConnectableCell(cell) {
        return true;
    }
    /**
     * Creates and returns the {@link CellMarker} used in {@link marker}.
     */ getCellAt(x, y) {
        return !this.outlineConnect ? this.graph.getCellAt(x, y) : null;
    }
    /**
     * Creates and returns the {@link CellMarker} used in {@link marker}.
     */ createMarker() {
        return new EdgeHandlerCellMarker(this.graph, this);
    }
    /**
     * Returns the error message or an empty string if the connection for the
     * given source, target pair is not valid. Otherwise, it returns null. This
     * implementation uses {@link Graph#getEdgeValidationError}.
     *
     * @param source {@link Cell} that represents the source terminal.
     * @param target {@link Cell} that represents the target terminal.
     */ validateConnection(source, target) {
        return this.graph.getEdgeValidationError(this.state.cell, source, target);
    }
    /**
     * Creates and returns the bends used for modifying the edge. This is
     * typically an array of {@link RectangleShape}.
     */ createBends() {
        const { cell } = this.state;
        const bends = [];
        for(let i = 0; i < this.abspoints.length; i += 1){
            if (this.isHandleVisible(i)) {
                const source = i === 0;
                const target = i === this.abspoints.length - 1;
                const terminal = source || target;
                if (terminal || this.graph.isCellBendable(cell)) {
                    ((index)=>{
                        const bend = this.createHandleShape(index);
                        this.initBend(bend, ()=>{
                            if (this.dblClickRemoveEnabled) {
                                this.removePoint(this.state, index);
                            }
                        });
                        if (this.isHandleEnabled(i)) {
                            bend.setCursor(terminal ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CURSOR"].TERMINAL_HANDLE : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CURSOR"].BEND_HANDLE);
                        }
                        bends.push(bend);
                        if (!terminal) {
                            this.points.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](0, 0));
                            bend.node.style.visibility = 'hidden';
                        }
                    })(i);
                }
            }
        }
        return bends;
    }
    /**
     * Creates and returns the bends used for modifying the edge. This is
     * typically an array of {@link RectangleShape}.
     */ createVirtualBends() {
        const { cell } = this.state;
        const last = this.abspoints[0];
        const bends = [];
        if (this.graph.isCellBendable(cell)) {
            for(let i = 1; i < this.abspoints.length; i += 1){
                ((bend)=>{
                    this.initBend(bend);
                    bend.setCursor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CURSOR"].VIRTUAL_BEND_HANDLE);
                    bends.push(bend);
                })(this.createHandleShape());
            }
        }
        return bends;
    }
    /**
     * Creates the shape used to display the given bend.
     */ isHandleEnabled(index) {
        return true;
    }
    /**
     * Returns true if the handle at the given index is visible.
     */ isHandleVisible(index) {
        const source = this.state.getVisibleTerminalState(true);
        const target = this.state.getVisibleTerminalState(false);
        const geo = this.state.cell.getGeometry();
        const edgeStyle = geo ? this.graph.view.getEdgeStyle(this.state, geo.points || undefined, source, target) : null;
        return edgeStyle !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].EntityRelation || index === 0 || index === this.abspoints.length - 1;
    }
    /**
     * Creates the shape used to display the given bend.
     * Note that the index
     * - may be `null` for special cases, such as when called from {@link ElbowEdgeHandler.createVirtualBend}.
     * - is `null` for virtual handles.
     *
     * Only images and rectangles should be returned if support for HTML labels with not foreign objects is required.
     */ createHandleShape(_index) {
        if (this.handleImage) {
            const shape = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](0, 0, this.handleImage.width, this.handleImage.height), this.handleImage.src);
            // Allows HTML rendering of the images
            shape.preserveImageAspect = false;
            return shape;
        }
        let s = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].size;
        if (this.preferHtml) {
            s -= 1;
        }
        const shapeConstructor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EdgeHandlerConfig"].handleShape === 'circle' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$EllipseShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"];
        return new shapeConstructor(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](0, 0, s, s), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].fillColor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].strokeColor);
    }
    /**
     * Creates the shape used to display the label handle.
     */ createLabelHandleShape() {
        if (this.labelHandleImage) {
            const shape = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](0, 0, this.labelHandleImage.width, this.labelHandleImage.height), this.labelHandleImage.src);
            // Allows HTML rendering of the images
            shape.preserveImageAspect = false;
            return shape;
        }
        const s = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].labelSize;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](0, 0, s, s), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].labelFillColor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].strokeColor);
    }
    /**
     * Helper method to initialize the given bend.
     *
     * @param bend {@link Shape} that represents the bend to be initialized.
     */ initBend(bend, dblClick) {
        if (this.preferHtml) {
            bend.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].STRICTHTML;
            bend.init(this.graph.container);
        } else {
            bend.dialect = this.graph.dialect !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].MIXEDHTML : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG;
            bend.init(this.graph.getView().getOverlayPane());
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].redirectMouseEvents(bend.node, this.graph, this.state, null, null, null, dblClick);
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IS_TOUCH) {
            bend.node.setAttribute('pointer-events', 'none');
        }
    }
    /**
     * Returns the index of the handle for the given event.
     */ getHandleForEvent(me) {
        let result = null;
        // Connection highlight may consume events before they reach sizer handle
        const tol = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMouseEvent"])(me.getEvent()) ? this.tolerance : 1;
        const hit = this.allowHandleBoundsCheck && tol > 0 ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
        let minDistSq = Number.POSITIVE_INFINITY;
        function checkShape(shape) {
            if (shape && shape.bounds && shape.node && shape.node.style.display !== 'none' && shape.node.style.visibility !== 'hidden' && (me.isSource(shape) || hit && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersects"])(shape.bounds, hit))) {
                const dx = me.getGraphX() - shape.bounds.getCenterX();
                const dy = me.getGraphY() - shape.bounds.getCenterY();
                const tmp = dx * dx + dy * dy;
                if (tmp <= minDistSq) {
                    minDistSq = tmp;
                    return true;
                }
            }
            return false;
        }
        if (this.isCustomHandleEvent(me) && this.customHandles) {
            // Inverse loop order to match display order
            for(let i = this.customHandles.length - 1; i >= 0; i--){
                if (checkShape(this.customHandles[i].shape)) {
                    // LATER: Return reference to active shape
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE - i;
                }
            }
        }
        if (me.isSource(this.state.text) || checkShape(this.labelShape)) {
            result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LABEL_HANDLE;
        }
        for(let i = 0; i < this.bends.length; i += 1){
            if (checkShape(this.bends[i])) {
                result = i;
            }
        }
        if (this.virtualBends && this.isAddVirtualBendEvent(me)) {
            for(let i = 0; i < this.virtualBends.length; i += 1){
                if (checkShape(this.virtualBends[i])) {
                    result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VIRTUAL_HANDLE - i;
                }
            }
        }
        return result;
    }
    /**
     * Returns true if the given event allows virtual bends to be added. This
     * implementation returns true.
     */ isAddVirtualBendEvent(me) {
        return true;
    }
    /**
     * Returns true if the given event allows custom handles to be changed. This
     * implementation returns true.
     */ isCustomHandleEvent(me) {
        return true;
    }
    /**
     * Handles the event by checking if a special element of the handler
     * was clicked, in which case the index parameter is non-null. The
     * indices may be one of {@link InternalEvent.LABEL_HANDLE} or the number of the respective
     * control point. The source and target points are used for reconnecting
     * the edge.
     */ mouseDown(sender, me) {
        const handle = this.getHandleForEvent(me);
        if (handle !== null && this.bends[handle]) {
            const b = this.bends[handle].bounds;
            if (b) this.snapPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](b.getCenterX(), b.getCenterY());
        }
        if (this.addEnabled && handle === null && this.isAddPointEvent(me.getEvent())) {
            this.addPoint(this.state, me.getEvent());
            me.consume();
        } else if (handle !== null && !me.isConsumed() && this.graph.isEnabled()) {
            const cell = me.getCell();
            if (this.removeEnabled && this.isRemovePointEvent(me.getEvent())) {
                this.removePoint(this.state, handle);
            } else if (handle !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LABEL_HANDLE || cell && this.graph.isLabelMovable(cell)) {
                if (this.virtualBends && handle <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VIRTUAL_HANDLE) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setOpacity"])(this.virtualBends[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VIRTUAL_HANDLE - handle].node, 100);
                }
                this.start(me.getX(), me.getY(), handle);
            }
            me.consume();
        }
    }
    /**
     * Starts the handling of the mouse gesture.
     */ start(x, y, index) {
        this.startX = x;
        this.startY = y;
        this.isSource = this.bends.length === 0 ? false : index === 0;
        this.isTarget = this.bends.length === 0 ? false : index === this.bends.length - 1;
        this.isLabel = index === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LABEL_HANDLE;
        if (this.isSource || this.isTarget) {
            const { cell } = this.state;
            const terminal = cell.getTerminal(this.isSource);
            if (terminal == null && this.graph.isTerminalPointMovable(cell, this.isSource) || terminal != null && this.graph.isCellDisconnectable(cell, terminal, this.isSource)) {
                this.index = index;
            }
        } else {
            this.index = index;
        }
        // Hides other custom handles
        if (this.index !== null && this.index <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE && this.index > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VIRTUAL_HANDLE) {
            if (this.customHandles != null) {
                for(let i = 0; i < this.customHandles.length; i += 1){
                    if (i !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE - this.index) {
                        this.customHandles[i].setVisible(false);
                    }
                }
            }
        }
    }
    /**
     * Returns a clone of the current preview state for the given point and terminal.
     */ clonePreviewState(point, terminal) {
        return this.state.clone();
    }
    /**
     * Returns the tolerance for the guides. Default value is
     * gridSize * scale / 2.
     */ getSnapToTerminalTolerance() {
        return this.graph.getGridSize() * this.graph.getView().scale / 2;
    }
    /**
     * Hook for subclassers do show details while the handler is active.
     */ updateHint(me, point) {
        return;
    }
    /**
     * Hooks for subclassers to hide details when the handler gets inactive.
     */ removeHint() {
        return;
    }
    /**
     * Hook for rounding the unscaled width or height. This uses Math.round.
     */ roundLength(length) {
        return Math.round(length);
    }
    /**
     * Returns true if {@link snapToTerminals} is true and if alt is not pressed.
     */ isSnapToTerminalsEvent(me) {
        return this.snapToTerminals && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAltDown"])(me.getEvent());
    }
    /**
     * Returns the point for the given event.
     */ getPointForEvent(me) {
        const view = this.graph.getView();
        const { scale } = view;
        const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.roundLength(me.getGraphX() / scale) * scale, this.roundLength(me.getGraphY() / scale) * scale);
        const tt = this.getSnapToTerminalTolerance();
        let overrideX = false;
        let overrideY = false;
        if (tt > 0 && this.isSnapToTerminalsEvent(me)) {
            const snapToPoint = (pt)=>{
                if (pt) {
                    const { x } = pt;
                    if (Math.abs(point.x - x) < tt) {
                        point.x = x;
                        overrideX = true;
                    }
                    const { y } = pt;
                    if (Math.abs(point.y - y) < tt) {
                        point.y = y;
                        overrideY = true;
                    }
                }
            };
            // Temporary function
            const snapToTerminal = (terminal)=>{
                if (terminal) {
                    snapToPoint(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](view.getRoutingCenterX(terminal), view.getRoutingCenterY(terminal)));
                }
            };
            snapToTerminal(this.state.getVisibleTerminalState(true));
            snapToTerminal(this.state.getVisibleTerminalState(false));
            for(let i = 0; i < this.state.absolutePoints.length; i += 1){
                snapToPoint(this.state.absolutePoints[i]);
            }
        }
        if (this.graph.isGridEnabledEvent(me.getEvent())) {
            const tr = view.translate;
            if (!overrideX) {
                point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;
            }
            if (!overrideY) {
                point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;
            }
        }
        return point;
    }
    /**
     * Updates the given preview state taking into account the state of the constraint handler.
     */ getPreviewTerminalState(me) {
        this.constraintHandler.update(me, this.isSource, true, me.isSource(this.marker.highlight.shape) ? null : this.currentPoint);
        if (this.constraintHandler.currentFocus && this.constraintHandler.currentConstraint) {
            // Handles special case where grid is large and connection point is at actual point in which
            // case the outline is not followed as long as we're < gridSize / 2 away from that point
            if (this.marker.highlight && this.marker.highlight.shape && this.marker.highlight.state && this.marker.highlight.state.cell === this.constraintHandler.currentFocus.cell) {
                // Direct repaint needed if cell already highlighted
                if (this.marker.highlight.shape.stroke !== 'transparent') {
                    this.marker.highlight.shape.stroke = 'transparent';
                    this.marker.highlight.repaint();
                }
            } else {
                this.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');
            }
            const other = this.graph.view.getTerminalPort(this.state, this.graph.view.getState(this.state.cell.getTerminal(!this.isSource)), !this.isSource);
            const otherCell = other ? other.cell : null;
            const source = this.isSource ? this.constraintHandler.currentFocus.cell : otherCell;
            const target = this.isSource ? otherCell : this.constraintHandler.currentFocus.cell;
            // Updates the error message of the handler
            this.error = this.validateConnection(source, target);
            let result = null;
            if (this.error === null) {
                result = this.constraintHandler.currentFocus;
            }
            if (this.error !== null || result && !this.isCellEnabled(result.cell)) {
                this.constraintHandler.reset();
            }
            return result;
        }
        if (!this.graph.isIgnoreTerminalEvent(me.getEvent())) {
            this.marker.process(me);
            const state = this.marker.getValidState();
            if (state && !this.isCellEnabled(state.cell)) {
                this.constraintHandler.reset();
                this.marker.reset();
            }
            return this.marker.getValidState();
        }
        this.marker.reset();
        return null;
    }
    /**
     * Updates the given preview state taking into account the state of the constraint handler.
     *
     * @param pt {@link Point} that contains the current pointer position.
     * @param me Optional {@link MouseEvent} that contains the current event.
     */ getPreviewPoints(pt, me) {
        const geometry = this.state.cell.getGeometry();
        if (!geometry) return null;
        let points = (geometry.points || []).slice();
        const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](pt.x, pt.y);
        let result = null;
        if (!this.isSource && !this.isTarget && this.index !== null) {
            this.convertPoint(point, false);
            // Adds point from virtual bend
            if (this.index <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VIRTUAL_HANDLE) {
                points.splice(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VIRTUAL_HANDLE - this.index, 0, point);
            }
            // Removes point if dragged on terminal point
            if (!this.isSource && !this.isTarget) {
                for(let i = 0; i < this.bends.length; i += 1){
                    if (i !== this.index) {
                        const bend = this.bends[i];
                        if (bend && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["contains"])(bend.bounds, pt.x, pt.y)) {
                            if (this.index <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VIRTUAL_HANDLE) {
                                points.splice(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VIRTUAL_HANDLE - this.index, 1);
                            } else {
                                points.splice(this.index - 1, 1);
                            }
                            result = points;
                        }
                    }
                }
                // Removes point if user tries to straighten a segment
                if (!result && this.straightRemoveEnabled && (!me || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAltDown"])(me.getEvent()))) {
                    const tol = this.graph.getEventTolerance() * this.graph.getEventTolerance();
                    const abs = this.state.absolutePoints.slice();
                    abs[this.index] = pt;
                    // Handes special case where removing waypoint affects tolerance (flickering)
                    const src = this.state.getVisibleTerminalState(true);
                    if (src != null) {
                        const c = this.graph.getConnectionConstraint(this.state, src, true);
                        // Checks if point is not fixed
                        if (c == null || this.graph.getConnectionPoint(src, c) == null) {
                            abs[0] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](src.view.getRoutingCenterX(src), src.view.getRoutingCenterY(src));
                        }
                    }
                    const trg = this.state.getVisibleTerminalState(false);
                    if (trg != null) {
                        const c = this.graph.getConnectionConstraint(this.state, trg, false);
                        // Checks if point is not fixed
                        if (c == null || this.graph.getConnectionPoint(trg, c) == null) {
                            abs[abs.length - 1] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](trg.view.getRoutingCenterX(trg), trg.view.getRoutingCenterY(trg));
                        }
                    }
                    const checkRemove = (idx, tmp)=>{
                        if (idx > 0 && idx < abs.length - 1 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ptSegDistSq"])(abs[idx - 1].x, abs[idx - 1].y, abs[idx + 1].x, abs[idx + 1].y, tmp.x, tmp.y) < tol) {
                            points.splice(idx - 1, 1);
                            result = points;
                        }
                    };
                    // LATER: Check if other points can be removed if a segment is made straight
                    checkRemove(this.index, pt);
                }
            }
            // Updates existing point
            if (result == null && this.index > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VIRTUAL_HANDLE) {
                points[this.index - 1] = point;
            }
        } else if (this.graph.isResetEdgesOnConnect()) {
            points = [];
        }
        return result != null ? result : points;
    }
    /**
     * Returns true if {@link outlineConnect} is true and the source of the event is the outline shape
     * or shift is pressed.
     */ isOutlineConnectEvent(me) {
        if (!this.currentPoint) return false;
        const offset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOffset"])(this.graph.container);
        const evt = me.getEvent();
        const clientX = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientX"])(evt);
        const clientY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientY"])(evt);
        const doc = document.documentElement;
        const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
        const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
        const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;
        const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;
        return this.outlineConnect && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isShiftDown"])(me.getEvent()) && (me.isSource(this.marker.highlight.shape) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAltDown"])(me.getEvent()) && me.getState() != null || this.marker.highlight.isHighlightAt(clientX, clientY) || (gridX !== clientX || gridY !== clientY) && me.getState() == null && this.marker.highlight.isHighlightAt(gridX, gridY));
    }
    /**
     * Updates the given preview state taking into account the state of the constraint handler.
     */ updatePreviewState(edgeState, point, terminalState, me, outline = false) {
        // Computes the points for the edge style and terminals
        const sourceState = this.isSource ? terminalState : this.state.getVisibleTerminalState(true);
        const targetState = this.isTarget ? terminalState : this.state.getVisibleTerminalState(false);
        let sourceConstraint = this.graph.getConnectionConstraint(edgeState, sourceState, true);
        let targetConstraint = this.graph.getConnectionConstraint(edgeState, targetState, false);
        let constraint = this.constraintHandler.currentConstraint;
        if (constraint == null && outline) {
            if (terminalState != null) {
                // Handles special case where mouse is on outline away from actual end point
                // in which case the grid is ignored and mouse point is used instead
                if (me.isSource(this.marker.highlight.shape)) {
                    point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](me.getGraphX(), me.getGraphY());
                }
                constraint = this.graph.getOutlineConstraint(point, terminalState, me);
                this.constraintHandler.setFocus(me, terminalState, this.isSource);
                this.constraintHandler.currentConstraint = constraint;
                this.constraintHandler.currentPoint = point;
            } else {
                constraint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$other$2f$ConnectionConstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](null);
            }
        }
        if (this.outlineConnect && this.marker.highlight != null && this.marker.highlight.shape != null) {
            const s = this.graph.view.scale;
            if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
                this.marker.highlight.shape.stroke = outline ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OUTLINE_HIGHLIGHT_COLOR"] : 'transparent';
                this.marker.highlight.shape.strokeWidth = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OUTLINE_HIGHLIGHT_STROKEWIDTH"] / s / s;
                this.marker.highlight.repaint();
            } else if (this.marker.hasValidState()) {
                const cell = me.getCell();
                this.marker.highlight.shape.stroke = cell && cell.isConnectable() && this.marker.getValidState() !== me.getState() ? 'transparent' : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_VALID_COLOR"];
                this.marker.highlight.shape.strokeWidth = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HIGHLIGHT_STROKEWIDTH"] / s / s;
                this.marker.highlight.repaint();
            }
        }
        if (this.isSource) {
            sourceConstraint = constraint;
        } else if (this.isTarget) {
            targetConstraint = constraint;
        }
        if (this.isSource || this.isTarget) {
            if (constraint != null && constraint.point != null) {
                edgeState.style[this.isSource ? 'exitX' : 'entryX'] = constraint.point.x;
                edgeState.style[this.isSource ? 'exitY' : 'entryY'] = constraint.point.y;
            } else {
                delete edgeState.style[this.isSource ? 'exitX' : 'entryX'];
                delete edgeState.style[this.isSource ? 'exitY' : 'entryY'];
            }
        }
        edgeState.setVisibleTerminalState(sourceState, true);
        edgeState.setVisibleTerminalState(targetState, false);
        if (!this.isSource || sourceState != null) {
            edgeState.view.updateFixedTerminalPoint(edgeState, sourceState, true, sourceConstraint);
        }
        if (!this.isTarget || targetState != null) {
            edgeState.view.updateFixedTerminalPoint(edgeState, targetState, false, targetConstraint);
        }
        if ((this.isSource || this.isTarget) && terminalState == null) {
            edgeState.setAbsoluteTerminalPoint(point, this.isSource);
            if (this.marker.getMarkedState() == null) {
                this.error = this.graph.isAllowDanglingEdges() ? null : '';
            }
        }
        edgeState.view.updatePoints(edgeState, this.points, sourceState, targetState);
        edgeState.view.updateFloatingTerminalPoints(edgeState, sourceState, targetState);
    }
    /**
     * Handles the event by updating the preview.
     */ mouseMove(sender, me) {
        if (this.index != null && this.marker != null) {
            this.currentPoint = this.getPointForEvent(me);
            this.error = null;
            // Uses the current point from the constraint handler if available
            if (!this.graph.isIgnoreTerminalEvent(me.getEvent()) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isShiftDown"])(me.getEvent()) && this.snapPoint != null) {
                if (Math.abs(this.snapPoint.x - this.currentPoint.x) < Math.abs(this.snapPoint.y - this.currentPoint.y)) {
                    this.currentPoint.x = this.snapPoint.x;
                } else {
                    this.currentPoint.y = this.snapPoint.y;
                }
            }
            if (this.index <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE && this.index > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VIRTUAL_HANDLE) {
                if (this.customHandles != null) {
                    this.customHandles[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE - this.index].processEvent(me);
                    this.customHandles[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE - this.index].positionChanged();
                    if (this.shape != null && this.shape.node != null) {
                        this.shape.node.style.display = 'none';
                    }
                }
            } else if (this.isLabel && this.label) {
                this.label.x = this.currentPoint.x;
                this.label.y = this.currentPoint.y;
            } else {
                this.points = this.getPreviewPoints(this.currentPoint, me);
                let terminalState = this.isSource || this.isTarget ? this.getPreviewTerminalState(me) : null;
                if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null && this.constraintHandler.currentPoint != null) {
                    this.currentPoint = this.constraintHandler.currentPoint.clone();
                } else if (this.outlineConnect) {
                    // Need to check outline before cloning terminal state
                    const outline = this.isSource || this.isTarget ? this.isOutlineConnectEvent(me) : false;
                    if (outline) {
                        terminalState = this.marker.highlight.state;
                    } else if (terminalState != null && terminalState !== me.getState() && me.getCell()?.isConnectable() && this.marker.highlight.shape != null) {
                        this.marker.highlight.shape.stroke = 'transparent';
                        this.marker.highlight.repaint();
                        terminalState = null;
                    }
                }
                if (terminalState != null && !this.isCellEnabled(terminalState.cell)) {
                    terminalState = null;
                    this.marker.reset();
                }
                if (this.currentPoint) {
                    const clone = this.clonePreviewState(this.currentPoint, terminalState != null ? terminalState.cell : null);
                    this.updatePreviewState(clone, this.currentPoint, terminalState, me, this.outline);
                    // Sets the color of the preview to valid or invalid, updates the
                    // points of the preview and redraws
                    const color = this.error == null ? this.marker.validColor : this.marker.invalidColor;
                    this.setPreviewColor(color);
                    this.abspoints = clone.absolutePoints;
                    this.active = true;
                    this.updateHint(me, this.currentPoint);
                }
            }
            // This should go before calling isOutlineConnectEvent above. As a workaround
            // we add an offset of gridSize to the hint to avoid problem with hit detection
            // in highlight.isHighlightAt (which uses comonentFromPoint)
            this.drawPreview();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(me.getEvent());
            me.consume();
        }
    }
    /**
     * Handles the event to applying the previewed changes on the edge by
     * using {@link moveLabel}, {@link connect} or {@link changePoints}.
     */ mouseUp(sender, me) {
        // Workaround for wrong event source in Webkit
        if (this.index != null && this.marker != null) {
            if (this.shape != null && this.shape.node != null) {
                this.shape.node.style.display = '';
            }
            let edge = this.state.cell;
            const { index } = this;
            this.index = null;
            // Ignores event if mouse has not been moved
            if (me.getX() !== this.startX || me.getY() !== this.startY) {
                const clone = !this.graph.isIgnoreTerminalEvent(me.getEvent()) && this.graph.isCloneEvent(me.getEvent()) && this.cloneEnabled && this.graph.isCellsCloneable();
                // Displays the reason for not carriying out the change
                // if there is an error message with non-zero length
                if (this.error != null) {
                    if (this.error.length > 0) {
                        this.graph.validationAlert(this.error);
                    }
                } else if (index <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE && index > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].VIRTUAL_HANDLE) {
                    if (this.customHandles != null) {
                        const model = this.graph.getDataModel();
                        model.beginUpdate();
                        try {
                            this.customHandles[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE - index].execute(me);
                            if (this.shape != null && this.shape.node != null) {
                                this.shape.apply(this.state);
                                this.shape.redraw();
                            }
                        } finally{
                            model.endUpdate();
                        }
                    }
                } else if (this.isLabel && this.label) {
                    this.moveLabel(this.state, this.label.x, this.label.y);
                } else if (this.isSource || this.isTarget) {
                    let terminal = null;
                    if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
                        terminal = this.constraintHandler.currentFocus.cell;
                    }
                    if (!terminal && this.marker.hasValidState() && this.marker.highlight != null && this.marker.highlight.shape != null && this.marker.highlight.shape.stroke !== 'transparent' && this.marker.highlight.shape.stroke !== 'white') {
                        terminal = this.marker.validState.cell;
                    }
                    if (terminal) {
                        const model = this.graph.getDataModel();
                        const parent = edge.getParent();
                        model.beginUpdate();
                        try {
                            // Clones and adds the cell
                            if (clone) {
                                let geo = edge.getGeometry();
                                const cloned = this.graph.cloneCell(edge);
                                model.add(parent, cloned, parent.getChildCount());
                                if (geo != null) {
                                    geo = geo.clone();
                                    model.setGeometry(cloned, geo);
                                }
                                const other = edge.getTerminal(!this.isSource);
                                this.graph.connectCell(cloned, other, !this.isSource);
                                edge = cloned;
                            }
                            edge = this.connect(edge, terminal, this.isSource, clone, me);
                        } finally{
                            model.endUpdate();
                        }
                    } else if (this.graph.isAllowDanglingEdges()) {
                        const pt = this.abspoints[this.isSource ? 0 : this.abspoints.length - 1];
                        pt.x = this.roundLength(pt.x / this.graph.view.scale - this.graph.view.translate.x);
                        pt.y = this.roundLength(pt.y / this.graph.view.scale - this.graph.view.translate.y);
                        const parent = edge.getParent();
                        const pstate = parent ? this.graph.getView().getState(parent) : null;
                        if (pstate != null) {
                            pt.x -= pstate.origin.x;
                            pt.y -= pstate.origin.y;
                        }
                        pt.x -= this.graph.getPanDx() / this.graph.view.scale;
                        pt.y -= this.graph.getPanDy() / this.graph.view.scale;
                        // Destroys and recreates this handler
                        edge = this.changeTerminalPoint(edge, pt, this.isSource, clone);
                    }
                } else if (this.active) {
                    edge = this.changePoints(edge, this.points, clone);
                } else {
                    this.graph.getView().invalidate(this.state.cell);
                    this.graph.getView().validate(this.state.cell);
                }
            } else if (this.graph.isToggleEvent(me.getEvent())) {
                this.graph.selectCellForEvent(this.state.cell, me.getEvent());
            }
            // Resets the preview color the state of the handler if this
            // handler has not been recreated
            if (this.marker != null) {
                this.reset();
                // Updates the selection if the edge has been cloned
                if (edge !== this.state.cell) {
                    this.graph.setSelectionCell(edge);
                }
            }
            me.consume();
        }
    }
    /**
     * Resets the state of this handler.
     */ reset() {
        if (this.active) {
            this.refresh();
        }
        this.error = null;
        this.index = null;
        this.points = [];
        this.snapPoint = null;
        this.isLabel = false;
        this.isSource = false;
        this.isTarget = false;
        this.active = false;
        if (this.marker) {
            this.marker.reset();
        }
        this.constraintHandler.reset();
        if (this.customHandles) {
            for(let i = 0; i < this.customHandles.length; i += 1){
                this.customHandles[i].reset();
            }
        }
        this.setPreviewColor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EdgeHandlerConfig"].selectionColor);
        this.removeHint();
        this.redraw();
    }
    /**
     * Sets the color of the preview to the given value.
     */ setPreviewColor(color) {
        this.shape.stroke = color;
    }
    /**
     * Converts the given point in-place from screen to unscaled, untranslated
     * graph coordinates and applies the grid. Returns the given, modified
     * point instance.
     *
     * @param point {@link Point} to be converted.
     * @param gridEnabled Boolean that specifies if the grid should be applied.
     */ convertPoint(point, gridEnabled) {
        const scale = this.graph.getView().getScale();
        const tr = this.graph.getView().getTranslate();
        if (gridEnabled) {
            point.x = this.graph.snap(point.x);
            point.y = this.graph.snap(point.y);
        }
        point.x = Math.round(point.x / scale - tr.x);
        point.y = Math.round(point.y / scale - tr.y);
        const parent = this.state.cell.getParent();
        const pstate = parent ? this.graph.getView().getState(parent) : parent;
        if (pstate) {
            point.x -= pstate.origin.x;
            point.y -= pstate.origin.y;
        }
        return point;
    }
    /**
     * Changes the coordinates for the label of the given edge.
     *
     * @param edge {@link Cell} that represents the edge.
     * @param x Integer that specifies the x-coordinate of the new location.
     * @param y Integer that specifies the y-coordinate of the new location.
     */ moveLabel(edgeState, x, y) {
        const model = this.graph.getDataModel();
        let geometry = edgeState.cell.getGeometry();
        if (geometry != null) {
            const { scale } = this.graph.getView();
            geometry = geometry.clone();
            if (geometry.relative) {
                // Resets the relative location stored inside the geometry
                let pt = this.graph.getView().getRelativePoint(edgeState, x, y);
                geometry.x = Math.round(pt.x * 10000) / 10000;
                geometry.y = Math.round(pt.y);
                // Resets the offset inside the geometry to find the offset
                // from the resulting point
                geometry.offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](0, 0);
                pt = this.graph.view.getPoint(edgeState, geometry);
                geometry.offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.round((x - pt.x) / scale), Math.round((y - pt.y) / scale));
            } else {
                const points = edgeState.absolutePoints;
                const p0 = points[0];
                const pe = points[points.length - 1];
                if (p0 != null && pe != null) {
                    const cx = p0.x + (pe.x - p0.x) / 2;
                    const cy = p0.y + (pe.y - p0.y) / 2;
                    geometry.offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.round((x - cx) / scale), Math.round((y - cy) / scale));
                    geometry.x = 0;
                    geometry.y = 0;
                }
            }
            model.setGeometry(edgeState.cell, geometry);
        }
    }
    /**
     * Changes the terminal or terminal point of the given edge in the graph
     * model.
     *
     * @param edge {@link Cell} that represents the edge to be reconnected.
     * @param terminal {@link Cell} that represents the new terminal.
     * @param isSource Boolean indicating if the new terminal is the source or
     * target terminal.
     * @param isClone Boolean indicating if the new connection should be a clone of
     * the old edge.
     * @param me {@link MouseEvent} that contains the mouse up event.
     */ connect(edge, terminal, isSource, isClone, me) {
        const parent = edge.getParent();
        this.graph.batchUpdate(()=>{
            let constraint = this.constraintHandler.currentConstraint;
            if (constraint == null) {
                constraint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$other$2f$ConnectionConstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](null);
            }
            this.graph.connectCell(edge, terminal, isSource, constraint);
        });
        return edge;
    }
    /**
     * Changes the terminal point of the given edge.
     */ changeTerminalPoint(edge, point, isSource, clone) {
        const model = this.graph.getDataModel();
        model.batchUpdate(()=>{
            if (clone) {
                const parent = edge.getParent();
                const terminal = edge.getTerminal(!isSource);
                edge = this.graph.cloneCell(edge);
                model.add(parent, edge, parent.getChildCount());
                model.setTerminal(edge, terminal, !isSource);
            }
            let geo = edge.getGeometry();
            if (geo != null) {
                geo = geo.clone();
                geo.setTerminalPoint(point, isSource);
                model.setGeometry(edge, geo);
                this.graph.connectCell(edge, null, isSource, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$other$2f$ConnectionConstraint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](null));
            }
        });
        return edge;
    }
    /**
     * Changes the control points of the given edge in the graph model.
     */ changePoints(edge, points, clone) {
        const model = this.graph.getDataModel();
        model.batchUpdate(()=>{
            if (clone) {
                const parent = edge.getParent();
                const source = edge.getTerminal(true);
                const target = edge.getTerminal(false);
                edge = this.graph.cloneCell(edge);
                model.add(parent, edge, parent.getChildCount());
                model.setTerminal(edge, source, true);
                model.setTerminal(edge, target, false);
            }
            let geo = edge.getGeometry();
            if (geo != null) {
                geo = geo.clone();
                geo.points = points;
                model.setGeometry(edge, geo);
            }
        });
        return edge;
    }
    /**
     * Adds a control point for the given state and event.
     */ addPoint(state, evt) {
        const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertPoint"])(this.graph.container, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientX"])(evt), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientY"])(evt));
        const gridEnabled = this.graph.isGridEnabledEvent(evt);
        this.convertPoint(pt, gridEnabled);
        this.addPointAt(state, pt.x, pt.y);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(evt);
    }
    /**
     * Adds a control point at the given point.
     */ addPointAt(state, x, y) {
        let geo = state.cell.getGeometry();
        const pt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](x, y);
        if (geo != null) {
            geo = geo.clone();
            const t = this.graph.view.translate;
            const s = this.graph.view.scale;
            let offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](t.x * s, t.y * s);
            const parent = this.state.cell.getParent();
            if (parent && parent.isVertex()) {
                const pState = this.graph.view.getState(parent);
                if (pState) offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](pState.x, pState.y);
            }
            const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["findNearestSegment"])(state, pt.x * s + offset.x, pt.y * s + offset.y);
            if (geo.points == null) {
                geo.points = [
                    pt
                ];
            } else {
                geo.points.splice(index, 0, pt);
            }
            this.graph.getDataModel().setGeometry(state.cell, geo);
            this.refresh();
            this.redraw();
        }
    }
    /**
     * Removes the control point at the given index from the given state.
     */ removePoint(state, index) {
        if (index > 0 && index < this.abspoints.length - 1) {
            let geo = this.state.cell.getGeometry();
            if (geo != null && geo.points != null) {
                geo = geo.clone();
                (geo.points || []).splice(index - 1, 1);
                this.graph.getDataModel().setGeometry(state.cell, geo);
                this.refresh();
                this.redraw();
            }
        }
    }
    /**
     * Returns the fillcolor for the handle at the given index.
     */ getHandleFillColor(index) {
        const isSource = index === 0;
        const { cell } = this.state;
        const terminal = cell.getTerminal(isSource);
        let color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].fillColor;
        if (terminal != null && !this.graph.isCellDisconnectable(cell, terminal, isSource) || terminal == null && !this.graph.isTerminalPointMovable(cell, isSource)) {
            color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LOCKED_HANDLE_FILLCOLOR"];
        } else if (terminal != null && this.graph.isCellDisconnectable(cell, terminal, isSource)) {
            color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EdgeHandlerConfig"].connectFillColor;
        }
        return color;
    }
    /**
     * Redraws the preview, and the bends- and label control points.
     */ redraw(ignoreHandles) {
        this.abspoints = this.state.absolutePoints.slice();
        const g = this.state.cell.getGeometry();
        if (g) {
            const pts = g.points;
            if (this.bends != null && this.bends.length > 0) {
                if (pts != null) {
                    if (this.points == null) {
                        this.points = [];
                    }
                    for(let i = 1; i < this.bends.length - 1; i += 1){
                        if (this.bends[i] != null && this.abspoints[i] != null) {
                            this.points[i - 1] = pts[i - 1];
                        }
                    }
                }
            }
        }
        this.drawPreview();
        if (!ignoreHandles) {
            this.redrawHandles();
        }
    }
    /**
     * Redraws the handles.
     */ redrawHandles() {
        const { cell } = this.state;
        // Updates the handle for the label position
        let b = this.labelShape.bounds;
        this.label = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.state.absoluteOffset.x, this.state.absoluteOffset.y);
        this.labelShape.bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);
        // Shows or hides the label handle depending on the label
        const lab = this.graph.getLabel(cell);
        this.labelShape.visible = lab != null && lab.length > 0 && this.graph.isLabelMovable(cell);
        if (this.bends != null && this.bends.length > 0) {
            const n = this.abspoints.length - 1;
            const p0 = this.abspoints[0];
            const x0 = p0.x;
            const y0 = p0.y;
            b = this.bends[0].bounds;
            this.bends[0].bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.floor(x0 - b.width / 2), Math.floor(y0 - b.height / 2), b.width, b.height);
            this.bends[0].fill = this.getHandleFillColor(0);
            this.bends[0].redraw();
            if (this.manageLabelHandle) {
                this.checkLabelHandle(this.bends[0].bounds);
            }
            const pe = this.abspoints[n];
            const xn = pe.x;
            const yn = pe.y;
            const bn = this.bends.length - 1;
            b = this.bends[bn].bounds;
            this.bends[bn].bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.floor(xn - b.width / 2), Math.floor(yn - b.height / 2), b.width, b.height);
            this.bends[bn].fill = this.getHandleFillColor(bn);
            this.bends[bn].redraw();
            if (this.manageLabelHandle) {
                this.checkLabelHandle(this.bends[bn].bounds);
            }
            this.redrawInnerBends(p0, pe);
        }
        if (this.virtualBends && this.virtualBends.length > 0) {
            let last = this.abspoints[0];
            for(let i = 0; i < this.virtualBends.length; i += 1){
                if (this.virtualBends[i] != null && this.abspoints[i + 1] != null) {
                    const pt = this.abspoints[i + 1];
                    const b = this.virtualBends[i];
                    const x = last.x + (pt.x - last.x) / 2;
                    const y = last.y + (pt.y - last.y) / 2;
                    if (b.bounds) {
                        b.bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.floor(x - b.bounds.width / 2), Math.floor(y - b.bounds.height / 2), b.bounds.width, b.bounds.height);
                        b.redraw();
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setOpacity"])(b.node, this.virtualBendOpacity);
                    last = pt;
                    if (this.manageLabelHandle) {
                        this.checkLabelHandle(b.bounds);
                    }
                }
            }
        }
        this.labelShape.redraw();
        if (this.customHandles) {
            for(let i = 0; i < this.customHandles.length; i += 1){
                const shape = this.customHandles[i].shape;
                if (shape) {
                    const temp = shape.node.style.display;
                    this.customHandles[i].redraw();
                    shape.node.style.display = temp;
                    // Hides custom handles during text editing
                    shape.node.style.visibility = this.isCustomHandleVisible(this.customHandles[i]) ? '' : 'hidden';
                }
            }
        }
    }
    /**
     * Returns true if the given custom handle is visible.
     */ isCustomHandleVisible(handle) {
        return !this.graph.isEditing() && this.state.view.graph.getSelectionCount() === 1;
    }
    /**
     * Shortcut to {@link hideSizers}.
     */ setHandlesVisible(visible) {
        for(let i = 0; i < this.bends.length; i += 1){
            this.bends[i].node.style.display = visible ? '' : 'none';
        }
        if (this.virtualBends) {
            for(let i = 0; i < this.virtualBends.length; i += 1){
                this.virtualBends[i].node.style.display = visible ? '' : 'none';
            }
        }
        this.labelShape.node.style.display = visible ? '' : 'none';
        if (this.customHandles) {
            for(let i = 0; i < this.customHandles.length; i += 1){
                this.customHandles[i].setVisible(visible);
            }
        }
    }
    /**
     * Updates and redraws the inner bends.
     *
     * @param p0 {@link Point} that represents the location of the first point.
     * @param pe {@link Point} that represents the location of the last point.
     */ redrawInnerBends(p0, pe) {
        for(let i = 1; i < this.bends.length - 1; i += 1){
            if (this.bends[i] != null) {
                if (this.abspoints[i] != null) {
                    const { x } = this.abspoints[i];
                    const { y } = this.abspoints[i];
                    const b = this.bends[i].bounds;
                    this.bends[i].node.style.visibility = 'visible';
                    this.bends[i].bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.round(x - b.width / 2), Math.round(y - b.height / 2), b.width, b.height);
                    if (this.manageLabelHandle) {
                        this.checkLabelHandle(this.bends[i].bounds);
                    } else if (this.handleImage == null && this.labelShape.visible && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersects"])(this.bends[i].bounds, this.labelShape.bounds)) {
                        const w = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].size + 3;
                        const h = w;
                        this.bends[i].bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.round(x - w / 2), Math.round(y - h / 2), w, h);
                    }
                    this.bends[i].redraw();
                } else {
                    this.bends[i].destroy();
                }
            }
        }
    }
    /**
     * Checks if the label handle intersects the given bounds and moves it if it
     * intersects.
     */ checkLabelHandle(b) {
        const b2 = this.labelShape.bounds;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersects"])(b, b2)) {
            if (b.getCenterY() < b2.getCenterY()) {
                b2.y = b.y + b.height;
            } else {
                b2.y = b.y - b2.height;
            }
        }
    }
    /**
     * Redraws the preview.
     */ drawPreview() {
        try {
            if (this.isLabel) {
                const b = this.labelShape.bounds;
                const bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);
                if (!b.equals(bounds)) {
                    this.labelShape.bounds = bounds;
                    this.labelShape.redraw();
                }
            }
            if (this.shape != null && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$arrayUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["equalPoints"])(this.shape.points, this.abspoints)) {
                this.shape.apply(this.state);
                this.shape.points = this.abspoints.slice();
                this.shape.scale = this.state.view.scale;
                this.shape.isDashed = this.isSelectionDashed();
                this.shape.stroke = this.getSelectionColor();
                this.shape.strokeWidth = this.getSelectionStrokeWidth() / this.shape.scale / this.shape.scale;
                this.shape.isShadow = false;
                this.shape.redraw();
            }
            this.updateParentHighlight();
        } catch (e) {
        // ignore
        }
    }
    /**
     * Refreshes the bends of this handler.
     */ refresh() {
        if (this.state != null) {
            this.abspoints = this.getSelectionPoints(this.state);
            this.points = [];
            this.destroyBends(this.bends);
            this.bends = this.createBends();
            if (this.virtualBends) {
                this.destroyBends(this.virtualBends);
                this.virtualBends = this.createVirtualBends();
            }
            if (this.customHandles) {
                this.destroyBends(this.customHandles);
                this.customHandles = this.createCustomHandles();
            }
            // Puts label node on top of bends
            if (this.labelShape != null && this.labelShape.node != null && this.labelShape.node.parentNode != null) {
                this.labelShape.node.parentNode.appendChild(this.labelShape.node);
            }
        }
    }
    /**
     * Returns true if {@link destroy} was called.
     */ isDestroyed() {
        return this.shape == null;
    }
    /**
     * Destroys all elements in {@link bends}.
     */ destroyBends(bends) {
        if (bends != null) {
            for(let i = 0; i < bends.length; i += 1){
                if (bends[i] != null) {
                    bends[i].destroy();
                }
            }
        }
    }
    /**
     * Destroys the handler and all its resources and DOM nodes. This does
     * normally not need to be called as handlers are destroyed automatically
     * when the corresponding cell is deselected.
     */ onDestroy() {
        this.state.view.graph.removeListener(this.escapeHandler);
        this.marker.destroy();
        // @ts-expect-error Can be null when destroyed.
        this.marker = null;
        this.shape.destroy();
        // @ts-expect-error Can be null when destroyed.
        this.shape = null;
        if (this.parentHighlight) {
            const parent = this.state.cell.getParent();
            const pstate = parent ? this.graph.view.getState(parent) : null;
            if (pstate && pstate.parentHighlight === this.parentHighlight) {
                pstate.parentHighlight = null;
            }
            this.parentHighlight.destroy();
            this.parentHighlight = null;
        }
        this.labelShape.destroy();
        // @ts-expect-error Can be null when destroyed.
        this.labelShape = null;
        this.constraintHandler.onDestroy();
        // @ts-expect-error Can be null when destroyed.
        this.constraintHandler = null;
        if (this.virtualBends) {
            this.destroyBends(this.virtualBends);
            this.virtualBends = [];
        }
        if (this.customHandles) {
            this.destroyBends(this.customHandles);
            this.customHandles = [];
        }
        this.destroyBends(this.bends);
        this.bends = [];
        this.removeHint();
    }
}
class EdgeHandlerCellMarker extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellMarker$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    constructor(graph, edgeHandler, validColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_VALID_COLOR"], invalidColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_INVALID_COLOR"], hotspot = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_HOTSPOT"]){
        super(graph, validColor, invalidColor, hotspot);
        // Only returns edges if they are connectable and never returns
        // the edge that is currently being modified
        this.getCell = (me)=>{
            let cell = super.getCell(me);
            // Checks for cell at preview point (with grid)
            if ((cell === this.edgeHandler.state.cell || !cell) && this.edgeHandler.currentPoint) {
                cell = this.edgeHandler.graph.getCellAt(this.edgeHandler.currentPoint.x, this.edgeHandler.currentPoint.y);
            }
            // Uses connectable parent vertex if one exists
            if (cell && !cell.isConnectable()) {
                const parent = cell.getParent();
                if (parent && parent.isVertex() && parent.isConnectable()) {
                    cell = parent;
                }
            }
            if (cell) {
                if (this.graph.isSwimlane(cell) && this.edgeHandler.currentPoint && this.graph.hitsSwimlaneContent(cell, this.edgeHandler.currentPoint.x, this.edgeHandler.currentPoint.y) || !this.edgeHandler.isConnectableCell(cell) || cell === this.edgeHandler.state.cell || cell && !this.edgeHandler.graph.connectableEdges && cell.isEdge() || this.edgeHandler.state.cell.isAncestor(cell)) {
                    cell = null;
                }
            }
            if (cell && !cell.isConnectable()) {
                cell = null;
            }
            return cell;
        };
        // Sets the highlight color according to validateConnection
        this.isValidState = (state)=>{
            const cell = this.edgeHandler.state.cell.getTerminal(!this.edgeHandler.isSource);
            const cellState = this.edgeHandler.graph.view.getState(cell);
            const other = this.edgeHandler.graph.view.getTerminalPort(state, cellState, !this.edgeHandler.isSource);
            const otherCell = other ? other.cell : null;
            const source = this.edgeHandler.isSource ? state.cell : otherCell;
            const target = this.edgeHandler.isSource ? otherCell : state.cell;
            // Updates the error message of the handler
            this.edgeHandler.error = this.edgeHandler.validateConnection(source, target);
            return !this.edgeHandler.error;
        };
        this.edgeHandler = edgeHandler;
    }
}
const __TURBOPACK__default__export__ = EdgeHandler;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/handler/ElbowEdgeHandler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Translations$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Translations.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$EdgeHandler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/EdgeHandler.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
/**
 * Graph event handler that reconnects edges and modifies control points and
 * the edge label location. Uses {@link CellMarker} for finding and
 * highlighting new source and target vertices. This handler is automatically
 * created in {@link Graph.createHandler}. It extends {@link EdgeHandler}.
 *
 * Constructor: mxEdgeHandler
 *
 * Constructs an edge handler for the specified {@link CellState}.
 *
 * @param state {@link CellState} of the cell to be modified.
 */ class ElbowEdgeHandler extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$EdgeHandler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    constructor(state){
        super(state);
        /**
         * Specifies if a double click on the middle handle should call {@link Graph#flipEdge}.
         * @default true
         */ this.flipEnabled = true;
        /**
         * Specifies the resource key for the tooltip to be displayed on the single
         * control point for routed edges. If the resource for this key does not
         * exist then the value is used as the error message.
         * @default 'doubleClickOrientation'.
         */ this.doubleClickOrientationResource = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].language !== 'none' ? 'doubleClickOrientation' : '';
    }
    /**
     * Overrides {@link EdgeHandler.createBends} to create custom bends.
     */ createBends() {
        const bends = [];
        // Source
        let bend = this.createHandleShape(0);
        this.initBend(bend);
        bend.setCursor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CURSOR"].TERMINAL_HANDLE);
        bends.push(bend);
        // Virtual
        bends.push(this.createVirtualBend((evt)=>{
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isConsumed"])(evt) && this.flipEnabled) {
                this.graph.flipEdge(this.state.cell);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(evt);
            }
        }));
        this.points.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](0, 0));
        // Target
        bend = this.createHandleShape(2);
        this.initBend(bend);
        bend.setCursor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CURSOR"].TERMINAL_HANDLE);
        bends.push(bend);
        return bends;
    }
    /**
     * Creates a virtual bend that supports double-clicking and calls {@link Graph#flipEdge}.
     */ createVirtualBend(dblClickHandler) {
        const bend = this.createHandleShape();
        this.initBend(bend, dblClickHandler);
        bend.setCursor(this.getCursorForBend());
        if (!this.graph.isCellBendable(this.state.cell)) {
            bend.node.style.display = 'none';
        }
        return bend;
    }
    /**
     * Returns the cursor to be used for the bend.
     */ getCursorForBend() {
        return this.state.style.edgeStyle === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EDGESTYLE"].TOPTOBOTTOM || this.state.style.edgeStyle === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EDGESTYLE"].ELBOW && this.state.style.elbow === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ELBOW"].VERTICAL ? 'row-resize' : 'col-resize';
    }
    /**
     * Returns the tooltip for the given node.
     */ getTooltipForNode(node) {
        let tip = null;
        if (this.bends != null && this.bends[1] != null && (node === this.bends[1].node || node.parentNode === this.bends[1].node)) {
            tip = this.doubleClickOrientationResource;
            tip = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Translations$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].get(tip) || tip; // translate
        }
        return tip;
    }
    /**
     * Converts the given point in-place from screen to unscaled, untranslated
     * graph coordinates and applies the grid.
     *
     * @param point {@link Point} to be converted.
     * @param gridEnabled Boolean that specifies if the grid should be applied.
     */ convertPoint(point, gridEnabled) {
        const scale = this.graph.getView().getScale();
        const tr = this.graph.getView().getTranslate();
        const { origin } = this.state;
        if (gridEnabled) {
            point.x = this.graph.snap(point.x);
            point.y = this.graph.snap(point.y);
        }
        point.x = Math.round(point.x / scale - tr.x - origin.x);
        point.y = Math.round(point.y / scale - tr.y - origin.y);
        return point;
    }
    /**
     * Updates and redraws the inner bends.
     *
     * @param p0 {@link Point} that represents the location of the first point.
     * @param pe {@link Point} that represents the location of the last point.
     */ redrawInnerBends(p0, pe) {
        const g = this.state.cell.getGeometry();
        const pts = this.state.absolutePoints;
        let pt = null;
        // Keeps the virtual bend on the edge shape
        if (pts.length > 1) {
            p0 = pts[1];
            pe = pts[pts.length - 2];
        } else if (g.points != null && g.points.length > 0) {
            pt = pts[0];
        }
        if (pt == null) {
            pt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);
        } else {
            pt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.graph.getView().scale * (pt.x + this.graph.getView().translate.x + this.state.origin.x), this.graph.getView().scale * (pt.y + this.graph.getView().translate.y + this.state.origin.y));
        }
        // Makes handle slightly bigger if the yellow  label handle
        // exists and intersects this green handle
        const b = this.bends[1].bounds;
        let w = b.width;
        let h = b.height;
        let bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.round(pt.x - w / 2), Math.round(pt.y - h / 2), w, h);
        if (this.manageLabelHandle) {
            this.checkLabelHandle(bounds);
        } else if (this.handleImage == null && this.labelShape.visible && this.labelShape.bounds && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersects"])(bounds, this.labelShape.bounds)) {
            w = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].size + 3;
            h = w;
            bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.floor(pt.x - w / 2), Math.floor(pt.y - h / 2), w, h);
        }
        this.bends[1].bounds = bounds;
        this.bends[1].redraw();
        if (this.manageLabelHandle) {
            this.checkLabelHandle(this.bends[1].bounds);
        }
    }
}
const __TURBOPACK__default__export__ = ElbowEdgeHandler;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/handler/EdgeSegmentHandler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$ElbowEdgeHandler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/ElbowEdgeHandler.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
class EdgeSegmentHandler extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$ElbowEdgeHandler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    constructor(state){
        super(state);
        this.points = [];
    }
    /**
     * Returns the current absolute points.
     */ getCurrentPoints() {
        let pts = this.state.absolutePoints;
        // Special case for straight edges where we add a virtual middle handle for moving the edge
        const tol = Math.max(1, this.graph.view.scale);
        if (pts.length === 2 && pts[0] && pts[1] || pts.length === 3 && pts[0] && pts[1] && pts[2] && (Math.abs(pts[0].x - pts[1].x) < tol && Math.abs(pts[1].x - pts[2].x) < tol || Math.abs(pts[0].y - pts[1].y) < tol && Math.abs(pts[1].y - pts[2].y) < tol)) {
            const cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;
            const cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;
            pts = [
                pts[0],
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](cx, cy),
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](cx, cy),
                pts[pts.length - 1]
            ];
        }
        return pts;
    }
    /**
     * Updates the given preview state taking into account the state of the constraint handler.
     */ getPreviewPoints(point) {
        if (this.isSource || this.isTarget) {
            return super.getPreviewPoints(point);
        }
        const pts = this.getCurrentPoints();
        let last = this.convertPoint(pts[0].clone(), false);
        point = this.convertPoint(point.clone(), false);
        let result = [];
        for(let i = 1; i < pts.length; i += 1){
            const pt = this.convertPoint(pts[i].clone(), false);
            if (i === this.index) {
                if (Math.round(last.x - pt.x) === 0) {
                    last.x = point.x;
                    pt.x = point.x;
                }
                if (Math.round(last.y - pt.y) === 0) {
                    last.y = point.y;
                    pt.y = point.y;
                }
            }
            if (i < pts.length - 1) {
                result.push(pt);
            }
            last = pt;
        }
        // Replaces single point that intersects with source or target
        if (result.length === 1) {
            const source = this.state.getVisibleTerminalState(true);
            const target = this.state.getVisibleTerminalState(false);
            const scale = this.state.view.getScale();
            const tr = this.state.view.getTranslate();
            const x = result[0].x * scale + tr.x;
            const y = result[0].y * scale + tr.y;
            if (source != null && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["contains"])(source, x, y) || target != null && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["contains"])(target, x, y)) {
                result = [
                    point,
                    point
                ];
            }
        }
        return result;
    }
    /**
     * Overridden to perform optimization of the edge style result.
     */ updatePreviewState(edge, point, terminalState, me) {
        super.updatePreviewState(edge, point, terminalState, me);
        // Checks and corrects preview by running edge style again
        if (!this.isSource && !this.isTarget) {
            point = this.convertPoint(point.clone(), false);
            const pts = edge.absolutePoints;
            let pt0 = pts[0];
            let pt1 = pts[1];
            let result = [];
            for(let i = 2; i < pts.length; i += 1){
                const pt2 = pts[i];
                // Merges adjacent segments only if more than 2 to allow for straight edges
                if ((Math.round(pt0.x - pt1.x) !== 0 || Math.round(pt1.x - pt2.x) !== 0) && (Math.round(pt0.y - pt1.y) !== 0 || Math.round(pt1.y - pt2.y) !== 0)) {
                    result.push(this.convertPoint(pt1.clone(), false));
                }
                pt0 = pt1;
                pt1 = pt2;
            }
            const source = this.state.getVisibleTerminalState(true);
            const target = this.state.getVisibleTerminalState(false);
            const rpts = this.state.absolutePoints;
            const end = pts[pts.length - 1];
            // A straight line is represented by 3 handles
            if (result.length === 0 && pts[0] && end && (Math.round(pts[0].x - end.x) === 0 || Math.round(pts[0].y - end.y) === 0)) {
                result = [
                    point,
                    point
                ];
            } else if (pts.length === 5 && result.length === 2 && source != null && target != null && rpts != null && Math.round(rpts[0].x - rpts[rpts.length - 1].x) === 0) {
                const view = this.graph.getView();
                const scale = view.getScale();
                const tr = view.getTranslate();
                let y0 = view.getRoutingCenterY(source) / scale - tr.y;
                // Use fixed connection point y-coordinate if one exists
                const sc = this.graph.getConnectionConstraint(edge, source, true);
                if (sc != null) {
                    const pt = this.graph.getConnectionPoint(source, sc);
                    if (pt != null) {
                        this.convertPoint(pt, false);
                        y0 = pt.y;
                    }
                }
                let ye = view.getRoutingCenterY(target) / scale - tr.y;
                // Use fixed connection point y-coordinate if one exists
                const tc = this.graph.getConnectionConstraint(edge, target, false);
                if (tc) {
                    const pt = this.graph.getConnectionPoint(target, tc);
                    if (pt != null) {
                        this.convertPoint(pt, false);
                        ye = pt.y;
                    }
                }
                result = [
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](point.x, y0),
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](point.x, ye)
                ];
            }
            this.points = result;
            // LATER: Check if points and result are different
            edge.view.updateFixedTerminalPoints(edge, source, target);
            edge.view.updatePoints(edge, this.points, source, target);
            edge.view.updateFloatingTerminalPoints(edge, source, target);
        }
    }
    /**
     * Overriden to merge edge segments.
     */ connect(edge, terminal, isSource, isClone, me) {
        const model = this.graph.getDataModel();
        let geo = edge.getGeometry();
        let result = null;
        // Merges adjacent edge segments
        if (geo != null && geo.points != null && geo.points.length > 0) {
            const pts = this.abspoints;
            let pt0 = pts[0];
            let pt1 = pts[1];
            result = [];
            for(let i = 2; i < pts.length; i += 1){
                const pt2 = pts[i];
                // Merges adjacent segments only if more than 2 to allow for straight edges
                if (pt0 && pt1 && pt2 && (Math.round(pt0.x - pt1.x) !== 0 || Math.round(pt1.x - pt2.x) !== 0) && (Math.round(pt0.y - pt1.y) !== 0 || Math.round(pt1.y - pt2.y) !== 0)) {
                    result.push(this.convertPoint(pt1.clone(), false));
                }
                pt0 = pt1;
                pt1 = pt2;
            }
        }
        this.graph.batchUpdate(()=>{
            if (result != null) {
                geo = edge.getGeometry();
                if (geo != null) {
                    geo = geo.clone();
                    geo.points = result;
                    model.setGeometry(edge, geo);
                }
            }
            edge = super.connect(edge, terminal, isSource, isClone, me);
        });
        return edge;
    }
    /**
     * Returns no tooltips.
     */ getTooltipForNode(node) {
        return null;
    }
    /**
     * Adds custom bends for the center of each segment.
     */ start(x, y, index) {
        super.start(x, y, index);
        if (this.bends != null && this.bends[index] != null && !this.isSource && !this.isTarget) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setOpacity"])(this.bends[index].node, 100);
        }
    }
    /**
     * Adds custom bends for the center of each segment.
     */ createBends() {
        const bends = [];
        // Source
        let bend = this.createHandleShape(0);
        this.initBend(bend);
        bend.setCursor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CURSOR"].TERMINAL_HANDLE);
        bends.push(bend);
        const pts = this.getCurrentPoints();
        // Waypoints (segment handles)
        if (this.graph.isCellBendable(this.state.cell)) {
            if (this.points == null) {
                this.points = [];
            }
            for(let i = 0; i < pts.length - 1; i += 1){
                bend = this.createVirtualBend();
                bends.push(bend);
                let horizontal = Math.round(pts[i].x - pts[i + 1].x) === 0;
                // Special case where dy is 0 as well
                if (Math.round(pts[i].y - pts[i + 1].y) === 0 && i < pts.length - 2) {
                    horizontal = Math.round(pts[i].x - pts[i + 2].x) === 0;
                }
                bend.setCursor(horizontal ? 'col-resize' : 'row-resize');
                this.points.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](0, 0));
            }
        }
        // Target
        bend = this.createHandleShape(pts.length);
        this.initBend(bend);
        bend.setCursor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CURSOR"].TERMINAL_HANDLE);
        bends.push(bend);
        return bends;
    }
    /**
     * Overridden to invoke <refresh> before the redraw.
     */ redraw() {
        this.refresh();
        super.redraw();
    }
    /**
     * Updates the position of the custom bends.
     */ redrawInnerBends(p0, pe) {
        if (this.graph.isCellBendable(this.state.cell)) {
            const pts = this.getCurrentPoints();
            if (pts != null && pts.length > 1) {
                let straight = false;
                // Puts handle in the center of straight edges
                if (pts.length === 4 && pts[0] && pts[1] && pts[2] && pts[3] && Math.round(pts[1].x - pts[2].x) === 0 && Math.round(pts[1].y - pts[2].y) === 0) {
                    straight = true;
                    if (Math.round(pts[0].y - pts[pts.length - 1].y) === 0) {
                        const cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;
                        pts[1] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](cx, pts[1].y);
                        pts[2] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](cx, pts[2].y);
                    } else {
                        const cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;
                        pts[1] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](pts[1].x, cy);
                        pts[2] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](pts[2].x, cy);
                    }
                }
                for(let i = 0; i < pts.length - 1; i += 1){
                    if (this.bends[i + 1] != null) {
                        p0 = pts[i];
                        pe = pts[i + 1];
                        const pt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);
                        const b = this.bends[i + 1].bounds;
                        this.bends[i + 1].bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.floor(pt.x - b.width / 2), Math.floor(pt.y - b.height / 2), b.width, b.height);
                        this.bends[i + 1].redraw();
                        if (this.manageLabelHandle) {
                            this.checkLabelHandle(this.bends[i + 1].bounds);
                        }
                    }
                }
                if (straight) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setOpacity"])(this.bends[1].node, this.virtualBendOpacity);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setOpacity"])(this.bends[3].node, this.virtualBendOpacity);
                }
            }
        }
    }
}
const __TURBOPACK__default__export__ = EdgeSegmentHandler;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/handler/VertexHandler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/RectangleShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$EllipseShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/EllipseShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/ImageShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
/**
 * Event handler for resizing cells.
 *
 * This handler is automatically created in {@link Graph#createHandler}.
 *
 * Some elements of this handler and its subclasses can be configured using {@link EdgeHandlerConfig}.
 */ class VertexHandler {
    /**
     * Specifies if a rotation handle should be visible.
     *
     * This implementation returns {@link VertexHandlerConfig.rotationEnabled}.
     * @since 0.12.0
     */ isRotationEnabled() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VertexHandlerConfig"].rotationEnabled;
    }
    /**
     * Constructs an event handler that allows to resize vertices and groups.
     *
     * @param state {@link CellState} of the cell to be resized.
     */ constructor(state){
        this.sizers = [];
        /**
         * Specifies if only one sizer handle at the bottom, right corner should be used.
         * @default false
         */ this.singleSizer = false;
        /**
         * Holds the index of the current handle.
         */ this.index = null;
        /**
         * Specifies if the bounds of handles should be used for hit-detection in IE or if {@link tolerance} > 0.
         * @default true
         */ this.allowHandleBoundsCheck = true;
        /**
         * Optional {@link Image} to be used as handles.
         * @default null
         */ this.handleImage = null;
        /**
         * If handles are currently visible.
         * @default true
         */ this.handlesVisible = true;
        /**
         * Optional tolerance for hit-detection in {@link getHandleForEvent}.
         * @default 0
         */ this.tolerance = 0;
        /**
         * Specifies if the parent should be highlighted if a child cell is selected.
         * @default false
         */ this.parentHighlightEnabled = false;
        /**
         * Specifies if rotation steps should be "rasterized" depending on the distance to the handle.
         * @default true
         */ this.rotationRaster = true;
        /**
         * Specifies the cursor for the rotation handle.
         * @default 'crosshair'.
         */ this.rotationCursor = 'crosshair';
        /**
         * Specifies if resize should change the cell in-place. This is an experimental
         * feature for non-touch devices.
         * @default false
         */ this.livePreview = false;
        /**
         * Specifies if the live preview should be moved to the front.
         * @default false
         */ this.movePreviewToFront = false;
        /**
         * Specifies if sizers should be hidden and spaced if the vertex is small.
         * @default false
         */ this.manageSizers = false;
        /**
         * Specifies if the size of groups should be constrained by the children.
         * @default false
         */ this.constrainGroupByChildren = false;
        /**
         * Vertical spacing for rotation icon.
         * @default -16
         */ this.rotationHandleVSpacing = -16;
        /**
         * The horizontal offset for the handles. This is updated in {@link redrawHandles}
         * if {@link manageSizers} is `true` and the sizers are offset horizontally.
         */ this.horizontalOffset = 0;
        /**
         * The horizontal offset for the handles. This is updated in <redrawHandles>
         * if {@link manageSizers} is true and the sizers are offset vertically.
         */ this.verticalOffset = 0;
        this.minBounds = null;
        this.x0 = 0;
        this.y0 = 0;
        this.customHandles = [];
        this.inTolerance = false;
        this.startX = 0;
        this.startY = 0;
        this.rotationShape = null;
        this.currentAlpha = 100;
        this.startAngle = 0;
        this.startDist = 0;
        this.ghostPreview = null;
        this.livePreviewActive = false;
        this.childOffsetX = 0;
        this.childOffsetY = 0;
        this.parentState = null;
        this.parentHighlight = null;
        this.unscaledBounds = null;
        this.preview = null;
        this.labelShape = null;
        this.edgeHandlers = [];
        this.EMPTY_POINT = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
        this.state = state;
        this.graph = this.state.view.graph;
        this.selectionBounds = this.getSelectionBounds(this.state);
        this.bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
        this.selectionBorder = this.createSelectionShape(this.bounds);
        // VML dialect required here for event transparency in IE
        this.selectionBorder.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG;
        this.selectionBorder.pointerEvents = false;
        this.selectionBorder.rotation = this.state.style.rotation ?? 0;
        this.selectionBorder.init(this.graph.getView().getOverlayPane());
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].redirectMouseEvents(this.selectionBorder.node, this.graph, this.state);
        if (this.graph.isCellMovable(this.state.cell)) {
            this.selectionBorder.setCursor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CURSOR"].MOVABLE_VERTEX);
        }
        const selectionHandler = this.graph.getPlugin('SelectionHandler');
        // Adds the sizer handles
        if (selectionHandler && (selectionHandler.maxCells <= 0 || this.graph.getSelectionCount() < selectionHandler.maxCells)) {
            const resizable = this.graph.isCellResizable(this.state.cell);
            this.sizers = [];
            if (resizable || this.graph.isLabelMovable(this.state.cell) && this.state.width >= 2 && this.state.height >= 2) {
                let i = 0;
                if (resizable) {
                    if (!this.singleSizer) {
                        this.sizers.push(this.createSizer('nw-resize', i++));
                        this.sizers.push(this.createSizer('n-resize', i++));
                        this.sizers.push(this.createSizer('ne-resize', i++));
                        this.sizers.push(this.createSizer('w-resize', i++));
                        this.sizers.push(this.createSizer('e-resize', i++));
                        this.sizers.push(this.createSizer('sw-resize', i++));
                        this.sizers.push(this.createSizer('s-resize', i++));
                    }
                    this.sizers.push(this.createSizer('se-resize', i++));
                }
                const geo = this.state.cell.getGeometry();
                if (geo != null && !geo.relative && //!this.graph.isSwimlane(this.state.cell) &&      disable for now
                this.graph.isLabelMovable(this.state.cell)) {
                    // Marks this as the label handle for getHandleForEvent
                    this.labelShape = this.createSizer(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CURSOR"].LABEL_HANDLE, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LABEL_HANDLE, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].labelSize, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].labelFillColor);
                    this.sizers.push(this.labelShape);
                }
            } else if (this.graph.isCellMovable(this.state.cell) && !this.graph.isCellResizable(this.state.cell) && this.state.width < 2 && this.state.height < 2) {
                this.labelShape = this.createSizer(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CURSOR"].MOVABLE_VERTEX, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LABEL_HANDLE, undefined, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].labelFillColor);
                this.sizers.push(this.labelShape);
            }
        }
        // Adds the rotation handler
        if (this.isRotationHandleVisible()) {
            this.rotationShape = this.createSizer(this.rotationCursor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ROTATION_HANDLE, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].size + 3, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].fillColor);
            this.sizers.push(this.rotationShape);
        }
        this.customHandles = this.createCustomHandles();
        this.redraw();
        if (this.constrainGroupByChildren) {
            this.updateMinBounds();
        }
        // Handles escape keystrokes
        this.escapeHandler = (_sender, _evt)=>{
            if (this.livePreview && this.index != null) {
                // Redraws the live preview
                this.state.view.graph.cellRenderer.redraw(this.state, true);
                // Redraws connected edges
                this.state.view.invalidate(this.state.cell);
                this.state.invalid = false;
                this.state.view.validate();
            }
            this.reset();
        };
        this.state.view.graph.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ESCAPE, this.escapeHandler);
    }
    /**
     * Returns `true` if the rotation handle should be showing.
     */ isRotationHandleVisible() {
        const selectionHandler = this.graph.getPlugin('SelectionHandler');
        const selectionHandlerCheck = selectionHandler ? selectionHandler.maxCells <= 0 || this.graph.getSelectionCount() < selectionHandler.maxCells : true;
        return this.graph.isEnabled() && this.isRotationEnabled() && this.graph.isCellRotatable(this.state.cell) && selectionHandlerCheck;
    }
    /**
     * Returns `true` if the aspect ratio if the cell should be maintained.
     */ isConstrainedEvent(me) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isShiftDown"])(me.getEvent()) || this.state.style.aspect === 'fixed';
    }
    /**
     * Returns `true` if the center of the vertex should be maintained during the resize.
     */ isCenteredEvent(state, me) {
        return false;
    }
    /**
     * Returns an array of custom handles.
     *
     * This implementation returns an empty array.
     */ createCustomHandles() {
        return [];
    }
    /**
     * Initializes the shapes required for this vertex handler.
     */ updateMinBounds() {
        const children = this.graph.getChildCells(this.state.cell);
        if (children.length > 0) {
            this.minBounds = this.graph.view.getBounds(children);
            if (this.minBounds) {
                const s = this.state.view.scale;
                const t = this.state.view.translate;
                this.minBounds.x -= this.state.x;
                this.minBounds.y -= this.state.y;
                this.minBounds.x /= s;
                this.minBounds.y /= s;
                this.minBounds.width /= s;
                this.minBounds.height /= s;
                this.x0 = this.state.x / s - t.x;
                this.y0 = this.state.y / s - t.y;
            }
        }
    }
    /**
     * Returns the Rectangle that defines the bounds of the selection border.
     */ getSelectionBounds(state) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.round(state.x), Math.round(state.y), Math.round(state.width), Math.round(state.height));
    }
    /**
     * Creates the shape used to draw the selection border.
     */ createParentHighlightShape(bounds) {
        return this.createSelectionShape(bounds);
    }
    /**
     * Creates the shape used to draw the selection border.
     */ createSelectionShape(bounds) {
        const shape = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].fromRectangle(bounds), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"], this.getSelectionColor());
        shape.strokeWidth = this.getSelectionStrokeWidth();
        shape.isDashed = this.isSelectionDashed();
        return shape;
    }
    /**
     * Returns {@link VertexHandlerConfig.selectionColor}.
     */ getSelectionColor() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VertexHandlerConfig"].selectionColor;
    }
    /**
     * Returns {@link VertexHandlerConfig.selectionStrokeWidth}.
     */ getSelectionStrokeWidth() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VertexHandlerConfig"].selectionStrokeWidth;
    }
    /**
     * Returns {@link VertexHandlerConfig.selectionDashed}.
     */ isSelectionDashed() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VertexHandlerConfig"].selectionDashed;
    }
    /**
     * Creates a sizer handle for the specified cursor and index and returns
     * the new {@link RectangleShape} that represents the handle.
     */ createSizer(cursor, index, size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].size, fillColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].fillColor) {
        const bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](0, 0, size, size);
        const sizer = this.createSizerShape(bounds, index, fillColor);
        if (sizer.bounds && sizer.isHtmlAllowed() && this.state.text && this.state.text.node.parentNode === this.graph.container) {
            sizer.bounds.height -= 1;
            sizer.bounds.width -= 1;
            sizer.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].STRICTHTML;
            sizer.init(this.graph.container);
        } else {
            sizer.dialect = this.graph.dialect !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].MIXEDHTML : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG;
            sizer.init(this.graph.getView().getOverlayPane());
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].redirectMouseEvents(sizer.node, this.graph, this.state);
        if (this.graph.isEnabled()) {
            sizer.setCursor(cursor);
        }
        if (!this.isSizerVisible(index)) {
            sizer.visible = false;
        }
        return sizer;
    }
    /**
     * Returns `true` if the sizer for the given index is visible.
     *
     * This implementation returns `true` for all given indices.
     */ isSizerVisible(_index) {
        return true;
    }
    /**
     * Creates the shape used for the sizer handle for the specified bounds an
     * index. Only images and rectangles should be returned if support for HTML
     * labels with not foreign objects is required.
     */ createSizerShape(bounds, index, fillColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].fillColor) {
        if (this.handleImage) {
            bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](bounds.x, bounds.y, this.handleImage.width, this.handleImage.height);
            const shape = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](bounds, this.handleImage.src);
            // Allows HTML rendering of the images
            shape.preserveImageAspect = false;
            return shape;
        }
        const strokeColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HandleConfig"].strokeColor;
        if (index === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ROTATION_HANDLE) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$EllipseShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](bounds, fillColor, strokeColor);
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](bounds, fillColor, strokeColor);
    }
    /**
     * Helper method to create an {@link Rectangle} around the given center point
     * with a width and height of 2*s or 6, if no s is given.
     */ moveSizerTo(shape, x, y) {
        if (shape && shape.bounds) {
            shape.bounds.x = Math.floor(x - shape.bounds.width / 2);
            shape.bounds.y = Math.floor(y - shape.bounds.height / 2);
            // Fixes visible inactive handles in VML
            if (shape.node && shape.node.style.display !== 'none') {
                shape.redraw();
            }
        }
    }
    /**
     * Returns the index of the handle for the given event. This returns the index
     * of the sizer from where the event originated or {@link InternalEvent.LABEL_HANDLE}.
     */ getHandleForEvent(me) {
        // Connection highlight may consume events before they reach sizer handle
        const tol = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMouseEvent"])(me.getEvent()) ? this.tolerance : 1;
        const hit = this.allowHandleBoundsCheck && tol > 0 ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
        const checkShape = (shape)=>{
            const st = shape && shape.constructor !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] && this.allowHandleBoundsCheck ? shape.strokeWidth + shape.svgStrokeTolerance : null;
            const real = st ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](me.getGraphX() - Math.floor(st / 2), me.getGraphY() - Math.floor(st / 2), st, st) : hit;
            return shape && shape.bounds && (me.isSource(shape) || real && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersects"])(shape.bounds, real) && shape.node.style.display !== 'none' && shape.node.style.visibility !== 'hidden');
        };
        if (checkShape(this.rotationShape)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ROTATION_HANDLE;
        }
        if (checkShape(this.labelShape)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LABEL_HANDLE;
        }
        for(let i = 0; i < this.sizers.length; i += 1){
            if (checkShape(this.sizers[i])) {
                return i;
            }
        }
        if (this.customHandles != null && this.isCustomHandleEvent(me)) {
            // Inverse loop order to match display order
            for(let i = this.customHandles.length - 1; i >= 0; i--){
                if (checkShape(this.customHandles[i].shape)) {
                    // LATER: Return reference to active shape
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE - i;
                }
            }
        }
        return null;
    }
    /**
     * Returns `true` if the given event allows custom handles to be changed.
     *
     * This implementation returns `true`.
     */ isCustomHandleEvent(me) {
        return true;
    }
    /**
     * Handles the event if a handle has been clicked. By consuming the
     * event all subsequent events of the gesture are redirected to this
     * handler.
     */ mouseDown(sender, me) {
        if (!me.isConsumed() && this.graph.isEnabled()) {
            const handle = this.getHandleForEvent(me);
            if (handle) {
                this.start(me.getGraphX(), me.getGraphY(), handle);
                me.consume();
            }
        }
    }
    /**
     * Called if {@link livePreview} is enabled to check if a border should be painted.
     *
     * This implementation returns `true` if the shape is transparent.
     */ isLivePreviewBorder() {
        return this.state.shape && this.state.shape.fill === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"] && this.state.shape.stroke === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"];
    }
    /**
     * Starts the handling of the mouse gesture.
     */ start(x, y, index) {
        this.livePreviewActive = this.livePreview && this.state.cell.getChildCount() === 0;
        this.inTolerance = true;
        this.childOffsetX = 0;
        this.childOffsetY = 0;
        this.index = index;
        this.startX = x;
        this.startY = y;
        if (this.index <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE && this.isGhostPreview()) {
            this.ghostPreview = this.createGhostPreview();
        } else {
            // Saves reference to parent state
            const { model } = this.state.view.graph;
            const parent = this.state.cell.getParent();
            if (this.state.view.currentRoot !== parent && parent && (parent.isVertex() || parent.isEdge())) {
                this.parentState = this.state.view.graph.view.getState(parent);
            }
            // Creates a preview that can be on top of any HTML label
            this.selectionBorder.node.style.display = index === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ROTATION_HANDLE ? 'inline' : 'none';
            // Creates the border that represents the new bounds
            if (!this.livePreviewActive || this.isLivePreviewBorder()) {
                this.preview = this.createSelectionShape(this.bounds);
                if (!(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IS_SVG && Number(this.state.style.rotation || '0') !== 0) && this.state.text != null && this.state.text.node.parentNode === this.graph.container) {
                    this.preview.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].STRICTHTML;
                    this.preview.init(this.graph.container);
                } else {
                    this.preview.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG;
                    this.preview.init(this.graph.view.getOverlayPane());
                }
            }
            if (index === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ROTATION_HANDLE) {
                // With the rotation handle in a corner, need the angle and distance
                const pos = this.getRotationHandlePosition();
                const dx = pos.x - this.state.getCenterX();
                const dy = pos.y - this.state.getCenterY();
                this.startAngle = dx !== 0 ? Math.atan(dy / dx) * 180 / Math.PI + 90 : 0;
                this.startDist = Math.sqrt(dx * dx + dy * dy);
            }
            // Prepares the handles for live preview
            if (this.livePreviewActive) {
                this.hideSizers();
                if (index === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ROTATION_HANDLE && this.rotationShape) {
                    this.rotationShape.node.style.display = '';
                } else if (index === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LABEL_HANDLE && this.labelShape) {
                    this.labelShape.node.style.display = '';
                } else if (this.sizers[index]) {
                    this.sizers[index].node.style.display = '';
                } else if (index <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE) {
                    this.customHandles[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE - index].setVisible(true);
                }
                // Gets the array of connected edge handlers for redrawing
                const edges = this.state.cell.getEdges();
                this.edgeHandlers = [];
                const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');
                for(let i = 0; i < edges.length; i += 1){
                    const handler = selectionCellsHandler?.getHandler(edges[i]);
                    if (handler) {
                        this.edgeHandlers.push(handler);
                    }
                }
            }
        }
    }
    /**
     * Starts the handling of the mouse gesture.
     */ createGhostPreview() {
        const shape = this.graph.cellRenderer.createShape(this.state);
        shape.init(this.graph.view.getOverlayPane());
        shape.scale = this.state.view.scale;
        shape.bounds = this.bounds;
        shape.outline = true;
        return shape;
    }
    /**
     * Shortcut to {@link hideSizers}.
     */ setHandlesVisible(visible) {
        this.handlesVisible = visible;
        for(let i = 0; i < this.sizers.length; i += 1){
            this.sizers[i].node.style.display = visible ? '' : 'none';
        }
        for(let i = 0; i < this.customHandles.length; i += 1){
            this.customHandles[i].setVisible(visible);
        }
    }
    /**
     * Hides all sizers except.
     *
     * Starts the handling of the mouse gesture.
     */ hideSizers() {
        this.setHandlesVisible(false);
    }
    /**
     * Checks if the coordinates for the given event are within the
     * {@link Graph#tolerance}. If the event is a mouse event then the tolerance is
     * ignored.
     */ checkTolerance(me) {
        if (this.inTolerance && this.startX !== null && this.startY !== null) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMouseEvent"])(me.getEvent()) || Math.abs(me.getGraphX() - this.startX) > this.graph.getEventTolerance() || Math.abs(me.getGraphY() - this.startY) > this.graph.getEventTolerance()) {
                this.inTolerance = false;
            }
        }
    }
    /**
     * Hook for subclasses do show details while the handler is active.
     */ updateHint(me) {
        return;
    }
    /**
     * Hooks for subclasses to hide details when the handler gets inactive.
     */ removeHint() {
        return;
    }
    /**
     * Hook for rounding the angle. This uses {@link Math.round}.
     */ roundAngle(angle) {
        return Math.round(angle * 10) / 10;
    }
    /**
     * Hook for rounding the unscaled width or height. This uses {@link Math.round}.
     */ roundLength(length) {
        return Math.round(length * 100) / 100;
    }
    /**
     * Handles the event by updating the preview.
     */ mouseMove(sender, me) {
        if (!me.isConsumed() && this.index != null) {
            // Checks tolerance for ignoring single clicks
            this.checkTolerance(me);
            if (!this.inTolerance) {
                if (this.index <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE) {
                    if (this.customHandles != null) {
                        this.customHandles[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE - this.index].processEvent(me);
                        this.customHandles[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE - this.index].active = true;
                        if (this.ghostPreview != null) {
                            this.ghostPreview.apply(this.state);
                            this.ghostPreview.strokeWidth = this.getSelectionStrokeWidth() / this.ghostPreview.scale / this.ghostPreview.scale;
                            this.ghostPreview.isDashed = this.isSelectionDashed();
                            this.ghostPreview.stroke = this.getSelectionColor();
                            this.ghostPreview.redraw();
                            if (this.selectionBounds != null) {
                                this.selectionBorder.node.style.display = 'none';
                            }
                        } else {
                            if (this.movePreviewToFront) {
                                this.moveToFront();
                            }
                            this.customHandles[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE - this.index].positionChanged();
                        }
                    }
                } else if (this.index === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LABEL_HANDLE) {
                    this.moveLabel(me);
                } else {
                    if (this.index === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ROTATION_HANDLE) {
                        this.rotateVertex(me);
                    } else {
                        this.resizeVertex(me);
                    }
                    this.updateHint(me);
                }
            }
            me.consume();
        } else if (!this.graph.isMouseDown && this.getHandleForEvent(me)) {
            me.consume(false);
        }
    }
    /**
     * Returns `true` if a ghost preview should be used for custom handles.
     */ isGhostPreview() {
        return this.state.cell.getChildCount() > 0;
    }
    /**
     * Moves the vertex.
     */ moveLabel(me) {
        const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](me.getGraphX(), me.getGraphY());
        const tr = this.graph.view.translate;
        const { scale } = this.graph.view;
        if (this.graph.isGridEnabledEvent(me.getEvent())) {
            point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;
            point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;
        }
        const index = this.rotationShape ? this.sizers.length - 2 : this.sizers.length - 1;
        this.moveSizerTo(this.sizers[index], point.x, point.y);
    }
    /**
     * Rotates the vertex.
     */ rotateVertex(me) {
        const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](me.getGraphX(), me.getGraphY());
        let dx = this.state.x + this.state.width / 2 - point.x;
        let dy = this.state.y + this.state.height / 2 - point.y;
        this.currentAlpha = dx !== 0 ? Math.atan(dy / dx) * 180 / Math.PI + 90 : dy < 0 ? 180 : 0;
        if (dx > 0) {
            this.currentAlpha -= 180;
        }
        this.currentAlpha -= this.startAngle;
        // Rotation raster
        if (this.rotationRaster && this.graph.isGridEnabledEvent(me.getEvent())) {
            let raster;
            dx = point.x - this.state.getCenterX();
            dy = point.y - this.state.getCenterY();
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist - this.startDist < 2) {
                raster = 15;
            } else if (dist - this.startDist < 25) {
                raster = 5;
            } else {
                raster = 1;
            }
            this.currentAlpha = Math.round(this.currentAlpha / raster) * raster;
        } else {
            this.currentAlpha = this.roundAngle(this.currentAlpha);
        }
        this.selectionBorder.rotation = this.currentAlpha;
        this.selectionBorder.redraw();
        if (this.livePreviewActive) {
            this.redrawHandles();
        }
    }
    /**
     * Resizes the vertex.
     */ resizeVertex(me) {
        const ct = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.state.getCenterX(), this.state.getCenterY());
        const alpha = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(this.state.style.rotation ?? 0);
        const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](me.getGraphX(), me.getGraphY());
        const tr = this.graph.view.translate;
        const { scale } = this.graph.view;
        let cos = Math.cos(-alpha);
        let sin = Math.sin(-alpha);
        let dx = point.x - this.startX;
        let dy = point.y - this.startY;
        // Rotates vector for mouse gesture
        const tx = cos * dx - sin * dy;
        const ty = sin * dx + cos * dy;
        dx = tx;
        dy = ty;
        const geo = this.state.cell.getGeometry();
        if (geo && this.index !== null) {
            this.unscaledBounds = this.union(geo, dx / scale, dy / scale, this.index, this.graph.isGridEnabledEvent(me.getEvent()), 1, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](0, 0), this.isConstrainedEvent(me), this.isCenteredEvent(this.state, me));
        }
        // Keeps vertex within maximum graph or parent bounds
        if (geo && !geo.relative) {
            let max = this.graph.getMaximumGraphBounds();
            // Handles child cells
            if (max != null && this.parentState != null) {
                max = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].fromRectangle(max);
                max.x -= (this.parentState.x - tr.x * scale) / scale;
                max.y -= (this.parentState.y - tr.y * scale) / scale;
            }
            if (this.graph.isConstrainChild(this.state.cell)) {
                let tmp = this.graph.getCellContainmentArea(this.state.cell);
                if (tmp != null) {
                    const overlap = this.graph.getOverlap(this.state.cell);
                    if (overlap > 0) {
                        tmp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].fromRectangle(tmp);
                        tmp.x -= tmp.width * overlap;
                        tmp.y -= tmp.height * overlap;
                        tmp.width += 2 * tmp.width * overlap;
                        tmp.height += 2 * tmp.height * overlap;
                    }
                    if (!max) {
                        max = tmp;
                    } else {
                        max = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].fromRectangle(max);
                        max.intersect(tmp);
                    }
                }
            }
            if (max && this.unscaledBounds) {
                if (this.unscaledBounds.x < max.x) {
                    this.unscaledBounds.width -= max.x - this.unscaledBounds.x;
                    this.unscaledBounds.x = max.x;
                }
                if (this.unscaledBounds.y < max.y) {
                    this.unscaledBounds.height -= max.y - this.unscaledBounds.y;
                    this.unscaledBounds.y = max.y;
                }
                if (this.unscaledBounds.x + this.unscaledBounds.width > max.x + max.width) {
                    this.unscaledBounds.width -= this.unscaledBounds.x + this.unscaledBounds.width - max.x - max.width;
                }
                if (this.unscaledBounds.y + this.unscaledBounds.height > max.y + max.height) {
                    this.unscaledBounds.height -= this.unscaledBounds.y + this.unscaledBounds.height - max.y - max.height;
                }
            }
        }
        if (this.unscaledBounds) {
            const old = this.bounds;
            this.bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]((this.parentState ? this.parentState.x : tr.x * scale) + this.unscaledBounds.x * scale, (this.parentState ? this.parentState.y : tr.y * scale) + this.unscaledBounds.y * scale, this.unscaledBounds.width * scale, this.unscaledBounds.height * scale);
            if (geo && geo.relative && this.parentState) {
                this.bounds.x += this.state.x - this.parentState.x;
                this.bounds.y += this.state.y - this.parentState.y;
            }
            cos = Math.cos(alpha);
            sin = Math.sin(alpha);
            const c2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.bounds.getCenterX(), this.bounds.getCenterY());
            dx = c2.x - ct.x;
            dy = c2.y - ct.y;
            const dx2 = cos * dx - sin * dy;
            const dy2 = sin * dx + cos * dy;
            const dx3 = dx2 - dx;
            const dy3 = dy2 - dy;
            const dx4 = this.bounds.x - this.state.x;
            const dy4 = this.bounds.y - this.state.y;
            const dx5 = cos * dx4 - sin * dy4;
            const dy5 = sin * dx4 + cos * dy4;
            this.bounds.x += dx3;
            this.bounds.y += dy3;
            // Rounds unscaled bounds to int
            this.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + dx3 / scale);
            this.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + dy3 / scale);
            this.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);
            this.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);
            // Shifts the children according to parent offset
            if (!this.state.cell.isCollapsed() && (dx3 !== 0 || dy3 !== 0)) {
                this.childOffsetX = this.state.x - this.bounds.x + dx5;
                this.childOffsetY = this.state.y - this.bounds.y + dy5;
            } else {
                this.childOffsetX = 0;
                this.childOffsetY = 0;
            }
            if (!old.equals(this.bounds)) {
                if (this.livePreviewActive) {
                    this.updateLivePreview(me);
                }
                if (this.preview != null) {
                    this.drawPreview();
                } else {
                    this.updateParentHighlight();
                }
            }
        }
    }
    /**
     * Repaints the live preview.
     */ updateLivePreview(me) {
        // TODO: Apply child offset to children in live preview
        const { scale } = this.graph.view;
        const tr = this.graph.view.translate;
        // Saves current state
        const tempState = this.state.clone();
        // Temporarily changes size and origin
        this.state.x = this.bounds.x;
        this.state.y = this.bounds.y;
        this.state.origin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.state.x / scale - tr.x, this.state.y / scale - tr.y);
        this.state.width = this.bounds.width;
        this.state.height = this.bounds.height;
        // Redraws cell and handles
        let off = this.state.absoluteOffset;
        off = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](off.x, off.y);
        // Required to store and reset absolute offset for updating label position
        this.state.absoluteOffset.x = 0;
        this.state.absoluteOffset.y = 0;
        const geo = this.state.cell.getGeometry();
        if (geo != null) {
            const offset = geo.offset || this.EMPTY_POINT;
            if (offset != null && !geo.relative) {
                this.state.absoluteOffset.x = this.state.view.scale * offset.x;
                this.state.absoluteOffset.y = this.state.view.scale * offset.y;
            }
            this.state.view.updateVertexLabelOffset(this.state);
        }
        // Draws the live preview
        this.state.view.graph.cellRenderer.redraw(this.state, true);
        // Redraws connected edges TODO: Include child edges
        this.state.view.invalidate(this.state.cell);
        this.state.invalid = false;
        this.state.view.validate();
        this.redrawHandles();
        // Moves live preview to front
        if (this.movePreviewToFront) {
            this.moveToFront();
        }
        // Hides folding icon
        if (this.state.control != null && this.state.control.node != null) {
            this.state.control.node.style.visibility = 'hidden';
        }
        // Restores current state
        this.state.setState(tempState);
    }
    /**
     * Handles the event by applying the changes to the geometry.
     */ moveToFront() {
        if (this.state.text && this.state.text.node && this.state.text.node.nextSibling || this.state.shape && this.state.shape.node && this.state.shape.node.nextSibling && (!this.state.text || this.state.shape.node.nextSibling !== this.state.text.node)) {
            if (this.state.shape && this.state.shape.node && this.state.shape.node.parentNode) {
                this.state.shape.node.parentNode.appendChild(this.state.shape.node);
            }
            if (this.state.text && this.state.text.node && this.state.text.node.parentNode) {
                this.state.text.node.parentNode.appendChild(this.state.text.node);
            }
        }
    }
    /**
     * Handles the event by applying the changes to the geometry.
     */ mouseUp(sender, me) {
        if (this.index != null && this.state != null) {
            const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](me.getGraphX(), me.getGraphY());
            const { index } = this;
            this.index = null;
            if (this.ghostPreview == null) {
                // Required to restore order in case of no change
                this.state.view.invalidate(this.state.cell, false, false);
                this.state.view.validate();
            }
            this.graph.batchUpdate(()=>{
                if (index <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE) {
                    if (this.customHandles != null) {
                        // Creates style before changing cell state
                        const style = this.state.view.graph.getCellStyle(this.state.cell);
                        this.customHandles[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE - index].active = false;
                        this.customHandles[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE - index].execute(me);
                        // Sets style and apply on shape to force repaint and
                        // check if execute has removed custom handles
                        if (this.customHandles != null && this.customHandles[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE - index] != null) {
                            this.state.style = style;
                            this.customHandles[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CUSTOM_HANDLE - index].positionChanged();
                        }
                    }
                } else if (index === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ROTATION_HANDLE) {
                    if (this.currentAlpha != null) {
                        const delta = this.currentAlpha - (this.state.style.rotation ?? 0);
                        if (delta !== 0) {
                            this.rotateCell(this.state.cell, delta);
                        }
                    } else {
                        this.rotateClick();
                    }
                } else {
                    const gridEnabled = this.graph.isGridEnabledEvent(me.getEvent());
                    const alpha = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(this.state.style.rotation ?? 0);
                    const cos = Math.cos(-alpha);
                    const sin = Math.sin(-alpha);
                    let dx = point.x - this.startX;
                    let dy = point.y - this.startY;
                    // Rotates vector for mouse gesture
                    const tx = cos * dx - sin * dy;
                    const ty = sin * dx + cos * dy;
                    dx = tx;
                    dy = ty;
                    const s = this.graph.view.scale;
                    const recurse = this.isRecursiveResize(this.state, me);
                    this.resizeCell(this.state.cell, this.roundLength(dx / s), this.roundLength(dy / s), index, gridEnabled, this.isConstrainedEvent(me), recurse);
                }
            });
            me.consume();
            this.reset();
            this.redrawHandles();
        }
    }
    /**
     * Returns the `recursiveResize` status of the given state.
     * @param state the given {@link CellState}. This implementation takes the value of this state.
     * @param me the mouse event.
     */ isRecursiveResize(state, me) {
        return this.graph.isRecursiveResize(this.state);
    }
    /**
     * Hook for subclasses to implement a single click on the rotation handle.
     * This code is executed as part of the model transaction.
     *
     * This implementation is empty.
     */ rotateClick() {
        return;
    }
    /**
     * Rotates the given cell and its children by the given angle in degrees.
     *
     * @param cell {@link Cell} to be rotated.
     * @param angle Angle in degrees.
     * @param parent if set, consider the parent in the rotation computation.
     */ rotateCell(cell, angle, parent) {
        if (angle !== 0) {
            const model = this.graph.getDataModel();
            if (cell.isVertex() || cell.isEdge()) {
                if (!cell.isEdge()) {
                    const style = this.graph.getCurrentCellStyle(cell);
                    const total = (style.rotation || 0) + angle;
                    this.graph.setCellStyles('rotation', total, [
                        cell
                    ]);
                }
                let geo = cell.getGeometry();
                if (geo && parent) {
                    const pgeo = parent.getGeometry();
                    if (pgeo != null && !parent.isEdge()) {
                        geo = geo.clone();
                        geo.rotate(angle, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](pgeo.width / 2, pgeo.height / 2));
                        model.setGeometry(cell, geo);
                    }
                    if (cell.isVertex() && !geo.relative || cell.isEdge()) {
                        // Recursive rotation
                        const childCount = cell.getChildCount();
                        for(let i = 0; i < childCount; i += 1){
                            this.rotateCell(cell.getChildAt(i), angle, cell);
                        }
                    }
                }
            }
        }
    }
    /**
     * Resets the state of this handler.
     */ reset() {
        if (this.index !== null && this.sizers[this.index].node.style.display === 'none') {
            this.sizers[this.index].node.style.display = '';
        }
        this.index = null;
        // TODO: Reset and redraw cell states for live preview
        if (this.preview) {
            this.preview.destroy();
            this.preview = null;
        }
        if (this.ghostPreview) {
            this.ghostPreview.destroy();
            this.ghostPreview = null;
        }
        if (this.livePreviewActive) {
            for(let i = 0; i < this.sizers.length; i += 1){
                this.sizers[i].node.style.display = '';
            }
            // Shows folding icon
            if (this.state.control && this.state.control.node) {
                this.state.control.node.style.visibility = '';
            }
        }
        for(let i = 0; i < this.customHandles.length; i += 1){
            if (this.customHandles[i].active) {
                this.customHandles[i].active = false;
                this.customHandles[i].reset();
            } else {
                this.customHandles[i].setVisible(true);
            }
        }
        // Checks if handler has been destroyed
        this.selectionBorder.node.style.display = 'inline';
        this.selectionBounds = this.getSelectionBounds(this.state);
        this.bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
        this.drawPreview();
        this.removeHint();
        this.redrawHandles();
        this.edgeHandlers = [];
        this.handlesVisible = true;
        this.unscaledBounds = null;
    }
    /**
     * Uses the given vector to change the bounds of the given cell
     * in the graph using {@link Graph#resizeCell}.
     */ resizeCell(cell, dx, dy, index, gridEnabled, constrained, recurse) {
        let geo = cell.getGeometry();
        if (geo) {
            if (index === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].LABEL_HANDLE && this.labelShape && this.labelShape.bounds) {
                const alpha = -(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(this.state.style.rotation ?? 0);
                const cos = Math.cos(alpha);
                const sin = Math.sin(alpha);
                const { scale } = this.graph.view;
                const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.round((this.labelShape.bounds.getCenterX() - this.startX) / scale), Math.round((this.labelShape.bounds.getCenterY() - this.startY) / scale)), cos, sin);
                geo = geo.clone();
                if (geo.offset == null) {
                    geo.offset = pt;
                } else {
                    geo.offset.x += pt.x;
                    geo.offset.y += pt.y;
                }
                this.graph.model.setGeometry(cell, geo);
            } else if (this.unscaledBounds) {
                const { scale } = this.graph.view;
                if (this.childOffsetX !== 0 || this.childOffsetY !== 0) {
                    this.moveChildren(cell, Math.round(this.childOffsetX / scale), Math.round(this.childOffsetY / scale));
                }
                this.graph.resizeCell(cell, this.unscaledBounds, recurse);
            }
        }
    }
    /**
     * Moves the children of the given cell by the given vector.
     */ moveChildren(cell, dx, dy) {
        const model = this.graph.getDataModel();
        const childCount = cell.getChildCount();
        for(let i = 0; i < childCount; i += 1){
            const child = cell.getChildAt(i);
            let geo = child.getGeometry();
            if (geo != null) {
                geo = geo.clone();
                geo.translate(dx, dy);
                model.setGeometry(child, geo);
            }
        }
    }
    /**
     * Returns the union of the given bounds and location for the specified
     * handle index.
     *
     * To override this to limit the size of vertex via a minWidth/-Height style,
     * the following code can be used.
     *
     * ```javascript
     * let vertexHandlerUnion = union;
     * union = (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)=>
     * {
     *   let result = vertexHandlerUnion.apply(this, arguments);
     *
     *   result.width = Math.max(result.width, mxUtils.getNumber(this.state.style, 'minWidth', 0));
     *   result.height = Math.max(result.height, mxUtils.getNumber(this.state.style, 'minHeight', 0));
     *
     *   return result;
     * };
     * ```
     *
     * The minWidth/-Height style can then be used as follows:
     *
     * ```javascript
     * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'minWidth=100;minHeight=100;');
     * ```
     *
     * To override this to update the height for a wrapped text if the width of a vertex is
     * changed, the following can be used.
     *
     * ```javascript
     * let mxVertexHandlerUnion = union;
     * union = (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)=>
     * {
     *   let result = mxVertexHandlerUnion.apply(this, arguments);
     *   let s = this.state;
     *
     *   if (this.graph.isHtmlLabel(s.cell) && (index == 3 || index == 4) &&
     *       s.text != null && s.style.whiteSpace == 'wrap')
     *   {
     *     let label = this.graph.getLabel(s.cell);
     *     let fontSize = mxUtils.getNumber(s.style, 'fontSize', mxConstants.DEFAULT_FONTSIZE);
     *     let ww = result.width / s.view.scale - s.text.spacingRight - s.text.spacingLeft
     *
     *     result.height = mxUtils.getSizeForString(label, fontSize, s.style.fontFamily, ww).height;
     *   }
     *
     *   return result;
     * };
     * ```
     */ union(bounds, dx, dy, index, gridEnabled, scale, tr, constrained, centered) {
        gridEnabled = gridEnabled && this.graph.isGridEnabled();
        if (this.singleSizer) {
            let x = bounds.x + bounds.width + dx;
            let y = bounds.y + bounds.height + dy;
            if (gridEnabled) {
                x = this.graph.snap(x / scale) * scale;
                y = this.graph.snap(y / scale) * scale;
            }
            const rect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](bounds.x, bounds.y, 0, 0);
            rect.add(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](x, y, 0, 0));
            return rect;
        }
        const w0 = bounds.width;
        const h0 = bounds.height;
        let left = bounds.x - tr.x * scale;
        let right = left + w0;
        let top = bounds.y - tr.y * scale;
        let bottom = top + h0;
        const cx = left + w0 / 2;
        const cy = top + h0 / 2;
        if (index > 4 /* Bottom Row */ ) {
            bottom += dy;
            if (gridEnabled) {
                bottom = this.graph.snap(bottom / scale) * scale;
            } else {
                bottom = Math.round(bottom / scale) * scale;
            }
        } else if (index < 3 /* Top Row */ ) {
            top += dy;
            if (gridEnabled) {
                top = this.graph.snap(top / scale) * scale;
            } else {
                top = Math.round(top / scale) * scale;
            }
        }
        if (index === 0 || index === 3 || index === 5 /* Left */ ) {
            left += dx;
            if (gridEnabled) {
                left = this.graph.snap(left / scale) * scale;
            } else {
                left = Math.round(left / scale) * scale;
            }
        } else if (index === 2 || index === 4 || index === 7 /* Right */ ) {
            right += dx;
            if (gridEnabled) {
                right = this.graph.snap(right / scale) * scale;
            } else {
                right = Math.round(right / scale) * scale;
            }
        }
        let width = right - left;
        let height = bottom - top;
        if (constrained) {
            const geo = this.state.cell.getGeometry();
            if (geo != null) {
                const aspect = geo.width / geo.height;
                if (index === 1 || index === 2 || index === 7 || index === 6) {
                    width = height * aspect;
                } else {
                    height = width / aspect;
                }
                if (index === 0) {
                    left = right - width;
                    top = bottom - height;
                }
            }
        }
        if (centered) {
            width += width - w0;
            height += height - h0;
            const cdx = cx - (left + width / 2);
            const cdy = cy - (top + height / 2);
            left += cdx;
            top += cdy;
            right += cdx;
            bottom += cdy;
        }
        // Flips over left side
        if (width < 0) {
            left += width;
            width = Math.abs(width);
        }
        // Flips over top side
        if (height < 0) {
            top += height;
            height = Math.abs(height);
        }
        const result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](left + tr.x * scale, top + tr.y * scale, width, height);
        if (this.minBounds != null) {
            result.width = Math.max(result.width, this.minBounds.x * scale + this.minBounds.width * scale + Math.max(0, this.x0 * scale - result.x));
            result.height = Math.max(result.height, this.minBounds.y * scale + this.minBounds.height * scale + Math.max(0, this.y0 * scale - result.y));
        }
        return result;
    }
    /**
     * Redraws the handles and the preview.
     */ redraw(ignoreHandles) {
        this.selectionBounds = this.getSelectionBounds(this.state);
        this.bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
        this.drawPreview();
        if (!ignoreHandles) {
            this.redrawHandles();
        }
    }
    /**
     * Returns the padding to be used for drawing handles for the current <bounds>.
     */ getHandlePadding() {
        // KNOWN: Tolerance depends on event type (eg. 0 for mouse events)
        const result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](0, 0);
        let tol = this.tolerance;
        if (this.sizers.length > 0 && this.sizers[0].bounds && (this.bounds.width < 2 * this.sizers[0].bounds.width + 2 * tol || this.bounds.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {
            tol /= 2;
            result.x = this.sizers[0].bounds.width + tol;
            result.y = this.sizers[0].bounds.height + tol;
        }
        return result;
    }
    /**
     * Returns the bounds used to paint the resize handles.
     */ getSizerBounds() {
        return this.bounds;
    }
    /**
     * Redraws the handles. To hide certain handles the following code can be used.
     *
     * ```javascript
     * redrawHandles()
     * {
     *   mxVertexHandlerRedrawHandles.apply(this, arguments);
     *
     *   if (this.sizers != null && this.sizers.length > 7)
     *   {
     *     this.sizers[1].node.style.display = 'none';
     *     this.sizers[6].node.style.display = 'none';
     *   }
     * };
     * ```
     */ redrawHandles() {
        let s = this.getSizerBounds();
        const tol = this.tolerance;
        this.horizontalOffset = 0;
        this.verticalOffset = 0;
        for(let i = 0; i < this.customHandles.length; i += 1){
            const shape = this.customHandles[i].shape;
            if (shape) {
                const temp = shape.node.style.display;
                this.customHandles[i].redraw();
                shape.node.style.display = temp;
                // Hides custom handles during text editing
                shape.node.style.visibility = this.handlesVisible && this.isCustomHandleVisible(this.customHandles[i]) ? '' : 'hidden';
            }
        }
        if (this.sizers.length > 0 && this.sizers[0]) {
            if (this.index === null && this.manageSizers && this.sizers.length >= 8) {
                // KNOWN: Tolerance depends on event type (eg. 0 for mouse events)
                const padding = this.getHandlePadding();
                this.horizontalOffset = padding.x;
                this.verticalOffset = padding.y;
                if (this.horizontalOffset !== 0 || this.verticalOffset !== 0) {
                    s = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](s.x, s.y, s.width, s.height);
                    s.x -= this.horizontalOffset / 2;
                    s.width += this.horizontalOffset;
                    s.y -= this.verticalOffset / 2;
                    s.height += this.verticalOffset;
                }
                if (this.sizers.length >= 8) {
                    if (this.sizers[0].bounds && (s.width < 2 * this.sizers[0].bounds.width + 2 * tol || s.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {
                        this.sizers[0].node.style.display = 'none';
                        this.sizers[2].node.style.display = 'none';
                        this.sizers[5].node.style.display = 'none';
                        this.sizers[7].node.style.display = 'none';
                    } else if (this.handlesVisible) {
                        this.sizers[0].node.style.display = '';
                        this.sizers[2].node.style.display = '';
                        this.sizers[5].node.style.display = '';
                        this.sizers[7].node.style.display = '';
                    }
                }
            }
            const r = s.x + s.width;
            const b = s.y + s.height;
            if (this.singleSizer) {
                this.moveSizerTo(this.sizers[0], r, b);
            } else {
                const cx = s.x + s.width / 2;
                const cy = s.y + s.height / 2;
                if (this.sizers.length >= 8) {
                    const crs = [
                        'nw-resize',
                        'n-resize',
                        'ne-resize',
                        'e-resize',
                        'se-resize',
                        's-resize',
                        'sw-resize',
                        'w-resize'
                    ];
                    const alpha = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(this.state.style.rotation ?? 0);
                    const cos = Math.cos(alpha);
                    const sin = Math.sin(alpha);
                    const da = Math.round(alpha * 4 / Math.PI);
                    const ct = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](s.getCenterX(), s.getCenterY());
                    let pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](s.x, s.y), cos, sin, ct);
                    this.moveSizerTo(this.sizers[0], pt.x, pt.y);
                    this.sizers[0].setCursor(crs[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mod"])(0 + da, crs.length)]);
                    pt.x = cx;
                    pt.y = s.y;
                    pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(pt, cos, sin, ct);
                    this.moveSizerTo(this.sizers[1], pt.x, pt.y);
                    this.sizers[1].setCursor(crs[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mod"])(1 + da, crs.length)]);
                    pt.x = r;
                    pt.y = s.y;
                    pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(pt, cos, sin, ct);
                    this.moveSizerTo(this.sizers[2], pt.x, pt.y);
                    this.sizers[2].setCursor(crs[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mod"])(2 + da, crs.length)]);
                    pt.x = s.x;
                    pt.y = cy;
                    pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(pt, cos, sin, ct);
                    this.moveSizerTo(this.sizers[3], pt.x, pt.y);
                    this.sizers[3].setCursor(crs[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mod"])(7 + da, crs.length)]);
                    pt.x = r;
                    pt.y = cy;
                    pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(pt, cos, sin, ct);
                    this.moveSizerTo(this.sizers[4], pt.x, pt.y);
                    this.sizers[4].setCursor(crs[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mod"])(3 + da, crs.length)]);
                    pt.x = s.x;
                    pt.y = b;
                    pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(pt, cos, sin, ct);
                    this.moveSizerTo(this.sizers[5], pt.x, pt.y);
                    this.sizers[5].setCursor(crs[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mod"])(6 + da, crs.length)]);
                    pt.x = cx;
                    pt.y = b;
                    pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(pt, cos, sin, ct);
                    this.moveSizerTo(this.sizers[6], pt.x, pt.y);
                    this.sizers[6].setCursor(crs[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mod"])(5 + da, crs.length)]);
                    pt.x = r;
                    pt.y = b;
                    pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(pt, cos, sin, ct);
                    this.moveSizerTo(this.sizers[7], pt.x, pt.y);
                    this.sizers[7].setCursor(crs[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mod"])(4 + da, crs.length)]);
                    pt.x = cx + this.state.absoluteOffset.x;
                    pt.y = cy + this.state.absoluteOffset.y;
                    pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(pt, cos, sin, ct);
                    this.moveSizerTo(this.sizers[8], pt.x, pt.y);
                } else if (this.state.width >= 2 && this.state.height >= 2) {
                    this.moveSizerTo(this.sizers[0], cx + this.state.absoluteOffset.x, cy + this.state.absoluteOffset.y);
                } else {
                    this.moveSizerTo(this.sizers[0], this.state.x, this.state.y);
                }
            }
        }
        if (this.rotationShape) {
            const alpha = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(this.currentAlpha);
            const cos = Math.cos(alpha);
            const sin = Math.sin(alpha);
            const ct = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.state.getCenterX(), this.state.getCenterY());
            const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(this.getRotationHandlePosition(), cos, sin, ct);
            if (this.rotationShape.node != null) {
                this.moveSizerTo(this.rotationShape, pt.x, pt.y);
                // Hides rotation handle during text editing
                this.rotationShape.node.style.visibility = this.state.view.graph.isEditing() || !this.handlesVisible ? 'hidden' : '';
            }
        }
        if (this.selectionBorder != null) {
            this.selectionBorder.rotation = this.state.style.rotation ?? 0;
        }
        if (this.edgeHandlers != null) {
            for(let i = 0; i < this.edgeHandlers.length; i += 1){
                this.edgeHandlers[i].redraw();
            }
        }
    }
    /**
     * Returns true if the given custom handle is visible.
     */ isCustomHandleVisible(handle) {
        return !this.graph.isEditing() && this.state.view.graph.getSelectionCount() === 1;
    }
    /**
     * Returns an {@link Point} that defines the rotation handle position.
     */ getRotationHandlePosition() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.bounds.x + this.bounds.width / 2, this.bounds.y + this.rotationHandleVSpacing);
    }
    /**
     * Returns `true` if the parent highlight should be visible.
     *
     * This implementation always returns `true`.
     */ isParentHighlightVisible() {
        const parent = this.state.cell.getParent();
        return parent ? !this.graph.isCellSelected(parent) : false;
    }
    /**
     * Updates the highlight of the parent if {@link parentHighlightEnabled} is `true`.
     */ updateParentHighlight() {
        if (!this.isDestroyed()) {
            const visible = this.isParentHighlightVisible();
            const parent = this.state.cell.getParent();
            const pstate = parent ? this.graph.view.getState(parent) : null;
            if (this.parentHighlight) {
                if (parent && parent.isVertex() && visible) {
                    const b = this.parentHighlight.bounds;
                    if (pstate && b && (b.x !== pstate.x || b.y !== pstate.y || b.width !== pstate.width || b.height !== pstate.height)) {
                        this.parentHighlight.bounds = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].fromRectangle(pstate);
                        this.parentHighlight.redraw();
                    }
                } else {
                    if (pstate != null && pstate.parentHighlight === this.parentHighlight) {
                        pstate.parentHighlight = null;
                    }
                    this.parentHighlight.destroy();
                    this.parentHighlight = null;
                }
            } else if (this.parentHighlightEnabled && visible) {
                if (parent && parent.isVertex() && pstate != null && pstate.parentHighlight == null) {
                    this.parentHighlight = this.createParentHighlightShape(pstate);
                    // VML dialect required here for event transparency in IE
                    this.parentHighlight.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG;
                    this.parentHighlight.pointerEvents = false;
                    this.parentHighlight.rotation = pstate.style.rotation ?? 0;
                    this.parentHighlight.init(this.graph.getView().getOverlayPane());
                    this.parentHighlight.redraw();
                    // Shows highlight once per parent
                    pstate.parentHighlight = this.parentHighlight;
                }
            }
        }
    }
    /**
     * Redraws the preview.
     */ drawPreview() {
        if (this.preview != null) {
            this.preview.bounds = this.bounds;
            if (this.preview.node.parentNode === this.graph.container) {
                this.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1);
                this.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1);
            }
            this.preview.rotation = this.state.style.rotation ?? 0;
            this.preview.redraw();
        }
        this.selectionBorder.bounds = this.getSelectionBorderBounds();
        this.selectionBorder.redraw();
        this.updateParentHighlight();
    }
    /**
     * Returns the bounds for the selection border.
     */ getSelectionBorderBounds() {
        return this.bounds;
    }
    /**
     * Returns `true` if this handler was destroyed or not initialized.
     */ isDestroyed() {
        return this.selectionBorder == null;
    }
    /**
     * Destroys the handler and all its resources and DOM nodes.
     */ onDestroy() {
        this.state.view.graph.removeListener(this.escapeHandler);
        this.escapeHandler = ()=>{
            return;
        };
        if (this.preview) {
            this.preview.destroy();
            this.preview = null;
        }
        if (this.parentHighlight) {
            const parent = this.state.cell.getParent();
            const pstate = parent ? this.graph.view.getState(parent) : null;
            if (pstate && pstate.parentHighlight === this.parentHighlight) {
                pstate.parentHighlight = null;
            }
            this.parentHighlight.destroy();
            this.parentHighlight = null;
        }
        if (this.ghostPreview) {
            this.ghostPreview.destroy();
            this.ghostPreview = null;
        }
        if (this.selectionBorder) {
            this.selectionBorder.destroy();
        }
        this.labelShape = null;
        this.removeHint();
        for(let i = 0; i < this.sizers.length; i += 1){
            this.sizers[i].destroy();
        }
        this.sizers = [];
        for(let i = 0; i < this.customHandles.length; i += 1){
            this.customHandles[i].destroy();
        }
        this.customHandles = [];
    }
}
const __TURBOPACK__default__export__ = VertexHandler;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/handler/CellEditorHandler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/StringUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/domUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$TextShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/TextShape.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
/**
 * In-place editor for the graph. To control this editor, use
 * {@link Graph#invokesStopCellEditing}, {@link Graph#enterStopsCellEditing} and
 * {@link Graph#escapeEnabled}. If {@link Graph#enterStopsCellEditing} is true then
 * ctrl-enter or shift-enter can be used to create a linefeed. The F2 and
 * escape keys can always be used to stop editing.
 *
 * To customize the location of the textbox in the graph, override
 * <getEditorBounds> as follows:
 *
 * ```javascript
 * graph.cellEditor.getEditorBounds = (state)=>
 * {
 *   let result = getEditorBounds.apply(this, arguments);
 *
 *   if (this.graph.getDataModel().isEdge(state.cell))
 *   {
 *     result.x = state.getCenterX() - result.width / 2;
 *     result.y = state.getCenterY() - result.height / 2;
 *   }
 *
 *   return result;
 * };
 * ```
 *
 * Note that this hook is only called if <autoSize> is false. If <autoSize> is true,
 * then {@link Shape#getLabelBounds} is used to compute the current bounds of the textbox.
 *
 * The textarea uses the mxCellEditor CSS class. You can modify this class in
 * your custom CSS. Note: You should modify the CSS after loading the client
 * in the page.
 *
 * Example:
 *
 * To only allow numeric input in the in-place editor, use the following code.
 *
 * ```javascript
 * let text = graph.cellEditor.textarea;
 *
 * mxEvent.addListener(text, 'keydown', function (evt)
 * {
 *   if (!(evt.keyCode >= 48 && evt.keyCode <= 57) &&
 *       !(evt.keyCode >= 96 && evt.keyCode <= 105))
 *   {
 *     mxEvent.consume(evt);
 *   }
 * });
 * ```
 *
 * Placeholder:
 *
 * To implement a placeholder for cells without a label, use the
 * <emptyLabelText> variable.
 *
 * Resize in Chrome:
 *
 * Resize of the textarea is disabled by default. If you want to enable
 * this feature extend <init> and set this.textarea.style.resize = ''.
 *
 * To start editing on a key press event, the container of the graph
 * should have focus or a focusable parent should be used to add the
 * key press handler as follows.
 *
 * ```javascript
 * mxEvent.addListener(graph.container, 'keypress', mxUtils.bind(this, (evt)=>
 * {
 *   if (!graph.isEditing() && !graph.isSelectionEmpty() && evt.which !== 0 &&
 *       !mxEvent.isAltDown(evt) && !mxEvent.isControlDown(evt) && !mxEvent.isMetaDown(evt))
 *   {
 *     graph.startEditing();
 *
 *     if (Client.IS_FF)
 *     {
 *       graph.cellEditor.textarea.value = String.fromCharCode(evt.which);
 *     }
 *   }
 * }));
 * ```
 *
 * To allow focus for a DIV, and hence to receive key press events, some browsers
 * require it to have a valid tabindex attribute. In this case the following
 * code may be used to keep the container focused.
 *
 * ```javascript
 * let graphFireMouseEvent = graph.fireMouseEvent;
 * graph.fireMouseEvent = (evtName, me, sender)=>
 * {
 *   if (evtName == mxEvent.MOUSE_DOWN)
 *   {
 *     this.container.focus();
 *   }
 *
 *   graphFireMouseEvent.apply(this, arguments);
 * };
 * ```
 *
 * @category Plugin
 */ class CellEditorHandler {
    constructor(graph){
        this.clearOnChange = false;
        this.bounds = null;
        this.resizeThread = null;
        this.textDirection = null;
        /**
         * Holds the DIV that is used for text editing. Note that this may be null before the first
         * edit. Instantiated in <init>.
         */ this.textarea = null;
        /**
         * Reference to the <Cell> that is currently being edited.
         */ // editingCell: mxCell;
        this.editingCell = null;
        /**
         * Reference to the event that was used to start editing.
         */ // trigger: MouseEvent;
        this.trigger = null;
        /**
         * Specifies if the label has been modified.
         */ // modified: boolean;
        this.modified = false;
        /**
         * Specifies if the textarea should be resized while the text is being edited.
         * Default is true.
         */ // autoSize: boolean;
        this.autoSize = true;
        /**
         * Specifies if the text should be selected when editing starts. Default is
         * true.
         */ // selectText: boolean;
        this.selectText = true;
        /**
         * Text to be displayed for empty labels. Default is '' or '<br>' in Firefox as
         * a workaround for the missing cursor bug for empty content editable. This can
         * be set to eg. "[Type Here]" to easier visualize editing of empty labels. The
         * value is only displayed before the first keystroke and is never used as the
         * actual editing value.
         */ // emptyLabelText: '<br>' | '';
        this.emptyLabelText = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IS_FF ? '<br>' : '';
        /**
         * If true, pressing the escape key will stop editing and not accept the new
         * value. Change this to false to accept the new value on escape, and cancel
         * editing on Shift+Escape instead. Default is true.
         */ // escapeCancelsEditing: boolean;
        this.escapeCancelsEditing = true;
        /**
         * Reference to the label DOM node that has been hidden.
         */ // textNode: string;
        this.textNode = null;
        /**
         * Specifies the zIndex for the textarea. Default is 5.
         */ // zIndex: number;
        this.zIndex = 5;
        /**
         * Defines the minimum width and height to be used in <resize>. Default is 0x20px.
         */ // minResize: mxRectangle;
        this.minResize = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](0, 20);
        /**
         * Correction factor for word wrapping width. Default is 2 in quirks, 0 in IE
         * 11 and 1 in all other browsers and modes.
         */ // wordWrapPadding: 2 | 1 | 0;
        this.wordWrapPadding = 0;
        /**
         * If <focusLost> should be called if <textarea> loses the focus. Default is false.
         */ // blurEnabled: boolean;
        this.blurEnabled = false;
        /**
         * Holds the initial editing value to check if the current value was modified.
         */ // initialValue: string;
        this.initialValue = null;
        /**
         * Holds the current temporary horizontal alignment for the cell style. If this
         * is modified then the current text alignment is changed and the cell style is
         * updated when the value is applied.
         */ this.align = null;
        this.graph = graph;
        // Stops editing after zoom changes
        this.zoomHandler = ()=>{
            if (this.graph.isEditing()) {
                this.resize();
            }
        };
        // Handling of deleted cells while editing
        this.changeHandler = (sender)=>{
            if (this.editingCell && !this.graph.getView().getState(this.editingCell, false)) {
                this.stopEditing(true);
            }
        };
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SCALE, this.zoomHandler);
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SCALE_AND_TRANSLATE, this.zoomHandler);
        this.graph.getDataModel().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, this.changeHandler);
    }
    /**
     * Creates the <textarea> and installs the event listeners. The key handler
     * updates the {@link odified} state.
     */ init() {
        this.textarea = document.createElement('div');
        this.textarea.className = 'mxCellEditor mxPlainTextEditor';
        this.textarea.contentEditable = String(true);
        // Workaround for selection outside of DIV if height is 0
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IS_GC) {
            this.textarea.style.minHeight = '1em';
        }
        this.textarea.style.position = 'absolute';
        this.installListeners(this.textarea);
    }
    /**
     * Called in <stopEditing> if cancel is false to invoke {@link Graph#labelChanged}.
     */ // applyValue(state: CellState, value: string): void;
    applyValue(state, value) {
        this.graph.labelChanged(state.cell, value, this.trigger);
    }
    /**
     * Sets the temporary horizontal alignment for the current editing session.
     */ setAlign(align) {
        if (this.textarea) {
            this.textarea.style.textAlign = align;
        }
        this.align = align;
        this.resize();
    }
    /**
     * Gets the initial editing value for the given cell.
     */ getInitialValue(state, trigger) {
        let result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["htmlEntities"])(this.graph.getEditingValue(state.cell, trigger), false);
        result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["replaceTrailingNewlines"])(result, '<div><br></div>');
        return result.replace(/\n/g, '<br>');
    }
    /**
     * Returns the current editing value.
     */ getCurrentValue(state) {
        if (!this.textarea) return null;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extractTextWithWhitespace"])(Array.from(this.textarea.childNodes));
    }
    /**
     * Returns true if <escapeCancelsEditing> is true and shift, control and meta
     * are not pressed.
     */ // isCancelEditingKeyEvent(evt: Event): boolean;
    isCancelEditingKeyEvent(evt) {
        return this.escapeCancelsEditing || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isShiftDown"])(evt) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isControlDown"])(evt) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMetaDown"])(evt);
    }
    /**
     * Installs listeners for focus, change and standard key event handling.
     */ // installListeners(elt: Element): void;
    installListeners(elt) {
        // Applies value if text is dragged
        // LATER: Gesture mouse events ignored for starting move
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(elt, 'dragstart', (evt)=>{
            this.graph.stopEditing(false);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(evt);
        });
        // Applies value if focus is lost
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(elt, 'blur', (evt)=>{
            if (this.blurEnabled) {
                this.focusLost();
            }
        });
        // Updates modified state and handles placeholder text
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(elt, 'keydown', (evt)=>{
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isConsumed"])(evt)) {
                if (this.isStopEditingEvent(evt)) {
                    this.graph.stopEditing(false);
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(evt);
                } else if (evt.keyCode === 27 /* Escape */ ) {
                    this.graph.stopEditing(this.isCancelEditingKeyEvent(evt));
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(evt);
                }
            }
        });
        // Keypress only fires if printable key was pressed and handles removing the empty placeholder
        const keypressHandler = (evt)=>{
            if (this.editingCell != null) {
                // Clears the initial empty label on the first keystroke
                // and workaround for FF which fires keypress for delete and backspace
                if (this.clearOnChange && elt.innerHTML === this.getEmptyLabelText() && (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IS_FF || evt.keyCode !== 8 /* Backspace */  && evt.keyCode !== 46)) {
                    this.clearOnChange = false;
                    elt.innerHTML = '';
                }
            }
        };
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(elt, 'keypress', keypressHandler);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(elt, 'paste', keypressHandler);
        // Handler for updating the empty label text value after a change
        const keyupHandler = (evt)=>{
            if (this.editingCell != null) {
                // Uses an optional text value for sempty labels which is cleared
                // when the first keystroke appears. This makes it easier to see
                // that a label is being edited even if the label is empty.
                // In Safari and FF, an empty text is represented by <BR> which isn't enough to force a valid size
                const textarea = this.textarea;
                if (textarea.innerHTML.length === 0 || textarea.innerHTML === '<br>') {
                    textarea.innerHTML = this.getEmptyLabelText();
                    this.clearOnChange = textarea.innerHTML.length > 0;
                } else {
                    this.clearOnChange = false;
                }
            }
        };
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(elt, 'input', keyupHandler);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(elt, 'cut', keyupHandler);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(elt, 'paste', keyupHandler);
        // Adds automatic resizing of the textbox while typing using input, keyup and/or DOM change events
        const evtName = 'input';
        const resizeHandler = (evt)=>{
            if (this.editingCell != null && this.autoSize && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isConsumed"])(evt)) {
                // Asynchronous is needed for keydown and shows better results for input events overall
                // (ie non-blocking and cases where the offsetWidth/-Height was wrong at this time)
                if (this.resizeThread != null) {
                    window.clearTimeout(this.resizeThread);
                }
                this.resizeThread = window.setTimeout(()=>{
                    this.resizeThread = null;
                    this.resize();
                }, 0);
            }
        };
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(elt, evtName, resizeHandler);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(window, 'resize', resizeHandler);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(elt, 'cut', resizeHandler);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(elt, 'paste', resizeHandler);
    }
    /**
     * Returns true if the given keydown event should stop cell editing. This
     * returns true if F2 is pressed of if {@link Graph#enterStopsCellEditing} is true
     * and enter is pressed without control or shift.
     */ isStopEditingEvent(evt) {
        return evt.keyCode === 113 /* F2 */  || this.graph.isEnterStopsCellEditing() && evt.keyCode === 13 /* Enter */  && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isControlDown"])(evt) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isShiftDown"])(evt);
    }
    /**
     * Returns true if this editor is the source for the given native event.
     */ isEventSource(evt) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSource"])(evt) === this.textarea;
    }
    /**
     * Returns {@link odified}.
     */ resize() {
        const state = this.editingCell ? this.graph.getView().getState(this.editingCell) : null;
        if (!state) {
            this.stopEditing(true);
        } else if (this.textarea != null) {
            const isEdge = state.cell.isEdge();
            const { scale } = this.graph.getView();
            let m = null;
            if (!this.autoSize || state.style.overflow === 'fill') {
                // Specifies the bounds of the editor box
                this.bounds = this.getEditorBounds(state);
                this.textarea.style.width = `${Math.round(this.bounds.width / scale)}px`;
                this.textarea.style.height = `${Math.round(this.bounds.height / scale)}px`;
                // FIXME: Offset when scaled
                this.textarea.style.left = `${Math.max(0, Math.round(this.bounds.x + 1))}px`;
                this.textarea.style.top = `${Math.max(0, Math.round(this.bounds.y + 1))}px`;
                // Installs native word wrapping and avoids word wrap for empty label placeholder
                if (this.graph.isWrapping(state.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) && this.textarea.innerHTML !== this.getEmptyLabelText()) {
                    this.textarea.style.wordWrap = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WORD_WRAP"];
                    this.textarea.style.whiteSpace = 'normal';
                    if (state.style.overflow !== 'fill') {
                        this.textarea.style.width = `${Math.round(this.bounds.width / scale) + this.wordWrapPadding}px`;
                    }
                } else {
                    this.textarea.style.whiteSpace = 'nowrap';
                    if (state.style.overflow !== 'fill') {
                        this.textarea.style.width = '';
                    }
                }
            } else {
                const lw = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getValue"])(state.style, 'labelWidth', null);
                m = state.text != null && this.align == null ? state.text.margin : null;
                if (m == null) {
                    m = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAlignmentAsPoint"])(this.align || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getValue"])(state.style, 'align', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].CENTER), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getValue"])(state.style, 'verticalAlign', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE));
                }
                if (isEdge) {
                    this.bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](state.absoluteOffset.x, state.absoluteOffset.y, 0, 0);
                    if (lw != null) {
                        const tmp = (parseFloat(lw) + 2) * scale;
                        this.bounds.width = tmp;
                        this.bounds.x += m.x * tmp;
                    }
                } else {
                    let bounds = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].fromRectangle(state);
                    let hpos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getValue"])(state.style, 'labelPosition', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].CENTER);
                    let vpos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getValue"])(state.style, 'verticalLabelPosition', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE);
                    bounds = state.shape != null && hpos === 'center' && vpos === 'middle' ? state.shape.getLabelBounds(bounds) : bounds;
                    if (lw != null) {
                        bounds.width = parseFloat(lw) * scale;
                    }
                    if (!state.view.graph.cellRenderer.legacySpacing || state.style.overflow !== 'width') {
                        // @ts-ignore
                        const dummy = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$TextShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](); // FIXME!!!! ===================================================================================================
                        const spacing = (state.style.spacing ?? 2) * scale;
                        const spacingTop = ((state.style.spacingTop ?? 0) + dummy.baseSpacingTop) * scale + spacing;
                        const spacingRight = ((state.style.spacingRight ?? 0) + dummy.baseSpacingRight) * scale + spacing;
                        const spacingBottom = ((state.style.spacingBottom ?? 0) + dummy.baseSpacingBottom) * scale + spacing;
                        const spacingLeft = ((state.style.spacingLeft ?? 0) + dummy.baseSpacingLeft) * scale + spacing;
                        hpos = state.style.labelPosition != null ? state.style.labelPosition : 'center';
                        vpos = state.style.verticalLabelPosition != null ? state.style.verticalLabelPosition : 'middle';
                        bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](bounds.x + spacingLeft, bounds.y + spacingTop, bounds.width - (hpos === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].CENTER && lw == null ? spacingLeft + spacingRight : 0), bounds.height - (vpos === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE ? spacingTop + spacingBottom : 0));
                    }
                    this.bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](bounds.x + state.absoluteOffset.x, bounds.y + state.absoluteOffset.y, bounds.width, bounds.height);
                }
                // Needed for word wrap inside text blocks with oversize lines to match the final result where
                // the width of the longest line is used as the reference for text alignment in the cell
                // TODO: Fix word wrapping preview for edge labels in helloworld.html
                if (this.graph.isWrapping(state.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) && this.textarea.innerHTML !== this.getEmptyLabelText()) {
                    this.textarea.style.wordWrap = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WORD_WRAP"];
                    this.textarea.style.whiteSpace = 'normal';
                    // Forces automatic reflow if text is removed from an oversize label and normal word wrap
                    const tmp = Math.round(this.bounds.width / scale) + this.wordWrapPadding;
                    if (this.textarea.style.position !== 'relative') {
                        this.textarea.style.width = `${tmp}px`;
                        if (this.textarea.scrollWidth > tmp) {
                            this.textarea.style.width = `${this.textarea.scrollWidth}px`;
                        }
                    } else {
                        this.textarea.style.maxWidth = `${tmp}px`;
                    }
                } else {
                    // KNOWN: Trailing cursor in IE9 quirks mode is not visible
                    this.textarea.style.whiteSpace = 'nowrap';
                    this.textarea.style.width = '';
                }
                const ow = this.textarea.scrollWidth;
                const oh = this.textarea.scrollHeight;
                // TODO: Update CSS width and height if smaller than minResize or remove minResize
                // if (this.minResize != null)
                // {
                //  ow = Math.max(ow, this.minResize.width);
                //  oh = Math.max(oh, this.minResize.height);
                // }
                // LATER: Keep in visible area, add fine tuning for pixel precision
                this.textarea.style.left = `${Math.max(0, Math.round(this.bounds.x - m.x * (this.bounds.width - 2)) + 1)}px`;
                this.textarea.style.top = `${Math.max(0, Math.round(this.bounds.y - m.y * (this.bounds.height - 4) + (m.y === -1 ? 3 : 0)) + 1)}px`;
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setPrefixedStyle"])(this.textarea.style, 'transformOrigin', '0px 0px');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setPrefixedStyle"])(this.textarea.style, 'transform', `scale(${scale},${scale})${m == null ? '' : ` translate(${m.x * 100}%,${m.y * 100}%)`}`);
        }
    }
    /**
     * Called if the textarea has lost focus.
     */ focusLost() {
        this.stopEditing(!this.graph.isInvokesStopCellEditing());
    }
    /**
     * Returns the background color for the in-place editor. This implementation
     * always returns NONE.
     */ getBackgroundColor(state) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"];
    }
    /**
     * Starts the editor for the given cell.
     *
     * @param cell <Cell> to start editing.
     * @param trigger Optional mouse event that triggered the editor.
     */ startEditing(cell, trigger = null) {
        this.stopEditing(true);
        this.align = null;
        // Creates new textarea instance
        if (this.textarea == null) {
            this.init();
        }
        const tooltipHandler = this.graph.getPlugin('TooltipHandler');
        tooltipHandler?.hideTooltip();
        const state = this.graph.getView().getState(cell);
        if (state) {
            // Configures the style of the in-place editor
            const { scale } = this.graph.getView();
            const size = state.style.fontSize ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_FONTSIZE"];
            const family = state.style.fontFamily ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_FONTFAMILY"];
            const color = state.style.fontColor ?? 'black';
            const align = state.style.align ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].LEFT;
            const bold = (state.style.fontStyle || 0) & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FONT"].BOLD;
            const italic = (state.style.fontStyle || 0) & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FONT"].ITALIC;
            const txtDecor = [];
            if ((state.style.fontStyle || 0) & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FONT"].UNDERLINE) {
                txtDecor.push('underline');
            }
            if ((state.style.fontStyle || 0) & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FONT"].STRIKETHROUGH) {
                txtDecor.push('line-through');
            }
            const textarea = this.textarea;
            textarea.style.lineHeight = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ABSOLUTE_LINE_HEIGHT"] ? `${Math.round(size * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LINE_HEIGHT"])}px` : String(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LINE_HEIGHT"]);
            textarea.style.backgroundColor = this.getBackgroundColor(state) || 'transparent';
            textarea.style.textDecoration = txtDecor.join(' ');
            textarea.style.fontWeight = bold ? 'bold' : 'normal';
            textarea.style.fontStyle = italic ? 'italic' : '';
            textarea.style.fontSize = `${Math.round(size)}px`;
            textarea.style.zIndex = String(this.zIndex);
            textarea.style.fontFamily = family;
            textarea.style.textAlign = align;
            textarea.style.outline = 'none';
            textarea.style.color = color;
            let dir = this.textDirection = state.style.textDirection ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_TEXT_DIRECTION"];
            if (dir === 'auto') {
                if (state.text !== null && state.text.dialect !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].STRICTHTML && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNode"])(state.text.value)) {
                    dir = state.text.getAutoDirection();
                }
            }
            if (dir === 'ltr' || dir === 'rtl') {
                textarea.setAttribute('dir', dir);
            } else {
                textarea.removeAttribute('dir');
            }
            // Sets the initial editing value
            textarea.innerHTML = this.getInitialValue(state, trigger) || '';
            this.initialValue = textarea.innerHTML;
            // Uses an optional text value for empty labels which is cleared
            // when the first keystroke appears. This makes it easier to see
            // that a label is being edited even if the label is empty.
            if (textarea.innerHTML.length === 0 || textarea.innerHTML === '<br>') {
                textarea.innerHTML = this.getEmptyLabelText();
                this.clearOnChange = true;
            } else {
                this.clearOnChange = textarea.innerHTML === this.getEmptyLabelText();
            }
            // @ts-ignore
            this.graph.container.appendChild(textarea);
            // Update this after firing all potential events that could update the cleanOnChange flag
            this.editingCell = cell;
            this.trigger = trigger;
            this.textNode = null;
            if (state.text !== null && this.isHideLabel(state)) {
                this.textNode = state.text.node;
                this.textNode.style.visibility = 'hidden';
            }
            // Workaround for initial offsetHeight not ready for heading in markup
            if (this.autoSize && (state.cell.isEdge() || state.style.overflow !== 'fill')) {
                window.setTimeout(()=>{
                    this.resize();
                }, 0);
            }
            this.resize();
            // Workaround for NS_ERROR_FAILURE in FF
            try {
                // Prefers blinking cursor over no selected text if empty
                textarea.focus();
                if (this.isSelectText() && textarea.innerHTML.length > 0 && (textarea.innerHTML !== this.getEmptyLabelText() || !this.clearOnChange)) {
                    document.execCommand('selectAll', false);
                }
            } catch (e) {
            // ignore
            }
        }
    }
    /**
     * Returns <selectText>.
     */ isSelectText() {
        return this.selectText;
    }
    /**
    clearSelection() {
      const selection = window.getSelection();
  
      if (selection) {
        if (selection.empty) {
          selection.empty();
        } else if (selection.removeAllRanges) {
          selection.removeAllRanges();
        }
      }
    }
  
    /**
     * Stops the editor and applies the value if cancel is false.
     */ stopEditing(cancel = false) {
        if (this.editingCell) {
            if (this.textNode) {
                this.textNode.style.visibility = 'visible';
                this.textNode = null;
            }
            const state = !cancel ? this.graph.view.getState(this.editingCell) : null;
            const textarea = this.textarea;
            const initial = this.initialValue;
            this.initialValue = null;
            this.editingCell = null;
            this.bounds = null;
            textarea.blur();
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clearSelection"])();
            if (textarea.parentNode) {
                textarea.parentNode.removeChild(textarea);
            }
            if (this.clearOnChange && textarea.innerHTML === this.getEmptyLabelText()) {
                textarea.innerHTML = '';
                this.clearOnChange = false;
            }
            if (state && (textarea.innerHTML !== initial || this.align !== null)) {
                this.prepareTextarea();
                const value = this.getCurrentValue(state);
                this.graph.batchUpdate(()=>{
                    if (value !== null) {
                        this.applyValue(state, value);
                    }
                    if (this.align !== null) {
                        this.graph.setCellStyles('align', this.align, [
                            state.cell
                        ]);
                    }
                });
            }
            this.trigger = null;
            // Forces new instance on next edit for undo history reset
            if (this.textarea) __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].release(this.textarea);
            this.textarea = null;
            this.align = null;
        }
    }
    /**
     * Prepares the textarea for getting its value in <stopEditing>.
     * This implementation removes the extra trailing linefeed in Firefox.
     */ prepareTextarea() {
        const textarea = this.textarea;
        if (textarea.lastChild && textarea.lastChild.nodeName === 'BR') {
            textarea.removeChild(textarea.lastChild);
        }
    }
    /**
     * Returns true if the label should be hidden while the cell is being
     * edited.
     */ isHideLabel(state = null) {
        return true;
    }
    /**
     * Returns the minimum width and height for editing the given state.
     */ getMinimumSize(state) {
        const { scale } = this.graph.getView();
        const textarea = this.textarea;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](0, 0, state.text === null ? 30 : state.text.size * scale + 20, textarea.style.textAlign === 'left' ? 120 : 40);
    }
    /**
     * Returns the {@link Rectangle} that defines the bounds of the editor.
     */ getEditorBounds(state) {
        const isEdge = state.cell.isEdge();
        const { scale } = this.graph.getView();
        const minSize = this.getMinimumSize(state);
        const minWidth = minSize.width;
        const minHeight = minSize.height;
        let result = null;
        if (!isEdge && state.view.graph.cellRenderer.legacySpacing && state.style.overflow === 'fill') {
            result = state.shape.getLabelBounds(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].fromRectangle(state));
        } else {
            // @ts-ignore
            const dummy = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$TextShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](); // FIXME!!!! ===================================================================================================
            const spacing = (state.style.spacing ?? 0) * scale;
            const spacingTop = ((state.style.spacingTop ?? 0) + dummy.baseSpacingTop) * scale + spacing;
            const spacingRight = ((state.style.spacingRight ?? 0) + dummy.baseSpacingRight) * scale + spacing;
            const spacingBottom = ((state.style.spacingBottom ?? 0) + dummy.baseSpacingBottom) * scale + spacing;
            const spacingLeft = ((state.style.spacingLeft ?? 0) + dummy.baseSpacingLeft) * scale + spacing;
            result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](state.x, state.y, Math.max(minWidth, state.width - spacingLeft - spacingRight), Math.max(minHeight, state.height - spacingTop - spacingBottom));
            const hpos = state.style.labelPosition != null ? state.style.labelPosition : 'center';
            const vpos = state.style.verticalLabelPosition != null ? state.style.verticalLabelPosition : 'middle';
            result = state.shape != null && hpos === 'center' && vpos === 'middle' ? state.shape.getLabelBounds(result) : result;
            if (isEdge) {
                result.x = state.absoluteOffset.x;
                result.y = state.absoluteOffset.y;
                if (state.text != null && state.text.boundingBox != null) {
                    // Workaround for label containing just spaces in which case
                    // the bounding box location contains negative numbers
                    if (state.text.boundingBox.x > 0) {
                        result.x = state.text.boundingBox.x;
                    }
                    if (state.text.boundingBox.y > 0) {
                        result.y = state.text.boundingBox.y;
                    }
                }
            } else if (state.text != null && state.text.boundingBox != null) {
                result.x = Math.min(result.x, state.text.boundingBox.x);
                result.y = Math.min(result.y, state.text.boundingBox.y);
            }
            result.x += spacingLeft;
            result.y += spacingTop;
            if (state.text != null && state.text.boundingBox != null) {
                if (!isEdge) {
                    result.width = Math.max(result.width, state.text.boundingBox.width);
                    result.height = Math.max(result.height, state.text.boundingBox.height);
                } else {
                    result.width = Math.max(minWidth, state.text.boundingBox.width);
                    result.height = Math.max(minHeight, state.text.boundingBox.height);
                }
            }
            // Applies the horizontal and vertical label positions
            if (state.cell.isVertex()) {
                const horizontal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getStringValue"])(state.style, 'labelPosition', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALIGN"].CENTER);
                if (horizontal === 'left') {
                    result.x -= state.width;
                } else if (horizontal === 'right') {
                    result.x += state.width;
                }
                const vertical = state.style.verticalLabelPosition != null ? state.style.verticalLabelPosition : 'middle';
                if (vertical === 'top') {
                    result.y -= state.height;
                } else if (vertical === 'bottom') {
                    result.y += state.height;
                }
            }
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.round(result.x), Math.round(result.y), Math.round(result.width), Math.round(result.height));
    }
    /**
     * Returns the initial label value to be used of the label of the given
     * cell is empty. This label is displayed and cleared on the first keystroke.
     * This implementation returns <emptyLabelText>.
     *
     * @param cell <Cell> for which a text for an empty editing box should be
     * returned.
     */ getEmptyLabelText(cell = null) {
        return this.emptyLabelText ?? '';
    }
    /**
     * Returns the cell that is currently being edited or null if no cell is
     * being edited.
     */ getEditingCell() {
        return this.editingCell;
    }
    /**
     * Destroys the editor and removes all associated resources.
     */ onDestroy() {
        if (this.textarea) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].release(this.textarea);
            if (this.textarea.parentNode) {
                this.textarea.parentNode.removeChild(this.textarea);
            }
            this.textarea = null;
        }
        this.graph.getDataModel().removeListener(this.changeHandler);
        this.graph.getView().removeListener(this.zoomHandler);
    }
}
CellEditorHandler.pluginId = 'CellEditorHandler';
const __TURBOPACK__default__export__ = CellEditorHandler;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/handler/TooltipHandler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/domUtils.js [app-ssr] (ecmascript)");
;
;
;
;
;
/**
 * Graph event handler that displays tooltips.
 *
 * {@link Graph#getTooltip} is used to get the tooltip for a cell or handle.
 *
 * This handler is generally enabled using {@link Graph#setTooltips}.
 *
 * @category Plugin
 */ class TooltipHandler {
    /**
     * Constructs an event handler that displays tooltips.
     *
     * @param graph Reference to the enclosing {@link Graph}.
     */ constructor(graph){
        /**
         * Specifies the zIndex for the tooltip and its shadow.
         * @default 10005
         */ this.zIndex = 10005;
        /**
         * Delay to show the tooltip in milliseconds.
         * @default 500
         */ this.delay = 500;
        /**
         * Specifies if touch and pen events should be ignored.
         * @default true
         */ this.ignoreTouchEvents = true;
        /**
         * Specifies if the tooltip should be hidden if the mouse is moved over the current cell.
         * @default false
         */ this.hideOnHover = false;
        /**
         * `true` if this handler was destroyed using {@link onDestroy}.
         */ this.destroyed = false;
        this.lastX = 0;
        this.lastY = 0;
        this.state = null;
        this.stateSource = false;
        this.thread = null;
        /**
         * Specifies if events are handled.
         * @default false
         */ this.enabled = false;
        this.graph = graph;
        this.graph.addMouseListener(this);
        this.div = document.createElement('div');
        this.div.className = 'mxTooltip';
        this.div.style.visibility = 'hidden';
        document.body.appendChild(this.div);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addGestureListeners(this.div, (evt)=>{
            const source = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSource"])(evt);
            // @ts-ignore nodeName may exist
            if (source && source.nodeName !== 'A') {
                this.hideTooltip();
            }
        });
        // Hides tooltips and resets tooltip timer if mouse leaves container
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(this.graph.getContainer(), 'mouseleave', (evt)=>{
            if (this.div !== evt.relatedTarget) {
                this.hide();
            }
        });
    }
    /**
     * Returns `true` if events are handled.
     *
     * This implementation returns {@link enabled}.
     */ isEnabled() {
        return this.enabled;
    }
    /**
     * Enables or disables event handling.
     *
     * This implementation updates {@link enabled}.
     */ setEnabled(enabled) {
        this.enabled = enabled;
    }
    /**
     * Returns {@link hideOnHover}.
     */ isHideOnHover() {
        return this.hideOnHover;
    }
    /**
     * Sets <hideOnHover>.
     */ setHideOnHover(value) {
        this.hideOnHover = value;
    }
    /**
     * Returns the <CellState> to be used for showing a tooltip for this event.
     */ getStateForEvent(me) {
        return me.getState();
    }
    /**
     * Handles the event by initiating a rubberband selection. By consuming the
     * event all subsequent events of the gesture are redirected to this
     * handler.
     */ mouseDown(sender, me) {
        this.reset(me, false);
        this.hideTooltip();
    }
    /**
     * Handles the event by updating the rubberband selection.
     */ mouseMove(sender, me) {
        if (me.getX() !== this.lastX || me.getY() !== this.lastY) {
            this.reset(me, true);
            const state = this.getStateForEvent(me);
            if (this.isHideOnHover() || state !== this.state || me.getSource() !== this.node && (!this.stateSource || state != null && this.stateSource === (me.isSource(state.shape) || !me.isSource(state.text)))) {
                this.hideTooltip();
            }
        }
        this.lastX = me.getX();
        this.lastY = me.getY();
    }
    /**
     * Handles the event by resetting the tooltip timer or hiding the existing
     * tooltip.
     */ mouseUp(sender, me) {
        this.reset(me, true);
        this.hideTooltip();
    }
    /**
     * Resets the timer.
     */ resetTimer() {
        if (this.thread) {
            window.clearTimeout(this.thread);
            this.thread = null;
        }
    }
    /**
     * Resets and/or restarts the timer to trigger the display of the tooltip.
     */ reset(me, restart, state = null) {
        if (!this.ignoreTouchEvents || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMouseEvent"])(me.getEvent())) {
            this.resetTimer();
            state = state ?? this.getStateForEvent(me);
            if (restart && this.isEnabled() && state && this.div.style.visibility === 'hidden') {
                const node = me.getSource();
                const x = me.getX();
                const y = me.getY();
                const stateSource = me.isSource(state.shape) || me.isSource(state.text);
                const popupMenuHandler = this.graph.getPlugin('PopupMenuHandler');
                this.thread = window.setTimeout(()=>{
                    if (state && node && !this.graph.isEditing() && popupMenuHandler && !popupMenuHandler.isMenuShowing() && !this.graph.isMouseDown) {
                        // Uses information from inside event cause using the event at
                        // this (delayed) point in time is not possible in IE as it no
                        // longer contains the required information (member not found)
                        const tip = this.graph.getTooltip(state, node, x, y);
                        this.show(tip, x, y);
                        this.state = state;
                        this.node = node;
                        this.stateSource = stateSource;
                    }
                }, this.delay);
            }
        }
    }
    /**
     * Hides the tooltip and resets the timer.
     */ hide() {
        this.resetTimer();
        this.hideTooltip();
    }
    /**
     * Hides the tooltip.
     */ hideTooltip() {
        this.div.style.visibility = 'hidden';
        this.div.innerHTML = '';
    }
    /**
     * Shows the tooltip for the specified cell and optional index at the
     * specified location (with a vertical offset of 10 pixels).
     */ show(tip, x, y) {
        if (!this.destroyed && tip && tip !== '') {
            const origin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getScrollOrigin"])();
            this.div.style.zIndex = String(this.zIndex);
            this.div.style.left = `${x + origin.x}px`;
            this.div.style.top = `${y + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TOOLTIP_VERTICAL_OFFSET"] + origin.y}px`;
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNode"])(tip)) {
                this.div.innerHTML = tip.replace(/\n/g, '<br>');
            } else {
                this.div.innerHTML = '';
                this.div.appendChild(tip);
            }
            this.div.style.visibility = '';
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fit"])(this.div);
        }
    }
    /**
     * Destroys the handler and all its resources and DOM nodes.
     */ onDestroy() {
        if (!this.destroyed) {
            this.graph.removeMouseListener(this);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].release(this.div);
            if (this.div.parentNode) {
                this.div.parentNode.removeChild(this.div);
            }
            this.destroyed = true;
        }
    }
}
TooltipHandler.pluginId = 'TooltipHandler';
const __TURBOPACK__default__export__ = TooltipHandler;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/handler/SelectionCellsHandler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Dictionary.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventSource.js [app-ssr] (ecmascript)");
;
;
;
;
;
/**
 * An event handler that manages cell handlers and invokes their mouse event
 * processing functions.
 *
 * Group: Events
 *
 * Event: mxEvent.ADD
 *
 * Fires if a cell has been added to the selection. The <code>state</code>
 * property contains the <CellState> that has been added.
 *
 * Event: mxEvent.REMOVE
 *
 * Fires if a cell has been remove from the selection. The <code>state</code>
 * property contains the <CellState> that has been removed.
 *
 * @category Plugin
 */ class SelectionCellsHandler extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    constructor(graph){
        super();
        /**
         * Specifies if events are handled. Default is true.
         */ this.enabled = true;
        /**
         * Defines the maximum number of handlers to paint individually. Default is 100.
         */ this.maxHandlers = 100;
        this.graph = graph;
        this.handlers = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
        this.graph.addMouseListener(this);
        this.refreshHandler = (sender, evt)=>{
            if (this.isEnabled()) {
                this.refresh();
            }
        };
        this.graph.getSelectionModel().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, this.refreshHandler);
        this.graph.getDataModel().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, this.refreshHandler);
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SCALE, this.refreshHandler);
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].TRANSLATE, this.refreshHandler);
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SCALE_AND_TRANSLATE, this.refreshHandler);
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].DOWN, this.refreshHandler);
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].UP, this.refreshHandler);
    }
    /**
     * Returns <enabled>.
     */ isEnabled() {
        return this.enabled;
    }
    /**
     * Sets <enabled>.
     */ setEnabled(value) {
        this.enabled = value;
    }
    /**
     * Returns the handler for the given cell.
     */ getHandler(cell) {
        return this.handlers.get(cell);
    }
    /**
     * Returns true if the given cell has a handler.
     */ isHandled(cell) {
        return !!this.getHandler(cell);
    }
    /**
     * Resets all handlers.
     */ reset() {
        this.handlers.visit((key, handler)=>{
            handler.reset.apply(handler);
        });
    }
    /**
     * Reloads or updates all handlers.
     */ getHandledSelectionCells() {
        return this.graph.getSelectionCells();
    }
    /**
     * Reloads or updates all handlers.
     */ refresh() {
        // Removes all existing handlers
        const oldHandlers = this.handlers;
        this.handlers = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
        // Creates handles for all selection cells
        const tmp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sortCells"])(this.getHandledSelectionCells(), false);
        // Destroys or updates old handlers
        for(let i = 0; i < tmp.length; i += 1){
            const state = this.graph.view.getState(tmp[i]);
            if (state) {
                let handler = oldHandlers.remove(tmp[i]);
                if (handler) {
                    if (handler.state !== state) {
                        handler.onDestroy();
                        handler = null;
                    } else if (!this.isHandlerActive(handler)) {
                        // @ts-ignore refresh may exist
                        if (handler.refresh) handler.refresh();
                        handler.redraw();
                    }
                }
                if (handler) {
                    this.handlers.put(tmp[i], handler);
                }
            }
        }
        // Destroys unused handlers
        oldHandlers.visit((key, handler)=>{
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].REMOVE, {
                state: handler.state
            }));
            handler.onDestroy();
        });
        // Creates new handlers and updates parent highlight on existing handlers
        for(let i = 0; i < tmp.length; i += 1){
            const state = this.graph.view.getState(tmp[i]);
            if (state) {
                let handler = this.handlers.get(tmp[i]);
                if (!handler) {
                    handler = this.graph.createHandler(state);
                    this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ADD, {
                        state
                    }));
                    this.handlers.put(tmp[i], handler);
                } else {
                    handler.updateParentHighlight();
                }
            }
        }
    }
    /**
     * Returns true if the given handler is active and should not be redrawn.
     */ isHandlerActive(handler) {
        return handler.index !== null;
    }
    /**
     * Updates the handler for the given shape if one exists.
     */ updateHandler(state) {
        let handler = this.handlers.remove(state.cell);
        if (handler) {
            // Transfers the current state to the new handler
            const { index } = handler;
            const x = handler.startX;
            const y = handler.startY;
            handler.onDestroy();
            handler = this.graph.createHandler(state);
            if (handler) {
                this.handlers.put(state.cell, handler);
                if (index !== null) {
                    handler.start(x, y, index);
                }
            }
        }
    }
    /**
     * Redirects the given event to the handlers.
     */ mouseDown(sender, me) {
        if (this.graph.isEnabled() && this.isEnabled()) {
            this.handlers.visit((key, handler)=>{
                handler.mouseDown(sender, me);
            });
        }
    }
    /**
     * Redirects the given event to the handlers.
     */ mouseMove(sender, me) {
        if (this.graph.isEnabled() && this.isEnabled()) {
            this.handlers.visit((key, handler)=>{
                handler.mouseMove(sender, me);
            });
        }
    }
    /**
     * Redirects the given event to the handlers.
     */ mouseUp(sender, me) {
        if (this.graph.isEnabled() && this.isEnabled()) {
            this.handlers.visit((key, handler)=>{
                handler.mouseUp(sender, me);
            });
        }
    }
    /**
     * Destroys the handler and all its resources and DOM nodes.
     */ onDestroy() {
        this.graph.removeMouseListener(this);
        this.graph.removeListener(this.refreshHandler);
        this.graph.getDataModel().removeListener(this.refreshHandler);
        this.graph.getView().removeListener(this.refreshHandler);
    }
}
SelectionCellsHandler.pluginId = 'SelectionCellsHandler';
const __TURBOPACK__default__export__ = SelectionCellsHandler;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/handler/PopupMenuHandler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$gui$2f$MaxPopupMenu$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/gui/MaxPopupMenu.js [app-ssr] (ecmascript)");
;
;
;
;
/**
 * Event handler that creates popupmenus.
 *
 * Relates to {@link MaxPopupMenu}.
 *
 * @category Plugin
 */ class PopupMenuHandler extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$gui$2f$MaxPopupMenu$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    constructor(graph){
        super();
        this.inTolerance = false;
        this.popupTrigger = false;
        /**
         * Specifies if cells should be selected if a popupmenu is displayed for
         * them. Default is true.
         */ this.selectOnPopup = true;
        /**
         * Specifies if cells should be deselected if a popupmenu is displayed for
         * the diagram background. Default is true.
         */ this.clearSelectionOnBackground = true;
        /**
         * X-coordinate of the mouse down event.
         */ this.triggerX = null;
        /**
         * Y-coordinate of the mouse down event.
         */ this.triggerY = null;
        /**
         * Screen X-coordinate of the mouse down event.
         */ this.screenX = null;
        /**
         * Screen Y-coordinate of the mouse down event.
         */ this.screenY = null;
        this.graph = graph;
        this.graph.addMouseListener(this);
        // Does not show menu if any touch gestures take place after the trigger
        this.gestureHandler = (sender, eo)=>{
            this.inTolerance = false;
        };
        this.graph.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].GESTURE, this.gestureHandler);
        this.init();
    }
    /**
     * Initializes the shapes required for this vertex handler.
     */ init() {
        // Hides the tooltip if the mouse is over the context menu
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addGestureListeners(this.div, (evt)=>{
            const tooltipHandler = this.graph.getPlugin('TooltipHandler');
            tooltipHandler?.hide();
        });
    }
    /**
     * Hook for returning if a cell should be selected for a given {@link MouseEvent}.
     * This implementation returns <selectOnPopup>.
     */ isSelectOnPopup(me) {
        return this.selectOnPopup;
    }
    /**
     * Handles the event by initiating the panning. By consuming the event all
     * subsequent events of the gesture are redirected to this handler.
     */ mouseDown(sender, me) {
        if (this.isEnabled() && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMultiTouchEvent"])(me.getEvent())) {
            // Hides the popupmenu if is is being displayed
            this.hideMenu();
            this.triggerX = me.getGraphX();
            this.triggerY = me.getGraphY();
            this.screenX = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getMainEvent"])(me.getEvent()).screenX;
            this.screenY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getMainEvent"])(me.getEvent()).screenY;
            this.popupTrigger = this.isPopupTrigger(me);
            this.inTolerance = true;
        }
    }
    /**
     * Handles the event by updating the panning on the graph.
     */ mouseMove(sender, me) {
        // Popup trigger may change on mouseUp so ignore it
        if (this.inTolerance && this.screenX != null && this.screenY != null) {
            if (Math.abs((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getMainEvent"])(me.getEvent()).screenX - this.screenX) > this.graph.getEventTolerance() || Math.abs((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getMainEvent"])(me.getEvent()).screenY - this.screenY) > this.graph.getEventTolerance()) {
                this.inTolerance = false;
            }
        }
    }
    /**
     * Handles the event by setting the translation on the view or showing the
     * popupmenu.
     */ mouseUp(sender, me) {
        if (this.popupTrigger && this.inTolerance && this.triggerX != null && this.triggerY != null) {
            const cell = this.getCellForPopupEvent(me);
            // Selects the cell for which the context menu is being displayed
            if (this.graph.isEnabled() && this.isSelectOnPopup(me) && cell != null && !this.graph.isCellSelected(cell)) {
                this.graph.setSelectionCell(cell);
            } else if (this.clearSelectionOnBackground && cell == null) {
                this.graph.clearSelection();
            }
            // Hides the tooltip if there is one
            const tooltipHandler = this.graph.getPlugin('TooltipHandler');
            tooltipHandler?.hide();
            // Menu is shifted by 1 pixel so that the mouse up event
            // is routed via the underlying shape instead of the DIV
            const origin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getScrollOrigin"])();
            this.popup(me.getX() + origin.x + 1, me.getY() + origin.y + 1, cell, me.getEvent());
            me.consume();
        }
        this.popupTrigger = false;
        this.inTolerance = false;
    }
    /**
     * Hook to return the cell for the mouse up popup trigger handling.
     */ getCellForPopupEvent(me) {
        return me.getCell();
    }
    /**
     * Destroys the handler and all its resources and DOM nodes.
     */ onDestroy() {
        this.graph.removeMouseListener(this);
        this.graph.removeListener(this.gestureHandler);
        // Supercall
        super.destroy();
    }
}
PopupMenuHandler.pluginId = 'PopupMenuHandler';
const __TURBOPACK__default__export__ = PopupMenuHandler;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/handler/ConnectionHandler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2016, JGraph Ltd
Copyright (c) 2006-2016, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$ConstraintHandler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/ConstraintHandler.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$PolylineShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/PolylineShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/ImageShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalMouseEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Geometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/Cell.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventSource.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellMarker$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/CellMarker.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * Graph event handler that creates new connections.
 * Uses {@link CellMarker} for finding and highlighting the source and target vertices and {@link factoryMethod} to create the edge instance.
 *
 * This handler is enabled using {@link Graph.setConnectable}.
 *
 * Example:
 *
 * ```javascript
 * new ConnectionHandler(graph, (source, target, style)=>
 * {
 *   edge = new Cell('', new Geometry());
 *   edge.setEdge(true);
 *   edge.setStyle(style);
 *   edge.geometry.relative = true;
 *   return edge;
 * });
 * ```
 *
 * Here is an alternative solution that just sets a specific user object for new edges by overriding {@link insertEdge}.
 *
 * ```javascript
 * originalConnectionHandlerInsertEdge = connectionHandler.insertEdge;
 * connectionHandler.insertEdge = (parent, id, value, source, target, style) => {
 *   value = 'Test';
 *   return originalConnectionHandlerInsertEdge.apply(this, arguments);
 * };
 * ```
 *
 * ### Using images to trigger connections
 *
 * This handler uses {@link CellMarker} to find the source and target cell for
 * the new connection and creates a new edge using {@link connect}. The new edge is
 * created using {@link createEdge} which in turn uses {@link factoryMethod} or creates a
 * new default edge.
 *
 * The handler uses a "highlight-paradigm" for indicating if a cell is being
 * used as a source or target terminal, as seen in other diagramming products.
 * In order to allow both, moving and connecting cells at the same time,
 * {@link DEFAULT_HOTSPOT} is used in the handler to determine the hotspot
 * of a cell, that is, the region of the cell which is used to trigger a new
 * connection. The constant is a value between 0 and 1 that specifies the
 * amount of the width and height around the center to be used for the hotspot
 * of a cell and its default value is 0.5. In addition,
 * {@link MIN_HOTSPOT_SIZE} defines the minimum number of pixels for the
 * width and height of the hotspot.
 *
 * This solution, while standards compliant, may be somewhat confusing because
 * there is no visual indicator for the hotspot and the highlight is seen to
 * switch on and off while the mouse is being moved in and out. Furthermore,
 * this paradigm does not allow to create different connections depending on
 * the highlighted hotspot as there is only one hotspot per cell, and it
 * normally does not allow cells to be moved and connected at the same time as
 * there is no clear indication of the connectable area of the cell.
 *
 * To come across these issues, the handle has an additional {@link createIcons} hook
 * with a default implementation that allows to create one icon to be used to
 * trigger new connections. If this icon is specified, then new connections can
 * only be created if the image is clicked while the cell is being highlighted.
 * The {@link createIcons} hook may be overridden to create more than one
 * {@link ImageShape} for creating new connections, but the default implementation
 * supports one image and is used as follows:
 *
 * In order to display the "connect image" whenever the mouse is over the cell, an DEFAULT_HOTSPOT of 1 should be used:
 *
 * ```javascript
 * mxConstants.DEFAULT_HOTSPOT = 1;
 * ```
 *
 * In order to avoid confusion with the highlighting, the highlight color should not be used with a connect image:
 *
 * ```javascript
 * mxConstants.HIGHLIGHT_COLOR = null;
 * ```
 *
 * To install the image, the connectImage field of the ConnectionHandler must be assigned a new {@link Image} instance:
 *
 * ```javascript
 * connectImage = new ImageBox('images/green-dot.gif', 14, 14);
 * ```
 *
 * This will use the green-dot.gif with a width and height of 14 pixels as the
 * image to trigger new connections. In createIcons the icon field of the
 * handler will be set in order to remember the icon that has been clicked for
 * creating the new connection. This field will be available under selectedIcon
 * in the connect method, which may be overridden to take the icon that
 * triggered the new connection into account. This is useful if more than one
 * icon may be used to create a connection.
 *
 * ### Events
 *
 * #### InternalEvent.START
 *
 * Fires when a new connection is being created by the user. The `state`
 * property contains the state of the source cell.
 *
 * #### InternalEvent.CONNECT
 *
 * Fires between begin- and endUpdate in {@link connect}. The `cell`
 * property contains the inserted edge, the `event` and `target`
 * properties contain the respective arguments that were passed to {@link connect} (where
 * target corresponds to the dropTarget argument). Finally, the `terminal`
 * property corresponds to the target argument in {@link connect} or the clone of the source
 * terminal if {@link createTarget} is enabled.
 *
 * Note that the target is the cell under the mouse where the mouse button was released.
 * Depending on the logic in the handler, this doesn't necessarily have to be the target
 * of the inserted edge. To print the source, target or any optional ports IDs that the
 * edge is connected to, the following code can be used. To get more details about the
 * actual connection point, {@link Graph.getConnectionConstraint} can be used. To resolve
 * the port IDs, use <Transactions.getCell>.
 *
 * ```javascript
 * graph.getPlugin('ConnectionHandler')?.addListener(mxEvent.CONNECT, (sender, evt) => {
 *   const edge = evt.getProperty('cell');
 *   const source = graph.getDataModel().getTerminal(edge, true);
 *   const target = graph.getDataModel().getTerminal(edge, false);
 *
 *   const style = graph.getCellStyle(edge);
 *   const sourcePortId = style.sourcePort;
 *   const targetPortId = style.targetPort;
 *
 *   GlobalConfig.logger.show();
 *   GlobalConfig.logger.debug('connect', edge, source.id, target.id, sourcePortId, targetPortId);
 * });
 * ```
 *
 * #### InternalEvent.RESET
 *
 * Fires when the {@link reset} method is invoked.
 *
 * @category Plugin
 */ class ConnectionHandler extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    /**
     * Constructs an event handler that connects vertices using the specified
     * factory method to create the new edges.
     *
     * @param graph Reference to the enclosing {@link Graph}.
     * @param factoryMethod Optional function to create the edge. The function takes
     * the source and target {@link Cell} as the first and second argument and an
     * optional cell style from the preview as the third argument. It returns
     * the {@link Cell} that represents the new edge.
     */ constructor(graph, factoryMethod = null){
        super();
        this.previous = null;
        this.iconState = null;
        this.icons = [];
        this.cell = null;
        this.currentPoint = null;
        this.sourceConstraint = null;
        this.shape = null;
        this.icon = null;
        this.originalPoint = null;
        this.currentState = null;
        this.selectedIcon = null;
        this.waypoints = [];
        /**
         * Function that is used for creating new edges. The function takes the
         * source and target {@link Cell} as the first and second argument and returns
         * a new {@link Cell} that represents the edge. This is used in {@link createEdge}.
         */ this.factoryMethod = null;
        /**
         * Specifies if icons should be displayed inside the graph container instead
         * of the overlay pane. This is used for HTML labels on vertices which hide
         * the connect icon. This has precedence over {@link moveIconBack} when set
         * to true.
         * @default `false`
         */ this.moveIconFront = false;
        /**
         * Specifies if icons should be moved to the back of the overlay pane. This can
         * be set to true if the icons of the connection handler conflict with other
         * handles, such as the vertex label move handle. Default is false.
         */ this.moveIconBack = false;
        /**
         * {@link Image} that is used to trigger the creation of a new connection.
         * This is used in {@link createIcons}.
         * @default null
         */ this.connectImage = null;
        /**
         * Specifies if the connect icon should be centered on the target state
         * while connections are being previewed. Default is false.
         */ this.targetConnectImage = false;
        /**
         * Specifies if events are handled. Default is false.
         */ this.enabled = false;
        /**
         * Specifies if new edges should be selected. Default is true.
         */ this.select = true;
        /**
         * Specifies if <createTargetVertex> should be called if no target was under the
         * mouse for the new connection. Setting this to true means the connection
         * will be drawn as valid if no target is under the mouse, and
         * <createTargetVertex> will be called before the connection is created between
         * the source cell and the newly created vertex in <createTargetVertex>, which
         * can be overridden to create a new target. Default is false.
         */ this.createTarget = false;
        /**
         * Holds the current validation error while connections are being created.
         */ this.error = null;
        /**
         * Specifies if single clicks should add waypoints on the new edge. Default is
         * false.
         */ this.waypointsEnabled = false;
        /**
         * Specifies if the connection handler should ignore the state of the mouse
         * button when highlighting the source. Default is false, that is, the
         * handler only highlights the source if no button is being pressed.
         */ this.ignoreMouseDown = false;
        /**
         * Holds the {@link Point} where the mouseDown took place while the handler is
         * active.
         */ this.first = null;
        /**
         * Holds the offset for connect icons during connection preview.
         * Default is mxPoint(0, {@link Constants#TOOLTIP_VERTICAL_OFFSET}).
         * Note that placing the icon under the mouse pointer with an
         * offset of (0,0) will affect hit detection.
         */ this.connectIconOffset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TOOLTIP_VERTICAL_OFFSET"]);
        /**
         * Optional <CellState> that represents the preview edge while the
         * handler is active. This is created in <createEdgeState>.
         */ this.edgeState = null;
        /**
         * Counts the number of mouseDown events since the start. The initial mouse
         * down event counts as 1.
         */ this.mouseDownCounter = 0;
        /**
         * Switch to enable moving the preview away from the mousepointer. This is required in browsers
         * where the preview cannot be made transparent to events and if the built-in hit detection on
         * the HTML elements in the page should be used.
         * @default false
         */ this.movePreviewAway = false;
        /**
         * Specifies if connections to the outline of a highlighted target should be
         * enabled. This will allow to place the connection point along the outline of
         * the highlighted target.
         * @default false
         */ this.outlineConnect = false;
        /**
         * Specifies if the actual shape of the edge state should be used for the preview.
         * Default is false. (Ignored if no edge state is created in <createEdgeState>.)
         */ this.livePreview = false;
        /**
         * Specifies the cursor to be used while the handler is active. Default is null.
         */ this.cursor = null;
        /**
         * Specifies if new edges should be inserted before the source vertex in the
         * cell hierarchy. Default is false for backwards compatibility.
         */ this.insertBeforeSource = false;
        this.graph = graph;
        this.factoryMethod = factoryMethod;
        this.graph.addMouseListener(this);
        this.marker = this.createMarker();
        this.constraintHandler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$ConstraintHandler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.graph);
        // Redraws the icons if the graph changes
        this.changeHandler = (sender)=>{
            if (this.iconState) {
                this.iconState = this.graph.getView().getState(this.iconState.cell);
            }
            if (this.iconState) {
                this.redrawIcons(this.icons, this.iconState);
                this.constraintHandler.reset();
            } else if (this.previous && !this.graph.view.getState(this.previous.cell)) {
                this.reset();
            }
        };
        this.graph.getDataModel().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, this.changeHandler);
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SCALE, this.changeHandler);
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].TRANSLATE, this.changeHandler);
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].SCALE_AND_TRANSLATE, this.changeHandler);
        // Removes the icon if we step into/up or start editing
        this.drillHandler = (sender)=>{
            this.reset();
        };
        this.graph.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].START_EDITING, this.drillHandler);
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].DOWN, this.drillHandler);
        this.graph.getView().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].UP, this.drillHandler);
        // Handles escape keystrokes
        this.escapeHandler = ()=>{
            this.reset();
        };
        this.graph.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ESCAPE, this.escapeHandler);
    }
    /**
     * Returns true if events are handled. This implementation
     * returns <enabled>.
     */ isEnabled() {
        return this.enabled;
    }
    /**
     * Enables or disables event handling. This implementation
     * updates <enabled>.
     *
     * @param enabled Boolean that specifies the new enabled state.
     */ setEnabled(enabled) {
        this.enabled = enabled;
    }
    /**
     * Returns <insertBeforeSource> for non-loops and false for loops.
     *
     * @param edge <Cell> that represents the edge to be inserted.
     * @param source <Cell> that represents the source terminal.
     * @param target <Cell> that represents the target terminal.
     * @param evt Mousedown event of the connect gesture.
     * @param dropTarget <Cell> that represents the cell under the mouse when it was
     * released.
     */ isInsertBefore(edge, source, target, evt, dropTarget) {
        return this.insertBeforeSource && source !== target;
    }
    /**
     * Returns <createTarget>.
     *
     * @param evt Current active native pointer event.
     */ isCreateTarget(evt) {
        return this.createTarget;
    }
    /**
     * Sets <createTarget>.
     */ setCreateTarget(value) {
        this.createTarget = value;
    }
    /**
     * Creates the preview shape for new connections.
     */ createShape() {
        // Creates the edge preview
        const shape = this.livePreview && this.edgeState ? this.graph.cellRenderer.createShape(this.edgeState) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$PolylineShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]([], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["INVALID_COLOR"]);
        if (shape && shape.node) {
            shape.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG;
            shape.scale = this.graph.view.scale;
            shape.pointerEvents = false;
            shape.isDashed = true;
            shape.init(this.graph.getView().getOverlayPane());
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].redirectMouseEvents(shape.node, this.graph, null);
        }
        return shape;
    }
    /**
     * Returns true if the given cell is connectable. This is a hook to
     * disable floating connections. This implementation returns true.
     */ isConnectableCell(cell) {
        return true;
    }
    /**
     * Creates and returns the {@link CellMarker} used in {@link arker}.
     */ createMarker() {
        return new ConnectionHandlerCellMarker(this.graph, this);
    }
    /**
     * Starts a new connection for the given state and coordinates.
     */ start(state, x, y, edgeState) {
        this.previous = state;
        this.first = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](x, y);
        this.edgeState = edgeState ?? this.createEdgeState();
        // Marks the source state
        this.marker.currentColor = this.marker.validColor;
        this.marker.markedState = state;
        this.marker.mark();
        this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].START, {
            state: this.previous
        }));
    }
    /**
     * Returns true if the source terminal has been clicked and a new
     * connection is currently being previewed.
     */ isConnecting() {
        return !!this.first && !!this.shape;
    }
    /**
     * Returns {@link Graph#isValidSource} for the given source terminal.
     *
     * @param cell <Cell> that represents the source terminal.
     * @param me {@link MouseEvent} that is associated with this call.
     */ isValidSource(cell, me) {
        return this.graph.isValidSource(cell);
    }
    /**
     * Returns true. The call to {@link Graph#isValidTarget} is implicit by calling
     * {@link Graph#getEdgeValidationError} in <validateConnection>. This is an
     * additional hook for disabling certain targets in this specific handler.
     *
     * @param cell <Cell> that represents the target terminal.
     */ isValidTarget(cell) {
        return true;
    }
    /**
     * Returns the error message or an empty string if the connection for the
     * given source target pair is not valid. Otherwise it returns null. This
     * implementation uses {@link Graph#getEdgeValidationError}.
     *
     * @param source <Cell> that represents the source terminal.
     * @param target <Cell> that represents the target terminal.
     */ validateConnection(source, target) {
        if (!this.isValidTarget(target)) {
            return '';
        }
        return this.graph.getEdgeValidationError(null, source, target);
    }
    /**
     * Hook to return the {@link Image} used for the connection icon of the given
     * {@link CellState}. This implementation returns {@link connectImage}.
     *
     * @param state {@link CellState} whose connect image should be returned.
     */ getConnectImage(state) {
        return this.connectImage;
    }
    /**
     * Returns true if the state has a HTML label in the graph's container, otherwise
     * it returns {@link oveIconFront}.
     *
     * @param state <CellState> whose connect icons should be returned.
     */ isMoveIconToFrontForState(state) {
        if (state.text && state.text.node.parentNode === this.graph.container) {
            return true;
        }
        return this.moveIconFront;
    }
    /**
     * Creates the array {@link ImageShape}s that represent the connect icons for
     * the given {@link CellState}.
     *
     * @param state {@link CellState} whose connect icons should be returned.
     */ createIcons(state) {
        const image = this.getConnectImage(state);
        if (image) {
            this.iconState = state;
            const icons = [];
            // Cannot use HTML for the connect icons because the icon receives all
            // mouse move events in IE, must use VML and SVG instead even if the
            // connect-icon appears behind the selection border and the selection
            // border consumes the events before the icon gets a chance
            const bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](0, 0, image.width, image.height);
            const icon = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](bounds, image.src, undefined, undefined, 0);
            icon.preserveImageAspect = false;
            if (this.isMoveIconToFrontForState(state)) {
                icon.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].STRICTHTML;
                icon.init(this.graph.container);
            } else {
                icon.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG;
                icon.init(this.graph.getView().getOverlayPane());
                // Move the icon back in the overlay pane
                if (this.moveIconBack && icon.node.parentNode && icon.node.previousSibling) {
                    icon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);
                }
            }
            icon.node.style.cursor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CURSOR"].CONNECT;
            // Events transparency
            const getState = ()=>{
                return this.currentState ?? state;
            };
            // Updates the local icon before firing the mouse down event.
            const mouseDown = (evt)=>{
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isConsumed"])(evt)) {
                    this.icon = icon;
                    this.graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](evt, getState()));
                }
            };
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].redirectMouseEvents(icon.node, this.graph, getState, mouseDown);
            icons.push(icon);
            this.redrawIcons(icons, this.iconState);
            return icons;
        }
        return [];
    }
    /**
     * Redraws the given array of {@link ImageShapes}.
     *
     * @param icons Array of {@link ImageShapes} to be redrawn.
     */ redrawIcons(icons, state) {
        if (icons[0] && icons[0].bounds) {
            const pos = this.getIconPosition(icons[0], state);
            icons[0].bounds.x = pos.x;
            icons[0].bounds.y = pos.y;
            icons[0].redraw();
        }
    }
    // TODO: Document me! ===========================================================================================================
    getIconPosition(icon, state) {
        const { scale } = this.graph.getView();
        let cx = state.getCenterX();
        let cy = state.getCenterY();
        if (this.graph.isSwimlane(state.cell)) {
            const size = this.graph.getStartSize(state.cell);
            cx = size.width !== 0 ? state.x + size.width * scale / 2 : cx;
            cy = size.height !== 0 ? state.y + size.height * scale / 2 : cy;
            const alpha = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(state.style.rotation ?? 0);
            if (alpha !== 0) {
                const cos = Math.cos(alpha);
                const sin = Math.sin(alpha);
                const ct = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](state.getCenterX(), state.getCenterY());
                const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](cx, cy), cos, sin, ct);
                cx = pt.x;
                cy = pt.y;
            }
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](cx - icon.bounds.width / 2, cy - icon.bounds.height / 2);
    }
    /**
     * Destroys the connect icons and resets the respective state.
     */ destroyIcons() {
        for(let i = 0; i < this.icons.length; i += 1){
            this.icons[i].destroy();
        }
        this.icons = [];
        this.icon = null;
        this.selectedIcon = null;
        this.iconState = null;
    }
    /**
     * Returns true if the given mouse down event should start this handler. The
     * This implementation returns true if the event does not force marquee
     * selection, and the currentConstraint and currentFocus of the
     * <constraintHandler> are not null, or <previous> and <error> are not null and
     * <icons> is null or <icons> and <icon> are not null.
     */ isStartEvent(me) {
        return this.constraintHandler.currentFocus !== null && this.constraintHandler.currentConstraint !== null || this.previous !== null && this.error === null && (this.icons.length === 0 || this.icon !== null);
    }
    /**
     * Handles the event by initiating a new connection.
     */ mouseDown(sender, me) {
        this.mouseDownCounter += 1;
        if (this.isEnabled() && this.graph.isEnabled() && !me.isConsumed() && !this.isConnecting() && this.isStartEvent(me)) {
            if (this.constraintHandler.currentConstraint && this.constraintHandler.currentFocus && this.constraintHandler.currentPoint) {
                this.sourceConstraint = this.constraintHandler.currentConstraint;
                this.previous = this.constraintHandler.currentFocus;
                this.first = this.constraintHandler.currentPoint.clone();
            } else {
                // Stores the location of the initial mousedown
                this.first = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](me.getGraphX(), me.getGraphY());
            }
            this.edgeState = this.createEdgeState(me);
            this.mouseDownCounter = 1;
            if (this.waypointsEnabled && !this.shape) {
                this.waypoints = [];
                this.shape = this.createShape();
                if (this.edgeState) {
                    this.shape.apply(this.edgeState);
                }
            }
            // Stores the starting point in the geometry of the preview
            if (!this.previous && this.edgeState && this.edgeState.cell.geometry) {
                const pt = this.graph.getPointForEvent(me.getEvent());
                this.edgeState.cell.geometry.setTerminalPoint(pt, true);
            }
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].START, {
                state: this.previous
            }));
            me.consume();
        }
        this.selectedIcon = this.icon;
        this.icon = null;
    }
    /**
     * Returns true if a tap on the given source state should immediately start
     * connecting. This implementation returns true if the state is not movable
     * in the graph.
     */ isImmediateConnectSource(state) {
        return !this.graph.isCellMovable(state.cell);
    }
    /**
     * Hook to return an <CellState> which may be used during the preview.
     * This implementation returns null.
     *
     * Use the following code to create a preview for an existing edge style:
     *
     * ```javascript
     * graph.getPlugin('ConnectionHandler').createEdgeState(me)
     * {
     *   var edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=elbowEdgeStyle');
     *
     *   return new CellState(this.graph.view, edge, this.graph.getCellStyle(edge));
     * };
     * ```
     */ createEdgeState(me) {
        return null;
    }
    /**
     * Returns true if <outlineConnect> is true and the source of the event is the outline shape
     * or shift is pressed.
     */ isOutlineConnectEvent(me) {
        if (!this.currentPoint) return false;
        const offset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOffset"])(this.graph.container);
        const evt = me.getEvent();
        const clientX = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientX"])(evt);
        const clientY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientY"])(evt);
        const doc = document.documentElement;
        const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
        const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
        const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;
        const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;
        return this.outlineConnect && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isShiftDown"])(me.getEvent()) && (me.isSource(this.marker.highlight.shape) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAltDown"])(me.getEvent()) && me.getState() != null || this.marker.highlight.isHighlightAt(clientX, clientY) || (gridX !== clientX || gridY !== clientY) && me.getState() == null && this.marker.highlight.isHighlightAt(gridX, gridY));
    }
    /**
     * Updates the current state for a given mouse move event by using
     * the {@link arker}.
     */ updateCurrentState(me, point) {
        this.constraintHandler.update(me, !this.first, false, !this.first || me.isSource(this.marker.highlight.shape) ? null : point);
        if (this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null) {
            // Handles special case where grid is large and connection point is at actual point in which
            // case the outline is not followed as long as we're < gridSize / 2 away from that point
            if (this.marker.highlight && this.marker.highlight.state && this.marker.highlight.state.cell === this.constraintHandler.currentFocus.cell && this.marker.highlight.shape) {
                // Direct repaint needed if cell already highlighted
                if (this.marker.highlight.shape.stroke !== 'transparent') {
                    this.marker.highlight.shape.stroke = 'transparent';
                    this.marker.highlight.repaint();
                }
            } else {
                this.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');
            }
            // Updates validation state
            if (this.previous) {
                this.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell);
                if (!this.error) {
                    this.currentState = this.constraintHandler.currentFocus;
                }
                if (this.error || this.currentState && !this.isCellEnabled(this.currentState.cell)) {
                    this.constraintHandler.reset();
                }
            }
        } else {
            if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {
                this.marker.reset();
                this.currentState = null;
            } else {
                this.marker.process(me);
                this.currentState = this.marker.getValidState();
            }
            if (this.currentState != null && !this.isCellEnabled(this.currentState.cell)) {
                this.constraintHandler.reset();
                this.marker.reset();
                this.currentState = null;
            }
            const outline = this.isOutlineConnectEvent(me);
            if (this.currentState != null && outline) {
                // Handles special case where mouse is on outline away from actual end point
                // in which case the grid is ignored and mouse point is used instead
                if (me.isSource(this.marker.highlight.shape)) {
                    point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](me.getGraphX(), me.getGraphY());
                }
                const constraint = this.graph.getOutlineConstraint(point, this.currentState, me);
                this.constraintHandler.setFocus(me, this.currentState, false);
                this.constraintHandler.currentConstraint = constraint;
                this.constraintHandler.currentPoint = point;
            }
            if (this.outlineConnect) {
                if (this.marker.highlight != null && this.marker.highlight.shape != null) {
                    const s = this.graph.view.scale;
                    if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
                        this.marker.highlight.shape.stroke = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OUTLINE_HIGHLIGHT_COLOR"];
                        this.marker.highlight.shape.strokeWidth = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OUTLINE_HIGHLIGHT_STROKEWIDTH"] / s / s;
                        this.marker.highlight.repaint();
                    } else if (this.marker.hasValidState()) {
                        const cell = me.getCell();
                        // Handles special case where actual end point of edge and current mouse point
                        // are not equal (due to grid snapping) and there is no hit on shape or highlight
                        // but ignores cases where parent is used for non-connectable child cells
                        if (cell && cell.isConnectable() && this.marker.getValidState() !== me.getState()) {
                            this.marker.highlight.shape.stroke = 'transparent';
                            this.currentState = null;
                        } else {
                            this.marker.highlight.shape.stroke = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_VALID_COLOR"];
                        }
                        this.marker.highlight.shape.strokeWidth = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HIGHLIGHT_STROKEWIDTH"] / s / s;
                        this.marker.highlight.repaint();
                    }
                }
            }
        }
    }
    /**
     * Returns true if the given cell does not allow new connections to be created.
     */ isCellEnabled(cell) {
        return true;
    }
    /**
     * Converts the given point from screen coordinates to model coordinates.
     */ convertWaypoint(point) {
        const scale = this.graph.getView().getScale();
        const tr = this.graph.getView().getTranslate();
        point.x = point.x / scale - tr.x;
        point.y = point.y / scale - tr.y;
    }
    /**
     * Called to snap the given point to the current preview. This snaps to the
     * first point of the preview if alt is not pressed.
     */ snapToPreview(me, point) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAltDown"])(me.getEvent()) && this.previous) {
            const tol = this.graph.getGridSize() * this.graph.view.scale / 2;
            const tmp = this.sourceConstraint && this.first ? this.first : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.previous.getCenterX(), this.previous.getCenterY());
            if (Math.abs(tmp.x - me.getGraphX()) < tol) {
                point.x = tmp.x;
            }
            if (Math.abs(tmp.y - me.getGraphY()) < tol) {
                point.y = tmp.y;
            }
        }
    }
    /**
     * Handles the event by updating the preview edge or by highlighting
     * a possible source or target terminal.
     */ mouseMove(sender, me) {
        if (!me.isConsumed() && (this.ignoreMouseDown || this.first || !this.graph.isMouseDown)) {
            // Handles special case when handler is disabled during highlight
            if (!this.isEnabled() && this.currentState) {
                this.destroyIcons();
                this.currentState = null;
            }
            const view = this.graph.getView();
            const { scale } = view;
            const tr = view.translate;
            let point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](me.getGraphX(), me.getGraphY());
            this.error = null;
            if (this.graph.isGridEnabledEvent(me.getEvent())) {
                point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]((this.graph.snap(point.x / scale - tr.x) + tr.x) * scale, (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale);
            }
            this.snapToPreview(me, point);
            this.currentPoint = point;
            if ((this.first || this.isEnabled() && this.graph.isEnabled()) && (this.shape || !this.first || Math.abs(me.getGraphX() - this.first.x) > this.graph.getEventTolerance() || Math.abs(me.getGraphY() - this.first.y) > this.graph.getEventTolerance())) {
                this.updateCurrentState(me, point);
            }
            if (this.first) {
                let constraint = null;
                let current = point;
                // Uses the current point from the constraint handler if available
                if (this.constraintHandler.currentConstraint && this.constraintHandler.currentFocus && this.constraintHandler.currentPoint) {
                    constraint = this.constraintHandler.currentConstraint;
                    current = this.constraintHandler.currentPoint.clone();
                } else if (this.previous && !this.graph.isIgnoreTerminalEvent(me.getEvent()) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isShiftDown"])(me.getEvent())) {
                    if (Math.abs(this.previous.getCenterX() - point.x) < Math.abs(this.previous.getCenterY() - point.y)) {
                        point.x = this.previous.getCenterX();
                    } else {
                        point.y = this.previous.getCenterY();
                    }
                }
                let pt2 = this.first;
                // Moves the connect icon with the mouse
                if (this.selectedIcon && this.selectedIcon.bounds) {
                    const w = this.selectedIcon.bounds.width;
                    const h = this.selectedIcon.bounds.height;
                    if (this.currentState && this.targetConnectImage) {
                        const pos = this.getIconPosition(this.selectedIcon, this.currentState);
                        this.selectedIcon.bounds.x = pos.x;
                        this.selectedIcon.bounds.y = pos.y;
                    } else {
                        const bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](me.getGraphX() + this.connectIconOffset.x, me.getGraphY() + this.connectIconOffset.y, w, h);
                        this.selectedIcon.bounds = bounds;
                    }
                    this.selectedIcon.redraw();
                }
                // Uses edge state to compute the terminal points
                if (this.edgeState) {
                    this.updateEdgeState(current, constraint);
                    current = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1];
                    pt2 = this.edgeState.absolutePoints[0];
                } else {
                    if (this.currentState) {
                        if (!this.constraintHandler.currentConstraint) {
                            const tmp = this.getTargetPerimeterPoint(this.currentState, me);
                            if (tmp != null) {
                                current = tmp;
                            }
                        }
                    }
                    // Computes the source perimeter point
                    if (!this.sourceConstraint && this.previous) {
                        const next = this.waypoints.length > 0 ? this.waypoints[0] : current;
                        const tmp = this.getSourcePerimeterPoint(this.previous, next, me);
                        if (tmp) {
                            pt2 = tmp;
                        }
                    }
                }
                // Makes sure the cell under the mousepointer can be detected
                // by moving the preview shape away from the mouse. This
                // makes sure the preview shape does not prevent the detection
                // of the cell under the mousepointer even for slow gestures.
                if (!this.currentState && this.movePreviewAway && current) {
                    let tmp = pt2;
                    if (this.edgeState && this.edgeState.absolutePoints.length >= 2) {
                        const tmp2 = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2];
                        if (tmp2) {
                            tmp = tmp2;
                        }
                    }
                    if (tmp) {
                        const dx = current.x - tmp.x;
                        const dy = current.y - tmp.y;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        if (len === 0) {
                            return;
                        }
                        // Stores old point to reuse when creating edge
                        this.originalPoint = current.clone();
                        current.x -= dx * 4 / len;
                        current.y -= dy * 4 / len;
                    }
                } else {
                    this.originalPoint = null;
                }
                // Creates the preview shape (lazy)
                if (!this.shape) {
                    const dx = Math.abs(me.getGraphX() - this.first.x);
                    const dy = Math.abs(me.getGraphY() - this.first.y);
                    if (dx > this.graph.getEventTolerance() || dy > this.graph.getEventTolerance()) {
                        this.shape = this.createShape();
                        if (this.edgeState) {
                            this.shape.apply(this.edgeState);
                        }
                        // Revalidates current connection
                        this.updateCurrentState(me, point);
                    }
                }
                // Updates the points in the preview edge
                if (this.shape) {
                    if (this.edgeState) {
                        this.shape.points = this.edgeState.absolutePoints;
                    } else {
                        let pts = [
                            pt2
                        ];
                        if (this.waypoints.length > 0) {
                            pts = pts.concat(this.waypoints);
                        }
                        pts.push(current);
                        this.shape.points = pts;
                    }
                    this.drawPreview();
                }
                // Makes sure endpoint of edge is visible during connect
                if (this.cursor) {
                    this.graph.container.style.cursor = this.cursor;
                }
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(me.getEvent());
                me.consume();
            } else if (!this.isEnabled() || !this.graph.isEnabled()) {
                this.constraintHandler.reset();
            } else if (this.previous !== this.currentState && !this.edgeState) {
                this.destroyIcons();
                // Sets the cursor on the current shape
                if (this.currentState && !this.error && !this.constraintHandler.currentConstraint) {
                    this.icons = this.createIcons(this.currentState);
                    if (this.icons.length === 0) {
                        this.currentState.setCursor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CURSOR"].CONNECT);
                        me.consume();
                    }
                }
                this.previous = this.currentState;
            } else if (this.previous === this.currentState && this.currentState != null && this.icons.length === 0 && !this.graph.isMouseDown) {
                // Makes sure that no cursors are changed
                me.consume();
            }
            if (!this.graph.isMouseDown && this.currentState != null && this.icons != null) {
                let hitsIcon = false;
                const target = me.getSource();
                for(let i = 0; i < this.icons.length && !hitsIcon; i += 1){
                    hitsIcon = target === this.icons[i].node || !!target && target.parentNode === this.icons[i].node;
                }
                if (!hitsIcon) {
                    this.updateIcons(this.currentState, this.icons, me);
                }
            }
        } else {
            this.constraintHandler.reset();
        }
    }
    /**
     * Updates <edgeState>.
     */ updateEdgeState(current, constraint) {
        if (!this.edgeState) return;
        // TODO: Use generic method for writing constraint to style
        if (this.sourceConstraint && this.sourceConstraint.point) {
            this.edgeState.style.exitX = this.sourceConstraint.point.x;
            this.edgeState.style.exitY = this.sourceConstraint.point.y;
        }
        if (constraint && constraint.point) {
            this.edgeState.style.entryX = constraint.point.x;
            this.edgeState.style.entryY = constraint.point.y;
        } else {
            this.edgeState.style.entryX = 0;
            this.edgeState.style.entryY = 0;
        }
        this.edgeState.absolutePoints = [
            null,
            this.currentState != null ? null : current
        ];
        if (this.sourceConstraint) {
            this.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, true, this.sourceConstraint);
        }
        if (this.currentState != null) {
            if (constraint == null) {
                constraint = this.graph.getConnectionConstraint(this.edgeState, this.previous, false);
            }
            this.edgeState.setAbsoluteTerminalPoint(null, false);
            this.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, false, constraint);
        }
        // Scales and translates the waypoints to the model
        const realPoints = [];
        for(let i = 0; i < this.waypoints.length; i += 1){
            const pt = this.waypoints[i].clone();
            this.convertWaypoint(pt);
            realPoints[i] = pt;
        }
        this.graph.view.updatePoints(this.edgeState, realPoints, this.previous, this.currentState);
        this.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);
    }
    /**
     * Returns the perimeter point for the given target state.
     *
     * @param state <CellState> that represents the target cell state.
     * @param _me {@link MouseEvent} that represents the mouse move.
     */ getTargetPerimeterPoint(state, _me) {
        let result = null;
        const { view } = state;
        const targetPerimeter = view.getPerimeterFunction(state);
        if (targetPerimeter && this.previous && this.edgeState) {
            const next = this.waypoints.length > 0 ? this.waypoints[this.waypoints.length - 1] : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.previous.getCenterX(), this.previous.getCenterY());
            const tmp = targetPerimeter(view.getPerimeterBounds(state), this.edgeState, next, false);
            if (tmp) {
                result = tmp;
            }
        } else {
            result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](state.getCenterX(), state.getCenterY());
        }
        return result;
    }
    /**
     * Hook to update the icon position(s) based on a mouseOver event. This is
     * an empty implementation.
     *
     * @param state <CellState> that represents the target cell state.
     * @param next {@link Point} that represents the next point along the previewed edge.
     * @param me {@link MouseEvent} that represents the mouse move.
     */ getSourcePerimeterPoint(state, next, me) {
        let result = null;
        const { view } = state;
        const sourcePerimeter = view.getPerimeterFunction(state);
        const c = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](state.getCenterX(), state.getCenterY());
        if (sourcePerimeter) {
            const theta = state.style.rotation ?? 0;
            const rad = -theta * (Math.PI / 180);
            if (theta !== 0) {
                next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](next.x, next.y), Math.cos(rad), Math.sin(rad), c);
            }
            let tmp = sourcePerimeter(view.getPerimeterBounds(state), state, next, false);
            if (tmp) {
                if (theta !== 0) {
                    tmp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](tmp.x, tmp.y), Math.cos(-rad), Math.sin(-rad), c);
                }
                result = tmp;
            }
        } else {
            result = c;
        }
        return result;
    }
    /**
     * Hook to update the icon position(s) based on a mouseOver event. This is
     * an empty implementation.
     *
     * @param state <CellState> under the mouse.
     * @param icons Array of currently displayed icons.
     * @param me {@link MouseEvent} that contains the mouse event.
     */ updateIcons(state, icons, me) {
    // empty
    }
    /**
     * Returns true if the given mouse up event should stop this handler. The
     * connection will be created if <error> is null. Note that this is only
     * called if <waypointsEnabled> is true. This implemtation returns true
     * if there is a cell state in the given event.
     */ isStopEvent(me) {
        return !!me.getState();
    }
    /**
     * Adds the waypoint for the given event to <waypoints>.
     */ addWaypointForEvent(me) {
        if (!this.first) return;
        let point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertPoint"])(this.graph.container, me.getX(), me.getY());
        const dx = Math.abs(point.x - this.first.x);
        const dy = Math.abs(point.y - this.first.y);
        const addPoint = this.waypoints.length > 0 || this.mouseDownCounter > 1 && (dx > this.graph.getEventTolerance() || dy > this.graph.getEventTolerance());
        if (addPoint) {
            const { scale } = this.graph.view;
            point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.graph.snap(me.getGraphX() / scale) * scale, this.graph.snap(me.getGraphY() / scale) * scale);
            this.waypoints.push(point);
        }
    }
    /**
     * Returns true if the connection for the given constraints is valid. This
     * implementation returns true if the constraints are not pointing to the
     * same fixed connection point.
     */ checkConstraints(c1, c2) {
        return !c1 || !c2 || !c1.point || !c2.point || !c1.point.equals(c2.point) || c1.dx !== c2.dx || c1.dy !== c2.dy || c1.perimeter !== c2.perimeter;
    }
    /**
     * Handles the event by inserting the new connection.
     */ mouseUp(sender, me) {
        if (!me.isConsumed() && this.isConnecting()) {
            if (this.waypointsEnabled && !this.isStopEvent(me)) {
                this.addWaypointForEvent(me);
                me.consume();
                return;
            }
            const c1 = this.sourceConstraint;
            const c2 = this.constraintHandler.currentConstraint;
            const source = this.previous ? this.previous.cell : null;
            let target = null;
            if (this.constraintHandler.currentConstraint && this.constraintHandler.currentFocus) {
                target = this.constraintHandler.currentFocus.cell;
            }
            if (!target && this.currentState) {
                target = this.currentState.cell;
            }
            // Inserts the edge if no validation error exists and if constraints differ
            if (!this.error && (!source || !target || source !== target || this.checkConstraints(c1, c2))) {
                this.connect(source, target, me.getEvent(), me.getCell());
            } else {
                // Selects the source terminal for self-references
                if (this.previous != null && this.marker.validState != null && this.previous.cell === this.marker.validState.cell) {
                    this.graph.selectCellForEvent(this.marker.validState.cell, me.getEvent());
                }
                // Displays the error message if it is not an empty string,
                // for empty error messages, the event is silently dropped
                if (this.error != null && this.error.length > 0) {
                    this.graph.validationAlert(this.error);
                }
            }
            // Redraws the connect icons and resets the handler state
            this.destroyIcons();
            me.consume();
        }
        if (this.first != null) {
            this.reset();
        }
    }
    /**
     * Resets the state of this handler.
     */ reset() {
        if (this.shape != null) {
            this.shape.destroy();
            this.shape = null;
        }
        // Resets the cursor on the container
        if (this.cursor != null && this.graph.container != null) {
            this.graph.container.style.cursor = '';
        }
        this.destroyIcons();
        this.marker.reset();
        this.constraintHandler.reset();
        this.originalPoint = null;
        this.currentPoint = null;
        this.edgeState = null;
        this.previous = null;
        this.error = null;
        this.sourceConstraint = null;
        this.mouseDownCounter = 0;
        this.first = null;
        this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].RESET));
    }
    /**
     * Redraws the preview edge using the color and width returned by
     * <getEdgeColor> and <getEdgeWidth>.
     */ drawPreview() {
        this.updatePreview(this.error === null);
        if (this.shape) this.shape.redraw();
    }
    /**
     * Returns the color used to draw the preview edge. This returns green if
     * there is no edge validation error and red otherwise.
     *
     * @param valid Boolean indicating if the color for a valid edge should be
     * returned.
     */ updatePreview(valid) {
        if (this.shape) {
            this.shape.strokeWidth = this.getEdgeWidth(valid);
            this.shape.stroke = this.getEdgeColor(valid);
        }
    }
    /**
     * Returns the color used to draw the preview edge. This returns green if
     * there is no edge validation error and red otherwise.
     *
     * @param valid Boolean indicating if the color for a valid edge should be
     * returned.
     */ getEdgeColor(valid) {
        return valid ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VALID_COLOR"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["INVALID_COLOR"];
    }
    /**
     * Returns the width used to draw the preview edge. This returns 3 if
     * there is no edge validation error and 1 otherwise.
     *
     * @param valid Boolean indicating if the width for a valid edge should be
     * returned.
     */ getEdgeWidth(valid) {
        return valid ? 3 : 1;
    }
    /**
     * Connects the given source and target using a new edge. This
     * implementation uses <createEdge> to create the edge.
     *
     * @param source <Cell> that represents the source terminal.
     * @param target <Cell> that represents the target terminal.
     * @param evt Mousedown event of the connect gesture.
     * @param dropTarget <Cell> that represents the cell under the mouse when it was
     * released.
     */ connect(source, target, evt, dropTarget = null) {
        if (target || this.isCreateTarget(evt) || this.graph.isAllowDanglingEdges()) {
            // Uses the common parent of source and target or
            // the default parent to insert the edge
            const model = this.graph.getDataModel();
            let terminalInserted = false;
            let edge = null;
            model.beginUpdate();
            try {
                if (source && !target && !this.graph.isIgnoreTerminalEvent(evt) && this.isCreateTarget(evt)) {
                    target = this.createTargetVertex(evt, source);
                    if (target) {
                        dropTarget = this.graph.getDropTarget([
                            target
                        ], evt, dropTarget);
                        terminalInserted = true;
                        // Disables edges as drop targets if the target cell was created
                        // FIXME: Should not shift if vertex was aligned (same in Java)
                        if (dropTarget == null || !dropTarget.isEdge()) {
                            const pstate = dropTarget ? this.graph.getView().getState(dropTarget) : null;
                            if (pstate) {
                                const tmp = target.getGeometry();
                                if (tmp) {
                                    tmp.x -= pstate.origin.x;
                                    tmp.y -= pstate.origin.y;
                                }
                            }
                        } else {
                            dropTarget = this.graph.getDefaultParent();
                        }
                        this.graph.addCell(target, dropTarget);
                    }
                }
                let parent = this.graph.getDefaultParent();
                if (source && target && source.getParent() === target.getParent() && source.getParent()?.getParent() !== model.getRoot()) {
                    parent = source.getParent();
                    if (source.geometry && source.geometry.relative && target.geometry && target.geometry.relative) {
                        parent = parent.getParent();
                    }
                }
                // Uses the value of the preview edge state for inserting
                // the new edge into the graph
                let value = null;
                let style = {};
                if (this.edgeState?.cell) {
                    value = this.edgeState.cell.value;
                    style = this.edgeState.cell.style ?? {};
                }
                edge = this.insertEdge(parent, '', value, source, target, style);
                if (edge && source) {
                    // Updates the connection constraints
                    this.graph.setConnectionConstraint(edge, source, true, this.sourceConstraint);
                    this.graph.setConnectionConstraint(edge, target, false, this.constraintHandler.currentConstraint);
                    // Uses geometry of the preview edge state
                    if (this.edgeState?.cell?.geometry) {
                        model.setGeometry(edge, this.edgeState.cell.geometry);
                    }
                    parent = source.getParent();
                    // Inserts edge before source
                    if (this.isInsertBefore(edge, source, target, evt, dropTarget)) {
                        const index = null;
                        let tmp = source;
                        while(tmp && tmp.parent != null && tmp.geometry != null && tmp.geometry.relative && tmp.parent !== edge.parent){
                            tmp = tmp.getParent();
                        }
                        if (tmp != null && tmp.parent != null && tmp.parent === edge.parent) {
                            model.add(parent, edge, tmp.parent.getIndex(tmp));
                        }
                    }
                    // Makes sure the edge has a non-null, relative geometry
                    let geo = edge.getGeometry();
                    if (geo == null) {
                        geo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
                        geo.relative = true;
                        model.setGeometry(edge, geo);
                    }
                    // Uses scaled waypoints in geometry
                    if (this.waypoints.length > 0) {
                        const s = this.graph.view.scale;
                        const tr = this.graph.view.translate;
                        geo.points = [];
                        for(let i = 0; i < this.waypoints.length; i += 1){
                            const pt = this.waypoints[i];
                            geo.points.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](pt.x / s - tr.x, pt.y / s - tr.y));
                        }
                    }
                    if (!target && this.currentPoint) {
                        const t = this.graph.view.translate;
                        const s = this.graph.view.scale;
                        const pt = this.originalPoint != null ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.originalPoint.x / s - t.x, this.originalPoint.y / s - t.y) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);
                        pt.x -= this.graph.getPanDx() / this.graph.view.scale;
                        pt.y -= this.graph.getPanDy() / this.graph.view.scale;
                        geo.setTerminalPoint(pt, false);
                    }
                    this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CONNECT, 'cell', edge, 'terminal', target, 'event', evt, 'target', dropTarget, 'terminalInserted', terminalInserted));
                }
            } catch (e) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GlobalConfig"].logger.show();
                const errorMessage = `Error in ConnectionHandler: ${e instanceof Error ? e.message + '\n' + e.stack : 'unknown cause'}`;
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GlobalConfig"].logger.debug(errorMessage);
            } finally{
                model.endUpdate();
            }
            if (this.select) {
                this.selectCells(edge, terminalInserted ? target : null);
            }
        }
    }
    /**
     * Selects the given edge after adding a new connection. The target argument
     * contains the target vertex if one has been inserted.
     */ selectCells(edge, target) {
        this.graph.setSelectionCell(edge);
    }
    /**
     * Creates, inserts and returns the new edge for the given parameters. This
     * implementation does only use <createEdge> if <factoryMethod> is defined,
     * otherwise {@link Graph#insertEdge} will be used.
     */ insertEdge(parent, id, value, source, target, style) {
        if (!this.factoryMethod) {
            return this.graph.insertEdge(parent, id, value, source, target, style);
        }
        let edge = this.createEdge(value, source, target, style);
        edge = this.graph.addEdge(edge, parent, source, target);
        return edge;
    }
    /**
     * Hook method for creating new vertices on the fly if no target was
     * under the mouse. This is only called if <createTarget> is true and
     * returns null.
     *
     * @param evt Mousedown event of the connect gesture.
     * @param source <Cell> that represents the source terminal.
     */ createTargetVertex(evt, source) {
        // Uses the first non-relative source
        let geo = source.getGeometry();
        while(geo && geo.relative){
            source = source.getParent();
            geo = source.getGeometry();
        }
        const clone = this.graph.cloneCell(source);
        geo = clone.getGeometry();
        if (geo && this.currentPoint) {
            const t = this.graph.view.translate;
            const s = this.graph.view.scale;
            const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);
            geo.x = Math.round(point.x - geo.width / 2 - this.graph.getPanDx() / s);
            geo.y = Math.round(point.y - geo.height / 2 - this.graph.getPanDy() / s);
            // Aligns with source if within certain tolerance
            const tol = this.getAlignmentTolerance();
            if (tol > 0) {
                const sourceState = this.graph.view.getState(source);
                if (sourceState != null) {
                    const x = sourceState.x / s - t.x;
                    const y = sourceState.y / s - t.y;
                    if (Math.abs(x - geo.x) <= tol) {
                        geo.x = Math.round(x);
                    }
                    if (Math.abs(y - geo.y) <= tol) {
                        geo.y = Math.round(y);
                    }
                }
            }
        }
        return clone;
    }
    /**
     * Returns the tolerance for aligning new targets to sources. This returns the grid size / 2.
     */ getAlignmentTolerance(evt) {
        return this.graph.isGridEnabled() ? this.graph.getGridSize() / 2 : this.graph.getSnapTolerance();
    }
    /**
     * Creates and returns a new edge using <factoryMethod> if one exists. If
     * no factory method is defined, then a new default edge is returned. The
     * source and target arguments are informal, the actual connection is
     * setup later by the caller of this function.
     *
     * @param value Value to be used for creating the edge.
     * @param source <Cell> that represents the source terminal.
     * @param target <Cell> that represents the target terminal.
     * @param style Optional style from the preview edge.
     */ createEdge(value, source, target, style = {}) {
        let edge = null;
        // Creates a new edge using the factoryMethod
        if (this.factoryMethod != null) {
            edge = this.factoryMethod(source, target, style);
        }
        if (edge == null) {
            edge = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](value || '');
            edge.setEdge(true);
            edge.setStyle(style);
            const geo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
            geo.relative = true;
            edge.setGeometry(geo);
        }
        return edge;
    }
    /**
     * Destroys the handler and all its resources and DOM nodes. This should be
     * called on all instances. It is called automatically for the built-in
     * instance created for each {@link Graph}.
     */ onDestroy() {
        this.graph.removeMouseListener(this);
        if (this.shape) {
            this.shape.destroy();
            this.shape = null;
        }
        if (this.marker) {
            this.marker.destroy();
            // @ts-expect-error this.marker is null when it is destroyed.
            this.marker = null;
        }
        if (this.constraintHandler) {
            this.constraintHandler.onDestroy();
        }
        if (this.changeHandler) {
            this.graph.getDataModel().removeListener(this.changeHandler);
            this.graph.getView().removeListener(this.changeHandler);
        }
        if (this.drillHandler) {
            this.graph.removeListener(this.drillHandler);
            this.graph.getView().removeListener(this.drillHandler);
        }
        if (this.escapeHandler) {
            this.graph.removeListener(this.escapeHandler);
        }
    }
}
ConnectionHandler.pluginId = 'ConnectionHandler';
class ConnectionHandlerCellMarker extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellMarker$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    constructor(graph, connectionHandler, validColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_VALID_COLOR"], invalidColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_INVALID_COLOR"], hotspot = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_HOTSPOT"]){
        super(graph, validColor, invalidColor, hotspot);
        this.hotspotEnabled = true;
        this.connectionHandler = connectionHandler;
    }
    // Overrides to return cell at location only if valid (so that
    // there is no highlight for invalid cells)
    getCell(me) {
        let cell = super.getCell(me);
        this.connectionHandler.error = null;
        // Checks for cell at preview point (with grid)
        if (!cell && this.connectionHandler.currentPoint) {
            cell = this.connectionHandler.graph.getCellAt(this.connectionHandler.currentPoint.x, this.connectionHandler.currentPoint.y);
        }
        // Uses connectable parent vertex if one exists
        if (cell && !cell.isConnectable() && this.connectionHandler.cell) {
            const parent = this.connectionHandler.cell.getParent();
            if (parent && parent.isVertex() && parent.isConnectable()) {
                cell = parent;
            }
        }
        if (cell) {
            if (this.connectionHandler.graph.isSwimlane(cell) && this.connectionHandler.currentPoint != null && this.connectionHandler.graph.hitsSwimlaneContent(cell, this.connectionHandler.currentPoint.x, this.connectionHandler.currentPoint.y) || !this.connectionHandler.isConnectableCell(cell)) {
                cell = null;
            }
        }
        if (cell) {
            if (this.connectionHandler.isConnecting()) {
                if (this.connectionHandler.previous) {
                    this.connectionHandler.error = this.connectionHandler.validateConnection(this.connectionHandler.previous.cell, cell);
                    if (this.connectionHandler.error !== null && this.connectionHandler.error.length === 0) {
                        cell = null;
                        // Enables create target inside groups
                        if (this.connectionHandler.isCreateTarget(me.getEvent())) {
                            this.connectionHandler.error = null;
                        }
                    }
                }
            } else if (!this.connectionHandler.isValidSource(cell, me)) {
                cell = null;
            }
        } else if (this.connectionHandler.isConnecting() && !this.connectionHandler.isCreateTarget(me.getEvent()) && !this.connectionHandler.graph.isAllowDanglingEdges()) {
            this.connectionHandler.error = '';
        }
        return cell;
    }
    // Sets the highlight color according to validateConnection
    isValidState(state) {
        if (this.connectionHandler.isConnecting()) {
            return !this.connectionHandler.error;
        }
        return super.isValidState(state);
    }
    // Overrides to use marker color only in highlight mode or for
    // target selection
    getMarkerColor(evt, state, isValid) {
        return !this.connectionHandler.connectImage || this.connectionHandler.isConnecting() ? super.getMarkerColor(evt, state, isValid) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"];
    }
    // Overrides to use hotspot only for source selection otherwise
    // intersects always returns true when over a cell
    intersects(state, evt) {
        if (this.connectionHandler.connectImage || this.connectionHandler.isConnecting()) {
            return true;
        }
        return super.intersects(state, evt);
    }
}
const __TURBOPACK__default__export__ = ConnectionHandler;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/handler/SelectionHandler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Dictionary.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/RectangleShape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$other$2f$Guide$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/other/Guide.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellHighlight$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/CellHighlight.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * Graph event handler that handles selection. Individual cells are handled
 * separately using {@link VertexHandler} or one of the edge handlers. These
 * handlers are created using {@link Graph#createHandler} in
 * {@link GraphSelectionModel#cellAdded}.
 *
 * To avoid the container to scroll a moved cell into view, set {@link scrollOnMove} to `false`.
 *
 * @category Plugin
 */ class SelectionHandler {
    /**
     * Constructs an event handler that creates handles for the selection cells.
     *
     * @param graph Reference to the enclosing {@link Graph}.
     */ constructor(graph){
        this.refreshThread = null;
        /**
         * Defines the maximum number of cells to paint subhandles
         * for. Default is 50 for Firefox and 20 for IE. Set this
         * to 0 if you want an unlimited number of handles to be
         * displayed. This is only recommended if the number of
         * cells in the graph is limited to a small number, eg.
         * 500.
         */ this.maxCells = 50;
        /**
         * Specifies if events are handled. Default is true.
         */ this.enabled = true;
        /**
         * Specifies if drop targets under the mouse should be enabled. Default is
         * true.
         */ this.highlightEnabled = true;
        /**
         * Specifies if cloning by control-drag is enabled. Default is true.
         */ this.cloneEnabled = true;
        /**
         * Specifies if moving is enabled. Default is true.
         */ this.moveEnabled = true;
        /**
         * Specifies if other cells should be used for snapping the right, center or
         * left side of the current selection. Default is false.
         */ this.guidesEnabled = false;
        /**
         * Whether the handles of the selection are currently visible.
         */ this.handlesVisible = true;
        /**
         * Holds the {@link Guide} instance that is used for alignment.
         */ this.guide = null;
        /**
         * Stores the x-coordinate of the current mouse move.
         */ this.currentDx = 0;
        /**
         * Stores the y-coordinate of the current mouse move.
         */ this.currentDy = 0;
        /**
         * Specifies if a move cursor should be shown if the mouse is over a movable
         * cell. Default is true.
         */ this.updateCursor = true;
        /**
         * Specifies if selecting is enabled. Default is true.
         */ this.selectEnabled = true;
        /**
         * Specifies if cells may be moved out of their parents. Default is true.
         */ this.removeCellsFromParent = true;
        /**
         * If empty parents should be removed from the model after all child cells
         * have been moved out. Default is true.
         */ this.removeEmptyParents = false;
        /**
         * Specifies if drop events are interpreted as new connections if no other
         * drop action is defined. Default is false.
         */ this.connectOnDrop = false;
        /**
         * Specifies if the view should be scrolled so that a moved cell is visible.
         * @default true
         */ this.scrollOnMove = true;
        /**
         * Specifies the minimum number of pixels for the width and height of a
         * selection border. Default is 6.
         */ this.minimumSize = 6;
        /**
         * Specifies the color of the preview shape. Default is black.
         */ this.previewColor = 'black';
        /**
         * Specifies if the graph container should be used for preview. If this is used
         * then drop target detection relies entirely on {@link Graph#getCellAt} because
         * the HTML preview does not "let events through". Default is false.
         */ this.htmlPreview = false;
        /**
         * Reference to the {@link Shape} that represents the preview.
         */ this.shape = null;
        /**
         * Specifies if the grid should be scaled. Default is false.
         */ this.scaleGrid = false;
        /**
         * Specifies if the bounding box should allow for rotation. Default is true.
         */ this.rotationEnabled = true;
        /**
         * Maximum number of cells for which live preview should be used.  Default is 0 which means no live preview.
         */ this.maxLivePreview = 0;
        /**
         * Variable allowLivePreview
         *
         * If live preview is allowed on this system.  Default is true for systems with SVG support.
         */ this.allowLivePreview = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IS_SVG;
        this.cell = null;
        this.delayedSelection = false;
        this.first = null;
        this.cells = null;
        this.bounds = null;
        this.pBounds = null;
        this.allCells = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
        this.cellWasClicked = false;
        this.cloning = false;
        this.cellCount = 0;
        this.target = null;
        this.suspended = false;
        this.livePreviewActive = false;
        this.livePreviewUsed = false;
        this.highlight = null;
        this.graph = graph;
        this.graph.addMouseListener(this);
        // Repaints the handler after autoscroll
        this.panHandler = ()=>{
            if (!this.suspended) {
                this.updatePreview();
                this.updateHint();
            }
        };
        this.graph.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PAN, this.panHandler);
        // Handles escape keystrokes
        this.escapeHandler = (sender, evt)=>{
            this.reset();
        };
        this.graph.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].ESCAPE, this.escapeHandler);
        // Updates the preview box for remote changes
        this.refreshHandler = (sender, evt)=>{
            // Merges multiple pending calls
            if (this.refreshThread) {
                window.clearTimeout(this.refreshThread);
            }
            // Waits for the states and handlers to be updated
            this.refreshThread = window.setTimeout(()=>{
                this.refreshThread = null;
                if (this.first && !this.suspended && this.cells) {
                    // Updates preview with no translate to compute bounding box
                    const dx = this.currentDx;
                    const dy = this.currentDy;
                    this.currentDx = 0;
                    this.currentDy = 0;
                    this.updatePreview();
                    this.bounds = this.graph.getView().getBounds(this.cells);
                    this.pBounds = this.getPreviewBounds(this.cells);
                    if (this.pBounds == null && !this.livePreviewUsed) {
                        this.reset();
                    } else {
                        // Restores translate and updates preview
                        this.currentDx = dx;
                        this.currentDy = dy;
                        this.updatePreview();
                        this.updateHint();
                        if (this.livePreviewUsed) {
                            const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');
                            // Forces update to ignore last visible state
                            this.setHandlesVisibleForCells(selectionCellsHandler?.getHandledSelectionCells() ?? [], false, true);
                            this.updatePreview();
                        }
                    }
                }
            }, 0);
        };
        this.graph.getDataModel().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].CHANGE, this.refreshHandler);
        this.graph.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].REFRESH, this.refreshHandler);
        this.keyHandler = (e)=>{
            if (this.graph.container != null && this.graph.container.style.visibility !== 'hidden' && this.first != null && !this.suspended) {
                const clone = this.graph.isCloneEvent(e) && this.graph.isCellsCloneable() && this.isCloneEnabled();
                if (clone !== this.cloning) {
                    this.cloning = clone;
                    this.checkPreview();
                    this.updatePreview();
                }
            }
        };
        if (typeof document !== 'undefined') {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(document, 'keydown', this.keyHandler);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(document, 'keyup', this.keyHandler);
        }
    }
    /**
     * Returns <enabled>.
     */ isEnabled() {
        return this.enabled;
    }
    /**
     * Sets <enabled>.
     */ setEnabled(value) {
        this.enabled = value;
    }
    /**
     * Returns <cloneEnabled>.
     */ isCloneEnabled() {
        return this.cloneEnabled;
    }
    /**
     * Sets <cloneEnabled>.
     *
     * @param value Boolean that specifies the new clone enabled state.
     */ setCloneEnabled(value) {
        this.cloneEnabled = value;
    }
    /**
     * Returns {@link oveEnabled}.
     */ isMoveEnabled() {
        return this.moveEnabled;
    }
    /**
     * Sets {@link oveEnabled}.
     */ setMoveEnabled(value) {
        this.moveEnabled = value;
    }
    /**
     * Returns <selectEnabled>.
     */ isSelectEnabled() {
        return this.selectEnabled;
    }
    /**
     * Sets <selectEnabled>.
     */ setSelectEnabled(value) {
        this.selectEnabled = value;
    }
    /**
     * Returns <removeCellsFromParent>.
     */ isRemoveCellsFromParent() {
        return this.removeCellsFromParent;
    }
    /**
     * Sets <removeCellsFromParent>.
     */ setRemoveCellsFromParent(value) {
        this.removeCellsFromParent = value;
    }
    /**
     * Returns true if the given cell and parent should propagate
     * selection state to the parent.
     */ isPropagateSelectionCell(cell, immediate, me) {
        const parent = cell.getParent();
        if (immediate) {
            const geo = cell.isEdge() ? null : cell.getGeometry();
            return !this.graph.isSiblingSelected(cell) && geo && geo.relative || !this.graph.isSwimlane(parent);
        }
        return (!this.graph.isToggleEvent(me.getEvent()) || !this.graph.isSiblingSelected(cell) && !this.graph.isCellSelected(cell) && !this.graph.isSwimlane(parent) || this.graph.isCellSelected(parent)) && (this.graph.isToggleEvent(me.getEvent()) || !this.graph.isCellSelected(parent));
    }
    /**
     * Hook to return initial cell for the given event.
     */ getInitialCellForEvent(me) {
        let state = me.getState();
        if ((!this.graph.isToggleEvent(me.getEvent()) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAltDown"])(me.getEvent())) && state && !this.graph.isCellSelected(state.cell)) {
            let parent = state.cell.getParent();
            let next = parent ? this.graph.view.getState(parent) : null;
            while(next && !this.graph.isCellSelected(next.cell) && (next.cell.isVertex() || next.cell.isEdge()) && this.isPropagateSelectionCell(state.cell, true, me)){
                state = next;
                parent = state.cell.getParent();
                next = parent ? this.graph.view.getState(parent) : null;
            }
        }
        return state ? state.cell : null;
    }
    /**
     * Hook to return true for delayed selections.
     */ isDelayedSelection(cell, me) {
        let c = cell;
        const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');
        if (!this.graph.isToggleEvent(me.getEvent()) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAltDown"])(me.getEvent())) {
            while(c){
                if (selectionCellsHandler?.isHandled(c)) {
                    const cellEditorHandler = this.graph.getPlugin('CellEditorHandler');
                    return cellEditorHandler?.getEditingCell() !== c;
                }
                c = c.getParent();
            }
        }
        return this.graph.isToggleEvent(me.getEvent()) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAltDown"])(me.getEvent());
    }
    /**
     * Implements the delayed selection for the given mouse event.
     */ selectDelayed(me) {
        const popupMenuHandler = this.graph.getPlugin('PopupMenuHandler');
        if (!popupMenuHandler || !popupMenuHandler.isPopupTrigger(me)) {
            let cell = me.getCell();
            if (cell === null) {
                cell = this.cell;
            }
            if (cell) this.selectCellForEvent(cell, me);
        }
    }
    /**
     * Selects the given cell for the given {@link MouseEvent}.
     */ selectCellForEvent(cell, me) {
        const state = this.graph.view.getState(cell);
        if (state) {
            if (me.isSource(state.control)) {
                this.graph.selectCellForEvent(cell, me.getEvent());
            } else {
                if (!this.graph.isToggleEvent(me.getEvent()) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAltDown"])(me.getEvent())) {
                    let parent = cell.getParent();
                    while(parent && this.graph.view.getState(parent) && (parent.isVertex() || parent.isEdge()) && this.isPropagateSelectionCell(cell, false, me)){
                        cell = parent;
                        parent = cell.getParent();
                    }
                }
                this.graph.selectCellForEvent(cell, me.getEvent());
            }
        }
        return cell;
    }
    /**
     * Consumes the given mouse event. NOTE: This may be used to enable click
     * events for links in labels on iOS as follows as consuming the initial
     * touchStart disables firing the subsequent click evnent on the link.
     *
     * <code>
     * consumeMouseEvent(evtName, me)
     * {
     *   var source = mxEvent.getSource(me.getEvent());
     *
     *   if (!mxEvent.isTouchEvent(me.getEvent()) || source.nodeName != 'A')
     *   {
     *     me.consume();
     *   }
     * }
     * </code>
     */ consumeMouseEvent(evtName, me) {
        me.consume();
    }
    /**
     * Handles the event by selecing the given cell and creating a handle for
     * it. By consuming the event all subsequent events of the gesture are
     * redirected to this handler.
     */ mouseDown(sender, me) {
        if (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() && me.getState() && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMultiTouchEvent"])(me.getEvent())) {
            const cell = this.getInitialCellForEvent(me);
            if (cell) {
                this.delayedSelection = this.isDelayedSelection(cell, me);
                this.cell = null;
                if (this.isSelectEnabled() && !this.delayedSelection) {
                    this.graph.selectCellForEvent(cell, me.getEvent());
                }
                if (this.isMoveEnabled()) {
                    const geo = cell.getGeometry();
                    if (geo && this.graph.isCellMovable(cell) && (!cell.isEdge() || this.graph.getSelectionCount() > 1 || geo.points && geo.points.length > 0 || !cell.getTerminal(true) || !cell.getTerminal(false) || this.graph.isAllowDanglingEdges() || this.graph.isCloneEvent(me.getEvent()) && this.graph.isCellsCloneable())) {
                        this.start(cell, me.getX(), me.getY());
                    } else if (this.delayedSelection) {
                        this.cell = cell;
                    }
                    this.cellWasClicked = true;
                    this.consumeMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN, me);
                }
            }
        }
    }
    /**
     * Creates an array of cell states which should be used as guides.
     */ getGuideStates() {
        const parent = this.graph.getDefaultParent();
        const filter = (cell)=>{
            const geo = cell.getGeometry();
            return !!this.graph.view.getState(cell) && cell.isVertex() && !!geo && !geo.relative;
        };
        return this.graph.view.getCellStates(parent.filterDescendants(filter));
    }
    /**
     * Returns the cells to be modified by this handler. This implementation
     * returns all selection cells that are movable, or the given initial cell if
     * the given cell is not selected and movable. This handles the case of moving
     * unselectable or unselected cells.
     *
     * @param initialCell <Cell> that triggered this handler.
     */ getCells(initialCell) {
        if (!this.delayedSelection && this.graph.isCellMovable(initialCell)) {
            return [
                initialCell
            ];
        }
        return this.graph.getMovableCells(this.graph.getSelectionCells());
    }
    /**
     * Returns the {@link Rectangle} used as the preview bounds for
     * moving the given cells.
     */ getPreviewBounds(cells) {
        const bounds = this.getBoundingBox(cells);
        if (bounds) {
            // Corrects width and height
            bounds.width = Math.max(0, bounds.width - 1);
            bounds.height = Math.max(0, bounds.height - 1);
            if (bounds.width < this.minimumSize) {
                const dx = this.minimumSize - bounds.width;
                bounds.x -= dx / 2;
                bounds.width = this.minimumSize;
            } else {
                bounds.x = Math.round(bounds.x);
                bounds.width = Math.ceil(bounds.width);
            }
            if (bounds.height < this.minimumSize) {
                const dy = this.minimumSize - bounds.height;
                bounds.y -= dy / 2;
                bounds.height = this.minimumSize;
            } else {
                bounds.y = Math.round(bounds.y);
                bounds.height = Math.ceil(bounds.height);
            }
        }
        return bounds;
    }
    /**
     * Returns the union of the {@link CellStates} for the given array of {@link Cells}.
     * For vertices, this method uses the bounding box of the corresponding shape
     * if one exists. The bounding box of the corresponding text label and all
     * controls and overlays are ignored. See also: {@link GraphView#getBounds} and
     * {@link Graph#getBoundingBox}.
     *
     * @param cells Array of {@link Cells} whose bounding box should be returned.
     */ getBoundingBox(cells) {
        let result = null;
        if (cells.length > 0) {
            for(let i = 0; i < cells.length; i += 1){
                if (cells[i].isVertex() || cells[i].isEdge()) {
                    const state = this.graph.view.getState(cells[i]);
                    if (state) {
                        let bbox = null;
                        if (cells[i].isVertex() && state.shape && state.shape.boundingBox) {
                            bbox = state.shape.boundingBox;
                        }
                        if (bbox) {
                            if (!result) {
                                result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].fromRectangle(bbox);
                            } else {
                                result.add(bbox);
                            }
                        }
                    }
                }
            }
        }
        return result;
    }
    /**
     * Creates the shape used to draw the preview for the given bounds.
     */ createPreviewShape(bounds) {
        const shape = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](bounds, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NONE"], this.previewColor);
        shape.isDashed = true;
        if (this.htmlPreview) {
            shape.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].STRICTHTML;
            shape.init(this.graph.container);
        } else {
            // Makes sure to use either VML or SVG shapes in order to implement
            // event-transparency on the background area of the rectangle since
            // HTML shapes do not let mouseevents through even when transparent
            shape.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DIALECT"].SVG;
            shape.init(this.graph.getView().getOverlayPane());
            shape.pointerEvents = false;
            // Workaround for artifacts on iOS
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].IS_IOS) {
                shape.getSvgScreenOffset = ()=>{
                    return 0;
                };
            }
        }
        return shape;
    }
    createGuide() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$other$2f$Guide$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.graph, this.getGuideStates());
    }
    /**
     * Starts the handling of the mouse gesture.
     */ start(cell, x, y, cells) {
        this.cell = cell;
        this.first = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertPoint"])(this.graph.container, x, y);
        this.cells = cells ? cells : this.getCells(this.cell);
        this.bounds = this.graph.getView().getBounds(this.cells);
        this.pBounds = this.getPreviewBounds(this.cells);
        this.cloning = false;
        this.cellCount = 0;
        for(let i = 0; i < this.cells.length; i += 1){
            this.cellCount += this.addStates(this.cells[i], this.allCells);
        }
        if (this.guidesEnabled) {
            this.guide = this.createGuide();
            const parent = cell.getParent();
            const ignore = parent.getChildCount() < 2;
            // Uses connected states as guides
            const connected = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
            const opps = this.graph.getOpposites(this.graph.getEdges(this.cell), this.cell);
            for(let i = 0; i < opps.length; i += 1){
                const state = this.graph.view.getState(opps[i]);
                if (state && !connected.get(state)) {
                    connected.put(state, true);
                }
            }
            this.guide.isStateIgnored = (state)=>{
                const p = state.cell.getParent();
                return !!state.cell && (!this.cloning && !!this.isCellMoving(state.cell) || state.cell !== (this.target || parent) && !ignore && !connected.get(state) && (!this.target || this.target.getChildCount() >= 2) && p !== (this.target || parent));
            };
        }
    }
    /**
     * Adds the states for the given cell recursively to the given dictionary.
     * @param cell
     * @param dict
     */ addStates(cell, dict) {
        const state = this.graph.view.getState(cell);
        let count = 0;
        if (state && !dict.get(cell)) {
            dict.put(cell, state);
            count++;
            const childCount = cell.getChildCount();
            for(let i = 0; i < childCount; i += 1){
                count += this.addStates(cell.getChildAt(i), dict);
            }
        }
        return count;
    }
    /**
     * Returns true if the given cell is currently being moved.
     */ isCellMoving(cell) {
        return this.allCells.get(cell);
    }
    /**
     * Returns true if the guides should be used for the given {@link MouseEvent}.
     * This implementation returns {@link Guide#isEnabledForEvent}.
     */ useGuidesForEvent(me) {
        return this.guide ? this.guide.isEnabledForEvent(me.getEvent()) && !this.graph.isConstrainedEvent(me.getEvent()) : true;
    }
    /**
     * Snaps the given vector to the grid and returns the given mxPoint instance.
     */ snap(vector) {
        const scale = this.scaleGrid ? this.graph.view.scale : 1;
        vector.x = this.graph.snap(vector.x / scale) * scale;
        vector.y = this.graph.snap(vector.y / scale) * scale;
        return vector;
    }
    /**
     * Returns an {@link Point} that represents the vector for moving the cells
     * for the given {@link MouseEvent}.
     */ getDelta(me) {
        const point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertPoint"])(this.graph.container, me.getX(), me.getY());
        if (!this.first) return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](point.x - this.first.x - this.graph.getPanDx(), point.y - this.first.y - this.graph.getPanDy());
    }
    /**
     * Hook for subclassers do show details while the handler is active.
     */ updateHint(me) {
        return;
    }
    /**
     * Hooks for subclassers to hide details when the handler gets inactive.
     */ removeHint() {
        return;
    }
    /**
     * Hook for rounding the unscaled vector. This uses Math.round.
     */ roundLength(length) {
        return Math.round(length * 100) / 100;
    }
    /**
     * Returns true if the given cell is a valid drop target.
     */ isValidDropTarget(target, me) {
        return this.cell ? this.cell.getParent() !== target : false;
    }
    /**
     * Updates the preview if cloning state has changed.
     */ checkPreview() {
        if (this.livePreviewActive && this.cloning) {
            this.resetLivePreview();
            this.livePreviewActive = false;
        } else if (this.maxLivePreview >= this.cellCount && !this.livePreviewActive && this.allowLivePreview) {
            if (!this.cloning || !this.livePreviewActive) {
                this.livePreviewActive = true;
                this.livePreviewUsed = true;
            }
        } else if (!this.livePreviewUsed && !this.shape && this.bounds) {
            this.shape = this.createPreviewShape(this.bounds);
        }
    }
    /**
     * Handles the event by highlighting possible drop targets and updating the
     * preview.
     */ mouseMove(sender, me) {
        const { graph } = this;
        if (!me.isConsumed() && graph.isMouseDown && this.cell && this.first && this.bounds && !this.suspended) {
            // Stops moving if a multi touch event is received
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMultiTouchEvent"])(me.getEvent())) {
                this.reset();
                return;
            }
            let delta = this.getDelta(me);
            const tol = graph.getEventTolerance();
            if (this.shape || this.livePreviewActive || Math.abs(delta.x) > tol || Math.abs(delta.y) > tol) {
                // Highlight is used for highlighting drop targets
                if (!this.highlight) {
                    this.highlight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellHighlight$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this.graph, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DROP_TARGET_COLOR"], 3);
                }
                const clone = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();
                const gridEnabled = graph.isGridEnabledEvent(me.getEvent());
                const cell = me.getCell();
                let hideGuide = true;
                let target = null;
                this.cloning = clone;
                if (graph.isDropEnabled() && this.highlightEnabled && this.cells) {
                    // Contains a call to getCellAt to find the cell under the mouse
                    target = graph.getDropTarget(this.cells, me.getEvent(), cell, clone);
                }
                let state = target ? graph.getView().getState(target) : null;
                let highlight = false;
                if (state && (clone || target && this.isValidDropTarget(target, me))) {
                    if (this.target !== target) {
                        this.target = target;
                        this.setHighlightColor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DROP_TARGET_COLOR"]);
                    }
                    highlight = true;
                } else {
                    this.target = null;
                    if (this.connectOnDrop && cell && this.cells && this.cells.length === 1 && cell.isVertex() && cell.isConnectable()) {
                        state = graph.getView().getState(cell);
                        if (state) {
                            const error = graph.getEdgeValidationError(null, this.cell, cell);
                            const color = error === null ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VALID_COLOR"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["INVALID_CONNECT_TARGET_COLOR"];
                            this.setHighlightColor(color);
                            highlight = true;
                        }
                    }
                }
                if (state && highlight) {
                    this.highlight.highlight(state);
                } else {
                    this.highlight.hide();
                }
                if (this.guide && this.useGuidesForEvent(me)) {
                    delta = this.guide.move(this.bounds, delta, gridEnabled, clone);
                    hideGuide = false;
                } else {
                    delta = this.graph.snapDelta(delta, this.bounds, !gridEnabled, false, false);
                }
                if (this.guide && hideGuide) {
                    this.guide.hide();
                }
                // Constrained movement if shift key is pressed
                if (graph.isConstrainedEvent(me.getEvent())) {
                    if (Math.abs(delta.x) > Math.abs(delta.y)) {
                        delta.y = 0;
                    } else {
                        delta.x = 0;
                    }
                }
                this.checkPreview();
                if (this.currentDx !== delta.x || this.currentDy !== delta.y) {
                    this.currentDx = delta.x;
                    this.currentDy = delta.y;
                    this.updatePreview();
                }
            }
            this.updateHint(me);
            this.consumeMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOUSE_MOVE, me);
            // Cancels the bubbling of events to the container so
            // that the droptarget is not reset due to an mouseMove
            // fired on the container with no associated state.
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(me.getEvent());
        } else if ((this.isMoveEnabled() || this.isCloneEnabled()) && this.updateCursor && !me.isConsumed() && (me.getState() || me.sourceState) && !graph.isMouseDown) {
            let cursor = graph.getCursorForMouseEvent(me);
            const cell = me.getCell();
            if (!cursor && cell && graph.isEnabled() && graph.isCellMovable(cell)) {
                if (cell.isEdge()) {
                    cursor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CURSOR"].MOVABLE_EDGE;
                } else {
                    cursor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CURSOR"].MOVABLE_VERTEX;
                }
            }
            // Sets the cursor on the original source state under the mouse
            // instead of the event source state which can be the parent
            if (cursor && me.sourceState) {
                me.sourceState.setCursor(cursor);
            }
        }
    }
    /**
     * Updates the bounds of the preview shape.
     */ updatePreview(remote = false) {
        if (this.livePreviewUsed && !remote) {
            if (this.cells) {
                const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');
                this.setHandlesVisibleForCells(selectionCellsHandler?.getHandledSelectionCells() ?? [], false);
                this.updateLivePreview(this.currentDx, this.currentDy);
            }
        } else {
            this.updatePreviewShape();
        }
    }
    /**
     * Updates the bounds of the preview shape.
     */ updatePreviewShape() {
        if (this.shape && this.pBounds) {
            this.shape.bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](Math.round(this.pBounds.x + this.currentDx), Math.round(this.pBounds.y + this.currentDy), this.pBounds.width, this.pBounds.height);
            this.shape.redraw();
        }
    }
    /**
     * Updates the bounds of the preview shape.
     */ updateLivePreview(dx, dy) {
        if (!this.suspended) {
            const states = [];
            if (this.allCells) {
                this.allCells.visit((key, state)=>{
                    const realState = state ? this.graph.view.getState(state.cell) : null;
                    // Checks if cell was removed or replaced
                    if (realState !== state && state) {
                        state.destroy();
                        if (realState) {
                            this.allCells.put(state.cell, realState);
                        } else {
                            this.allCells.remove(state.cell);
                        }
                        state = realState;
                    }
                    if (state) {
                        // Saves current state
                        const tempState = state.clone();
                        states.push([
                            state,
                            tempState
                        ]);
                        // Makes transparent for events to detect drop targets
                        if (state.shape) {
                            if (state.shape.originalPointerEvents === null) {
                                state.shape.originalPointerEvents = state.shape.pointerEvents;
                            }
                            state.shape.pointerEvents = false;
                            if (state.text) {
                                if (state.text.originalPointerEvents === null) {
                                    state.text.originalPointerEvents = state.text.pointerEvents;
                                }
                                state.text.pointerEvents = false;
                            }
                        }
                        // Temporarily changes position
                        if (state.cell.isVertex()) {
                            state.x += dx;
                            state.y += dy;
                            // Draws the live preview
                            if (!this.cloning) {
                                state.view.graph.cellRenderer.redraw(state, true);
                                // Forces redraw of connected edges after all states
                                // have been updated but avoids update of state
                                state.view.invalidate(state.cell);
                                state.invalid = false;
                                // Hides folding icon
                                if (state.control && state.control.node) {
                                    state.control.node.style.visibility = 'hidden';
                                }
                            } else if (state.text) {
                                state.text.updateBoundingBox();
                                // Fixes preview box for edge labels
                                if (state.text.boundingBox) {
                                    state.text.boundingBox.x += dx;
                                    state.text.boundingBox.y += dy;
                                }
                                if (state.text.unrotatedBoundingBox) {
                                    state.text.unrotatedBoundingBox.x += dx;
                                    state.text.unrotatedBoundingBox.y += dy;
                                }
                            }
                        }
                    }
                });
            }
            // Resets the handler if everything was removed
            if (states.length === 0) {
                this.reset();
            } else {
                // Redraws connected edges
                const s = this.graph.view.scale;
                for(let i = 0; i < states.length; i += 1){
                    const state = states[i][0];
                    if (state.cell.isEdge()) {
                        const geometry = state.cell.getGeometry();
                        const points = [];
                        if (geometry && geometry.points) {
                            for(let j = 0; j < geometry.points.length; j++){
                                if (geometry.points[j]) {
                                    points.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](geometry.points[j].x + dx / s, geometry.points[j].y + dy / s));
                                }
                            }
                        }
                        let source = state.visibleSourceState;
                        let target = state.visibleTargetState;
                        const pts = states[i][1].absolutePoints;
                        if (source == null || !this.isCellMoving(source.cell)) {
                            const pt0 = pts[0];
                            if (pt0) {
                                state.setAbsoluteTerminalPoint(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](pt0.x + dx, pt0.y + dy), true);
                                source = null;
                            }
                        } else {
                            state.view.updateFixedTerminalPoint(state, source, true, this.graph.getConnectionConstraint(state, source, true));
                        }
                        if (target == null || !this.isCellMoving(target.cell)) {
                            const ptn = pts[pts.length - 1];
                            if (ptn) {
                                state.setAbsoluteTerminalPoint(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](ptn.x + dx, ptn.y + dy), false);
                                target = null;
                            }
                        } else {
                            state.view.updateFixedTerminalPoint(state, target, false, this.graph.getConnectionConstraint(state, target, false));
                        }
                        state.view.updatePoints(state, points, source, target);
                        state.view.updateFloatingTerminalPoints(state, source, target);
                        state.view.updateEdgeLabelOffset(state);
                        state.invalid = false;
                        // Draws the live preview but avoids update of state
                        if (!this.cloning) {
                            state.view.graph.cellRenderer.redraw(state, true);
                        }
                    }
                }
                this.graph.view.validate();
                this.redrawHandles(states);
                this.resetPreviewStates(states);
            }
        }
    }
    /**
     * Redraws the preview shape for the given states array.
     */ redrawHandles(states) {
        const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');
        for(let i = 0; i < states.length; i += 1){
            const handler = selectionCellsHandler?.getHandler(states[i][0].cell);
            handler?.redraw(true);
        }
    }
    /**
     * Resets the given preview states array.
     */ resetPreviewStates(states) {
        for(let i = 0; i < states.length; i += 1){
            states[i][0].setState(states[i][1]);
        }
    }
    /**
     * Suspends the livew preview.
     */ suspend() {
        if (!this.suspended) {
            if (this.livePreviewUsed) {
                this.updateLivePreview(0, 0);
            }
            if (this.shape) {
                this.shape.node.style.visibility = 'hidden';
            }
            if (this.guide) {
                this.guide.setVisible(false);
            }
            this.suspended = true;
        }
    }
    /**
     * Suspends the livew preview.
     */ resume() {
        if (this.suspended) {
            this.suspended = false;
            if (this.livePreviewUsed) {
                this.livePreviewActive = true;
            }
            if (this.shape) {
                this.shape.node.style.visibility = 'visible';
            }
            if (this.guide) {
                this.guide.setVisible(true);
            }
        }
    }
    /**
     * Resets the livew preview.
     */ resetLivePreview() {
        this.allCells.visit((key, state)=>{
            // Restores event handling
            if (state.shape && state.shape.originalPointerEvents !== null) {
                state.shape.pointerEvents = state.shape.originalPointerEvents;
                state.shape.originalPointerEvents = null;
                // Forces repaint even if not moved to update pointer events
                state.shape.bounds = null;
                if (state.text && state.text.originalPointerEvents !== null) {
                    state.text.pointerEvents = state.text.originalPointerEvents;
                    state.text.originalPointerEvents = null;
                }
            }
            // Shows folding icon
            if (state.control && state.control.node && state.control.node.style.visibility === 'hidden') {
                state.control.node.style.visibility = '';
            }
            // Fixes preview box for edge labels
            if (!this.cloning) {
                if (state.text) {
                    state.text.updateBoundingBox();
                }
            }
            // Forces repaint of connected edges
            state.view.invalidate(state.cell);
        });
        // Repaints all invalid states
        this.graph.view.validate();
    }
    /**
     * Sets wether the handles attached to the given cells are visible.
     *
     * @param cells Array of {@link Cells}.
     * @param visible Boolean that specifies if the handles should be visible.
     * @param force Forces an update of the handler regardless of the last used value.
     */ setHandlesVisibleForCells(cells, visible, force = false) {
        if (force || this.handlesVisible !== visible) {
            this.handlesVisible = visible;
            const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');
            for(let i = 0; i < cells.length; i += 1){
                const handler = selectionCellsHandler?.getHandler(cells[i]);
                if (handler) {
                    handler.setHandlesVisible(visible);
                    if (visible) {
                        handler.redraw();
                    }
                }
            }
        }
    }
    /**
     * Sets the color of the rectangle used to highlight drop targets.
     *
     * @param color String that represents the new highlight color.
     */ setHighlightColor(color) {
        if (this.highlight) {
            this.highlight.setHighlightColor(color);
        }
    }
    /**
     * Handles the event by applying the changes to the selection cells.
     */ mouseUp(sender, me) {
        if (!me.isConsumed()) {
            if (this.livePreviewUsed) {
                this.resetLivePreview();
            }
            if (this.cell && this.first && (this.shape || this.livePreviewUsed) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumeric"])(this.currentDx) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumeric"])(this.currentDy)) {
                const { graph } = this;
                const cell = me.getCell();
                if (this.connectOnDrop && !this.target && cell && cell.isVertex() && cell.isConnectable() && graph.isEdgeValid(null, this.cell, cell)) {
                    const connectionHandler = graph.getPlugin('ConnectionHandler');
                    connectionHandler?.connect(this.cell, cell, me.getEvent());
                } else {
                    const clone = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();
                    const { scale } = graph.getView();
                    const dx = this.roundLength(this.currentDx / scale);
                    const dy = this.roundLength(this.currentDy / scale);
                    const target = this.target;
                    if (target && graph.isSplitEnabled() && this.cells && graph.isSplitTarget(target, this.cells, me.getEvent())) {
                        graph.splitEdge(target, this.cells, null, dx, dy, me.getGraphX(), me.getGraphY());
                    } else if (this.cells) {
                        this.moveCells(this.cells, dx, dy, clone, this.target, me.getEvent());
                    }
                }
            } else if (this.isSelectEnabled() && this.delayedSelection && this.cell != null) {
                this.selectDelayed(me);
            }
        }
        // Consumes the event if a cell was initially clicked
        if (this.cellWasClicked) {
            this.consumeMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOUSE_UP, me);
        }
        this.reset();
    }
    /**
     * Resets the state of this handler.
     */ reset() {
        if (this.livePreviewUsed) {
            this.resetLivePreview();
            const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');
            this.setHandlesVisibleForCells(selectionCellsHandler?.getHandledSelectionCells() ?? [], true);
        }
        this.destroyShapes();
        this.removeHint();
        this.delayedSelection = false;
        this.livePreviewActive = false;
        this.livePreviewUsed = false;
        this.cellWasClicked = false;
        this.suspended = false;
        this.currentDx = 0;
        this.currentDy = 0;
        this.cellCount = 0;
        this.cloning = false;
        this.allCells.clear();
        this.pBounds = null;
        this.target = null;
        this.first = null;
        this.cells = null;
        this.cell = null;
    }
    /**
     * Returns true if the given cells should be removed from the parent for the specified
     * mousereleased event.
     */ shouldRemoveCellsFromParent(parent, cells, evt) {
        if (parent.isVertex()) {
            const pState = this.graph.getView().getState(parent);
            if (pState) {
                let pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertPoint"])(this.graph.container, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientX"])(evt), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientY"])(evt));
                const alpha = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRadians"])(pState.style.rotation ?? 0);
                if (alpha !== 0) {
                    const cos = Math.cos(-alpha);
                    const sin = Math.sin(-alpha);
                    const cx = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](pState.getCenterX(), pState.getCenterY());
                    pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRotatedPoint"])(pt, cos, sin, cx);
                }
                return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["contains"])(pState, pt.x, pt.y);
            }
        }
        return false;
    }
    /**
     * Moves the given cells by the specified amount.
     */ moveCells(cells, dx, dy, clone, target, evt) {
        if (!this.cell) return;
        if (clone) {
            cells = this.graph.getCloneableCells(cells);
        }
        // Removes cells from parent
        const parent = this.cell.getParent();
        if (!target && parent && this.isRemoveCellsFromParent() && this.shouldRemoveCellsFromParent(parent, cells, evt)) {
            target = this.graph.getDefaultParent();
        }
        // Cloning into locked cells is not allowed
        clone = !!clone && !this.graph.isCellLocked(target || this.graph.getDefaultParent());
        this.graph.batchUpdate(()=>{
            const parents = [];
            // Removes parent if all child cells are removed
            if (!clone && target && this.removeEmptyParents) {
                // Collects all non-selected parents
                const dict = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
                for(let i = 0; i < cells.length; i += 1){
                    dict.put(cells[i], true);
                }
                // LATER: Recurse up the cell hierarchy
                for(let i = 0; i < cells.length; i += 1){
                    const par = cells[i].getParent();
                    if (par && !dict.get(par)) {
                        dict.put(par, true);
                        parents.push(par);
                    }
                }
            }
            // Passes all selected cells in order to correctly clone or move into
            // the target cell. The method checks for each cell if its movable.
            cells = this.graph.moveCells(cells, dx, dy, clone, target, evt);
            // Removes parent if all child cells are removed
            const temp = [];
            for(let i = 0; i < parents.length; i += 1){
                if (this.shouldRemoveParent(parents[i])) {
                    temp.push(parents[i]);
                }
            }
            this.graph.removeCells(temp, false);
        });
        // Selects the new cells if cells have been cloned
        if (clone) {
            this.graph.setSelectionCells(cells);
        }
        if (this.isSelectEnabled() && this.scrollOnMove) {
            this.graph.scrollCellToVisible(cells[0]);
        }
    }
    /**
     * Returns true if the given parent should be removed after removal of child cells.
     */ shouldRemoveParent(parent) {
        const state = this.graph.view.getState(parent);
        return state != null && (state.cell.isEdge() || state.cell.isVertex()) && this.graph.isCellDeletable(state.cell) && state.cell.getChildCount() === 0 && state.isTransparentState();
    }
    /**
     * Destroy the preview and highlight shapes.
     */ destroyShapes() {
        // Destroys the preview dashed rectangle
        if (this.shape) {
            this.shape.destroy();
            this.shape = null;
        }
        if (this.guide) {
            this.guide.destroy();
            this.guide = null;
        }
        // Destroys the drop target highlight
        if (this.highlight) {
            this.highlight.destroy();
            this.highlight = null;
        }
    }
    /**
     * Destroys the handler and all its resources and DOM nodes.
     */ onDestroy() {
        this.graph.removeMouseListener(this);
        this.graph.removeListener(this.panHandler);
        this.graph.removeListener(this.escapeHandler);
        this.graph.getDataModel().removeListener(this.refreshHandler);
        this.graph.removeListener(this.refreshHandler);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].removeListener(document, 'keydown', this.keyHandler);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].removeListener(document, 'keyup', this.keyHandler);
        this.destroyShapes();
        this.removeHint();
    }
}
SelectionHandler.pluginId = 'SelectionHandler';
const __TURBOPACK__default__export__ = SelectionHandler;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/handler/PanningHandler.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$other$2f$PanningManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/other/PanningManager.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventSource.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
/**
 * Event handler that pans and creates popupmenus. To use the left
 * mouse button for panning without interfering with cell moving and
 * resizing, use <isUseLeftButton> and <isIgnoreCell>. For grid size
 * steps while panning, use <useGrid>.
 *
 * When registered in the {@link Graph.constructor} plugins list, it can be enabled using {@link Graph.setPanning}.
 *
 * Event: mxEvent.PAN_START
 *
 * Fires when the panning handler changes its <active> state to true. The
 * <code>event</code> property contains the corresponding {@link MouseEvent}.
 *
 * Event: mxEvent.PAN
 *
 * Fires while handle is processing events. The <code>event</code> property contains
 * the corresponding {@link MouseEvent}.
 *
 * Event: mxEvent.PAN_END
 *
 * Fires when the panning handler changes its <active> state to false. The
 * <code>event</code> property contains the corresponding {@link MouseEvent}.
 *
 * @category Plugin
 */ class PanningHandler extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    constructor(graph){
        super();
        this.getPanningManager = ()=>this.panningManager;
        /**
         * Specifies if panning should be active for the left mouse button.
         * Setting this to true may conflict with {@link Rubberband}. Default is false.
         */ this.useLeftButtonForPanning = false;
        /**
         * Specifies if {@link Event#isPopupTrigger} should also be used for panning.
         */ this.usePopupTrigger = true;
        /**
         * Specifies if panning should be active even if there is a cell under the
         * mousepointer. Default is false.
         */ this.ignoreCell = false;
        /**
         * Specifies if the panning should be previewed. Default is true.
         */ this.previewEnabled = true;
        /**
         * Specifies if the panning steps should be aligned to the grid size.
         * Default is false.
         */ this.useGrid = false;
        /**
         * Specifies if panning should be enabled. Default is false.
         */ this.panningEnabled = false;
        /**
         * Specifies if pinch gestures should be handled as zoom. Default is true.
         */ this.pinchEnabled = true;
        this.initialScale = 0;
        /**
         * Specifies the maximum scale. Default is 8.
         */ this.maxScale = 8;
        /**
         * Specifies the minimum scale. Default is 0.01.
         */ this.minScale = 0.01;
        /**
         * Holds the current horizontal offset.
         */ this.dx = 0;
        /**
         * Holds the current vertical offset.
         */ this.dy = 0;
        /**
         * Holds the x-coordinate of the start point.
         */ this.startX = 0;
        /**
         * Holds the y-coordinate of the start point.
         */ this.startY = 0;
        this.dx0 = 0;
        this.dy0 = 0;
        this.panningTrigger = false;
        this.active = false;
        this.mouseDownEvent = null;
        this.graph = graph;
        this.graph.addMouseListener(this);
        // Handles force panning event
        this.forcePanningHandler = (sender, eo)=>{
            const evtName = eo.getProperty('eventName');
            const me = eo.getProperty('event');
            if (evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN && this.isForcePanningEvent(me)) {
                this.start(me);
                this.active = true;
                this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PAN_START, {
                    event: me
                }));
                me.consume();
            }
        };
        this.graph.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].FIRE_MOUSE_EVENT, this.forcePanningHandler);
        // Handles pinch gestures
        this.gestureHandler = (sender, eo)=>{
            if (this.isPinchEnabled()) {
                const evt = eo.getProperty('event');
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isConsumed"])(evt) && evt.type === 'gesturestart') {
                    this.initialScale = this.graph.view.scale;
                    // Forces start of panning when pinch gesture starts
                    if (!this.active && this.mouseDownEvent) {
                        this.start(this.mouseDownEvent);
                        this.mouseDownEvent = null;
                    }
                } else if (evt.type === 'gestureend' && this.initialScale !== 0) {
                    this.initialScale = 0;
                }
                if (this.initialScale !== 0) {
                    this.zoomGraph(evt);
                }
            }
        };
        this.graph.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].GESTURE, this.gestureHandler);
        this.mouseUpListener = ()=>{
            if (this.active) {
                this.reset();
            }
        };
        // Stops scrolling on every mouseup anywhere in the document
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].addListener(document, 'mouseup', this.mouseUpListener);
        this.panningManager = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$other$2f$PanningManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](graph);
    }
    /**
     * Returns true if the handler is currently active.
     */ isActive() {
        return this.active || this.initialScale !== null;
    }
    /**
     * Returns <panningEnabled>.
     */ isPanningEnabled() {
        return this.panningEnabled;
    }
    /**
     * Sets <panningEnabled>.
     */ setPanningEnabled(value) {
        this.panningEnabled = value;
    }
    /**
     * Returns <pinchEnabled>.
     */ isPinchEnabled() {
        return this.pinchEnabled;
    }
    /**
     * Sets <pinchEnabled>.
     */ setPinchEnabled(value) {
        this.pinchEnabled = value;
    }
    /**
     * Returns true if the given event is a panning trigger for the optional
     * given cell. This returns true if control-shift is pressed or if
     * <usePopupTrigger> is true and the event is a popup trigger.
     */ isPanningTrigger(me) {
        const evt = me.getEvent();
        return this.useLeftButtonForPanning && !me.getState() && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isLeftMouseButton"])(evt) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isControlDown"])(evt) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isShiftDown"])(evt) || this.usePopupTrigger && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isPopupTrigger"])(evt);
    }
    /**
     * Returns true if the given {@link MouseEvent} should start panning. This
     * implementation always returns true if <ignoreCell> is true or for
     * multi touch events.
     */ isForcePanningEvent(me) {
        return this.ignoreCell || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMultiTouchEvent"])(me.getEvent());
    }
    /**
     * Handles the event by initiating the panning. By consuming the event all
     * subsequent events of the gesture are redirected to this handler.
     */ mouseDown(sender, me) {
        this.mouseDownEvent = me;
        if (!me.isConsumed() && this.isPanningEnabled() && !this.active && this.isPanningTrigger(me)) {
            this.start(me);
            this.consumePanningTrigger(me);
        }
    }
    /**
     * Starts panning at the given event.
     */ start(me) {
        this.dx0 = -this.graph.container.scrollLeft;
        this.dy0 = -this.graph.container.scrollTop;
        // Stores the location of the trigger event
        this.startX = me.getX();
        this.startY = me.getY();
        this.dx = 0;
        this.dy = 0;
        this.panningTrigger = true;
    }
    /**
     * Consumes the given {@link MouseEvent} if it was a panning trigger in
     * {@link ouseDown}. The default is to invoke {@link MouseEvent#consume}. Note that this
     * will block any further event processing. If you haven't disabled built-in
     * context menus and require immediate selection of the cell on mouseDown in
     * Safari and/or on the Mac, then use the following code:
     *
     * ```javascript
     * consumePanningTrigger(me)
     * {
     *   if (me.evt.preventDefault)
     *   {
     *     me.evt.preventDefault();
     *   }
     *
     *   // Stops event processing in IE
     *   me.evt.returnValue = false;
     *
     *   // Sets local consumed state
     *   if (!Client.IS_SF && !Client.IS_MAC)
     *   {
     *     me.consumed = true;
     *   }
     * };
     * ```
     */ consumePanningTrigger(me) {
        me.consume();
    }
    /**
     * Handles the event by updating the panning on the graph.
     */ mouseMove(sender, me) {
        this.dx = me.getX() - this.startX;
        this.dy = me.getY() - this.startY;
        if (this.active) {
            if (this.previewEnabled) {
                // Applies the grid to the panning steps
                if (this.useGrid) {
                    this.dx = this.graph.snap(this.dx);
                    this.dy = this.graph.snap(this.dy);
                }
                this.graph.panGraph(this.dx + this.dx0, this.dy + this.dy0);
            }
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PAN, {
                event: me
            }));
        } else if (this.panningTrigger) {
            const tmp = this.active;
            // Panning is activated only if the mouse is moved
            // beyond the graph tolerance
            this.active = Math.abs(this.dx) > this.graph.getSnapTolerance() || Math.abs(this.dy) > this.graph.getSnapTolerance();
            if (!tmp && this.active) {
                this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PAN_START, {
                    event: me
                }));
            }
        }
        if (this.active || this.panningTrigger) {
            me.consume();
        }
    }
    /**
     * Handles the event by setting the translation on the view or showing the
     * popupmenu.
     */ mouseUp(sender, me) {
        if (this.active) {
            if (this.dx !== 0 && this.dy !== 0) {
                // Ignores if scrollbars have been used for panning
                if (!this.graph.isUseScrollbarsForPanning() || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasScrollbars"])(this.graph.container)) {
                    const { scale } = this.graph.getView();
                    const t = this.graph.getView().translate;
                    this.graph.panGraph(0, 0);
                    this.panGraph(t.x + this.dx / scale, t.y + this.dy / scale);
                }
                me.consume();
            }
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].PAN_END, {
                event: me
            }));
        }
        this.reset();
    }
    /**
     * Zooms the graph to the given value and consumed the event if needed.
     */ zoomGraph(evt) {
        // @ts-ignore evt may have scale property
        let value = Math.round(this.initialScale * evt.scale * 100) / 100;
        value = Math.max(this.minScale, value);
        value = Math.min(this.maxScale, value);
        if (this.graph.view.scale !== value) {
            this.graph.zoomTo(value);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].consume(evt);
        }
    }
    /**
     * Handles the event by setting the translation on the view or showing the
     * popupmenu.
     */ reset() {
        this.panningTrigger = false;
        this.mouseDownEvent = null;
        this.active = false;
        this.dx = 0;
        this.dy = 0;
    }
    /**
     * Pans <graph> by the given amount.
     */ panGraph(dx, dy) {
        this.graph.getView().setTranslate(dx, dy);
    }
    /**
     * Destroys the handler and all its resources and DOM nodes.
     */ onDestroy() {
        this.graph.removeMouseListener(this);
        this.graph.removeListener(this.forcePanningHandler);
        this.graph.removeListener(this.gestureHandler);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].removeListener(document, 'mouseup', this.mouseUpListener);
    }
}
PanningHandler.pluginId = 'PanningHandler';
const __TURBOPACK__default__export__ = PanningHandler;
}}),

};

//# sourceMappingURL=node_modules_%40maxgraph_core_lib_view_handler_fef0d1._.js.map