{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/edge/MarkerShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { ARROW } from '../../../util/Constants';\n/**\n * A registry that stores all edge markers using .\n *\n * NOTE: The signatures in this class will change.\n */\nclass MarkerShape {\n    /**\n     * Adds a factory method that updates a given endpoint and returns a\n     * function to paint the marker onto the given canvas.\n     */\n    static addMarker(type, funct) {\n        MarkerShape.markers[type] = funct;\n    }\n    /**\n     * Returns a function to paint the given marker.\n     */\n    static createMarker(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) {\n        const markerFunction = MarkerShape.markers[type];\n        return markerFunction\n            ? markerFunction(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled)\n            : null;\n    }\n}\n/**\n * Maps from markers names to functions to paint the markers.\n *\n * Mapping: the attribute name on the object is the marker type, the associated value is the function to paint the marker\n */\nMarkerShape.markers = {};\nexport default MarkerShape;\n/**\n * For the classic and block marker factory methods.\n */\nfunction createArrow(widthFactor) {\n    return (canvas, _shape, type, pe, unitX, unitY, size, _source, sw, filled) => {\n        // The angle of the forward facing arrow sides against the x axis is\n        // 26.565 degrees, 1/sin(26.565) = 2.236 / 2 = 1.118 ( / 2 allows for\n        // only half the strokewidth is processed ).\n        const endOffsetX = unitX * sw * 1.118;\n        const endOffsetY = unitY * sw * 1.118;\n        unitX *= size + sw;\n        unitY *= size + sw;\n        const pt = pe.clone();\n        pt.x -= endOffsetX;\n        pt.y -= endOffsetY;\n        const f = type !== ARROW.CLASSIC && type !== ARROW.CLASSIC_THIN ? 1 : 3 / 4;\n        pe.x += -unitX * f - endOffsetX;\n        pe.y += -unitY * f - endOffsetY;\n        return () => {\n            canvas.begin();\n            canvas.moveTo(pt.x, pt.y);\n            canvas.lineTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);\n            if (type === ARROW.CLASSIC || type === ARROW.CLASSIC_THIN) {\n                canvas.lineTo(pt.x - (unitX * 3) / 4, pt.y - (unitY * 3) / 4);\n            }\n            canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);\n            canvas.close();\n            if (filled) {\n                canvas.fillAndStroke();\n            }\n            else {\n                canvas.stroke();\n            }\n        };\n    };\n}\nfunction createOpenArrow(widthFactor) {\n    return (canvas, _shape, _type, pe, unitX, unitY, size, _source, sw, _filled) => {\n        // The angle of the forward facing arrow sides against the x axis is\n        // 26.565 degrees, 1/sin(26.565) = 2.236 / 2 = 1.118 ( / 2 allows for\n        // only half the strokewidth is processed ).\n        const endOffsetX = unitX * sw * 1.118;\n        const endOffsetY = unitY * sw * 1.118;\n        unitX *= size + sw;\n        unitY *= size + sw;\n        const pt = pe.clone();\n        pt.x -= endOffsetX;\n        pt.y -= endOffsetY;\n        pe.x += -endOffsetX * 2;\n        pe.y += -endOffsetY * 2;\n        return () => {\n            canvas.begin();\n            canvas.moveTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);\n            canvas.lineTo(pt.x, pt.y);\n            canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);\n            canvas.stroke();\n        };\n    };\n}\nconst oval = (canvas, _shape, _type, pe, unitX, unitY, size, _source, _sw, filled) => {\n    const a = size / 2;\n    const pt = pe.clone();\n    pe.x -= unitX * a;\n    pe.y -= unitY * a;\n    return () => {\n        canvas.ellipse(pt.x - a, pt.y - a, size, size);\n        if (filled) {\n            canvas.fillAndStroke();\n        }\n        else {\n            canvas.stroke();\n        }\n    };\n};\nfunction diamond(canvas, _shape, type, pe, unitX, unitY, size, _source, sw, filled) {\n    // The angle of the forward facing arrow sides against the x axis is\n    // 45 degrees, 1/sin(45) = 1.4142 / 2 = 0.7071 ( / 2 allows for\n    // only half the strokewidth is processed ). Or 0.9862 for thin diamond.\n    // Note these values and the tk variable below are dependent, update\n    // both together (saves trig hard coding it).\n    const swFactor = type === ARROW.DIAMOND ? 0.7071 : 0.9862;\n    const endOffsetX = unitX * sw * swFactor;\n    const endOffsetY = unitY * sw * swFactor;\n    unitX *= size + sw;\n    unitY *= size + sw;\n    const pt = pe.clone();\n    pt.x -= endOffsetX;\n    pt.y -= endOffsetY;\n    pe.x += -unitX - endOffsetX;\n    pe.y += -unitY - endOffsetY;\n    // thickness factor for diamond\n    const tk = type === ARROW.DIAMOND ? 2 : 3.4;\n    return () => {\n        canvas.begin();\n        canvas.moveTo(pt.x, pt.y);\n        canvas.lineTo(pt.x - unitX / 2 - unitY / tk, pt.y + unitX / tk - unitY / 2);\n        canvas.lineTo(pt.x - unitX, pt.y - unitY);\n        canvas.lineTo(pt.x - unitX / 2 + unitY / tk, pt.y - unitY / 2 - unitX / tk);\n        canvas.close();\n        if (filled) {\n            canvas.fillAndStroke();\n        }\n        else {\n            canvas.stroke();\n        }\n    };\n}\nlet isDefaultMarkersRegistered = false;\n/**\n * @category Configuration\n */\nexport const registerDefaultEdgeMarkers = () => {\n    if (!isDefaultMarkersRegistered) {\n        MarkerShape.addMarker('classic', createArrow(2));\n        MarkerShape.addMarker('classicThin', createArrow(3));\n        MarkerShape.addMarker('block', createArrow(2));\n        MarkerShape.addMarker('blockThin', createArrow(3));\n        MarkerShape.addMarker('open', createOpenArrow(2));\n        MarkerShape.addMarker('openThin', createOpenArrow(3));\n        MarkerShape.addMarker('oval', oval);\n        MarkerShape.addMarker('diamond', diamond);\n        MarkerShape.addMarker('diamondThin', diamond);\n        isDefaultMarkersRegistered = true;\n    }\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 171, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 177, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/Point.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Implements a 2-dimensional vector with double precision coordinates.\n *\n * Constructor: mxPoint\n *\n * Constructs a new point for the optional x and y coordinates. If no\n * coordinates are given, then the default values for <x> and <y> are used.\n */\nclass Point {\n    constructor(x = 0, y = 0) {\n        /**\n         * Holds the x-coordinate of the point. Default is 0.\n         */\n        this._x = 0;\n        /**\n         * Holds the y-coordinate of the point. Default is 0.\n         */\n        this._y = 0;\n        this.x = x;\n        this.y = y;\n    }\n    get x() {\n        return this._x;\n    }\n    set x(x) {\n        if (Number.isNaN(x))\n            throw new Error('Invalid x supplied.');\n        this._x = x;\n    }\n    get y() {\n        return this._y;\n    }\n    set y(y) {\n        if (Number.isNaN(y))\n            throw new Error('Invalid y supplied.');\n        this._y = y;\n    }\n    /**\n     * Returns true if the given object equals this point.\n     */\n    equals(p) {\n        if (!p)\n            return false;\n        return p.x === this.x && p.y === this.y;\n    }\n    /**\n     * Returns a clone of this {@link Point}.\n     */\n    clone() {\n        return new Point(this.x, this.y);\n    }\n}\nexport default Point;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA,GACA;;;;;;;CAOC;;;AACD,MAAM;IACF,YAAY,IAAI,CAAC,EAAE,IAAI,CAAC,CAAE;QACtB;;SAEC,GACD,IAAI,CAAC,EAAE,GAAG;QACV;;SAEC,GACD,IAAI,CAAC,EAAE,GAAG;QACV,IAAI,CAAC,CAAC,GAAG;QACT,IAAI,CAAC,CAAC,GAAG;IACb;IACA,IAAI,IAAI;QACJ,OAAO,IAAI,CAAC,EAAE;IAClB;IACA,IAAI,EAAE,CAAC,EAAE;QACL,IAAI,OAAO,KAAK,CAAC,IACb,MAAM,IAAI,MAAM;QACpB,IAAI,CAAC,EAAE,GAAG;IACd;IACA,IAAI,IAAI;QACJ,OAAO,IAAI,CAAC,EAAE;IAClB;IACA,IAAI,EAAE,CAAC,EAAE;QACL,IAAI,OAAO,KAAK,CAAC,IACb,MAAM,IAAI,MAAM;QACpB,IAAI,CAAC,EAAE,GAAG;IACd;IACA;;KAEC,GACD,OAAO,CAAC,EAAE;QACN,IAAI,CAAC,GACD,OAAO;QACX,OAAO,EAAE,CAAC,KAAK,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC,KAAK,IAAI,CAAC,CAAC;IAC3C;IACA;;KAEC,GACD,QAAQ;QACJ,OAAO,IAAI,MAAM,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;IACnC;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 247, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/Rectangle.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from './Point';\n/**\n * Extends {@link Point} to implement a 2-dimensional rectangle with double\n * precision coordinates.\n *\n * Constructor: mxRectangle\n *\n * Constructs a new rectangle for the optional parameters. If no parameters\n * are given then the respective default values are used.\n */\nclass Rectangle extends Point {\n    constructor(x = 0, y = 0, width = 0, height = 0) {\n        super(x, y);\n        /**\n         * Holds the width of the rectangle.\n         * @default 0\n         */\n        this._width = 0;\n        /**\n         * Holds the height of the rectangle.\n         * @default 0\n         */\n        this._height = 0;\n        this.width = width;\n        this.height = height;\n    }\n    get width() {\n        return this._width;\n    }\n    set width(width) {\n        if (Number.isNaN(width))\n            throw new Error('Invalid width supplied.');\n        this._width = width;\n    }\n    get height() {\n        return this._height;\n    }\n    set height(height) {\n        if (Number.isNaN(height))\n            throw new Error('Invalid height supplied.');\n        this._height = height;\n    }\n    /**\n     * Sets this rectangle to the specified values\n     */\n    setRect(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    /**\n     * Returns the x-coordinate of the center point.\n     */\n    getCenterX() {\n        return this.x + this.width / 2;\n    }\n    /**\n     * Returns the y-coordinate of the center point.\n     */\n    getCenterY() {\n        return this.y + this.height / 2;\n    }\n    /**\n     * Adds the given rectangle to this rectangle.\n     */\n    add(rect) {\n        const minX = Math.min(this.x, rect.x);\n        const minY = Math.min(this.y, rect.y);\n        const maxX = Math.max(this.x + this.width, rect.x + rect.width);\n        const maxY = Math.max(this.y + this.height, rect.y + rect.height);\n        this.x = minX;\n        this.y = minY;\n        this.width = maxX - minX;\n        this.height = maxY - minY;\n    }\n    /**\n     * Changes this rectangle to where it overlaps with the given rectangle.\n     */\n    intersect(rect) {\n        const r1 = this.x + this.width;\n        const r2 = rect.x + rect.width;\n        const b1 = this.y + this.height;\n        const b2 = rect.y + rect.height;\n        this.x = Math.max(this.x, rect.x);\n        this.y = Math.max(this.y, rect.y);\n        this.width = Math.min(r1, r2) - this.x;\n        this.height = Math.min(b1, b2) - this.y;\n    }\n    /**\n     * Grows the rectangle by the given amount, that is, this method subtracts\n     * the given amount from the x- and y-coordinates and adds twice the amount\n     * to the width and height.\n     */\n    grow(amount) {\n        this.x -= amount;\n        this.y -= amount;\n        this.width += 2 * amount;\n        this.height += 2 * amount;\n    }\n    /**\n     * Returns the top, left corner as a new {@link Point}.\n     */\n    getPoint() {\n        return new Point(this.x, this.y);\n    }\n    /**\n     * Rotates this rectangle by 90 degree around its center point.\n     */\n    rotate90() {\n        const t = (this.width - this.height) / 2;\n        this.x += t;\n        this.y -= t;\n        const tmp = this.width;\n        this.width = this.height;\n        this.height = tmp;\n    }\n    /**\n     * Returns true if the given object equals this rectangle.\n     */\n    equals(rect) {\n        if (!rect)\n            return false;\n        return (rect.x === this.x &&\n            rect.y === this.y &&\n            rect.width === this.width &&\n            rect.height === this.height);\n    }\n    clone() {\n        return new Rectangle(this.x, this.y, this.width, this.height);\n    }\n}\n/**\n * Returns a new {@link Rectangle} which is a copy of the given rectangle.\n */\nRectangle.fromRectangle = (rect) => {\n    return new Rectangle(rect.x, rect.y, rect.width, rect.height);\n};\nexport default Rectangle;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 387, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 393, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/Geometry.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from './Point';\nimport Rectangle from './Rectangle';\nimport { getRotatedPoint, toRadians } from '../../util/mathUtils';\nimport { equalPoints } from '../../util/arrayUtils';\nimport { clone } from '../../util/cloneUtils';\n/**\n * For vertices, the geometry consists of the x- and y-location, and the width\n * and height. For edges, the geometry consists of the optional terminal- and\n * control points. The terminal points are only required if an edge is\n * unconnected, and are stored in the {@link sourcePoint} and {@link targetPoint}\n * variables, respectively.\n *\n * ### Example\n *\n * If an edge is unconnected, that is, it has no source or target terminal,\n * then a geometry with terminal points for a new edge can be defined as\n * follows.\n *\n * ```javascript\n * geometry.setTerminalPoint(new mxPoint(x1, y1), true);\n * geometry.points: [new mxPoint(x2, y2)];\n * geometry.setTerminalPoint(new mxPoint(x3, y3), false);\n * ```\n *\n * Control points are used regardless of the connected state of an edge and may\n * be ignored or interpreted differently depending on the edge's {@link edgeStyle}.\n *\n * To disable automatic reset of control points after a cell has been moved or\n * resized, {@link graph.resetEdgesOnMove} and {@link graph.resetEdgesOnResize} may be used.\n *\n * ### Edge Labels\n *\n * Using the x- and y-coordinates of a cell's geometry, it is possible to\n * position the label on edges on a specific location on the actual edge shape\n * as it appears on the screen. The x-coordinate of an edge's geometry is used\n * to describe the distance from the center of the edge from -1 to 1 with 0\n * being the center of the edge and the default value. The y-coordinate of an\n * edge's geometry is used to describe the absolute, orthogonal distance in\n * pixels from that point. In addition, the {@link Geometry.offset} is used as an\n * absolute offset vector from the resulting point.\n *\n * This coordinate system is applied if {@link relative} is true, otherwise the\n * offset defines the absolute vector from the edge's center point to the\n * label and the values for {@link x} and {@link y} are ignored.\n *\n * The width and height parameter for edge geometries can be used to set the\n * label width and height (eg. for word wrapping).\n *\n * ### Ports\n *\n * The term \"port\" refers to a relatively positioned, connectable child cell,\n * which is used to specify the connection between the parent and another cell\n * in the graph. Ports are typically modeled as vertices with relative\n * geometries.\n *\n * ### Offsets\n *\n * The {@link offset} field is interpreted in 3 different ways, depending on the cell\n * and the geometry. For edges, the offset defines the absolute offset for the\n * edge label. For relative geometries, the offset defines the absolute offset\n * for the origin (top, left corner) of the vertex, otherwise the offset\n * defines the absolute offset for the label inside the vertex or group.\n */\nclass Geometry extends Rectangle {\n    constructor(x = 0, y = 0, width = 0, height = 0) {\n        super(x, y, width, height);\n        /**\n         * Global switch to translate the points in translate. Default is true.\n         */\n        this.TRANSLATE_CONTROL_POINTS = true;\n        /**\n         * Stores alternate values for x, y, width and height in a rectangle.\n         * See {@link swap} to exchange the values. Default is null.\n         *\n         * @see {@link swap}\n         */\n        this.alternateBounds = null;\n        /**\n         * Defines the source {@link Point} of the edge. This is used if the\n         * corresponding edge does not have a source vertex. Otherwise, it is ignored.\n         * @default null\n         */\n        this.sourcePoint = null;\n        /**\n         * Defines the source {@link Point} of the edge. This is used if the\n         * corresponding edge does not have a target vertex. Otherwise, it is ignored.\n         * @default null\n         */\n        this.targetPoint = null;\n        /**\n         * Array of {@link Point} which specifies the control points along the edge.\n         * These points are the intermediate points on the edge, for the endpoints\n         * use {@link targetPoint} and {@link sourcePoint} or set the terminals of the edge to\n         * a non-null value.\n         * @default null\n         */\n        this.points = null;\n        /**\n         * For edges, this holds the offset (in pixels) from the position defined by {@link x} and {@link y} on the edge.\n         *\n         * For relative geometries (for vertices), this defines the absolute offset from the point defined by the relative\n         * coordinates.\n         *\n         * For absolute geometries (for vertices), this defines the offset for the label.\n         * @default null\n         */\n        this.offset = null;\n        /**\n         * Specifies if the coordinates in the geometry are to be interpreted as relative coordinates.\n         *\n         * For edges, this is used to define the location of the edge label relative to the edge\n         * as rendered on the display.\n         *\n         * For vertices, this specifies the relative location inside the bounds of the parent cell.\n         *\n         * If this is `false`, then the coordinates are relative to the origin of the parent cell or,\n         * for edges, the edge label position is relative to the center of the edge as rendered on screen.\n         *\n         * @default false.\n         */\n        this.relative = false;\n    }\n    setRelative(isRelative) {\n        this.relative = isRelative;\n    }\n    /**\n     * Swaps the x, y, width and height with the values stored in\n     * {@link alternateBounds} and puts the previous values into {@link alternateBounds} as\n     * a rectangle. This operation is carried-out in-place, that is, using the\n     * existing geometry instance. If this operation is called during a graph\n     * model transactional change, then the geometry should be cloned before\n     * calling this method and setting the geometry of the cell using\n     * {@link GraphDataModel.setGeometry}.\n     */\n    swap() {\n        if (this.alternateBounds) {\n            const old = new Rectangle(this.x, this.y, this.width, this.height);\n            this.x = this.alternateBounds.x;\n            this.y = this.alternateBounds.y;\n            this.width = this.alternateBounds.width;\n            this.height = this.alternateBounds.height;\n            this.alternateBounds = old;\n        }\n    }\n    /**\n     * Returns the {@link Point} representing the source or target point of this\n     * edge. This is only used if the edge has no source or target vertex.\n     *\n     * @param {Boolean} isSource that specifies if the source or target point should be returned.\n     */\n    getTerminalPoint(isSource) {\n        return isSource ? this.sourcePoint : this.targetPoint;\n    }\n    /**\n     * Sets the {@link sourcePoint} or {@link targetPoint} to the given {@link Point} and\n     * returns the new point.\n     *\n     * @param {Point} point to be used as the new source or target point.\n     * @param {Boolean} isSource that specifies if the source or target point should be set.\n     */\n    setTerminalPoint(point, isSource) {\n        if (isSource) {\n            this.sourcePoint = point;\n        }\n        else {\n            this.targetPoint = point;\n        }\n        return point;\n    }\n    /**\n     * Rotates the geometry by the given angle around the given center. That is,\n     * {@link x} and {@link y} of the geometry, the {@link sourcePoint}, {@link targetPoint} and all\n     * {@link points} are translated by the given amount. {@link x} and {@link y} are only\n     * translated if {@link relative} is false.\n     *\n     * @param {Number} angle that specifies the rotation angle in degrees.\n     * @param {Point} cx   that specifies the center of the rotation.\n     */\n    rotate(angle, cx) {\n        const rad = toRadians(angle);\n        const cos = Math.cos(rad);\n        const sin = Math.sin(rad);\n        // Rotates the geometry\n        if (!this.relative) {\n            const ct = new Point(this.getCenterX(), this.getCenterY());\n            const pt = getRotatedPoint(ct, cos, sin, cx);\n            this.x = Math.round(pt.x - this.width / 2);\n            this.y = Math.round(pt.y - this.height / 2);\n        }\n        // Rotates the source point\n        if (this.sourcePoint) {\n            const pt = getRotatedPoint(this.sourcePoint, cos, sin, cx);\n            this.sourcePoint.x = Math.round(pt.x);\n            this.sourcePoint.y = Math.round(pt.y);\n        }\n        // Translates the target point\n        if (this.targetPoint) {\n            const pt = getRotatedPoint(this.targetPoint, cos, sin, cx);\n            this.targetPoint.x = Math.round(pt.x);\n            this.targetPoint.y = Math.round(pt.y);\n        }\n        // Translate the control points\n        if (this.points) {\n            for (let i = 0; i < this.points.length; i += 1) {\n                if (this.points[i]) {\n                    const pt = getRotatedPoint(this.points[i], cos, sin, cx);\n                    this.points[i].x = Math.round(pt.x);\n                    this.points[i].y = Math.round(pt.y);\n                }\n            }\n        }\n    }\n    /**\n     * Translates the geometry by the specified amount. That is, {@link x} and {@link y} of the\n     * geometry, the {@link sourcePoint}, {@link targetPoint} and all {@link points} are translated\n     * by the given amount. {@link x} and {@link y} are only translated if {@link relative} is false.\n     * If {@link TRANSLATE_CONTROL_POINTS} is false, then {@link points} are not modified by\n     * this function.\n     *\n     * @param {Number} dx that specifies the x-coordinate of the translation.\n     * @param {Number} dy that specifies the y-coordinate of the translation.\n     */\n    translate(dx, dy) {\n        // Translates the geometry\n        if (!this.relative) {\n            this.x += dx;\n            this.y += dy;\n        }\n        // Translates the source point\n        if (this.sourcePoint) {\n            this.sourcePoint.x = this.sourcePoint.x + dx;\n            this.sourcePoint.y = this.sourcePoint.y + dy;\n        }\n        // Translates the target point\n        if (this.targetPoint) {\n            this.targetPoint.x = this.targetPoint.x + dx;\n            this.targetPoint.y = this.targetPoint.y + dy;\n        }\n        // Translate the control points\n        if (this.TRANSLATE_CONTROL_POINTS && this.points) {\n            for (let i = 0; i < this.points.length; i += 1) {\n                if (this.points[i]) {\n                    this.points[i].x = this.points[i].x + dx;\n                    this.points[i].y = this.points[i].y + dy;\n                }\n            }\n        }\n    }\n    /**\n     * Scales the geometry by the given amount. That is, {@link x} and {@link y} of the\n     * geometry, the {@link sourcePoint}, {@link targetPoint} and all {@link points} are scaled\n     * by the given amount. {@link x}, {@link y}, {@link width} and {@link height} are only scaled if\n     * {@link relative} is false. If {@link fixedAspect} is true, then the smaller value\n     * is used to scale the width and the height.\n     *\n     * @param {Number} sx that specifies the horizontal scale factor.\n     * @param {Number} sy that specifies the vertical scale factor.\n     * @param {Optional} fixedAspect boolean to keep the aspect ratio fixed.\n     */\n    scale(sx, sy, fixedAspect) {\n        // Translates the source point\n        if (this.sourcePoint) {\n            this.sourcePoint.x = this.sourcePoint.x * sx;\n            this.sourcePoint.y = this.sourcePoint.y * sy;\n        }\n        // Translates the target point\n        if (this.targetPoint) {\n            this.targetPoint.x = this.targetPoint.x * sx;\n            this.targetPoint.y = this.targetPoint.y * sy;\n        }\n        // Translate the control points\n        if (this.points) {\n            for (let i = 0; i < this.points.length; i += 1) {\n                if (this.points[i]) {\n                    this.points[i].x = this.points[i].x * sx;\n                    this.points[i].y = this.points[i].y * sy;\n                }\n            }\n        }\n        // Translates the geometry\n        if (!this.relative) {\n            this.x *= sx;\n            this.y *= sy;\n            if (fixedAspect) {\n                sy = sx = Math.min(sx, sy);\n            }\n            this.width *= sx;\n            this.height *= sy;\n        }\n    }\n    /**\n     * Returns true if the given object equals this geometry.\n     */\n    equals(geom) {\n        if (!geom)\n            return false;\n        return (super.equals(geom) &&\n            this.relative === geom.relative &&\n            ((this.sourcePoint === null && geom.sourcePoint === null) ||\n                !!this.sourcePoint?.equals(geom.sourcePoint)) &&\n            ((this.targetPoint === null && geom.targetPoint === null) ||\n                !!this.targetPoint?.equals(geom.targetPoint)) &&\n            equalPoints(this.points, geom.points) &&\n            ((this.alternateBounds === null && geom.alternateBounds === null) ||\n                !!this.alternateBounds?.equals(geom.alternateBounds)) &&\n            ((this.offset === null && geom.offset === null) ||\n                !!this.offset?.equals(geom.offset)));\n    }\n    clone() {\n        return clone(this);\n    }\n}\nexport default Geometry;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AAEA;AACA;AAFA;AAGA;AACA;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyDC,GACD,MAAM,iBAAiB,0KAAA,CAAA,UAAS;IAC5B,YAAY,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,QAAQ,CAAC,EAAE,SAAS,CAAC,CAAE;QAC7C,KAAK,CAAC,GAAG,GAAG,OAAO;QACnB;;SAEC,GACD,IAAI,CAAC,wBAAwB,GAAG;QAChC;;;;;SAKC,GACD,IAAI,CAAC,eAAe,GAAG;QACvB;;;;SAIC,GACD,IAAI,CAAC,WAAW,GAAG;QACnB;;;;SAIC,GACD,IAAI,CAAC,WAAW,GAAG;QACnB;;;;;;SAMC,GACD,IAAI,CAAC,MAAM,GAAG;QACd;;;;;;;;SAQC,GACD,IAAI,CAAC,MAAM,GAAG;QACd;;;;;;;;;;;;SAYC,GACD,IAAI,CAAC,QAAQ,GAAG;IACpB;IACA,YAAY,UAAU,EAAE;QACpB,IAAI,CAAC,QAAQ,GAAG;IACpB;IACA;;;;;;;;KAQC,GACD,OAAO;QACH,IAAI,IAAI,CAAC,eAAe,EAAE;YACtB,MAAM,MAAM,IAAI,0KAAA,CAAA,UAAS,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM;YACjE,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC;YAC/B,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC;YAC/B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK;YACvC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM;YACzC,IAAI,CAAC,eAAe,GAAG;QAC3B;IACJ;IACA;;;;;KAKC,GACD,iBAAiB,QAAQ,EAAE;QACvB,OAAO,WAAW,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW;IACzD;IACA;;;;;;KAMC,GACD,iBAAiB,KAAK,EAAE,QAAQ,EAAE;QAC9B,IAAI,UAAU;YACV,IAAI,CAAC,WAAW,GAAG;QACvB,OACK;YACD,IAAI,CAAC,WAAW,GAAG;QACvB;QACA,OAAO;IACX;IACA;;;;;;;;KAQC,GACD,OAAO,KAAK,EAAE,EAAE,EAAE;QACd,MAAM,MAAM,CAAA,GAAA,8JAAA,CAAA,YAAS,AAAD,EAAE;QACtB,MAAM,MAAM,KAAK,GAAG,CAAC;QACrB,MAAM,MAAM,KAAK,GAAG,CAAC;QACrB,uBAAuB;QACvB,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAChB,MAAM,KAAK,IAAI,sKAAA,CAAA,UAAK,CAAC,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,UAAU;YACvD,MAAM,KAAK,CAAA,GAAA,8JAAA,CAAA,kBAAe,AAAD,EAAE,IAAI,KAAK,KAAK;YACzC,IAAI,CAAC,CAAC,GAAG,KAAK,KAAK,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG;YACxC,IAAI,CAAC,CAAC,GAAG,KAAK,KAAK,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG;QAC7C;QACA,2BAA2B;QAC3B,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,MAAM,KAAK,CAAA,GAAA,8JAAA,CAAA,kBAAe,AAAD,EAAE,IAAI,CAAC,WAAW,EAAE,KAAK,KAAK;YACvD,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,KAAK,KAAK,CAAC,GAAG,CAAC;YACpC,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,KAAK,KAAK,CAAC,GAAG,CAAC;QACxC;QACA,8BAA8B;QAC9B,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,MAAM,KAAK,CAAA,GAAA,8JAAA,CAAA,kBAAe,AAAD,EAAE,IAAI,CAAC,WAAW,EAAE,KAAK,KAAK;YACvD,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,KAAK,KAAK,CAAC,GAAG,CAAC;YACpC,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,KAAK,KAAK,CAAC,GAAG,CAAC;QACxC;QACA,+BAA+B;QAC/B,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,EAAG;gBAC5C,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE;oBAChB,MAAM,KAAK,CAAA,GAAA,8JAAA,CAAA,kBAAe,AAAD,EAAE,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE,KAAK,KAAK;oBACrD,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG,KAAK,KAAK,CAAC,GAAG,CAAC;oBAClC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG,KAAK,KAAK,CAAC,GAAG,CAAC;gBACtC;YACJ;QACJ;IACJ;IACA;;;;;;;;;KASC,GACD,UAAU,EAAE,EAAE,EAAE,EAAE;QACd,0BAA0B;QAC1B,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAChB,IAAI,CAAC,CAAC,IAAI;YACV,IAAI,CAAC,CAAC,IAAI;QACd;QACA,8BAA8B;QAC9B,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG;YAC1C,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG;QAC9C;QACA,8BAA8B;QAC9B,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG;YAC1C,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG;QAC9C;QACA,+BAA+B;QAC/B,IAAI,IAAI,CAAC,wBAAwB,IAAI,IAAI,CAAC,MAAM,EAAE;YAC9C,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,EAAG;gBAC5C,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE;oBAChB,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG;oBACtC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG;gBAC1C;YACJ;QACJ;IACJ;IACA;;;;;;;;;;KAUC,GACD,MAAM,EAAE,EAAE,EAAE,EAAE,WAAW,EAAE;QACvB,8BAA8B;QAC9B,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG;YAC1C,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG;QAC9C;QACA,8BAA8B;QAC9B,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG;YAC1C,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG;QAC9C;QACA,+BAA+B;QAC/B,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,EAAG;gBAC5C,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE;oBAChB,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG;oBACtC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG;gBAC1C;YACJ;QACJ;QACA,0BAA0B;QAC1B,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAChB,IAAI,CAAC,CAAC,IAAI;YACV,IAAI,CAAC,CAAC,IAAI;YACV,IAAI,aAAa;gBACb,KAAK,KAAK,KAAK,GAAG,CAAC,IAAI;YAC3B;YACA,IAAI,CAAC,KAAK,IAAI;YACd,IAAI,CAAC,MAAM,IAAI;QACnB;IACJ;IACA;;KAEC,GACD,OAAO,IAAI,EAAE;QACT,IAAI,CAAC,MACD,OAAO;QACX,OAAQ,KAAK,CAAC,OAAO,SACjB,IAAI,CAAC,QAAQ,KAAK,KAAK,QAAQ,IAC/B,CAAC,AAAC,IAAI,CAAC,WAAW,KAAK,QAAQ,KAAK,WAAW,KAAK,QAChD,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,OAAO,KAAK,WAAW,CAAC,KAChD,CAAC,AAAC,IAAI,CAAC,WAAW,KAAK,QAAQ,KAAK,WAAW,KAAK,QAChD,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,OAAO,KAAK,WAAW,CAAC,KAChD,CAAA,GAAA,+JAAA,CAAA,cAAW,AAAD,EAAE,IAAI,CAAC,MAAM,EAAE,KAAK,MAAM,KACpC,CAAC,AAAC,IAAI,CAAC,eAAe,KAAK,QAAQ,KAAK,eAAe,KAAK,QACxD,CAAC,CAAC,IAAI,CAAC,eAAe,EAAE,OAAO,KAAK,eAAe,CAAC,KACxD,CAAC,AAAC,IAAI,CAAC,MAAM,KAAK,QAAQ,KAAK,MAAM,KAAK,QACtC,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,KAAK,MAAM,CAAC;IAC9C;IACA,QAAQ;QACJ,OAAO,CAAA,GAAA,+JAAA,CAAA,QAAK,AAAD,EAAE,IAAI;IACrB;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 703, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 709, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/Shape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from './Rectangle';\nimport { isNotNullish } from '../../util/Utils';\nimport { getBoundingBox, getDirectedBounds, mod } from '../../util/mathUtils';\nimport { DIRECTION, LINE_ARCSIZE, NONE, NS_SVG, RECTANGLE_ROUNDING_FACTOR, } from '../../util/Constants';\nimport Point from './Point';\nimport SvgCanvas2D from '../canvas/SvgCanvas2D';\nimport InternalEvent from '../event/InternalEvent';\nimport Client from '../../Client';\nimport { StyleDefaultsConfig } from '../../util/config';\n/**\n * Base class for all shapes.\n * A shape in mxGraph is a separate implementation for SVG, VML and HTML.\n * Which implementation to use is controlled by the dialect property which\n * is assigned from within the mxCellRenderer when the shape is created.\n * The dialect must be assigned for a shape, and it does normally depend on\n * the browser and the configuration of the graph (see mxGraph rendering hint).\n *\n * For each supported shape in SVG and VML, a corresponding shape exists in\n * mxGraph, namely for text, image, rectangle, rhombus, ellipse and polyline.\n * The other shapes are a combination of these shapes (eg. label and swimlane)\n * or they consist of one or more (filled) path objects (eg. actor and cylinder).\n * The HTML implementation is optional but may be required for a HTML-only view\n * of the graph.\n *\n * ### Custom Shapes\n * To extend from this class, the basic code looks as follows.\n * In the special case where the custom shape consists only of one filled region\n * or one filled region and an additional stroke the mxActor and mxCylinder\n * should be subclassed, respectively.\n * ```javascript\n * function CustomShape() { }\n *\n * CustomShape.prototype = new mxShape();\n * CustomShape.prototype.constructor = CustomShape;\n * ```\n * To register a custom shape in an existing graph instance, one must register the\n * shape under a new name in the graph’s cell renderer as follows:\n * ```javascript\n * mxCellRenderer.registerShape('customShape', CustomShape);\n * ```\n * The second argument is the name of the constructor.\n * In order to use the shape you can refer to the given name above in a stylesheet.\n * For example, to change the shape for the default vertex style, the following code\n * is used:\n * ```javascript\n * var style = graph.getStylesheet().getDefaultVertexStyle();\n * style.shape = 'customShape';\n * ```\n */\nclass Shape {\n    constructor(stencil = null) {\n        // Assigned in mxCellRenderer\n        this.preserveImageAspect = false;\n        this.overlay = null;\n        this.indicator = null;\n        this.indicatorShape = null;\n        // Assigned in mxCellHighlight\n        this.opacity = 100;\n        this.isDashed = false;\n        this.fill = NONE;\n        this.gradient = NONE;\n        this.gradientDirection = DIRECTION.EAST;\n        this.fillOpacity = 100;\n        this.strokeOpacity = 100;\n        this.stroke = NONE;\n        this.strokeWidth = 1;\n        this.spacing = 0;\n        this.startSize = 1;\n        this.endSize = 1;\n        this.startArrow = NONE;\n        this.endArrow = NONE;\n        this.direction = DIRECTION.EAST;\n        this.flipH = false;\n        this.flipV = false;\n        this.isShadow = false;\n        this.isRounded = false;\n        this.rotation = 0;\n        this.cursor = '';\n        this.verticalTextRotation = 0;\n        this.oldGradients = {};\n        this.glass = false;\n        /**\n         * Holds the dialect in which the shape is to be painted.\n         * This can be one of the DIALECT constants in {@link Constants}.\n         */\n        this.dialect = null;\n        /**\n         * Holds the scale in which the shape is being painted.\n         */\n        this.scale = 1;\n        /**\n         * Rendering hint for configuring the canvas.\n         */\n        this.antiAlias = true;\n        /**\n         * Minimum stroke width for SVG output.\n         */\n        this.minSvgStrokeWidth = 1;\n        /**\n         * Holds the {@link Rectangle} that specifies the bounds of this shape.\n         */\n        this.bounds = null;\n        /**\n         * Holds the array of <Point> that specify the points of this shape.\n         */\n        this.points = [];\n        /**\n         * Optional reference to the corresponding <CellState>.\n         */\n        this.state = null;\n        /**\n         * Optional reference to the style of the corresponding <CellState>.\n         */\n        this.style = null;\n        /**\n         * Contains the bounding box of the shape, that is, the smallest rectangle\n         * that includes all pixels of the shape.\n         */\n        this.boundingBox = null;\n        /**\n         * Holds the {@link StencilShape} that defines the shape.\n         */\n        this.stencil = null;\n        /**\n         * Event-tolerance for SVG strokes (in px).\n         * This is only passed to the canvas in {@link createSvgCanvas} if {@link pointerEvents} is `true`.\n         * @default 8\n         */\n        this.svgStrokeTolerance = 8;\n        /**\n         * Specifies if pointer events should be handled. Default is true.\n         */\n        this.pointerEvents = true;\n        this.originalPointerEvents = null;\n        /**\n         * Specifies if pointer events should be handled. Default is true.\n         */\n        this.svgPointerEvents = 'all';\n        /**\n         * Specifies if pointer events outside of shape should be handled. Default\n         * is false.\n         */\n        this.shapePointerEvents = false;\n        /**\n         * Specifies if pointer events outside of stencils should be handled. Default\n         * is false. Set this to true for backwards compatibility with the 1.x branch.\n         */\n        this.stencilPointerEvents = false;\n        /**\n         * Specifies if the shape should be drawn as an outline. This disables all\n         * fill colors and can be used to disable other drawing states that should\n         * not be painted for outlines. Default is false. This should be set before\n         * calling <apply>.\n         */\n        this.outline = false;\n        /**\n         * Specifies if the shape is visible. Default is true.\n         */\n        this.visible = true;\n        /**\n         * Allows to use the SVG bounding box in SVG. Default is false for performance\n         * reasons.\n         */\n        this.useSvgBoundingBox = true;\n        this.image = null;\n        this.imageSrc = null;\n        this.indicatorColor = NONE;\n        this.indicatorStrokeColor = NONE;\n        this.indicatorGradientColor = NONE;\n        this.indicatorDirection = DIRECTION.EAST;\n        this.indicatorImageSrc = null;\n        // `stencil` is not null when instantiated directly,\n        // but can be null when instantiated through a child class.\n        if (stencil) {\n            this.stencil = stencil;\n        }\n        // moved from init()\n        this.node = this.create();\n    }\n    /**\n     * Initializes the shape by creaing the DOM node using <create>\n     * and adding it into the given container.\n     *\n     * @param container DOM node that will contain the shape.\n     */\n    init(container) {\n        if (!this.node.parentNode) {\n            container.appendChild(this.node);\n        }\n    }\n    /**\n     * Sets the styles to their default values.\n     */\n    initStyles() {\n        this.strokeWidth = 1;\n        this.rotation = 0;\n        this.opacity = 100;\n        this.fillOpacity = 100;\n        this.strokeOpacity = 100;\n        this.flipH = false;\n        this.flipV = false;\n    }\n    /**\n     * Returns true if HTML is allowed for this shape. This implementation always\n     * returns false.\n     */\n    isHtmlAllowed() {\n        return false;\n    }\n    /**\n     * Returns 0, or 0.5 if <strokewidth> % 2 == 1.\n     */\n    getSvgScreenOffset() {\n        const sw = this.stencil && this.stencil.strokeWidthValue !== 'inherit'\n            ? Number(this.stencil.strokeWidthValue)\n            : this.strokeWidth ?? 0;\n        return mod(Math.max(1, Math.round(sw * this.scale)), 2) === 1 ? 0.5 : 0;\n    }\n    /**\n     * Creates and returns the DOM node for the shape.\n     * This implementation assumes that `maxGraph` produces SVG elements.\n     */\n    create() {\n        return document.createElementNS(NS_SVG, 'g');\n    }\n    redraw() {\n        this.updateBoundsFromPoints();\n        if (this.visible && this.checkBounds()) {\n            this.node.style.visibility = 'visible';\n            this.clear();\n            this.redrawShape();\n            this.updateBoundingBox();\n        }\n        else {\n            this.node.style.visibility = 'hidden';\n            this.boundingBox = null;\n        }\n    }\n    /**\n     * Removes all child nodes and resets all CSS.\n     */\n    clear() {\n        while (this.node.lastChild) {\n            this.node.removeChild(this.node.lastChild);\n        }\n    }\n    /**\n     * Updates the bounds based on the points.\n     */\n    updateBoundsFromPoints() {\n        const pts = this.points;\n        if (pts.length > 0 && pts[0]) {\n            this.bounds = new Rectangle(Math.round(pts[0].x), Math.round(pts[0].y), 1, 1);\n            for (const pt of pts) {\n                if (pt) {\n                    this.bounds.add(new Rectangle(Math.round(pt.x), Math.round(pt.y), 1, 1));\n                }\n            }\n        }\n    }\n    /**\n     * Returns the {@link Rectangle} for the label bounds of this shape, based on the\n     * given scaled and translated bounds of the shape. This method should not\n     * change the rectangle in-place. This implementation returns the given rect.\n     */\n    getLabelBounds(rect) {\n        const d = this.style?.direction ?? DIRECTION.EAST;\n        let bounds = rect.clone();\n        // Normalizes argument for getLabelMargins hook\n        if (d !== DIRECTION.SOUTH &&\n            d !== DIRECTION.NORTH &&\n            this.state &&\n            this.state.text &&\n            this.state.text.isPaintBoundsInverted()) {\n            bounds = bounds.clone();\n            [bounds.width, bounds.height] = [bounds.height, bounds.width];\n        }\n        let labelMargins = this.getLabelMargins(bounds);\n        if (labelMargins) {\n            labelMargins = labelMargins.clone();\n            let flipH = this.style?.flipH ?? false;\n            let flipV = this.style?.flipV ?? false;\n            // Handles special case for vertical labels\n            if (this.state && this.state.text && this.state.text.isPaintBoundsInverted()) {\n                const tmp = labelMargins.x;\n                labelMargins.x = labelMargins.height;\n                labelMargins.height = labelMargins.width;\n                labelMargins.width = labelMargins.y;\n                labelMargins.y = tmp;\n                [flipH, flipV] = [flipV, flipH];\n            }\n            return getDirectedBounds(rect, labelMargins, this.style, flipH, flipV);\n        }\n        return rect;\n    }\n    /**\n     * Returns the scaled top, left, bottom and right margin to be used for\n     * computing the label bounds as an {@link Rectangle}, where the bottom and right\n     * margin are defined in the width and height of the rectangle, respectively.\n     */\n    getLabelMargins(rect) {\n        return null;\n    }\n    /**\n     * Returns true if the bounds are not null and all of its variables are numeric.\n     */\n    checkBounds() {\n        return (!Number.isNaN(this.scale) &&\n            Number.isFinite(this.scale) &&\n            this.scale > 0 &&\n            this.bounds &&\n            !Number.isNaN(this.bounds.x) &&\n            !Number.isNaN(this.bounds.y) &&\n            !Number.isNaN(this.bounds.width) &&\n            !Number.isNaN(this.bounds.height) &&\n            this.bounds.width > 0 &&\n            this.bounds.height > 0);\n    }\n    /**\n     * Updates the SVG or VML shape.\n     */\n    redrawShape() {\n        const canvas = this.createCanvas();\n        if (canvas) {\n            // Specifies if events should be handled\n            canvas.pointerEvents = this.pointerEvents;\n            this.beforePaint(canvas);\n            this.paint(canvas);\n            this.afterPaint(canvas);\n            if (this.node !== canvas.root && canvas.root) {\n                // Forces parsing in IE8 standards mode - slow! avoid\n                this.node.insertAdjacentHTML('beforeend', canvas.root.outerHTML);\n            }\n            this.destroyCanvas(canvas);\n        }\n    }\n    /**\n     * Creates a new canvas for drawing this shape. May return null.\n     */\n    createCanvas() {\n        const canvas = this.createSvgCanvas();\n        if (canvas && this.outline) {\n            canvas.setStrokeWidth(this.strokeWidth);\n            canvas.setStrokeColor(this.stroke);\n            if (this.isDashed) {\n                canvas.setDashed(this.isDashed);\n            }\n            canvas.setStrokeWidth = () => {\n                return;\n            };\n            canvas.setStrokeColor = () => {\n                return;\n            };\n            canvas.setFillColor = () => {\n                return;\n            };\n            canvas.setGradient = () => {\n                return;\n            };\n            canvas.setDashed = () => {\n                return;\n            };\n            canvas.text = () => {\n                return;\n            };\n        }\n        return canvas;\n    }\n    /**\n     * Creates and returns an {@link SvgCanvas2D} for rendering this shape.\n     */\n    createSvgCanvas() {\n        if (!this.node)\n            return null;\n        const canvas = new SvgCanvas2D(this.node, false);\n        canvas.strokeTolerance = this.pointerEvents ? this.svgStrokeTolerance : 0;\n        canvas.pointerEventsValue = this.svgPointerEvents;\n        const off = this.getSvgScreenOffset();\n        if (off !== 0) {\n            this.node.setAttribute('transform', `translate(${off},${off})`);\n        }\n        else {\n            this.node.removeAttribute('transform');\n        }\n        canvas.minStrokeWidth = this.minSvgStrokeWidth;\n        if (!this.antiAlias) {\n            // Rounds all numbers in the SVG output to integers\n            canvas.format = (value) => {\n                return Math.round(value);\n            };\n        }\n        return canvas;\n    }\n    /**\n     * Destroys the given canvas which was used for drawing. This implementation\n     * increments the reference counts on all shared gradients used in the canvas.\n     */\n    destroyCanvas(canvas) {\n        // Manages reference counts\n        if (canvas instanceof SvgCanvas2D) {\n            // Increments ref counts\n            for (const key in canvas.gradients) {\n                const gradient = canvas.gradients[key];\n                if (gradient) {\n                    gradient.mxRefCount = (gradient.mxRefCount || 0) + 1;\n                }\n            }\n            this.releaseSvgGradients(this.oldGradients);\n            this.oldGradients = canvas.gradients;\n        }\n    }\n    /**\n     * Invoked before paint is called.\n     */\n    beforePaint(c) {\n        return;\n    }\n    /**\n     * Invokes after paint was called.\n     */\n    afterPaint(c) {\n        return;\n    }\n    /**\n     * Generic rendering code.\n     */\n    paint(c) {\n        let strokeDrawn = false;\n        if (c && this.outline) {\n            const { stroke } = c;\n            c.stroke = (...args) => {\n                strokeDrawn = true;\n                stroke.apply(c, args);\n            };\n            const { fillAndStroke } = c;\n            c.fillAndStroke = (...args) => {\n                strokeDrawn = true;\n                fillAndStroke.apply(c, args);\n            };\n        }\n        // Scale is passed-through to canvas\n        const s = this.scale;\n        const bounds = this.bounds;\n        if (bounds) {\n            let x = bounds.x / s;\n            let y = bounds.y / s;\n            let w = bounds.width / s;\n            let h = bounds.height / s;\n            if (this.isPaintBoundsInverted()) {\n                const t = (w - h) / 2;\n                x += t;\n                y -= t;\n                const tmp = w;\n                w = h;\n                h = tmp;\n            }\n            this.updateTransform(c, x, y, w, h);\n            this.configureCanvas(c, x, y, w, h);\n            // Adds background rectangle to capture events\n            let bg = null;\n            if ((!this.stencil && this.points.length === 0 && this.shapePointerEvents) ||\n                (this.stencil && this.stencilPointerEvents)) {\n                const bb = this.createBoundingBox();\n                if (bb && this.node) {\n                    bg = this.createTransparentSvgRectangle(bb.x, bb.y, bb.width, bb.height);\n                    this.node.appendChild(bg);\n                }\n            }\n            if (this.stencil) {\n                this.stencil.drawShape(c, this, x, y, w, h);\n            }\n            else {\n                // Stencils have separate strokewidth\n                c.setStrokeWidth(this.strokeWidth);\n                if (this.points.length > 0) {\n                    // Paints edge shape\n                    const pts = [];\n                    for (let i = 0; i < this.points.length; i += 1) {\n                        const p = this.points[i];\n                        if (p) {\n                            pts.push(new Point(p.x / s, p.y / s));\n                        }\n                    }\n                    this.paintEdgeShape(c, pts);\n                }\n                else {\n                    // Paints vertex shape\n                    this.paintVertexShape(c, x, y, w, h);\n                }\n            }\n            if (bg && c.state && isNotNullish(c.state.transform)) {\n                bg.setAttribute('transform', c.state.transform);\n            }\n            // Draws highlight rectangle if no stroke was used\n            if (c && this.outline && !strokeDrawn) {\n                c.rect(x, y, w, h);\n                c.stroke();\n            }\n        }\n    }\n    /**\n     * Sets the state of the canvas for drawing the shape.\n     */\n    configureCanvas(c, x, y, w, h) {\n        let dash = null;\n        if (this.style && this.style.dashPattern != null) {\n            dash = this.style.dashPattern;\n        }\n        c.setAlpha(this.opacity / 100);\n        c.setFillAlpha(this.fillOpacity / 100);\n        c.setStrokeAlpha(this.strokeOpacity / 100);\n        // Sets alpha, colors and gradients\n        if (this.isShadow) {\n            c.setShadow(this.isShadow);\n        }\n        // Dash pattern\n        if (this.isDashed) {\n            c.setDashed(this.isDashed, this.style?.fixDash ?? false);\n        }\n        if (dash) {\n            c.setDashPattern(dash);\n        }\n        if (this.fill !== NONE && this.gradient !== NONE) {\n            const b = this.getGradientBounds(c, x, y, w, h);\n            c.setGradient(this.fill, this.gradient, b.x, b.y, b.width, b.height, this.gradientDirection);\n        }\n        else {\n            c.setFillColor(this.fill);\n        }\n        c.setStrokeColor(this.stroke);\n    }\n    /**\n     * Returns the bounding box for the gradient box for this shape.\n     */\n    getGradientBounds(c, x, y, w, h) {\n        return new Rectangle(x, y, w, h);\n    }\n    /**\n     * Sets the scale and rotation on the given canvas.\n     */\n    updateTransform(c, x, y, w, h) {\n        // NOTE: Currently, scale is implemented in state and canvas. This will\n        // move to canvas in a later version, so that the states are unscaled\n        // and untranslated and do not need an update after zooming or panning.\n        c.scale(this.scale);\n        c.rotate(this.getShapeRotation(), this.flipH, this.flipV, x + w / 2, y + h / 2);\n    }\n    /**\n     * Paints the vertex shape.\n     */\n    paintVertexShape(c, x, y, w, h) {\n        this.paintBackground(c, x, y, w, h);\n        if (!this.outline || !this.style || !(this.style.backgroundOutline ?? false)) {\n            c.setShadow(false);\n            this.paintForeground(c, x, y, w, h);\n        }\n    }\n    /**\n     * Hook for subclassers. This implementation is empty.\n     */\n    paintBackground(c, x, y, w, h) {\n        return;\n    }\n    /**\n     * Hook for subclassers. This implementation is empty.\n     */\n    paintForeground(c, x, y, w, h) {\n        return;\n    }\n    /**\n     * Hook for subclassers. This implementation is empty.\n     */\n    paintEdgeShape(c, pts) {\n        return;\n    }\n    /**\n     * Returns the arc size for the given dimension.\n     */\n    getArcSize(w, h) {\n        let r = 0;\n        if (this.style?.absoluteArcSize ?? false) {\n            r = Math.min(w / 2, Math.min(h / 2, (this.style?.arcSize ?? LINE_ARCSIZE) / 2));\n        }\n        else {\n            const f = (this.style?.arcSize ?? RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n            r = Math.min(w * f, h * f);\n        }\n        return r;\n    }\n    /**\n     * Paints the glass gradient effect.\n     */\n    paintGlassEffect(c, x, y, w, h, arc) {\n        const sw = Math.ceil((this.strokeWidth ?? 0) / 2);\n        const size = 0.4;\n        c.setGradient('#ffffff', '#ffffff', x, y, w, h * 0.6, 'south', 0.9, 0.1);\n        c.begin();\n        arc += 2 * sw;\n        if (this.isRounded) {\n            c.moveTo(x - sw + arc, y - sw);\n            c.quadTo(x - sw, y - sw, x - sw, y - sw + arc);\n            c.lineTo(x - sw, y + h * size);\n            c.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);\n            c.lineTo(x + w + sw, y - sw + arc);\n            c.quadTo(x + w + sw, y - sw, x + w + sw - arc, y - sw);\n        }\n        else {\n            c.moveTo(x - sw, y - sw);\n            c.lineTo(x - sw, y + h * size);\n            c.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);\n            c.lineTo(x + w + sw, y - sw);\n        }\n        c.close();\n        c.fill();\n    }\n    /**\n     * Paints the given points with rounded corners.\n     */\n    addPoints(c, pts, rounded = false, arcSize, close = false, exclude = [], initialMove = true) {\n        if (pts.length > 0) {\n            const pe = pts[pts.length - 1];\n            // Adds virtual waypoint in the center between start and end point\n            if (close && rounded) {\n                pts = pts.slice();\n                const p0 = pts[0];\n                const wp = new Point(pe.x + (p0.x - pe.x) / 2, pe.y + (p0.y - pe.y) / 2);\n                pts.splice(0, 0, wp);\n            }\n            let pt = pts[0];\n            let i = 1;\n            // Draws the line segments\n            if (initialMove) {\n                c.moveTo(pt.x, pt.y);\n            }\n            else {\n                c.lineTo(pt.x, pt.y);\n            }\n            while (i < (close ? pts.length : pts.length - 1)) {\n                let tmp = pts[mod(i, pts.length)];\n                let dx = pt.x - tmp.x;\n                let dy = pt.y - tmp.y;\n                if (rounded && (dx !== 0 || dy !== 0) && exclude.indexOf(i - 1) < 0) {\n                    // Draws a line from the last point to the current\n                    // point with a spacing of size off the current point\n                    // into direction of the last point\n                    let dist = Math.sqrt(dx * dx + dy * dy);\n                    const nx1 = (dx * Math.min(arcSize, dist / 2)) / dist;\n                    const ny1 = (dy * Math.min(arcSize, dist / 2)) / dist;\n                    const x1 = tmp.x + nx1;\n                    const y1 = tmp.y + ny1;\n                    c.lineTo(x1, y1);\n                    // Draws a curve from the last point to the current\n                    // point with a spacing of size off the current point\n                    // into direction of the next point\n                    let next = pts[mod(i + 1, pts.length)];\n                    // Uses next non-overlapping point\n                    while (i < pts.length - 2 &&\n                        Math.round(next.x - tmp.x) === 0 &&\n                        Math.round(next.y - tmp.y) === 0) {\n                        next = pts[mod(i + 2, pts.length)];\n                        i++;\n                    }\n                    dx = next.x - tmp.x;\n                    dy = next.y - tmp.y;\n                    dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n                    const nx2 = (dx * Math.min(arcSize, dist / 2)) / dist;\n                    const ny2 = (dy * Math.min(arcSize, dist / 2)) / dist;\n                    const x2 = tmp.x + nx2;\n                    const y2 = tmp.y + ny2;\n                    c.quadTo(tmp.x, tmp.y, x2, y2);\n                    tmp = new Point(x2, y2);\n                }\n                else {\n                    c.lineTo(tmp.x, tmp.y);\n                }\n                pt = tmp;\n                i += 1;\n            }\n            if (close) {\n                c.close();\n            }\n            else {\n                c.lineTo(pe.x, pe.y);\n            }\n        }\n    }\n    /**\n     * Resets all styles.\n     */\n    resetStyles() {\n        this.initStyles();\n        this.spacing = 0;\n        this.fill = NONE;\n        this.gradient = NONE;\n        this.gradientDirection = DIRECTION.EAST;\n        this.stroke = NONE;\n        this.startSize = 1;\n        this.endSize = 1;\n        this.startArrow = NONE;\n        this.endArrow = NONE;\n        this.direction = DIRECTION.EAST;\n        this.isShadow = false;\n        this.isDashed = false;\n        this.isRounded = false;\n        this.glass = false;\n    }\n    /**\n     * Applies the style of the given <CellState> to the shape. This\n     * implementation assigns the following styles to local fields:\n     *\n     * - <'fillColor'> => fill\n     * - <'gradientColor'> => gradient\n     * - <'gradientDirection'> => gradientDirection\n     * - <'opacity'> => opacity\n     * - {@link Constants#STYLE_FILL_OPACITY} => fillOpacity\n     * - {@link Constants#STYLE_STROKE_OPACITY} => strokeOpacity\n     * - <'strokeColor'> => stroke\n     * - <'strokeWidth'> => strokewidth\n     * - <'shadow'> => isShadow\n     * - <'dashed'> => isDashed\n     * - <'spacing'> => spacing\n     * - <'startSize'> => startSize\n     * - <'endSize'> => endSize\n     * - <'rounded'> => isRounded\n     * - <'startArrow'> => startArrow\n     * - <'endArrow'> => endArrow\n     * - <'rotation'> => rotation\n     * - <'direction'> => direction\n     * - <'glass'> => glass\n     *\n     * This keeps a reference to the <style>. If you need to keep a reference to\n     * the cell, you can override this method and store a local reference to\n     * state.cell or the <CellState> itself. If <outline> should be true, make\n     * sure to set it before calling this method.\n     *\n     * @param state <CellState> of the corresponding cell.\n     */\n    apply(state) {\n        this.state = state;\n        this.style = state.style;\n        if (this.style) {\n            this.fill = this.style.fillColor ?? this.fill;\n            this.gradient = this.style.gradientColor ?? this.gradient;\n            this.gradientDirection = this.style.gradientDirection ?? this.gradientDirection;\n            this.opacity = this.style.opacity ?? this.opacity;\n            this.fillOpacity = this.style.fillOpacity ?? this.fillOpacity;\n            this.strokeOpacity = this.style.strokeOpacity ?? this.strokeOpacity;\n            this.stroke = this.style.strokeColor ?? this.stroke;\n            this.strokeWidth = this.style.strokeWidth ?? this.strokeWidth;\n            this.spacing = this.style.spacing ?? this.spacing;\n            this.startSize = this.style.startSize ?? this.startSize;\n            this.endSize = this.style.endSize ?? this.endSize;\n            this.startArrow = this.style.startArrow ?? this.startArrow;\n            this.endArrow = this.style.endArrow ?? this.endArrow;\n            this.rotation = this.style.rotation ?? this.rotation;\n            this.direction = this.style.direction ?? this.direction;\n            this.flipH = !!this.style.flipH;\n            this.flipV = !!this.style.flipV;\n            if (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH) {\n                const tmp = this.flipH;\n                this.flipH = this.flipV;\n                this.flipV = tmp;\n            }\n            this.isShadow = this.style.shadow ?? this.isShadow;\n            this.isDashed = this.style.dashed ?? this.isDashed;\n            this.isRounded = this.style.rounded ?? this.isRounded;\n            this.glass = this.style.glass ?? this.glass;\n        }\n    }\n    /**\n     * Sets the cursor on the given shape.\n     *\n     * @param cursor The cursor to be used.\n     */\n    setCursor(cursor) {\n        this.cursor = cursor;\n        this.node.style.cursor = cursor;\n    }\n    /**\n     * Returns the current cursor.\n     */\n    getCursor() {\n        return this.cursor;\n    }\n    /**\n     * Hook for subclassers.\n     */\n    isRoundable(c, x, y, w, h) {\n        return false;\n    }\n    /**\n     * Updates the <boundingBox> for this shape using <createBoundingBox> and\n     * <augmentBoundingBox> and stores the result in <boundingBox>.\n     */\n    updateBoundingBox() {\n        // Tries to get bounding box from SVG subsystem\n        // LATER: Use getBoundingClientRect for fallback in VML\n        if (this.useSvgBoundingBox && this.node.ownerSVGElement) {\n            try {\n                const b = this.node.getBBox();\n                if (b.width > 0 && b.height > 0) {\n                    this.boundingBox = new Rectangle(b.x, b.y, b.width, b.height);\n                    // Adds strokeWidth\n                    this.boundingBox.grow(((this.strokeWidth ?? 0) * this.scale) / 2);\n                    return;\n                }\n            }\n            catch (e) {\n                // fallback to code below\n            }\n        }\n        if (this.bounds) {\n            let bbox = this.createBoundingBox();\n            if (bbox) {\n                this.augmentBoundingBox(bbox);\n                const rot = this.getShapeRotation();\n                if (rot !== 0) {\n                    bbox = getBoundingBox(bbox, rot);\n                }\n            }\n            this.boundingBox = bbox;\n        }\n    }\n    /**\n     * Returns a new rectangle that represents the bounding box of the bare shape\n     * with no shadows or strokewidths.\n     */\n    createBoundingBox() {\n        if (!this.bounds)\n            return null;\n        const bb = this.bounds.clone();\n        if ((this.stencil &&\n            (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH)) ||\n            this.isPaintBoundsInverted()) {\n            bb.rotate90();\n        }\n        return bb;\n    }\n    /**\n     * Augments the bounding box with the strokewidth and shadow offsets.\n     */\n    augmentBoundingBox(bbox) {\n        if (this.isShadow) {\n            bbox.width += Math.ceil(StyleDefaultsConfig.shadowOffsetX * this.scale);\n            bbox.height += Math.ceil(StyleDefaultsConfig.shadowOffsetX * this.scale);\n        }\n        // Adds strokeWidth\n        bbox.grow(((this.strokeWidth ?? 0) * this.scale) / 2);\n    }\n    /**\n     * Returns true if the bounds should be inverted.\n     */\n    isPaintBoundsInverted() {\n        // Stencil implements inversion via aspect\n        return (!this.stencil &&\n            (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH));\n    }\n    /**\n     * Returns the rotation from the style.\n     */\n    getRotation() {\n        return this.rotation ?? 0;\n    }\n    /**\n     * Returns the rotation for the text label.\n     */\n    getTextRotation() {\n        let rot = this.getRotation();\n        if (!(this.style?.horizontal ?? true)) {\n            rot += this.verticalTextRotation || -90; // WARNING WARNING!!!! ===============================================================================================\n        }\n        return rot;\n    }\n    /**\n     * Returns the actual rotation of the shape.\n     */\n    getShapeRotation() {\n        let rot = this.getRotation();\n        if (this.direction === DIRECTION.NORTH) {\n            rot += 270;\n        }\n        else if (this.direction === DIRECTION.WEST) {\n            rot += 180;\n        }\n        else if (this.direction === DIRECTION.SOUTH) {\n            rot += 90;\n        }\n        return rot;\n    }\n    /**\n     * Adds a transparent rectangle that catches all events.\n     */\n    createTransparentSvgRectangle(x, y, w, h) {\n        const rect = document.createElementNS(NS_SVG, 'rect');\n        rect.setAttribute('x', String(x));\n        rect.setAttribute('y', String(y));\n        rect.setAttribute('width', String(w));\n        rect.setAttribute('height', String(h));\n        rect.setAttribute('fill', NONE);\n        rect.setAttribute('stroke', NONE);\n        rect.setAttribute('pointer-events', 'all');\n        return rect;\n    }\n    redrawHtmlShape() {\n        return;\n    }\n    /**\n     * Sets a transparent background CSS style to catch all events.\n     *\n     * Paints the line shape.\n     */\n    setTransparentBackgroundImage(node) {\n        node.style.backgroundImage = `url('${Client.imageBasePath}/transparent.gif')`;\n    }\n    /**\n     * Paints the line shape.\n     */\n    releaseSvgGradients(grads) {\n        for (const key in grads) {\n            const gradient = grads[key];\n            if (gradient) {\n                gradient.mxRefCount = (gradient.mxRefCount || 0) - 1;\n                if (gradient.mxRefCount === 0 && gradient.parentNode) {\n                    gradient.parentNode.removeChild(gradient);\n                }\n            }\n        }\n    }\n    /**\n     * Destroys the shape by removing it from the DOM and releasing the DOM\n     * node associated with the shape using {@link Event#release}.\n     */\n    destroy() {\n        InternalEvent.release(this.node);\n        if (this.node.parentNode) {\n            this.node.parentNode.removeChild(this.node);\n        }\n        this.node.innerHTML = '';\n        // Decrements refCount and removes unused\n        this.releaseSvgGradients(this.oldGradients);\n        this.oldGradients = {};\n    }\n}\nexport default Shape;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1589, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1595, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/edge/PolylineShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\nimport { LINE_ARCSIZE } from '../../../util/Constants';\n/**\n * Extends {@link Shape} to implement a polyline (a line with multiple points).\n *\n * The shape is used to represent edges, not vertices.\n *\n * By default, this shape is not registered in {@link CellRenderer}.\n *\n * @category Edge Shapes\n */\nclass PolylineShape extends Shape {\n    /**\n     * Constructs a new polyline shape.\n     *\n     * @param points Array of <{@link Point} that define the points. This is stored in {@link Shape.points}.\n     * @param stroke String that defines the stroke color. Default is 'black'. This is stored in {@link Shape.stroke}.\n     * @param strokeWidth Optional integer that defines the stroke width. Default is 1. This is stored in {@link Shape.strokeWidth}.\n     */\n    constructor(points, stroke, strokeWidth = 1) {\n        super();\n        this.points = points;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Returns 0.\n     */\n    getRotation() {\n        return 0;\n    }\n    /**\n     * Returns 0.\n     */\n    getShapeRotation() {\n        return 0;\n    }\n    /**\n     * Returns false.\n     */\n    isPaintBoundsInverted() {\n        return false;\n    }\n    /**\n     * Paints the line shape.\n     */\n    paintEdgeShape(c, pts) {\n        const prev = c.pointerEventsValue;\n        c.pointerEventsValue = 'stroke';\n        if (!this.style || !this.style.curved) {\n            this.paintLine(c, pts, this.isRounded);\n        }\n        else {\n            this.paintCurvedLine(c, pts);\n        }\n        c.pointerEventsValue = prev;\n    }\n    /**\n     * Paints the line shape.\n     */\n    paintLine(c, pts, rounded) {\n        const arcSize = this.style?.arcSize ?? LINE_ARCSIZE;\n        c.begin();\n        this.addPoints(c, pts, rounded, arcSize, false);\n        c.stroke();\n    }\n    /**\n     * Paints the line shape.\n     */\n    paintCurvedLine(c, pts) {\n        c.begin();\n        const pt = pts[0];\n        const n = pts.length;\n        c.moveTo(pt.x, pt.y);\n        for (let i = 1; i < n - 2; i += 1) {\n            const p0 = pts[i];\n            const p1 = pts[i + 1];\n            const ix = (p0.x + p1.x) / 2;\n            const iy = (p0.y + p1.y) / 2;\n            c.quadTo(p0.x, p0.y, ix, iy);\n        }\n        const p0 = pts[n - 2];\n        const p1 = pts[n - 1];\n        c.quadTo(p0.x, p0.y, p1.x, p1.y);\n        c.stroke();\n    }\n}\nexport default PolylineShape;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AAEA;AADA;;;AAEA;;;;;;;;CAQC,GACD,MAAM,sBAAsB,sKAAA,CAAA,UAAK;IAC7B;;;;;;KAMC,GACD,YAAY,MAAM,EAAE,MAAM,EAAE,cAAc,CAAC,CAAE;QACzC,KAAK;QACL,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,WAAW,GAAG;IACvB;IACA;;KAEC,GACD,cAAc;QACV,OAAO;IACX;IACA;;KAEC,GACD,mBAAmB;QACf,OAAO;IACX;IACA;;KAEC,GACD,wBAAwB;QACpB,OAAO;IACX;IACA;;KAEC,GACD,eAAe,CAAC,EAAE,GAAG,EAAE;QACnB,MAAM,OAAO,EAAE,kBAAkB;QACjC,EAAE,kBAAkB,GAAG;QACvB,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;YACnC,IAAI,CAAC,SAAS,CAAC,GAAG,KAAK,IAAI,CAAC,SAAS;QACzC,OACK;YACD,IAAI,CAAC,eAAe,CAAC,GAAG;QAC5B;QACA,EAAE,kBAAkB,GAAG;IAC3B;IACA;;KAEC,GACD,UAAU,CAAC,EAAE,GAAG,EAAE,OAAO,EAAE;QACvB,MAAM,UAAU,IAAI,CAAC,KAAK,EAAE,WAAW,8JAAA,CAAA,eAAY;QACnD,EAAE,KAAK;QACP,IAAI,CAAC,SAAS,CAAC,GAAG,KAAK,SAAS,SAAS;QACzC,EAAE,MAAM;IACZ;IACA;;KAEC,GACD,gBAAgB,CAAC,EAAE,GAAG,EAAE;QACpB,EAAE,KAAK;QACP,MAAM,KAAK,GAAG,CAAC,EAAE;QACjB,MAAM,IAAI,IAAI,MAAM;QACpB,EAAE,MAAM,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC;QACnB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,KAAK,EAAG;YAC/B,MAAM,KAAK,GAAG,CAAC,EAAE;YACjB,MAAM,KAAK,GAAG,CAAC,IAAI,EAAE;YACrB,MAAM,KAAK,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,IAAI;YAC3B,MAAM,KAAK,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,IAAI;YAC3B,EAAE,MAAM,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,IAAI;QAC7B;QACA,MAAM,KAAK,GAAG,CAAC,IAAI,EAAE;QACrB,MAAM,KAAK,GAAG,CAAC,IAAI,EAAE;QACrB,EAAE,MAAM,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC;QAC/B,EAAE,MAAM;IACZ;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 1695, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1701, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/edge/ConnectorShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { DEFAULT_MARKERSIZE, NONE } from '../../../util/Constants';\nimport PolylineShape from './PolylineShape';\nimport MarkerShape from './MarkerShape';\n/**\n * Extends {@link PolylineShape} to implement a connector shape including a polyline (a line with multiple points)\n * that allows for arrow heads on either side.\n *\n * The shape is used to represent edges, not vertices.\n *\n * This shape is registered under {@link SHAPE.CONNECTOR} in {@link CellRenderer}.\n *\n * @category Edge Shapes\n */\nclass ConnectorShape extends PolylineShape {\n    constructor(points, stroke, strokewidth) {\n        super(points, stroke, strokewidth);\n    }\n    /**\n     * Updates the <boundingBox> for this shape using <createBoundingBox>\n     * and augmentBoundingBox and stores the result in <boundingBox>.\n     */\n    updateBoundingBox() {\n        this.useSvgBoundingBox = !!this.style?.curved;\n        super.updateBoundingBox();\n    }\n    /**\n     * Paints the line shape.\n     */\n    paintEdgeShape(c, pts) {\n        // The indirection via functions for markers is needed in\n        // order to apply the offsets before painting the line and\n        // paint the markers after painting the line.\n        const sourceMarker = this.createMarker(c, pts, true);\n        const targetMarker = this.createMarker(c, pts, false);\n        super.paintEdgeShape(c, pts);\n        // Disables shadows, dashed styles\n        c.setShadow(false);\n        c.setDashed(false);\n        if (sourceMarker) {\n            const strokeColor = this.style?.startStrokeColor ?? this.stroke;\n            c.setStrokeColor(strokeColor);\n            c.setFillColor(this.style?.startFillColor ?? strokeColor);\n            sourceMarker();\n        }\n        if (targetMarker) {\n            const strokeColor = this.style?.endStrokeColor ?? this.stroke;\n            c.setStrokeColor(strokeColor);\n            c.setFillColor(this.style?.endFillColor ?? strokeColor);\n            targetMarker();\n        }\n    }\n    /**\n     * Prepares the marker by adding offsets in pts and returning a function to paint the marker.\n     */\n    createMarker(c, pts, source) {\n        if (!this.style)\n            return null;\n        let result = null;\n        const n = pts.length;\n        const type = (source ? this.style.startArrow : this.style.endArrow) || NONE;\n        let p0 = source ? pts[1] : pts[n - 2];\n        const pe = source ? pts[0] : pts[n - 1];\n        if (type !== NONE && p0 !== null && pe !== null) {\n            let count = 1;\n            // Uses next non-overlapping point\n            while (count < n - 1 &&\n                Math.round(p0.x - pe.x) === 0 &&\n                Math.round(p0.y - pe.y) === 0) {\n                p0 = source ? pts[1 + count] : pts[n - 2 - count];\n                count++;\n            }\n            // Computes the norm and the inverse norm\n            const dx = pe.x - p0.x;\n            const dy = pe.y - p0.y;\n            const dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n            const unitX = dx / dist;\n            const unitY = dy / dist;\n            const size = (source ? this.style.startSize : this.style.endSize) ?? DEFAULT_MARKERSIZE;\n            // Allow for stroke width in the end point used and the\n            // orthogonal vectors describing the direction of the marker\n            const filled = (source ? this.style.startFill : this.style.endFill) ?? true;\n            result = MarkerShape.createMarker(c, this, type, pe, unitX, unitY, size, source, this.strokeWidth, filled);\n        }\n        return result;\n    }\n    /**\n     * Augments the bounding box with the strokewidth and shadow offsets.\n     */\n    augmentBoundingBox(bbox) {\n        super.augmentBoundingBox(bbox);\n        if (!this.style)\n            return;\n        // Adds marker sizes\n        let size = 0;\n        if (this.style.startArrow !== NONE) {\n            size = (this.style.startSize ?? DEFAULT_MARKERSIZE) + 1;\n        }\n        if (this.style.endArrow !== NONE) {\n            size = Math.max(size, this.style.endSize ?? DEFAULT_MARKERSIZE) + 1;\n        }\n        bbox.grow(size * this.scale);\n    }\n}\nexport default ConnectorShape;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1818, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1824, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/node/RectangleShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { LINE_ARCSIZE, NONE, RECTANGLE_ROUNDING_FACTOR } from '../../../util/Constants';\nimport Shape from '../Shape';\n/**\n * Extends {@link Shape} to implement a rectangle shape.\n * This shape is registered by default under {@link SHAPE.RECTANGLE} in {@link CellRenderer}.\n *\n * @category Vertex Shapes\n */\nclass RectangleShape extends Shape {\n    constructor(bounds, fill, stroke, strokeWidth = 1) {\n        super();\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Returns true for non-rounded, non-rotated shapes with no glass gradient.\n     */\n    isHtmlAllowed() {\n        let events = true;\n        if (this.style && this.style.pointerEvents != null) {\n            events = this.style.pointerEvents;\n        }\n        return (!this.isRounded &&\n            !this.glass &&\n            this.rotation === 0 &&\n            (events || this.fill !== NONE));\n    }\n    /**\n     * Generic background painting implementation.\n     */\n    paintBackground(c, x, y, w, h) {\n        let events = true;\n        if (this.style && this.style.pointerEvents != null) {\n            events = this.style.pointerEvents;\n        }\n        if (events || this.fill !== NONE || this.stroke !== NONE) {\n            if (!events && this.fill === NONE) {\n                c.pointerEvents = false;\n            }\n            if (this.isRounded) {\n                let r = 0;\n                if (this.style?.absoluteArcSize ?? false) {\n                    r = Math.min(w / 2, Math.min(h / 2, (this.style?.arcSize ?? LINE_ARCSIZE) / 2));\n                }\n                else {\n                    const f = (this.style?.arcSize ?? RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n                    r = Math.min(w * f, h * f);\n                }\n                c.roundrect(x, y, w, h, r, r);\n            }\n            else {\n                c.rect(x, y, w, h);\n            }\n            c.fillAndStroke();\n        }\n    }\n    /**\n     * Adds roundable support.\n     */\n    isRoundable(c, x, y, w, h) {\n        return true;\n    }\n    /**\n     * Generic background painting implementation.\n     */\n    paintForeground(c, x, y, w, h) {\n        if (this.glass && !this.outline && this.fill !== NONE) {\n            this.paintGlassEffect(c, x, y, w, h, this.getArcSize(w + this.strokeWidth, h + this.strokeWidth));\n        }\n    }\n}\nexport default RectangleShape;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AACA;AACA;;;AACA;;;;;CAKC,GACD,MAAM,uBAAuB,sKAAA,CAAA,UAAK;IAC9B,YAAY,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,cAAc,CAAC,CAAE;QAC/C,KAAK;QACL,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,WAAW,GAAG;IACvB;IACA;;KAEC,GACD,gBAAgB;QACZ,IAAI,SAAS;QACb,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,aAAa,IAAI,MAAM;YAChD,SAAS,IAAI,CAAC,KAAK,CAAC,aAAa;QACrC;QACA,OAAQ,CAAC,IAAI,CAAC,SAAS,IACnB,CAAC,IAAI,CAAC,KAAK,IACX,IAAI,CAAC,QAAQ,KAAK,KAClB,CAAC,UAAU,IAAI,CAAC,IAAI,KAAK,8JAAA,CAAA,OAAI;IACrC;IACA;;KAEC,GACD,gBAAgB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QAC3B,IAAI,SAAS;QACb,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,aAAa,IAAI,MAAM;YAChD,SAAS,IAAI,CAAC,KAAK,CAAC,aAAa;QACrC;QACA,IAAI,UAAU,IAAI,CAAC,IAAI,KAAK,8JAAA,CAAA,OAAI,IAAI,IAAI,CAAC,MAAM,KAAK,8JAAA,CAAA,OAAI,EAAE;YACtD,IAAI,CAAC,UAAU,IAAI,CAAC,IAAI,KAAK,8JAAA,CAAA,OAAI,EAAE;gBAC/B,EAAE,aAAa,GAAG;YACtB;YACA,IAAI,IAAI,CAAC,SAAS,EAAE;gBAChB,IAAI,IAAI;gBACR,IAAI,IAAI,CAAC,KAAK,EAAE,mBAAmB,OAAO;oBACtC,IAAI,KAAK,GAAG,CAAC,IAAI,GAAG,KAAK,GAAG,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,KAAK,EAAE,WAAW,8JAAA,CAAA,eAAY,IAAI;gBAChF,OACK;oBACD,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,WAAW,8JAAA,CAAA,4BAAyB,GAAG,GAAG,IAAI;oBACrE,IAAI,KAAK,GAAG,CAAC,IAAI,GAAG,IAAI;gBAC5B;gBACA,EAAE,SAAS,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG;YAC/B,OACK;gBACD,EAAE,IAAI,CAAC,GAAG,GAAG,GAAG;YACpB;YACA,EAAE,aAAa;QACnB;IACJ;IACA;;KAEC,GACD,YAAY,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QACvB,OAAO;IACX;IACA;;KAEC,GACD,gBAAgB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QAC3B,IAAI,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,IAAI,KAAK,8JAAA,CAAA,OAAI,EAAE;YACnD,IAAI,CAAC,gBAAgB,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,WAAW,EAAE,IAAI,IAAI,CAAC,WAAW;QACnG;IACJ;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 1909, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1915, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/node/TextShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../../../Client';\nimport { ABSOLUTE_LINE_HEIGHT, ALIGN, DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, DEFAULT_FONTSTYLE, DEFAULT_TEXT_DIRECTION, DIALECT, FONT, NONE, TEXT_DIRECTION, WORD_WRAP, LINE_HEIGHT, } from '../../../util/Constants';\nimport { getBoundingBox } from '../../../util/mathUtils';\nimport { getAlignmentAsPoint, matchBinaryMask } from '../../../util/styleUtils';\nimport Point from '../Point';\nimport Shape from '../Shape';\nimport Rectangle from '../Rectangle';\nimport { htmlEntities, replaceTrailingNewlines, trim } from '../../../util/StringUtils';\nimport { isNode } from '../../../util/domUtils';\nimport SvgCanvas2D from '../../canvas/SvgCanvas2D';\n/**\n * Extends {@link Shape} to implement a text shape.\n *\n * To change vertical text from \"bottom to top\" to \"top to bottom\", the following code can be used:\n * ```javascript\n * TextShape.prototype.verticalTextRotation = 90;\n * ```\n *\n * @category Vertex Shapes\n */\nclass TextShape extends Shape {\n    constructor(value, bounds, align = ALIGN.CENTER, valign = ALIGN.MIDDLE, color = 'black', family = DEFAULT_FONTFAMILY, size = DEFAULT_FONTSIZE, fontStyle = DEFAULT_FONTSTYLE, spacing = 2, spacingTop = 0, spacingRight = 0, spacingBottom = 0, spacingLeft = 0, horizontal = true, background = NONE, border = NONE, wrap = false, clipped = false, overflow = 'visible', labelPadding = 0, textDirection = DEFAULT_TEXT_DIRECTION) {\n        super();\n        this.margin = null;\n        this.unrotatedBoundingBox = null;\n        this.flipH = false;\n        this.flipV = false;\n        /**\n         * Specifies the spacing to be added to the top spacing. Default is 0. Use the\n         * value 5 here to get the same label positions as in mxGraph 1.x.\n         */\n        this.baseSpacingTop = 0;\n        /**\n         * Specifies the spacing to be added to the bottom spacing. Default is 0. Use the\n         * value 1 here to get the same label positions as in mxGraph 1.x.\n         */\n        this.baseSpacingBottom = 0;\n        /**\n         * Specifies the spacing to be added to the left spacing. Default is 0.\n         */\n        this.baseSpacingLeft = 0;\n        /**\n         * Specifies the spacing to be added to the right spacing. Default is 0.\n         */\n        this.baseSpacingRight = 0;\n        /**\n         * Specifies if linefeeds in HTML labels should be replaced with BR tags.\n         * Default is true.\n         */\n        this.replaceLinefeeds = true;\n        /**\n         * Rotation for vertical text. Default is -90 (bottom to top).\n         */\n        this.verticalTextRotation = -90;\n        /**\n         * Specifies if the string size should be measured in <updateBoundingBox> if\n         * the label is clipped and the label position is center and middle. If this is\n         * true, then the bounding box will be set to <bounds>. Default is true.\n         * <ignoreStringSize> has precedence over this switch.\n         */\n        this.ignoreClippedStringSize = true;\n        /**\n         * Specifies if the actual string size should be measured. If disabled the\n         * boundingBox will not ignore the actual size of the string, otherwise\n         * <bounds> will be used instead. Default is false.\n         */\n        this.ignoreStringSize = false;\n        /**\n         * Contains the last rendered text value. Used for caching.\n         */\n        this.lastValue = null;\n        /**\n         * Specifies if caching for HTML labels should be enabled. Default is true.\n         */\n        this.cacheEnabled = true;\n        this.value = value;\n        this.bounds = bounds;\n        this.color = color ?? 'black';\n        this.align = align ?? ALIGN.CENTER;\n        this.valign = valign ?? ALIGN.MIDDLE;\n        this.family = family ?? DEFAULT_FONTFAMILY;\n        this.size = size ?? DEFAULT_FONTSIZE;\n        this.fontStyle = fontStyle ?? DEFAULT_FONTSTYLE;\n        this.spacing = spacing ?? 2;\n        this.spacingTop = this.spacing + (spacingTop ?? 0);\n        this.spacingRight = this.spacing + (spacingRight ?? 0);\n        this.spacingBottom = this.spacing + (spacingBottom ?? 0);\n        this.spacingLeft = this.spacing + (spacingLeft ?? 0);\n        this.horizontal = horizontal ?? true;\n        this.background = background;\n        this.border = border;\n        this.wrap = wrap ?? false;\n        this.clipped = clipped ?? false;\n        this.overflow = overflow ?? 'visible';\n        this.labelPadding = labelPadding ?? 0;\n        this.textDirection = textDirection;\n        this.rotation = 0;\n        this.updateMargin();\n    }\n    /**\n     * Disables offset in IE9 for crisper image output.\n     */\n    getSvgScreenOffset() {\n        return 0;\n    }\n    /**\n     * Returns true if the bounds are not null and all of its variables are numeric.\n     */\n    checkBounds() {\n        return (!isNaN(this.scale) &&\n            isFinite(this.scale) &&\n            this.scale > 0 &&\n            this.bounds &&\n            !isNaN(this.bounds.x) &&\n            !isNaN(this.bounds.y) &&\n            !isNaN(this.bounds.width) &&\n            !isNaN(this.bounds.height));\n    }\n    /**\n     * Generic rendering code.\n     */\n    paint(c, update = false) {\n        // Scale is passed-through to canvas\n        const s = this.scale;\n        const x = this.bounds.x / s;\n        const y = this.bounds.y / s;\n        const w = this.bounds.width / s;\n        const h = this.bounds.height / s;\n        this.updateTransform(c, x, y, w, h);\n        this.configureCanvas(c, x, y, w, h);\n        if (update) {\n            c.updateText(x, y, w, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.getTextRotation(), this.node);\n        }\n        else {\n            // Checks if text contains HTML markup\n            const realHtml = isNode(this.value) || this.dialect === DIALECT.STRICTHTML;\n            // Always renders labels as HTML in VML\n            const fmt = realHtml ? 'html' : '';\n            let val = this.value;\n            if (!realHtml && fmt === 'html') {\n                // @ts-ignore\n                val = htmlEntities(val, false);\n            }\n            if (fmt === 'html' && !isNode(this.value)) {\n                val = replaceTrailingNewlines(val, '<div><br></div>');\n            }\n            // Handles trailing newlines to make sure they are visible in rendering output\n            val =\n                !isNode(this.value) && this.replaceLinefeeds && fmt === 'html'\n                    ? val.replace(/\\n/g, '<br/>')\n                    : val;\n            let dir = this.textDirection;\n            if (dir === TEXT_DIRECTION.AUTO && !realHtml) {\n                dir = this.getAutoDirection();\n            }\n            if (dir !== TEXT_DIRECTION.LTR && dir !== TEXT_DIRECTION.RTL) {\n                dir = TEXT_DIRECTION.DEFAULT;\n            }\n            c.text(x, y, w, h, val, this.align, this.valign, this.wrap, fmt, this.overflow, this.clipped, this.getTextRotation(), dir);\n        }\n    }\n    /**\n     * Renders the text using the given DOM nodes.\n     */\n    redraw() {\n        if (this.visible &&\n            this.checkBounds() &&\n            this.cacheEnabled &&\n            this.lastValue === this.value &&\n            (isNode(this.value) || this.dialect === DIALECT.STRICTHTML)) {\n            if (this.node.nodeName === 'DIV') {\n                this.redrawHtmlShape();\n                this.updateBoundingBox();\n            }\n            else {\n                const canvas = this.createCanvas();\n                if (canvas) {\n                    // Specifies if events should be handled\n                    canvas.pointerEvents = this.pointerEvents;\n                    this.paint(canvas, true);\n                    this.destroyCanvas(canvas);\n                    this.updateBoundingBox();\n                }\n            }\n        }\n        else {\n            super.redraw();\n            if (isNode(this.value) || this.dialect === DIALECT.STRICTHTML) {\n                this.lastValue = this.value;\n            }\n            else {\n                this.lastValue = null;\n            }\n        }\n    }\n    /**\n     * Resets all styles.\n     */\n    resetStyles() {\n        super.resetStyles();\n        this.color = 'black';\n        this.align = ALIGN.CENTER;\n        this.valign = ALIGN.MIDDLE;\n        this.family = DEFAULT_FONTFAMILY;\n        this.size = DEFAULT_FONTSIZE;\n        this.fontStyle = DEFAULT_FONTSTYLE;\n        this.spacing = 2;\n        this.spacingTop = 2;\n        this.spacingRight = 2;\n        this.spacingBottom = 2;\n        this.spacingLeft = 2;\n        this.horizontal = true;\n        this.background = NONE;\n        this.border = NONE;\n        this.textDirection = DEFAULT_TEXT_DIRECTION;\n        this.margin = null;\n    }\n    /**\n     * Extends mxShape to update the text styles.\n     *\n     * @param state <CellState> of the corresponding cell.\n     */\n    apply(state) {\n        const old = this.spacing;\n        super.apply(state);\n        if (this.style) {\n            this.fontStyle = this.style.fontStyle ?? this.fontStyle;\n            this.family = this.style.fontFamily ?? this.family;\n            this.size = this.style.fontSize ?? this.size;\n            this.color = this.style.fontColor ?? this.color;\n            this.align = this.style.align ?? this.align;\n            this.valign = this.style.verticalAlign ?? this.valign;\n            this.spacing = this.style.spacing ?? this.spacing;\n            this.spacingTop = (this.style.spacingTop ?? this.spacingTop - old) + this.spacing;\n            this.spacingRight =\n                (this.style.spacingRight ?? this.spacingRight - old) + this.spacing;\n            this.spacingBottom =\n                (this.style.spacingBottom ?? this.spacingBottom - old) + this.spacing;\n            this.spacingLeft =\n                (this.style.spacingLeft ?? this.spacingLeft - old) + this.spacing;\n            this.horizontal = this.style.horizontal ?? this.horizontal;\n            this.background = this.style.labelBackgroundColor ?? this.background;\n            this.border = this.style.labelBorderColor ?? this.border;\n            this.textDirection = this.style.textDirection ?? DEFAULT_TEXT_DIRECTION;\n            this.opacity = this.style.textOpacity ?? 100;\n            this.updateMargin();\n        }\n        this.flipV = false;\n        this.flipH = false;\n    }\n    /**\n     * Used to determine the automatic text direction. Returns\n     * {@link Constants#TEXT_DIRECTION_LTR} or {@link Constants#TEXT_DIRECTION_RTL}\n     * depending on the contents of <value>. This is not invoked for HTML, wrapped\n     * content or if <value> is a DOM node.\n     */\n    getAutoDirection() {\n        // Looks for strong (directional) characters\n        const tmp = /[A-Za-z\\u05d0-\\u065f\\u066a-\\u06ef\\u06fa-\\u07ff\\ufb1d-\\ufdff\\ufe70-\\ufefc]/.exec(String(this.value));\n        // Returns the direction defined by the character\n        return tmp && tmp.length > 0 && tmp[0] > 'z'\n            ? TEXT_DIRECTION.RTL\n            : TEXT_DIRECTION.LTR;\n    }\n    /**\n     * Returns the node that contains the rendered input.\n     */\n    getContentNode() {\n        let result = this.node;\n        if (result) {\n            // Rendered with no foreignObject\n            if (!result.ownerSVGElement) {\n                // @ts-ignore\n                result = this.node.firstChild.firstChild;\n            }\n            else {\n                // Innermost DIV that contains the actual content\n                // @ts-ignore\n                result = result.firstChild.firstChild.firstChild.firstChild.firstChild;\n            }\n        }\n        return result;\n    }\n    /**\n     * Updates the <boundingBox> for this shape using the given node and position.\n     */\n    updateBoundingBox() {\n        let { node } = this;\n        this.boundingBox = this.bounds.clone();\n        const rot = this.getTextRotation();\n        const h = this.style?.labelPosition ?? ALIGN.CENTER;\n        const v = this.style?.verticalLabelPosition ?? ALIGN.MIDDLE;\n        if (!this.ignoreStringSize &&\n            node &&\n            this.overflow !== 'fill' &&\n            (!this.clipped ||\n                !this.ignoreClippedStringSize ||\n                h !== ALIGN.CENTER ||\n                v !== ALIGN.MIDDLE)) {\n            let ow = null;\n            let oh = null;\n            if (node.firstChild &&\n                node.firstChild.firstChild &&\n                node.firstChild.firstChild.nodeName === 'foreignObject') {\n                // Uses second inner DIV for font metrics\n                // @ts-ignore\n                node = node.firstChild.firstChild.firstChild.firstChild;\n                // @ts-ignore\n                oh = node.offsetHeight * this.scale;\n                if (this.overflow === 'width') {\n                    ow = this.boundingBox.width;\n                }\n                else {\n                    // @ts-ignore\n                    ow = node.offsetWidth * this.scale;\n                }\n            }\n            else {\n                try {\n                    const b = node.getBBox();\n                    // Workaround for bounding box of empty string\n                    if (typeof this.value === 'string' && trim(this.value)?.length === 0) {\n                        this.boundingBox = null;\n                    }\n                    else if (b.width === 0 && b.height === 0) {\n                        this.boundingBox = null;\n                    }\n                    else {\n                        this.boundingBox = new Rectangle(b.x, b.y, b.width, b.height);\n                    }\n                    return;\n                }\n                catch (e) {\n                    // Ignores NS_ERROR_FAILURE in FF if container display is none.\n                }\n            }\n            if (ow && oh) {\n                this.boundingBox = new Rectangle(this.bounds.x, this.bounds.y, ow, oh);\n            }\n        }\n        if (this.boundingBox) {\n            const margin = this.margin;\n            if (rot !== 0) {\n                // Accounts for pre-rotated x and y\n                const bbox = (getBoundingBox(new Rectangle(margin.x * this.boundingBox.width, margin.y * this.boundingBox.height, this.boundingBox.width, this.boundingBox.height), rot, new Point(0, 0)));\n                this.unrotatedBoundingBox = Rectangle.fromRectangle(this.boundingBox);\n                this.unrotatedBoundingBox.x += margin.x * this.unrotatedBoundingBox.width;\n                this.unrotatedBoundingBox.y += margin.y * this.unrotatedBoundingBox.height;\n                this.boundingBox.x += bbox.x;\n                this.boundingBox.y += bbox.y;\n                this.boundingBox.width = bbox.width;\n                this.boundingBox.height = bbox.height;\n            }\n            else {\n                this.boundingBox.x += margin.x * this.boundingBox.width;\n                this.boundingBox.y += margin.y * this.boundingBox.height;\n                this.unrotatedBoundingBox = null;\n            }\n        }\n    }\n    /**\n     * Returns 0 to avoid using rotation in the canvas via updateTransform.\n     */\n    getShapeRotation() {\n        return 0;\n    }\n    /**\n     * Returns the rotation for the text label of the corresponding shape.\n     */\n    getTextRotation() {\n        return this.state && this.state.shape ? this.state.shape.getTextRotation() : 0;\n    }\n    /**\n     * Inverts the bounds if {@link Shape#isBoundsInverted} returns true or if the\n     * horizontal style is false.\n     */\n    isPaintBoundsInverted() {\n        return !this.horizontal && !!this.state && this.state.cell.isVertex();\n    }\n    /**\n     * Sets the state of the canvas for drawing the shape.\n     */\n    configureCanvas(c, x, y, w, h) {\n        super.configureCanvas(c, x, y, w, h);\n        c.setFontColor(this.color);\n        c.setFontBackgroundColor(this.background);\n        c.setFontBorderColor(this.border);\n        c.setFontFamily(this.family);\n        c.setFontSize(this.size);\n        c.setFontStyle(this.fontStyle);\n    }\n    /**\n     * Private helper function to create SVG elements\n     */\n    getHtmlValue() {\n        let val = this.value;\n        if (this.dialect !== DIALECT.STRICTHTML) {\n            // @ts-ignore\n            val = htmlEntities(val, false);\n        }\n        // Handles trailing newlines to make sure they are visible in rendering output\n        val = replaceTrailingNewlines(val, '<div><br></div>');\n        val = this.replaceLinefeeds ? val.replace(/\\n/g, '<br/>') : val;\n        return val;\n    }\n    /**\n     * Private helper function to create SVG elements\n     */\n    getTextCss() {\n        const lh = ABSOLUTE_LINE_HEIGHT ? `${this.size * LINE_HEIGHT}px` : LINE_HEIGHT;\n        let css = `display: inline-block; font-size: ${this.size}px; ` +\n            `font-family: ${this.family}; color: ${this.color}; line-height: ${lh}; pointer-events: ${this.pointerEvents ? 'all' : 'none'}; `;\n        matchBinaryMask(this.fontStyle, FONT.BOLD) && (css += 'font-weight: bold; ');\n        matchBinaryMask(this.fontStyle, FONT.ITALIC) && (css += 'font-style: italic; ');\n        const txtDecor = [];\n        matchBinaryMask(this.fontStyle, FONT.UNDERLINE) && txtDecor.push('underline');\n        matchBinaryMask(this.fontStyle, FONT.STRIKETHROUGH) && txtDecor.push('line-through');\n        txtDecor.length > 0 && (css += `text-decoration: ${txtDecor.join(' ')}; `);\n        return css;\n    }\n    /**\n     * Updates the HTML node(s) to reflect the latest bounds and scale.\n     */\n    redrawHtmlShape() {\n        const w = Math.max(0, Math.round(this.bounds.width / this.scale));\n        const h = Math.max(0, Math.round(this.bounds.height / this.scale));\n        const flex = `position: absolute; left: ${Math.round(this.bounds.x)}px; ` +\n            `top: ${Math.round(this.bounds.y)}px; pointer-events: none; `;\n        const block = this.getTextCss();\n        const margin = this.margin;\n        const node = this.node;\n        SvgCanvas2D.createCss(w + 2, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.background !== NONE ? htmlEntities(this.background, true) : null, this.border !== NONE ? htmlEntities(this.border, true) : null, flex, block, this.scale, (dx, dy, flex, item, block, ofl) => {\n            const r = this.getTextRotation();\n            let tr = (this.scale !== 1 ? `scale(${this.scale}) ` : '') +\n                (r !== 0 ? `rotate(${r}deg) ` : '') +\n                (margin.x !== 0 || margin.y !== 0\n                    ? `translate(${margin.x * 100}%,${margin.y * 100}%)`\n                    : '');\n            if (tr !== '') {\n                tr = `transform-origin: 0 0; transform: ${tr}; `;\n            }\n            if (ofl === '') {\n                flex += item;\n                item = `display:inline-block; min-width: 100%; ${tr}`;\n            }\n            else {\n                item += tr;\n                if (Client.IS_SF) {\n                    item += '-webkit-clip-path: content-box;';\n                }\n            }\n            if (this.opacity < 100) {\n                block += `opacity: ${this.opacity / 100}; `;\n            }\n            node.setAttribute('style', flex);\n            const html = isNode(this.value)\n                ? // @ts-ignore\n                    this.value.outerHTML\n                : this.getHtmlValue();\n            if (!node.firstChild) {\n                node.innerHTML = `<div><div>${html}</div></div>`;\n            }\n            // @ts-ignore\n            node.firstChild.firstChild.setAttribute('style', block);\n            // @ts-ignore\n            node.firstChild.setAttribute('style', item);\n        });\n    }\n    /**\n     * Sets the inner HTML of the given element to the <value>.\n     */\n    updateInnerHtml(elt) {\n        if (isNode(this.value)) {\n            // @ts-ignore\n            elt.innerHTML = this.value.outerHTML;\n        }\n        else {\n            let val = this.value;\n            if (this.dialect !== DIALECT.STRICTHTML) {\n                // LATER: Can be cached in updateValue\n                val = htmlEntities(val, false);\n            }\n            // Handles trailing newlines to make sure they are visible in rendering output\n            val = replaceTrailingNewlines(val, '<div>&nbsp;</div>');\n            val = this.replaceLinefeeds ? val.replace(/\\n/g, '<br/>') : val;\n            val = `<div style=\"display:inline-block;_display:inline;\">${val}</div>`;\n            elt.innerHTML = val;\n        }\n    }\n    /**\n     * Updates the HTML node(s) to reflect the latest bounds and scale.\n     */\n    updateValue() {\n        const node = this.node;\n        if (isNode(this.value)) {\n            node.innerHTML = '';\n            node.appendChild(this.value);\n        }\n        else {\n            let val = this.value;\n            if (this.dialect !== DIALECT.STRICTHTML) {\n                val = htmlEntities(val, false);\n            }\n            // Handles trailing newlines to make sure they are visible in rendering output\n            val = replaceTrailingNewlines(val, '<div><br></div>');\n            val = this.replaceLinefeeds ? val.replace(/\\n/g, '<br/>') : val;\n            const bg = this.background !== NONE ? this.background : null;\n            const bd = this.border !== NONE ? this.border : null;\n            if (this.overflow === 'fill' || this.overflow === 'width') {\n                if (bg) {\n                    node.style.backgroundColor = bg;\n                }\n                if (bd) {\n                    node.style.border = `1px solid ${bd}`;\n                }\n            }\n            else {\n                let css = '';\n                if (bg) {\n                    css += `background-color:${htmlEntities(bg, true)};`;\n                }\n                if (bd) {\n                    css += `border:1px solid ${htmlEntities(bd, true)};`;\n                }\n                // Wrapper DIV for background, zoom needed for inline in quirks\n                // and to measure wrapped font sizes in all browsers\n                // FIXME: Background size in quirks mode for wrapped text\n                const lh = ABSOLUTE_LINE_HEIGHT ? `${this.size * LINE_HEIGHT}px` : LINE_HEIGHT;\n                val =\n                    `<div style=\"zoom:1;${css}display:inline-block;_display:inline;text-decoration:inherit;` +\n                        `padding-bottom:1px;padding-right:1px;line-height:${lh}\">${val}</div>`;\n            }\n            node.innerHTML = val;\n            // Sets text direction\n            const divs = node.getElementsByTagName('div');\n            if (divs.length > 0) {\n                let dir = this.textDirection;\n                if (dir === TEXT_DIRECTION.AUTO && this.dialect !== DIALECT.STRICTHTML) {\n                    dir = this.getAutoDirection();\n                }\n                if (dir === TEXT_DIRECTION.LTR || dir === TEXT_DIRECTION.RTL) {\n                    divs[divs.length - 1].setAttribute('dir', dir);\n                }\n                else {\n                    divs[divs.length - 1].removeAttribute('dir');\n                }\n            }\n        }\n    }\n    /**\n     * Updates the HTML node(s) to reflect the latest bounds and scale.\n     */\n    updateFont(node) {\n        const { style } = node;\n        // @ts-ignore\n        style.lineHeight = ABSOLUTE_LINE_HEIGHT\n            ? `${this.size * LINE_HEIGHT}px`\n            : LINE_HEIGHT;\n        style.fontSize = `${this.size}px`;\n        style.fontFamily = this.family;\n        style.verticalAlign = 'top';\n        style.color = this.color;\n        matchBinaryMask(this.fontStyle, FONT.BOLD)\n            ? (style.fontWeight = 'bold')\n            : (style.fontWeight = '');\n        matchBinaryMask(this.fontStyle, FONT.ITALIC)\n            ? (style.fontStyle = 'italic')\n            : (style.fontStyle = '');\n        const txtDecor = [];\n        matchBinaryMask(this.fontStyle, FONT.UNDERLINE) && txtDecor.push('underline');\n        matchBinaryMask(this.fontStyle, FONT.STRIKETHROUGH) && txtDecor.push('line-through');\n        txtDecor.length > 0 && (style.textDecoration = txtDecor.join(' '));\n        if (this.align === ALIGN.CENTER) {\n            style.textAlign = 'center';\n        }\n        else if (this.align === ALIGN.RIGHT) {\n            style.textAlign = 'right';\n        }\n        else {\n            style.textAlign = 'left';\n        }\n    }\n    /**\n     * Updates the HTML node(s) to reflect the latest bounds and scale.\n     */\n    updateSize(node, enableWrap = false) {\n        const w = Math.max(0, Math.round(this.bounds.width / this.scale));\n        const h = Math.max(0, Math.round(this.bounds.height / this.scale));\n        const { style } = node;\n        // NOTE: Do not use maxWidth here because wrapping will\n        // go wrong if the cell is outside of the viewable area\n        if (this.clipped) {\n            style.overflow = 'hidden';\n            style.maxHeight = `${h}px`;\n            style.maxWidth = `${w}px`;\n        }\n        else if (this.overflow === 'fill') {\n            style.width = `${w + 1}px`;\n            style.height = `${h + 1}px`;\n            style.overflow = 'hidden';\n        }\n        else if (this.overflow === 'width') {\n            style.width = `${w + 1}px`;\n            style.maxHeight = `${h + 1}px`;\n            style.overflow = 'hidden';\n        }\n        if (this.wrap && w > 0) {\n            style.wordWrap = WORD_WRAP;\n            style.whiteSpace = 'normal';\n            style.width = `${w}px`;\n            if (enableWrap && this.overflow !== 'fill' && this.overflow !== 'width') {\n                let sizeDiv = node;\n                if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName === 'DIV') {\n                    // @ts-ignore\n                    sizeDiv = sizeDiv.firstChild;\n                    if (node.style.wordWrap === 'break-word') {\n                        sizeDiv.style.width = '100%';\n                    }\n                }\n                let tmp = sizeDiv.offsetWidth;\n                // Workaround for text measuring in hidden containers\n                if (tmp === 0) {\n                    const prev = node.parentNode;\n                    node.style.visibility = 'hidden';\n                    document.body.appendChild(node);\n                    tmp = sizeDiv.offsetWidth;\n                    node.style.visibility = '';\n                    prev.appendChild(node);\n                }\n                tmp += 3;\n                if (this.clipped) {\n                    tmp = Math.min(tmp, w);\n                }\n                style.width = `${tmp}px`;\n            }\n        }\n        else {\n            style.whiteSpace = 'nowrap';\n        }\n    }\n    /**\n     * Returns the spacing as an {@link Point}.\n     */\n    updateMargin() {\n        this.margin = getAlignmentAsPoint(this.align, this.valign);\n    }\n    /**\n     * Returns the spacing as an {@link Point}.\n     */\n    getSpacing() {\n        let dx = 0;\n        let dy = 0;\n        if (this.align === ALIGN.CENTER) {\n            dx = (this.spacingLeft - this.spacingRight) / 2;\n        }\n        else if (this.align === ALIGN.RIGHT) {\n            dx = -this.spacingRight - this.baseSpacingRight;\n        }\n        else {\n            dx = this.spacingLeft + this.baseSpacingLeft;\n        }\n        if (this.valign === ALIGN.MIDDLE) {\n            dy = (this.spacingTop - this.spacingBottom) / 2;\n        }\n        else if (this.valign === ALIGN.BOTTOM) {\n            dy = -this.spacingBottom - this.baseSpacingBottom;\n        }\n        else {\n            dy = this.spacingTop + this.baseSpacingTop;\n        }\n        return new Point(dx, dy);\n    }\n}\nexport default TextShape;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2516, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2522, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/node/StencilShapeRegistry.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * A singleton class that provides a registry for stencils and the methods\n * for painting those stencils onto a canvas or into a DOM.\n *\n * Code to add stencils:\n * ```javascript\n * let req = mxUtils.load('test/stencils.xml');\n * let root = req.getDocumentElement();\n * let shape = root.firstChild;\n *\n * while (shape != null)\n * {\n *   if (shape.nodeType === mxConstants.NODETYPE_ELEMENT)\n *  {\n *    mxStencilRegistry.addStencil(shape.getAttribute('name'), new mxStencil(shape));\n *  }\n *\n *  shape = shape.nextSibling;\n * }\n * ```\n * @class StencilShapeRegistry\n */\nclass StencilShapeRegistry {\n    /**\n     * Adds the given {@link Stencil}.\n     * @static\n     * @param {string} name\n     * @param {StencilShape} stencil\n     */\n    static addStencil(name, stencil) {\n        StencilShapeRegistry.stencils[name] = stencil;\n    }\n    /**\n     * Returns the {@link Stencil} for the given name.\n     * @static\n     * @param {string} name\n     * @returns {StencilShape}\n     */\n    static getStencil(name) {\n        return StencilShapeRegistry.stencils[name];\n    }\n}\nStencilShapeRegistry.stencils = {};\nexport default StencilShapeRegistry;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA,GACA;;;;;;;;;;;;;;;;;;;;;CAqBC;;;AACD,MAAM;IACF;;;;;KAKC,GACD,OAAO,WAAW,IAAI,EAAE,OAAO,EAAE;QAC7B,qBAAqB,QAAQ,CAAC,KAAK,GAAG;IAC1C;IACA;;;;;KAKC,GACD,OAAO,WAAW,IAAI,EAAE;QACpB,OAAO,qBAAqB,QAAQ,CAAC,KAAK;IAC9C;AACJ;AACA,qBAAqB,QAAQ,GAAG,CAAC;uCAClB","ignoreList":[0]}},
    {"offset": {"line": 2582, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2588, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/node/ImageShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport RectangleShape from './RectangleShape';\nimport { NONE } from '../../../util/Constants';\n/**\n * Extends {@link RectangleShape} to implement an image shape.\n * This shape is registered by default under {@link SHAPE.IMAGE} in {@link CellRenderer}.\n *\n * @category Vertex Shapes\n */\nclass ImageShape extends RectangleShape {\n    constructor(bounds, imageSrc, fill = '#FFFFFF', stroke = '#000000', strokeWidth = 1) {\n        super(bounds, fill, stroke, strokeWidth);\n        // Used in mxCellRenderer\n        this.overlay = null;\n        /**\n         * Switch to preserve image aspect. Default is true.\n         * @default true\n         */\n        // preserveImageAspect: boolean;\n        this.preserveImageAspect = true;\n        this.imageSrc = imageSrc;\n        this.shadow = false;\n    }\n    /**\n     * Disables offset in IE9 for crisper image output.\n     */\n    getSvgScreenOffset() {\n        return 0;\n    }\n    /**\n     * Overrides to replace the fill and stroke colors with the respective values from {@link imageBackground} and {@link imageBorder}.\n     *\n     * Applies the style of the given {@link CellState} to the shape. This implementation assigns the following styles to local fields:\n     *\n     * - {@link imageBackground} => fill\n     * - {@link imageBorder} => stroke\n     *\n     * @param {CellState} state   {@link CellState} of the corresponding cell.\n     */\n    apply(state) {\n        super.apply(state);\n        this.fill = NONE;\n        this.stroke = NONE;\n        this.gradient = NONE;\n        if (this.style && this.style.imageAspect != null) {\n            this.preserveImageAspect = this.style.imageAspect;\n        }\n    }\n    /**\n     * Returns true if HTML is allowed for this shape. This implementation always\n     * returns false.\n     */\n    isHtmlAllowed() {\n        return !this.preserveImageAspect;\n    }\n    /**\n     * Disables inherited roundable support.\n     */\n    isRoundable(c, x, y, w, h) {\n        return false;\n    }\n    /**\n     * Generic background painting implementation.\n     */\n    paintVertexShape(c, x, y, w, h) {\n        if (this.imageSrc) {\n            const fill = this.style?.imageBackground ?? NONE;\n            const stroke = this.style?.imageBorder ?? NONE;\n            if (fill !== NONE) {\n                // Stroke rendering required for shadow\n                c.setFillColor(fill);\n                c.setStrokeColor(stroke);\n                c.rect(x, y, w, h);\n                c.fillAndStroke();\n            }\n            // FlipH/V are implicit via mxShape.updateTransform\n            c.image(x, y, w, h, this.imageSrc, this.preserveImageAspect, false, false);\n            if (stroke !== NONE) {\n                c.setShadow(false);\n                c.setStrokeColor(stroke);\n                c.rect(x, y, w, h);\n                c.stroke();\n            }\n        }\n        else {\n            this.paintBackground(c, x, y, w, h);\n        }\n    }\n}\nexport default ImageShape;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AAEA;AADA;;;AAEA;;;;;CAKC,GACD,MAAM,mBAAmB,uLAAA,CAAA,UAAc;IACnC,YAAY,MAAM,EAAE,QAAQ,EAAE,OAAO,SAAS,EAAE,SAAS,SAAS,EAAE,cAAc,CAAC,CAAE;QACjF,KAAK,CAAC,QAAQ,MAAM,QAAQ;QAC5B,yBAAyB;QACzB,IAAI,CAAC,OAAO,GAAG;QACf;;;SAGC,GACD,gCAAgC;QAChC,IAAI,CAAC,mBAAmB,GAAG;QAC3B,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,MAAM,GAAG;IAClB;IACA;;KAEC,GACD,qBAAqB;QACjB,OAAO;IACX;IACA;;;;;;;;;KASC,GACD,MAAM,KAAK,EAAE;QACT,KAAK,CAAC,MAAM;QACZ,IAAI,CAAC,IAAI,GAAG,8JAAA,CAAA,OAAI;QAChB,IAAI,CAAC,MAAM,GAAG,8JAAA,CAAA,OAAI;QAClB,IAAI,CAAC,QAAQ,GAAG,8JAAA,CAAA,OAAI;QACpB,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,IAAI,MAAM;YAC9C,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW;QACrD;IACJ;IACA;;;KAGC,GACD,gBAAgB;QACZ,OAAO,CAAC,IAAI,CAAC,mBAAmB;IACpC;IACA;;KAEC,GACD,YAAY,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QACvB,OAAO;IACX;IACA;;KAEC,GACD,iBAAiB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QAC5B,IAAI,IAAI,CAAC,QAAQ,EAAE;YACf,MAAM,OAAO,IAAI,CAAC,KAAK,EAAE,mBAAmB,8JAAA,CAAA,OAAI;YAChD,MAAM,SAAS,IAAI,CAAC,KAAK,EAAE,eAAe,8JAAA,CAAA,OAAI;YAC9C,IAAI,SAAS,8JAAA,CAAA,OAAI,EAAE;gBACf,uCAAuC;gBACvC,EAAE,YAAY,CAAC;gBACf,EAAE,cAAc,CAAC;gBACjB,EAAE,IAAI,CAAC,GAAG,GAAG,GAAG;gBAChB,EAAE,aAAa;YACnB;YACA,mDAAmD;YACnD,EAAE,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,mBAAmB,EAAE,OAAO;YACpE,IAAI,WAAW,8JAAA,CAAA,OAAI,EAAE;gBACjB,EAAE,SAAS,CAAC;gBACZ,EAAE,cAAc,CAAC;gBACjB,EAAE,IAAI,CAAC,GAAG,GAAG,GAAG;gBAChB,EAAE,MAAM;YACZ;QACJ,OACK;YACD,IAAI,CAAC,eAAe,CAAC,GAAG,GAAG,GAAG,GAAG;QACrC;IACJ;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 2690, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2696, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/node/EllipseShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\n/**\n * Extends {@link Shape} to implement an ellipse shape.\n * This shape is registered by default under {@link SHAPE.ELLIPSE} in {@link CellRenderer}.\n *\n * @category Vertex Shapes\n */\nclass EllipseShape extends Shape {\n    constructor(bounds, fill, stroke, strokeWidth = 1) {\n        super();\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Paints the ellipse shape.\n     */\n    paintVertexShape(c, x, y, w, h) {\n        c.ellipse(x, y, w, h);\n        c.fillAndStroke();\n    }\n}\nexport default EllipseShape;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AACA;;AACA;;;;;CAKC,GACD,MAAM,qBAAqB,sKAAA,CAAA,UAAK;IAC5B,YAAY,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,cAAc,CAAC,CAAE;QAC/C,KAAK;QACL,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,WAAW,GAAG;IACvB;IACA;;KAEC,GACD,iBAAiB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QAC5B,EAAE,OAAO,CAAC,GAAG,GAAG,GAAG;QACnB,EAAE,aAAa;IACnB;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 2738, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2744, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/ActorShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from './Shape';\nimport { NONE } from '../../util/Constants';\n/**\n * Extends {@link Shape} to implement an actor shape.\n * This shape is registered by default under {@link SHAPE.ACTOR} in {@link CellRenderer}.\n *\n * If a custom shape with one filled area is needed, then this shape's {@link redrawPath} method should be overridden\n * like in the following example:\n *\n * ```typescript\n * class SampleShape extends ActorShape {\n *   redrawPath(c: AbstractCanvas2D, x: number, y: number, w: number, h: number) {\n *     path.moveTo(0, 0);\n *     path.lineTo(w, h);\n *     // ...\n *     path.close();\n *   }\n * }\n * ```\n *\n * @category Vertex Shapes\n */\nclass ActorShape extends Shape {\n    constructor(bounds = null, fill = NONE, stroke = NONE, strokeWidth = 1) {\n        super();\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Redirects to redrawPath for subclasses to work.\n     */\n    paintVertexShape(c, x, y, w, h) {\n        c.translate(x, y);\n        c.begin();\n        this.redrawPath(c, x, y, w, h);\n        c.fillAndStroke();\n    }\n    /**\n     * Draws the path for this shape.\n     */\n    redrawPath(c, x, y, w, h) {\n        const width = w / 3;\n        c.moveTo(0, h);\n        c.curveTo(0, (3 * h) / 5, 0, (2 * h) / 5, w / 2, (2 * h) / 5);\n        c.curveTo(w / 2 - width, (2 * h) / 5, w / 2 - width, 0, w / 2, 0);\n        c.curveTo(w / 2 + width, 0, w / 2 + width, (2 * h) / 5, w / 2, (2 * h) / 5);\n        c.curveTo(w, (2 * h) / 5, w, (3 * h) / 5, w, h);\n        c.close();\n    }\n}\nexport default ActorShape;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AAEA;AADA;;;AAEA;;;;;;;;;;;;;;;;;;;CAmBC,GACD,MAAM,mBAAmB,sKAAA,CAAA,UAAK;IAC1B,YAAY,SAAS,IAAI,EAAE,OAAO,8JAAA,CAAA,OAAI,EAAE,SAAS,8JAAA,CAAA,OAAI,EAAE,cAAc,CAAC,CAAE;QACpE,KAAK;QACL,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,WAAW,GAAG;IACvB;IACA;;KAEC,GACD,iBAAiB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QAC5B,EAAE,SAAS,CAAC,GAAG;QACf,EAAE,KAAK;QACP,IAAI,CAAC,UAAU,CAAC,GAAG,GAAG,GAAG,GAAG;QAC5B,EAAE,aAAa;IACnB;IACA;;KAEC,GACD,WAAW,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QACtB,MAAM,QAAQ,IAAI;QAClB,EAAE,MAAM,CAAC,GAAG;QACZ,EAAE,OAAO,CAAC,GAAG,AAAC,IAAI,IAAK,GAAG,GAAG,AAAC,IAAI,IAAK,GAAG,IAAI,GAAG,AAAC,IAAI,IAAK;QAC3D,EAAE,OAAO,CAAC,IAAI,IAAI,OAAO,AAAC,IAAI,IAAK,GAAG,IAAI,IAAI,OAAO,GAAG,IAAI,GAAG;QAC/D,EAAE,OAAO,CAAC,IAAI,IAAI,OAAO,GAAG,IAAI,IAAI,OAAO,AAAC,IAAI,IAAK,GAAG,IAAI,GAAG,AAAC,IAAI,IAAK;QACzE,EAAE,OAAO,CAAC,GAAG,AAAC,IAAI,IAAK,GAAG,GAAG,AAAC,IAAI,IAAK,GAAG,GAAG;QAC7C,EAAE,KAAK;IACX;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 2815, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2821, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/edge/ArrowShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\nimport { ARROW_SIZE, ARROW_SPACING, ARROW_WIDTH } from '../../../util/Constants';\n/**\n * Extends {@link Shape} to implement an arrow shape. The shape is used to represent edges, not vertices.\n *\n * By default, this shape is registered under {@link SHAPE.ARROW} in {@link CellRenderer}.\n *\n * @category Edge Shapes\n */\nclass ArrowShape extends Shape {\n    constructor(points, fill, stroke, strokeWidth = 1, arrowWidth = ARROW_WIDTH, spacing = ARROW_SPACING, endSize = ARROW_SIZE) {\n        super();\n        this.points = points;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n        this.arrowWidth = arrowWidth;\n        this.spacing = spacing;\n        this.endSize = endSize;\n    }\n    /**\n     * Augments the bounding box with the edge width and markers.\n     */\n    augmentBoundingBox(bbox) {\n        super.augmentBoundingBox(bbox);\n        const w = Math.max(this.arrowWidth, this.endSize);\n        bbox.grow((w / 2 + this.strokeWidth) * this.scale);\n    }\n    /**\n     * Paints the line shape.\n     */\n    paintEdgeShape(c, pts) {\n        // Geometry of arrow\n        const spacing = ARROW_SPACING;\n        const width = ARROW_WIDTH;\n        const arrow = ARROW_SIZE;\n        // Base vector (between end points)\n        const p0 = pts[0];\n        const pe = pts[pts.length - 1];\n        const dx = pe.x - p0.x;\n        const dy = pe.y - p0.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        const length = dist - 2 * spacing - arrow;\n        // Computes the norm and the inverse norm\n        const nx = dx / dist;\n        const ny = dy / dist;\n        const basex = length * nx;\n        const basey = length * ny;\n        const floorx = (width * ny) / 3;\n        const floory = (-width * nx) / 3;\n        // Computes points\n        const p0x = p0.x - floorx / 2 + spacing * nx;\n        const p0y = p0.y - floory / 2 + spacing * ny;\n        const p1x = p0x + floorx;\n        const p1y = p0y + floory;\n        const p2x = p1x + basex;\n        const p2y = p1y + basey;\n        const p3x = p2x + floorx;\n        const p3y = p2y + floory;\n        // p4 not necessary\n        const p5x = p3x - 3 * floorx;\n        const p5y = p3y - 3 * floory;\n        c.begin();\n        c.moveTo(p0x, p0y);\n        c.lineTo(p1x, p1y);\n        c.lineTo(p2x, p2y);\n        c.lineTo(p3x, p3y);\n        c.lineTo(pe.x - spacing * nx, pe.y - spacing * ny);\n        c.lineTo(p5x, p5y);\n        c.lineTo(p5x + floorx, p5y + floory);\n        c.close();\n        c.fillAndStroke();\n    }\n}\nexport default ArrowShape;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AAEA;AADA;;;AAEA;;;;;;CAMC,GACD,MAAM,mBAAmB,sKAAA,CAAA,UAAK;IAC1B,YAAY,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,cAAc,CAAC,EAAE,aAAa,8JAAA,CAAA,cAAW,EAAE,UAAU,8JAAA,CAAA,gBAAa,EAAE,UAAU,8JAAA,CAAA,aAAU,CAAE;QACxH,KAAK;QACL,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,OAAO,GAAG;IACnB;IACA;;KAEC,GACD,mBAAmB,IAAI,EAAE;QACrB,KAAK,CAAC,mBAAmB;QACzB,MAAM,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,OAAO;QAChD,KAAK,IAAI,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,KAAK;IACrD;IACA;;KAEC,GACD,eAAe,CAAC,EAAE,GAAG,EAAE;QACnB,oBAAoB;QACpB,MAAM,UAAU,8JAAA,CAAA,gBAAa;QAC7B,MAAM,QAAQ,8JAAA,CAAA,cAAW;QACzB,MAAM,QAAQ,8JAAA,CAAA,aAAU;QACxB,mCAAmC;QACnC,MAAM,KAAK,GAAG,CAAC,EAAE;QACjB,MAAM,KAAK,GAAG,CAAC,IAAI,MAAM,GAAG,EAAE;QAC9B,MAAM,KAAK,GAAG,CAAC,GAAG,GAAG,CAAC;QACtB,MAAM,KAAK,GAAG,CAAC,GAAG,GAAG,CAAC;QACtB,MAAM,OAAO,KAAK,IAAI,CAAC,KAAK,KAAK,KAAK;QACtC,MAAM,SAAS,OAAO,IAAI,UAAU;QACpC,yCAAyC;QACzC,MAAM,KAAK,KAAK;QAChB,MAAM,KAAK,KAAK;QAChB,MAAM,QAAQ,SAAS;QACvB,MAAM,QAAQ,SAAS;QACvB,MAAM,SAAS,AAAC,QAAQ,KAAM;QAC9B,MAAM,SAAS,AAAC,CAAC,QAAQ,KAAM;QAC/B,kBAAkB;QAClB,MAAM,MAAM,GAAG,CAAC,GAAG,SAAS,IAAI,UAAU;QAC1C,MAAM,MAAM,GAAG,CAAC,GAAG,SAAS,IAAI,UAAU;QAC1C,MAAM,MAAM,MAAM;QAClB,MAAM,MAAM,MAAM;QAClB,MAAM,MAAM,MAAM;QAClB,MAAM,MAAM,MAAM;QAClB,MAAM,MAAM,MAAM;QAClB,MAAM,MAAM,MAAM;QAClB,mBAAmB;QACnB,MAAM,MAAM,MAAM,IAAI;QACtB,MAAM,MAAM,MAAM,IAAI;QACtB,EAAE,KAAK;QACP,EAAE,MAAM,CAAC,KAAK;QACd,EAAE,MAAM,CAAC,KAAK;QACd,EAAE,MAAM,CAAC,KAAK;QACd,EAAE,MAAM,CAAC,KAAK;QACd,EAAE,MAAM,CAAC,GAAG,CAAC,GAAG,UAAU,IAAI,GAAG,CAAC,GAAG,UAAU;QAC/C,EAAE,MAAM,CAAC,KAAK;QACd,EAAE,MAAM,CAAC,MAAM,QAAQ,MAAM;QAC7B,EAAE,KAAK;QACP,EAAE,aAAa;IACnB;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 2914, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2920, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/edge/ArrowConnectorShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\nimport { ARROW_SIZE, ARROW_SPACING, ARROW_WIDTH, NONE } from '../../../util/Constants';\nimport { relativeCcw } from '../../../util/mathUtils';\n/**\n * Extends {@link Shape} to implement a new rounded arrow shape with support for waypoints and double arrows.\n *\n * The shape is used to represent edges, not vertices.\n *\n * By default, this shape is registered under {@link SHAPE.ARROW_CONNECTOR} in {@link CellRenderer}.\n *\n * @category Edge Shapes\n */\nclass ArrowConnectorShape extends Shape {\n    constructor(points, fill, stroke, strokeWidth = 1, arrowWidth = ARROW_WIDTH, spacing = ARROW_SPACING, endSize = ARROW_SIZE / 5) {\n        super();\n        /**\n         * Allows to use the SVG bounding box in SVG.\n         * @defaultValue `false` for performance reasons.\n         */\n        this.useSvgBoundingBox = true;\n        this.points = points;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n        this.arrowWidth = arrowWidth;\n        this.arrowSpacing = spacing;\n        this.startSize = ARROW_SIZE / 5;\n        this.endSize = endSize;\n    }\n    /**\n     * Hook for subclassers.\n     */\n    isRoundable() {\n        return true;\n    }\n    /**\n     * Overrides mxShape to reset spacing.\n     */\n    resetStyles() {\n        super.resetStyles();\n        this.arrowSpacing = ARROW_SPACING;\n    }\n    /**\n     * Overrides apply to get smooth transition from default start- and endsize.\n     */\n    apply(state) {\n        super.apply(state);\n        if (this.style && this.style.startSize != null && this.style.endSize != null) {\n            this.startSize = this.style.startSize * 3;\n            this.endSize = this.style.endSize * 3;\n        }\n    }\n    /**\n     * Augments the bounding box with the edge width and markers.\n     */\n    augmentBoundingBox(bbox) {\n        super.augmentBoundingBox(bbox);\n        let w = this.getEdgeWidth();\n        if (this.isMarkerStart()) {\n            w = Math.max(w, this.getStartArrowWidth());\n        }\n        if (this.isMarkerEnd()) {\n            w = Math.max(w, this.getEndArrowWidth());\n        }\n        bbox.grow((w / 2 + this.strokeWidth) * this.scale);\n    }\n    /**\n     * Paints the line shape.\n     */\n    paintEdgeShape(c, pts) {\n        // Geometry of arrow\n        let strokeWidth = this.strokeWidth;\n        if (this.outline) {\n            strokeWidth = Math.max(1, this.style?.strokeWidth ?? 0);\n        }\n        const startWidth = this.getStartArrowWidth() + strokeWidth;\n        const endWidth = this.getEndArrowWidth() + strokeWidth;\n        const edgeWidth = this.outline\n            ? this.getEdgeWidth() + strokeWidth\n            : this.getEdgeWidth();\n        const openEnded = this.isOpenEnded();\n        const markerStart = this.isMarkerStart();\n        const markerEnd = this.isMarkerEnd();\n        const spacing = openEnded ? 0 : this.arrowSpacing + strokeWidth / 2;\n        const startSize = this.startSize + strokeWidth;\n        const endSize = this.endSize + strokeWidth;\n        const isRounded = this.isArrowRounded();\n        // Base vector (between first points)\n        const pe = pts[pts.length - 1];\n        // Finds first non-overlapping point\n        let i0 = 1;\n        while (i0 < pts.length - 1 && pts[i0].x === pts[0].x && pts[i0].y === pts[0].y) {\n            i0++;\n        }\n        const dx = pts[i0].x - pts[0].x;\n        const dy = pts[i0].y - pts[0].y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist === 0) {\n            return;\n        }\n        // Computes the norm and the inverse norm\n        let nx = dx / dist;\n        let nx2;\n        let nx1 = nx;\n        let ny = dy / dist;\n        let ny2;\n        let ny1 = ny;\n        let orthx = edgeWidth * ny;\n        let orthy = -edgeWidth * nx;\n        // Stores the inbound function calls in reverse order in fns\n        const fns = [];\n        if (isRounded) {\n            c.setLineJoin('round');\n        }\n        else if (pts.length > 2) {\n            // Only mitre if there are waypoints\n            c.setMiterLimit(1.42);\n        }\n        c.begin();\n        const startNx = nx;\n        const startNy = ny;\n        if (markerStart && !openEnded) {\n            this.paintMarker(c, pts[0].x, pts[0].y, nx, ny, startSize, startWidth, edgeWidth, spacing, true);\n        }\n        else {\n            const outStartX = pts[0].x + orthx / 2 + spacing * nx;\n            const outStartY = pts[0].y + orthy / 2 + spacing * ny;\n            const inEndX = pts[0].x - orthx / 2 + spacing * nx;\n            const inEndY = pts[0].y - orthy / 2 + spacing * ny;\n            if (openEnded) {\n                c.moveTo(outStartX, outStartY);\n                fns.push(() => {\n                    c.lineTo(inEndX, inEndY);\n                });\n            }\n            else {\n                c.moveTo(inEndX, inEndY);\n                c.lineTo(outStartX, outStartY);\n            }\n        }\n        let dx1 = 0;\n        let dy1 = 0;\n        let dist1 = 0;\n        for (let i = 0; i < pts.length - 2; i += 1) {\n            // Work out in which direction the line is bending\n            const pos = relativeCcw(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, pts[i + 2].x, pts[i + 2].y);\n            dx1 = pts[i + 2].x - pts[i + 1].x;\n            dy1 = pts[i + 2].y - pts[i + 1].y;\n            dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n            if (dist1 !== 0) {\n                nx1 = dx1 / dist1;\n                ny1 = dy1 / dist1;\n                const tmp1 = nx * nx1 + ny * ny1;\n                const tmp = Math.max(Math.sqrt((tmp1 + 1) / 2), 0.04);\n                // Work out the normal orthogonal to the line through the control point and the edge sides intersection\n                nx2 = nx + nx1;\n                ny2 = ny + ny1;\n                const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\n                if (dist2 !== 0) {\n                    nx2 /= dist2;\n                    ny2 /= dist2;\n                    // Higher strokewidths require a larger minimum bend, 0.35 covers all but the most extreme cases\n                    const strokeWidthFactor = Math.max(tmp, Math.min(this.strokeWidth / 200 + 0.04, 0.35));\n                    const angleFactor = pos !== 0 && isRounded\n                        ? Math.max(0.1, strokeWidthFactor)\n                        : Math.max(tmp, 0.06);\n                    const outX = pts[i + 1].x + (ny2 * edgeWidth) / 2 / angleFactor;\n                    const outY = pts[i + 1].y - (nx2 * edgeWidth) / 2 / angleFactor;\n                    const inX = pts[i + 1].x - (ny2 * edgeWidth) / 2 / angleFactor;\n                    const inY = pts[i + 1].y + (nx2 * edgeWidth) / 2 / angleFactor;\n                    if (pos === 0 || !isRounded) {\n                        // If the two segments are aligned, or if we're not drawing curved sections between segments\n                        // just draw straight to the intersection point\n                        c.lineTo(outX, outY);\n                        ((x, y) => {\n                            fns.push(() => {\n                                c.lineTo(x, y);\n                            });\n                        })(inX, inY);\n                    }\n                    else if (pos === -1) {\n                        const c1x = inX + ny * edgeWidth;\n                        const c1y = inY - nx * edgeWidth;\n                        const c2x = inX + ny1 * edgeWidth;\n                        const c2y = inY - nx1 * edgeWidth;\n                        c.lineTo(c1x, c1y);\n                        c.quadTo(outX, outY, c2x, c2y);\n                        ((x, y) => {\n                            fns.push(() => {\n                                c.lineTo(x, y);\n                            });\n                        })(inX, inY);\n                    }\n                    else {\n                        c.lineTo(outX, outY);\n                        ((x, y) => {\n                            const c1x = outX - ny * edgeWidth;\n                            const c1y = outY + nx * edgeWidth;\n                            const c2x = outX - ny1 * edgeWidth;\n                            const c2y = outY + nx1 * edgeWidth;\n                            fns.push(() => {\n                                c.quadTo(x, y, c1x, c1y);\n                            });\n                            fns.push(() => {\n                                c.lineTo(c2x, c2y);\n                            });\n                        })(inX, inY);\n                    }\n                    nx = nx1;\n                    ny = ny1;\n                }\n            }\n        }\n        orthx = edgeWidth * ny1;\n        orthy = -edgeWidth * nx1;\n        if (markerEnd && !openEnded) {\n            this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, false);\n        }\n        else {\n            c.lineTo(pe.x - spacing * nx1 + orthx / 2, pe.y - spacing * ny1 + orthy / 2);\n            const inStartX = pe.x - spacing * nx1 - orthx / 2;\n            const inStartY = pe.y - spacing * ny1 - orthy / 2;\n            if (!openEnded) {\n                c.lineTo(inStartX, inStartY);\n            }\n            else {\n                c.moveTo(inStartX, inStartY);\n                fns.splice(0, 0, () => {\n                    c.moveTo(inStartX, inStartY);\n                });\n            }\n        }\n        for (let i = fns.length - 1; i >= 0; i--) {\n            fns[i]();\n        }\n        if (openEnded) {\n            c.end();\n            c.stroke();\n        }\n        else {\n            c.close();\n            c.fillAndStroke();\n        }\n        // Workaround for shadow on top of base arrow\n        c.setShadow(false);\n        // Need to redraw the markers without the low miter limit\n        c.setMiterLimit(4);\n        if (isRounded) {\n            c.setLineJoin('flat');\n        }\n        if (pts.length > 2) {\n            // Only to repaint markers if no waypoints\n            // Need to redraw the markers without the low miter limit\n            c.setMiterLimit(4);\n            if (markerStart && !openEnded) {\n                c.begin();\n                this.paintMarker(c, pts[0].x, pts[0].y, startNx, startNy, startSize, startWidth, edgeWidth, spacing, true);\n                c.stroke();\n                c.end();\n            }\n            if (markerEnd && !openEnded) {\n                c.begin();\n                this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, true);\n                c.stroke();\n                c.end();\n            }\n        }\n    }\n    /**\n     * Paints the marker.\n     */\n    paintMarker(c, ptX, ptY, nx, ny, size, arrowWidth, edgeWidth, spacing, initialMove) {\n        const widthArrowRatio = edgeWidth / arrowWidth;\n        const orthx = (edgeWidth * ny) / 2;\n        const orthy = (-edgeWidth * nx) / 2;\n        const spaceX = (spacing + size) * nx;\n        const spaceY = (spacing + size) * ny;\n        if (initialMove) {\n            c.moveTo(ptX - orthx + spaceX, ptY - orthy + spaceY);\n        }\n        else {\n            c.lineTo(ptX - orthx + spaceX, ptY - orthy + spaceY);\n        }\n        c.lineTo(ptX - orthx / widthArrowRatio + spaceX, ptY - orthy / widthArrowRatio + spaceY);\n        c.lineTo(ptX + spacing * nx, ptY + spacing * ny);\n        c.lineTo(ptX + orthx / widthArrowRatio + spaceX, ptY + orthy / widthArrowRatio + spaceY);\n        c.lineTo(ptX + orthx + spaceX, ptY + orthy + spaceY);\n    }\n    /**\n     * @returns whether the arrow is rounded\n     */\n    isArrowRounded() {\n        return this.isRounded;\n    }\n    /**\n     * @returns the width of the start arrow\n     */\n    getStartArrowWidth() {\n        return ARROW_WIDTH;\n    }\n    /**\n     * @returns the width of the end arrow\n     */\n    getEndArrowWidth() {\n        return ARROW_WIDTH;\n    }\n    /**\n     * @returns the width of the body of the edge\n     */\n    getEdgeWidth() {\n        return ARROW_WIDTH / 3;\n    }\n    /**\n     * @returns whether the ends of the shape are drawn\n     */\n    isOpenEnded() {\n        return false;\n    }\n    /**\n     * @returns whether the start marker is drawn\n     */\n    isMarkerStart() {\n        return (this.style?.startArrow ?? NONE) !== NONE;\n    }\n    /**\n     * @returns whether the end marker is drawn\n     */\n    isMarkerEnd() {\n        return (this.style?.endArrow ?? NONE) !== NONE;\n    }\n}\nexport default ArrowConnectorShape;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AAEA;AACA;AAFA;;;;AAGA;;;;;;;;CAQC,GACD,MAAM,4BAA4B,sKAAA,CAAA,UAAK;IACnC,YAAY,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,cAAc,CAAC,EAAE,aAAa,8JAAA,CAAA,cAAW,EAAE,UAAU,8JAAA,CAAA,gBAAa,EAAE,UAAU,8JAAA,CAAA,aAAU,GAAG,CAAC,CAAE;QAC5H,KAAK;QACL;;;SAGC,GACD,IAAI,CAAC,iBAAiB,GAAG;QACzB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,SAAS,GAAG,8JAAA,CAAA,aAAU,GAAG;QAC9B,IAAI,CAAC,OAAO,GAAG;IACnB;IACA;;KAEC,GACD,cAAc;QACV,OAAO;IACX;IACA;;KAEC,GACD,cAAc;QACV,KAAK,CAAC;QACN,IAAI,CAAC,YAAY,GAAG,8JAAA,CAAA,gBAAa;IACrC;IACA;;KAEC,GACD,MAAM,KAAK,EAAE;QACT,KAAK,CAAC,MAAM;QACZ,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,IAAI,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,IAAI,MAAM;YAC1E,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG;YACxC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,GAAG;QACxC;IACJ;IACA;;KAEC,GACD,mBAAmB,IAAI,EAAE;QACrB,KAAK,CAAC,mBAAmB;QACzB,IAAI,IAAI,IAAI,CAAC,YAAY;QACzB,IAAI,IAAI,CAAC,aAAa,IAAI;YACtB,IAAI,KAAK,GAAG,CAAC,GAAG,IAAI,CAAC,kBAAkB;QAC3C;QACA,IAAI,IAAI,CAAC,WAAW,IAAI;YACpB,IAAI,KAAK,GAAG,CAAC,GAAG,IAAI,CAAC,gBAAgB;QACzC;QACA,KAAK,IAAI,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,KAAK;IACrD;IACA;;KAEC,GACD,eAAe,CAAC,EAAE,GAAG,EAAE;QACnB,oBAAoB;QACpB,IAAI,cAAc,IAAI,CAAC,WAAW;QAClC,IAAI,IAAI,CAAC,OAAO,EAAE;YACd,cAAc,KAAK,GAAG,CAAC,GAAG,IAAI,CAAC,KAAK,EAAE,eAAe;QACzD;QACA,MAAM,aAAa,IAAI,CAAC,kBAAkB,KAAK;QAC/C,MAAM,WAAW,IAAI,CAAC,gBAAgB,KAAK;QAC3C,MAAM,YAAY,IAAI,CAAC,OAAO,GACxB,IAAI,CAAC,YAAY,KAAK,cACtB,IAAI,CAAC,YAAY;QACvB,MAAM,YAAY,IAAI,CAAC,WAAW;QAClC,MAAM,cAAc,IAAI,CAAC,aAAa;QACtC,MAAM,YAAY,IAAI,CAAC,WAAW;QAClC,MAAM,UAAU,YAAY,IAAI,IAAI,CAAC,YAAY,GAAG,cAAc;QAClE,MAAM,YAAY,IAAI,CAAC,SAAS,GAAG;QACnC,MAAM,UAAU,IAAI,CAAC,OAAO,GAAG;QAC/B,MAAM,YAAY,IAAI,CAAC,cAAc;QACrC,qCAAqC;QACrC,MAAM,KAAK,GAAG,CAAC,IAAI,MAAM,GAAG,EAAE;QAC9B,oCAAoC;QACpC,IAAI,KAAK;QACT,MAAO,KAAK,IAAI,MAAM,GAAG,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC,CAAC,CAAE;YAC5E;QACJ;QACA,MAAM,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC;QAC/B,MAAM,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC;QAC/B,MAAM,OAAO,KAAK,IAAI,CAAC,KAAK,KAAK,KAAK;QACtC,IAAI,SAAS,GAAG;YACZ;QACJ;QACA,yCAAyC;QACzC,IAAI,KAAK,KAAK;QACd,IAAI;QACJ,IAAI,MAAM;QACV,IAAI,KAAK,KAAK;QACd,IAAI;QACJ,IAAI,MAAM;QACV,IAAI,QAAQ,YAAY;QACxB,IAAI,QAAQ,CAAC,YAAY;QACzB,4DAA4D;QAC5D,MAAM,MAAM,EAAE;QACd,IAAI,WAAW;YACX,EAAE,WAAW,CAAC;QAClB,OACK,IAAI,IAAI,MAAM,GAAG,GAAG;YACrB,oCAAoC;YACpC,EAAE,aAAa,CAAC;QACpB;QACA,EAAE,KAAK;QACP,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,IAAI,eAAe,CAAC,WAAW;YAC3B,IAAI,CAAC,WAAW,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,IAAI,WAAW,YAAY,WAAW,SAAS;QAC/F,OACK;YACD,MAAM,YAAY,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,QAAQ,IAAI,UAAU;YACnD,MAAM,YAAY,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,QAAQ,IAAI,UAAU;YACnD,MAAM,SAAS,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,QAAQ,IAAI,UAAU;YAChD,MAAM,SAAS,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,QAAQ,IAAI,UAAU;YAChD,IAAI,WAAW;gBACX,EAAE,MAAM,CAAC,WAAW;gBACpB,IAAI,IAAI,CAAC;oBACL,EAAE,MAAM,CAAC,QAAQ;gBACrB;YACJ,OACK;gBACD,EAAE,MAAM,CAAC,QAAQ;gBACjB,EAAE,MAAM,CAAC,WAAW;YACxB;QACJ;QACA,IAAI,MAAM;QACV,IAAI,MAAM;QACV,IAAI,QAAQ;QACZ,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,GAAG,GAAG,KAAK,EAAG;YACxC,kDAAkD;YAClD,MAAM,MAAM,CAAA,GAAA,8JAAA,CAAA,cAAW,AAAD,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;YAClG,MAAM,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;YACjC,MAAM,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;YACjC,QAAQ,KAAK,IAAI,CAAC,MAAM,MAAM,MAAM;YACpC,IAAI,UAAU,GAAG;gBACb,MAAM,MAAM;gBACZ,MAAM,MAAM;gBACZ,MAAM,OAAO,KAAK,MAAM,KAAK;gBAC7B,MAAM,MAAM,KAAK,GAAG,CAAC,KAAK,IAAI,CAAC,CAAC,OAAO,CAAC,IAAI,IAAI;gBAChD,uGAAuG;gBACvG,MAAM,KAAK;gBACX,MAAM,KAAK;gBACX,MAAM,QAAQ,KAAK,IAAI,CAAC,MAAM,MAAM,MAAM;gBAC1C,IAAI,UAAU,GAAG;oBACb,OAAO;oBACP,OAAO;oBACP,gGAAgG;oBAChG,MAAM,oBAAoB,KAAK,GAAG,CAAC,KAAK,KAAK,GAAG,CAAC,IAAI,CAAC,WAAW,GAAG,MAAM,MAAM;oBAChF,MAAM,cAAc,QAAQ,KAAK,YAC3B,KAAK,GAAG,CAAC,KAAK,qBACd,KAAK,GAAG,CAAC,KAAK;oBACpB,MAAM,OAAO,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,GAAG,AAAC,MAAM,YAAa,IAAI;oBACpD,MAAM,OAAO,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,GAAG,AAAC,MAAM,YAAa,IAAI;oBACpD,MAAM,MAAM,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,GAAG,AAAC,MAAM,YAAa,IAAI;oBACnD,MAAM,MAAM,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,GAAG,AAAC,MAAM,YAAa,IAAI;oBACnD,IAAI,QAAQ,KAAK,CAAC,WAAW;wBACzB,4FAA4F;wBAC5F,+CAA+C;wBAC/C,EAAE,MAAM,CAAC,MAAM;wBACf,CAAC,CAAC,GAAG;4BACD,IAAI,IAAI,CAAC;gCACL,EAAE,MAAM,CAAC,GAAG;4BAChB;wBACJ,CAAC,EAAE,KAAK;oBACZ,OACK,IAAI,QAAQ,CAAC,GAAG;wBACjB,MAAM,MAAM,MAAM,KAAK;wBACvB,MAAM,MAAM,MAAM,KAAK;wBACvB,MAAM,MAAM,MAAM,MAAM;wBACxB,MAAM,MAAM,MAAM,MAAM;wBACxB,EAAE,MAAM,CAAC,KAAK;wBACd,EAAE,MAAM,CAAC,MAAM,MAAM,KAAK;wBAC1B,CAAC,CAAC,GAAG;4BACD,IAAI,IAAI,CAAC;gCACL,EAAE,MAAM,CAAC,GAAG;4BAChB;wBACJ,CAAC,EAAE,KAAK;oBACZ,OACK;wBACD,EAAE,MAAM,CAAC,MAAM;wBACf,CAAC,CAAC,GAAG;4BACD,MAAM,MAAM,OAAO,KAAK;4BACxB,MAAM,MAAM,OAAO,KAAK;4BACxB,MAAM,MAAM,OAAO,MAAM;4BACzB,MAAM,MAAM,OAAO,MAAM;4BACzB,IAAI,IAAI,CAAC;gCACL,EAAE,MAAM,CAAC,GAAG,GAAG,KAAK;4BACxB;4BACA,IAAI,IAAI,CAAC;gCACL,EAAE,MAAM,CAAC,KAAK;4BAClB;wBACJ,CAAC,EAAE,KAAK;oBACZ;oBACA,KAAK;oBACL,KAAK;gBACT;YACJ;QACJ;QACA,QAAQ,YAAY;QACpB,QAAQ,CAAC,YAAY;QACrB,IAAI,aAAa,CAAC,WAAW;YACzB,IAAI,CAAC,WAAW,CAAC,GAAG,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,SAAS,UAAU,WAAW,SAAS;QACrF,OACK;YACD,EAAE,MAAM,CAAC,GAAG,CAAC,GAAG,UAAU,MAAM,QAAQ,GAAG,GAAG,CAAC,GAAG,UAAU,MAAM,QAAQ;YAC1E,MAAM,WAAW,GAAG,CAAC,GAAG,UAAU,MAAM,QAAQ;YAChD,MAAM,WAAW,GAAG,CAAC,GAAG,UAAU,MAAM,QAAQ;YAChD,IAAI,CAAC,WAAW;gBACZ,EAAE,MAAM,CAAC,UAAU;YACvB,OACK;gBACD,EAAE,MAAM,CAAC,UAAU;gBACnB,IAAI,MAAM,CAAC,GAAG,GAAG;oBACb,EAAE,MAAM,CAAC,UAAU;gBACvB;YACJ;QACJ;QACA,IAAK,IAAI,IAAI,IAAI,MAAM,GAAG,GAAG,KAAK,GAAG,IAAK;YACtC,GAAG,CAAC,EAAE;QACV;QACA,IAAI,WAAW;YACX,EAAE,GAAG;YACL,EAAE,MAAM;QACZ,OACK;YACD,EAAE,KAAK;YACP,EAAE,aAAa;QACnB;QACA,6CAA6C;QAC7C,EAAE,SAAS,CAAC;QACZ,yDAAyD;QACzD,EAAE,aAAa,CAAC;QAChB,IAAI,WAAW;YACX,EAAE,WAAW,CAAC;QAClB;QACA,IAAI,IAAI,MAAM,GAAG,GAAG;YAChB,0CAA0C;YAC1C,yDAAyD;YACzD,EAAE,aAAa,CAAC;YAChB,IAAI,eAAe,CAAC,WAAW;gBAC3B,EAAE,KAAK;gBACP,IAAI,CAAC,WAAW,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,SAAS,SAAS,WAAW,YAAY,WAAW,SAAS;gBACrG,EAAE,MAAM;gBACR,EAAE,GAAG;YACT;YACA,IAAI,aAAa,CAAC,WAAW;gBACzB,EAAE,KAAK;gBACP,IAAI,CAAC,WAAW,CAAC,GAAG,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,SAAS,UAAU,WAAW,SAAS;gBACjF,EAAE,MAAM;gBACR,EAAE,GAAG;YACT;QACJ;IACJ;IACA;;KAEC,GACD,YAAY,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,UAAU,EAAE,SAAS,EAAE,OAAO,EAAE,WAAW,EAAE;QAChF,MAAM,kBAAkB,YAAY;QACpC,MAAM,QAAQ,AAAC,YAAY,KAAM;QACjC,MAAM,QAAQ,AAAC,CAAC,YAAY,KAAM;QAClC,MAAM,SAAS,CAAC,UAAU,IAAI,IAAI;QAClC,MAAM,SAAS,CAAC,UAAU,IAAI,IAAI;QAClC,IAAI,aAAa;YACb,EAAE,MAAM,CAAC,MAAM,QAAQ,QAAQ,MAAM,QAAQ;QACjD,OACK;YACD,EAAE,MAAM,CAAC,MAAM,QAAQ,QAAQ,MAAM,QAAQ;QACjD;QACA,EAAE,MAAM,CAAC,MAAM,QAAQ,kBAAkB,QAAQ,MAAM,QAAQ,kBAAkB;QACjF,EAAE,MAAM,CAAC,MAAM,UAAU,IAAI,MAAM,UAAU;QAC7C,EAAE,MAAM,CAAC,MAAM,QAAQ,kBAAkB,QAAQ,MAAM,QAAQ,kBAAkB;QACjF,EAAE,MAAM,CAAC,MAAM,QAAQ,QAAQ,MAAM,QAAQ;IACjD;IACA;;KAEC,GACD,iBAAiB;QACb,OAAO,IAAI,CAAC,SAAS;IACzB;IACA;;KAEC,GACD,qBAAqB;QACjB,OAAO,8JAAA,CAAA,cAAW;IACtB;IACA;;KAEC,GACD,mBAAmB;QACf,OAAO,8JAAA,CAAA,cAAW;IACtB;IACA;;KAEC,GACD,eAAe;QACX,OAAO,8JAAA,CAAA,cAAW,GAAG;IACzB;IACA;;KAEC,GACD,cAAc;QACV,OAAO;IACX;IACA;;KAEC,GACD,gBAAgB;QACZ,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,cAAc,8JAAA,CAAA,OAAI,MAAM,8JAAA,CAAA,OAAI;IACpD;IACA;;KAEC,GACD,cAAc;QACV,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,YAAY,8JAAA,CAAA,OAAI,MAAM,8JAAA,CAAA,OAAI;IAClD;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 3246, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3252, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/node/CloudShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ActorShape from '../ActorShape';\n/**\n * Extends {@link ActorShape} to implement a cloud shape.\n * This shape is registered by default under {@link SHAPE.CLOUD} in {@link CellRenderer}.\n *\n * @category Vertex Shapes\n */\nclass CloudShape extends ActorShape {\n    constructor(bounds, fill, stroke, strokeWidth = 1) {\n        super();\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Draws the path for this shape.\n     */\n    redrawPath(c, x, y, w, h) {\n        c.moveTo(0.25 * w, 0.25 * h);\n        c.curveTo(0.05 * w, 0.25 * h, 0, 0.5 * h, 0.16 * w, 0.55 * h);\n        c.curveTo(0, 0.66 * h, 0.18 * w, 0.9 * h, 0.31 * w, 0.8 * h);\n        c.curveTo(0.4 * w, h, 0.7 * w, h, 0.8 * w, 0.8 * h);\n        c.curveTo(w, 0.8 * h, w, 0.6 * h, 0.875 * w, 0.5 * h);\n        c.curveTo(w, 0.3 * h, 0.8 * w, 0.1 * h, 0.625 * w, 0.2 * h);\n        c.curveTo(0.5 * w, 0.05 * h, 0.3 * w, 0.05 * h, 0.25 * w, 0.25 * h);\n        c.close();\n    }\n}\nexport default CloudShape;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AACA;;AACA;;;;;CAKC,GACD,MAAM,mBAAmB,2KAAA,CAAA,UAAU;IAC/B,YAAY,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,cAAc,CAAC,CAAE;QAC/C,KAAK;QACL,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,WAAW,GAAG;IACvB;IACA;;KAEC,GACD,WAAW,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QACtB,EAAE,MAAM,CAAC,OAAO,GAAG,OAAO;QAC1B,EAAE,OAAO,CAAC,OAAO,GAAG,OAAO,GAAG,GAAG,MAAM,GAAG,OAAO,GAAG,OAAO;QAC3D,EAAE,OAAO,CAAC,GAAG,OAAO,GAAG,OAAO,GAAG,MAAM,GAAG,OAAO,GAAG,MAAM;QAC1D,EAAE,OAAO,CAAC,MAAM,GAAG,GAAG,MAAM,GAAG,GAAG,MAAM,GAAG,MAAM;QACjD,EAAE,OAAO,CAAC,GAAG,MAAM,GAAG,GAAG,MAAM,GAAG,QAAQ,GAAG,MAAM;QACnD,EAAE,OAAO,CAAC,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,QAAQ,GAAG,MAAM;QACzD,EAAE,OAAO,CAAC,MAAM,GAAG,OAAO,GAAG,MAAM,GAAG,OAAO,GAAG,OAAO,GAAG,OAAO;QACjE,EAAE,KAAK;IACX;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 3300, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3306, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/node/CylinderShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\nimport { NONE } from '../../../util/Constants';\n/**\n * Extends {@link Shape} to implement a cylinder shape.\n * This shape is registered by default under {@link SHAPE.CYLINDER} in {@link CellRenderer}.\n *\n * If a custom shape with one filled area and an overlay path is needed, then this shape's {@link redrawPath} should be overridden.\n *\n * @category Vertex Shapes\n */\nclass CylinderShape extends Shape {\n    constructor(bounds, fill, stroke, strokeWidth = 1) {\n        super();\n        /**\n         * Defines the maximum height of the top and bottom part of the cylinder shape.\n         */\n        this.maxHeight = 40;\n        /**\n         * Sets stroke tolerance to 0 for SVG.\n         */\n        this.svgStrokeTolerance = 0;\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Redirects to redrawPath for subclasses to work.\n     */\n    paintVertexShape(c, x, y, w, h) {\n        c.translate(x, y);\n        c.begin();\n        this.redrawPath(c, x, y, w, h, false);\n        c.fillAndStroke();\n        if (!this.outline || !this.style || !(this.style.backgroundOutline ?? false)) {\n            c.setShadow(false);\n            c.begin();\n            this.redrawPath(c, x, y, w, h, true);\n            c.stroke();\n        }\n    }\n    /**\n     * Redirects to redrawPath for subclasses to work.\n     */\n    getCylinderSize(x, y, w, h) {\n        return Math.min(this.maxHeight, Math.round(h / 5));\n    }\n    /**\n     * Draws the path for this shape.\n     */\n    redrawPath(c, x, y, w, h, isForeground = false) {\n        const dy = this.getCylinderSize(x, y, w, h);\n        if ((isForeground && this.fill !== NONE) || (!isForeground && this.fill === NONE)) {\n            c.moveTo(0, dy);\n            c.curveTo(0, 2 * dy, w, 2 * dy, w, dy);\n            // Needs separate shapes for correct hit-detection\n            if (!isForeground) {\n                c.stroke();\n                c.begin();\n            }\n        }\n        if (!isForeground) {\n            c.moveTo(0, dy);\n            c.curveTo(0, -dy / 3, w, -dy / 3, w, dy);\n            c.lineTo(w, h - dy);\n            c.curveTo(w, h + dy / 3, 0, h + dy / 3, 0, h - dy);\n            c.close();\n        }\n    }\n}\nexport default CylinderShape;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AAEA;AADA;;;AAEA;;;;;;;CAOC,GACD,MAAM,sBAAsB,sKAAA,CAAA,UAAK;IAC7B,YAAY,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,cAAc,CAAC,CAAE;QAC/C,KAAK;QACL;;SAEC,GACD,IAAI,CAAC,SAAS,GAAG;QACjB;;SAEC,GACD,IAAI,CAAC,kBAAkB,GAAG;QAC1B,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,WAAW,GAAG;IACvB;IACA;;KAEC,GACD,iBAAiB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QAC5B,EAAE,SAAS,CAAC,GAAG;QACf,EAAE,KAAK;QACP,IAAI,CAAC,UAAU,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG;QAC/B,EAAE,aAAa;QACf,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,iBAAiB,IAAI,KAAK,GAAG;YAC1E,EAAE,SAAS,CAAC;YACZ,EAAE,KAAK;YACP,IAAI,CAAC,UAAU,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG;YAC/B,EAAE,MAAM;QACZ;IACJ;IACA;;KAEC,GACD,gBAAgB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QACxB,OAAO,KAAK,GAAG,CAAC,IAAI,CAAC,SAAS,EAAE,KAAK,KAAK,CAAC,IAAI;IACnD;IACA;;KAEC,GACD,WAAW,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,eAAe,KAAK,EAAE;QAC5C,MAAM,KAAK,IAAI,CAAC,eAAe,CAAC,GAAG,GAAG,GAAG;QACzC,IAAI,AAAC,gBAAgB,IAAI,CAAC,IAAI,KAAK,8JAAA,CAAA,OAAI,IAAM,CAAC,gBAAgB,IAAI,CAAC,IAAI,KAAK,8JAAA,CAAA,OAAI,EAAG;YAC/E,EAAE,MAAM,CAAC,GAAG;YACZ,EAAE,OAAO,CAAC,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG;YACnC,kDAAkD;YAClD,IAAI,CAAC,cAAc;gBACf,EAAE,MAAM;gBACR,EAAE,KAAK;YACX;QACJ;QACA,IAAI,CAAC,cAAc;YACf,EAAE,MAAM,CAAC,GAAG;YACZ,EAAE,OAAO,CAAC,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC,KAAK,GAAG,GAAG;YACrC,EAAE,MAAM,CAAC,GAAG,IAAI;YAChB,EAAE,OAAO,CAAC,GAAG,IAAI,KAAK,GAAG,GAAG,IAAI,KAAK,GAAG,GAAG,IAAI;YAC/C,EAAE,KAAK;QACX;IACJ;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 3392, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3398, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/node/DoubleEllipseShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../Rectangle';\nimport Shape from '../Shape';\n/**\n * Extends {@link Shape} to implement a double ellipse shape.\n * This shape is registered by default under {@link SHAPE.DOUBLE_ELLIPSE} in {@link CellRenderer}.\n *\n * If a custom shape is needed to only fill the inner ellipse, then this shape's {@link paintVertexShape} method should be overridden\n * like in the following example:\n *\n * ```typescript\n * class SampleShape extends DoubleEllipseShape {\n *   paintVertexShape(c: AbstractCanvas2D, x: number, y: number, w: number, h: number) {\n *     c.ellipse(x, y, w, h);\n *     c.stroke();\n *\n *     const inset = this.style.margin ?? Math.min(3 + this.strokewidth, Math.min(w / 5, h / 5));\n *     x += inset;\n *     y += inset;\n *     w -= 2 * inset;\n *     h -= 2 * inset;\n *\n *     if (w > 0 && h > 0) {\n *       c.ellipse(x, y, w, h);\n *     }\n *\n *     c.fillAndStroke();\n *   }\n * }\n * ```\n *\n * @category Vertex Shapes\n */\nclass DoubleEllipseShape extends Shape {\n    constructor(bounds, fill, stroke, strokeWidth = 1) {\n        super();\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Paints the background.\n     */\n    paintBackground(c, x, y, w, h) {\n        c.ellipse(x, y, w, h);\n        c.fillAndStroke();\n    }\n    /**\n     * Paints the foreground.\n     */\n    paintForeground(c, x, y, w, h) {\n        if (!this.outline) {\n            const margin = this.style?.margin ?? Math.min(3 + this.strokeWidth, Math.min(w / 5, h / 5));\n            x += margin;\n            y += margin;\n            w -= 2 * margin;\n            h -= 2 * margin;\n            // FIXME: Rounding issues in IE8 standards mode (not in 1.x)\n            if (w > 0 && h > 0) {\n                c.ellipse(x, y, w, h);\n            }\n            c.stroke();\n        }\n    }\n    /**\n     * @returns the bounds for the label.\n     */\n    getLabelBounds(rect) {\n        const margin = this.style?.margin ??\n            Math.min(3 + this.strokeWidth, Math.min(rect.width / 5 / this.scale, rect.height / 5 / this.scale)) * this.scale;\n        return new Rectangle(rect.x + margin, rect.y + margin, rect.width - 2 * margin, rect.height - 2 * margin);\n    }\n}\nexport default DoubleEllipseShape;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AACA;AACA;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6BC,GACD,MAAM,2BAA2B,sKAAA,CAAA,UAAK;IAClC,YAAY,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,cAAc,CAAC,CAAE;QAC/C,KAAK;QACL,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,WAAW,GAAG;IACvB;IACA;;KAEC,GACD,gBAAgB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QAC3B,EAAE,OAAO,CAAC,GAAG,GAAG,GAAG;QACnB,EAAE,aAAa;IACnB;IACA;;KAEC,GACD,gBAAgB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QAC3B,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACf,MAAM,SAAS,IAAI,CAAC,KAAK,EAAE,UAAU,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,WAAW,EAAE,KAAK,GAAG,CAAC,IAAI,GAAG,IAAI;YACxF,KAAK;YACL,KAAK;YACL,KAAK,IAAI;YACT,KAAK,IAAI;YACT,4DAA4D;YAC5D,IAAI,IAAI,KAAK,IAAI,GAAG;gBAChB,EAAE,OAAO,CAAC,GAAG,GAAG,GAAG;YACvB;YACA,EAAE,MAAM;QACZ;IACJ;IACA;;KAEC,GACD,eAAe,IAAI,EAAE;QACjB,MAAM,SAAS,IAAI,CAAC,KAAK,EAAE,UACvB,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,WAAW,EAAE,KAAK,GAAG,CAAC,KAAK,KAAK,GAAG,IAAI,IAAI,CAAC,KAAK,EAAE,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,KAAK;QACpH,OAAO,IAAI,0KAAA,CAAA,UAAS,CAAC,KAAK,CAAC,GAAG,QAAQ,KAAK,CAAC,GAAG,QAAQ,KAAK,KAAK,GAAG,IAAI,QAAQ,KAAK,MAAM,GAAG,IAAI;IACtG;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 3488, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3494, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/node/HexagonShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ActorShape from '../ActorShape';\nimport Point from '../Point';\nimport { LINE_ARCSIZE } from '../../../util/Constants';\n/**\n * Implementation of the hexagon shape.\n *\n * @category Vertex Shapes\n */\nclass HexagonShape extends ActorShape {\n    constructor() {\n        super();\n    }\n    /**\n     * Draws the path for this shape.\n     */\n    redrawPath(c, x, y, w, h) {\n        const arcSize = (this.style?.arcSize ?? LINE_ARCSIZE) / 2;\n        this.addPoints(c, [\n            new Point(0.25 * w, 0),\n            new Point(0.75 * w, 0),\n            new Point(w, 0.5 * h),\n            new Point(0.75 * w, h),\n            new Point(0.25 * w, h),\n            new Point(0, 0.5 * h),\n        ], this.isRounded, arcSize, true);\n    }\n}\nexport default HexagonShape;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AAGA;AADA;AADA;;;;AAGA;;;;CAIC,GACD,MAAM,qBAAqB,2KAAA,CAAA,UAAU;IACjC,aAAc;QACV,KAAK;IACT;IACA;;KAEC,GACD,WAAW,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QACtB,MAAM,UAAU,CAAC,IAAI,CAAC,KAAK,EAAE,WAAW,8JAAA,CAAA,eAAY,IAAI;QACxD,IAAI,CAAC,SAAS,CAAC,GAAG;YACd,IAAI,sKAAA,CAAA,UAAK,CAAC,OAAO,GAAG;YACpB,IAAI,sKAAA,CAAA,UAAK,CAAC,OAAO,GAAG;YACpB,IAAI,sKAAA,CAAA,UAAK,CAAC,GAAG,MAAM;YACnB,IAAI,sKAAA,CAAA,UAAK,CAAC,OAAO,GAAG;YACpB,IAAI,sKAAA,CAAA,UAAK,CAAC,OAAO,GAAG;YACpB,IAAI,sKAAA,CAAA,UAAK,CAAC,GAAG,MAAM;SACtB,EAAE,IAAI,CAAC,SAAS,EAAE,SAAS;IAChC;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 3542, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3548, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/node/LabelShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../Rectangle';\nimport { ALIGN, DEFAULT_IMAGESIZE, NONE } from '../../../util/Constants';\nimport RectangleShape from './RectangleShape';\n/**\n * Extends {@link RectangleShape} to implement an image shape with a label.\n * This shape is registered by default under {@link SHAPE.LABEL} in {@link CellRenderer}.\n *\n * @category Vertex Shapes\n */\nclass LabelShape extends RectangleShape {\n    /**\n     * Constructs a new label shape.\n     *\n     * @param bounds {@link Rectangle} that defines the bounds. This is stored in {@link bounds}.\n     * @param fill String that defines the fill color. This is stored in {@link fill}.\n     * @param stroke String that defines the stroke color. This is stored in {@link stroke}.\n     * @param strokeWidth Optional integer that defines the stroke width. Default is 1. This is stored in {@link strokeWidth}.\n     */\n    constructor(bounds, fill, stroke, strokeWidth) {\n        super(bounds, fill, stroke, strokeWidth);\n        /**\n         * Default width and height for the image.\n         * @default mxConstants.DEFAULT_IMAGESIZE\n         */\n        this.imageSize = DEFAULT_IMAGESIZE;\n        this.imageSrc = null;\n        /**\n         * Default value for image spacing\n         * @type {number}\n         * @default 2\n         */\n        this.spacing = 2;\n        /**\n         * Default width and height for the indicicator.\n         * @type {number}\n         * @default 10\n         */\n        this.indicatorSize = 10;\n        /**\n         * Default spacing between image and indicator\n         * @default 2\n         * @type {number}\n         */\n        this.indicatorSpacing = 2;\n        this.indicatorImageSrc = null;\n    }\n    /**\n     * Initializes the shape and the <indicator>.\n     */\n    init(container) {\n        super.init(container);\n        if (this.indicatorShape) {\n            this.indicator = new this.indicatorShape();\n            this.indicator.dialect = this.dialect;\n            this.indicator.init(this.node);\n        }\n    }\n    /**\n     * Reconfigures this shape. This will update the colors of the indicator\n     * and reconfigure it if required.\n     */\n    redraw() {\n        if (this.indicator) {\n            this.indicator.fill = this.indicatorColor;\n            this.indicator.stroke = this.indicatorStrokeColor;\n            this.indicator.gradient = this.indicatorGradientColor;\n            this.indicator.direction = this.indicatorDirection;\n            this.indicator.redraw();\n        }\n        super.redraw();\n    }\n    /**\n     * Returns true for non-rounded, non-rotated shapes with no glass gradient and\n     * no indicator shape.\n     */\n    isHtmlAllowed() {\n        return super.isHtmlAllowed() && this.indicatorColor === NONE && !!this.indicatorShape;\n    }\n    /**\n     * Generic background painting implementation.\n     * @param {mxAbstractCanvas2D} c\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     */\n    paintForeground(c, x, y, w, h) {\n        this.paintImage(c, x, y, w, h);\n        this.paintIndicator(c, x, y, w, h);\n        super.paintForeground(c, x, y, w, h);\n    }\n    /**\n     * Generic background painting implementation.\n     * @param {mxAbstractCanvas2D} c\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     */\n    paintImage(c, x, y, w, h) {\n        if (this.imageSrc) {\n            const bounds = this.getImageBounds(x, y, w, h);\n            c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.imageSrc, false, false, false);\n        }\n    }\n    /**\n     * Generic background painting implementation.\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     */\n    getImageBounds(x, y, w, h) {\n        const align = this.style?.imageAlign ?? ALIGN.LEFT;\n        const valign = this.style?.verticalAlign ?? ALIGN.MIDDLE;\n        const width = this.style?.imageWidth ?? DEFAULT_IMAGESIZE;\n        const height = this.style?.imageHeight ?? DEFAULT_IMAGESIZE;\n        const spacing = this.style?.spacing ?? this.spacing + 5;\n        if (align === ALIGN.CENTER) {\n            x += (w - width) / 2;\n        }\n        else if (align === ALIGN.RIGHT) {\n            x += w - width - spacing;\n        } // default is left\n        else {\n            x += spacing;\n        }\n        if (valign === ALIGN.TOP) {\n            y += spacing;\n        }\n        else if (valign === ALIGN.BOTTOM) {\n            y += h - height - spacing;\n        } // default is middle\n        else {\n            y += (h - height) / 2;\n        }\n        return new Rectangle(x, y, width, height);\n    }\n    /**\n     * Generic background painting implementation.\n     * @param {mxAbstractCanvas2D} c\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     */\n    paintIndicator(c, x, y, w, h) {\n        if (this.indicator) {\n            this.indicator.bounds = this.getIndicatorBounds(x, y, w, h);\n            this.indicator.paint(c);\n        }\n        else if (this.indicatorImageSrc) {\n            const bounds = this.getIndicatorBounds(x, y, w, h);\n            c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.indicatorImageSrc, false, false, false);\n        }\n    }\n    /**\n     * Generic background painting implementation.\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     * @returns {Rectangle}\n     */\n    getIndicatorBounds(x, y, w, h) {\n        const align = this.style?.imageAlign ?? ALIGN.LEFT;\n        const valign = this.style?.verticalAlign ?? ALIGN.MIDDLE;\n        const width = this.style?.indicatorWidth ?? this.indicatorSize;\n        const height = this.style?.indicatorHeight ?? this.indicatorSize;\n        const spacing = this.spacing + 5;\n        if (align === ALIGN.RIGHT) {\n            x += w - width - spacing;\n        }\n        else if (align === ALIGN.CENTER) {\n            x += (w - width) / 2;\n        } // default is left\n        else {\n            x += spacing;\n        }\n        if (valign === ALIGN.BOTTOM) {\n            y += h - height - spacing;\n        }\n        else if (valign === ALIGN.TOP) {\n            y += spacing;\n        } // default is middle\n        else {\n            y += (h - height) / 2;\n        }\n        return new Rectangle(x, y, width, height);\n    }\n    /**\n     * Generic background painting implementation.\n     */\n    redrawHtmlShape() {\n        super.redrawHtmlShape();\n        // Removes all children\n        while (this.node.hasChildNodes()) {\n            this.node.removeChild(this.node.lastChild);\n        }\n        if (this.imageSrc && this.bounds) {\n            const node = document.createElement('img');\n            node.style.position = 'relative';\n            node.setAttribute('border', '0');\n            const bounds = this.getImageBounds(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);\n            bounds.x -= this.bounds.x;\n            bounds.y -= this.bounds.y;\n            node.style.left = `${Math.round(bounds.x)}px`;\n            node.style.top = `${Math.round(bounds.y)}px`;\n            node.style.width = `${Math.round(bounds.width)}px`;\n            node.style.height = `${Math.round(bounds.height)}px`;\n            node.src = this.imageSrc;\n            this.node.appendChild(node);\n        }\n    }\n}\nexport default LabelShape;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3762, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3768, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/edge/LineShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\n/**\n * Extends {@link Shape} to implement a horizontal line shape.\n *\n * The shape is used to represent edges, not vertices.\n *\n * By default, this shape is registered under {@link SHAPE.LINE} in {@link CellRenderer}.\n *\n * @category Edge Shapes\n */\nclass LineShape extends Shape {\n    constructor(bounds, stroke, strokeWidth = 1, vertical = false) {\n        super();\n        this.bounds = bounds;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n        this.vertical = vertical;\n    }\n    /**\n     * Redirects to redrawPath for subclasses to work.\n     * @param {AbstractCanvas2D} c\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     */\n    paintVertexShape(c, x, y, w, h) {\n        c.begin();\n        if (this.vertical) {\n            const mid = x + w / 2;\n            c.moveTo(mid, y);\n            c.lineTo(mid, y + h);\n        }\n        else {\n            const mid = y + h / 2;\n            c.moveTo(x, mid);\n            c.lineTo(x + w, mid);\n        }\n        c.stroke();\n    }\n}\nexport default LineShape;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AACA;;AACA;;;;;;;;CAQC,GACD,MAAM,kBAAkB,sKAAA,CAAA,UAAK;IACzB,YAAY,MAAM,EAAE,MAAM,EAAE,cAAc,CAAC,EAAE,WAAW,KAAK,CAAE;QAC3D,KAAK;QACL,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,QAAQ,GAAG;IACpB;IACA;;;;;;;KAOC,GACD,iBAAiB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QAC5B,EAAE,KAAK;QACP,IAAI,IAAI,CAAC,QAAQ,EAAE;YACf,MAAM,MAAM,IAAI,IAAI;YACpB,EAAE,MAAM,CAAC,KAAK;YACd,EAAE,MAAM,CAAC,KAAK,IAAI;QACtB,OACK;YACD,MAAM,MAAM,IAAI,IAAI;YACpB,EAAE,MAAM,CAAC,GAAG;YACZ,EAAE,MAAM,CAAC,IAAI,GAAG;QACpB;QACA,EAAE,MAAM;IACZ;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 3827, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3833, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/node/RhombusShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\nimport Point from '../Point';\nimport { LINE_ARCSIZE } from '../../../util/Constants';\n/**\n * Extends {@link Shape} to implement a rhombus (aka diamond) shape.\n * This shape is registered by default under {@link SHAPE.RHOMBUS} in {@link CellRenderer}.\n *\n * @category Vertex Shapes\n */\nclass RhombusShape extends Shape {\n    constructor(bounds, fill, stroke, strokewidth = 1) {\n        super();\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokewidth;\n    }\n    /**\n     * Adds roundable support.\n     */\n    // isRoundable(): boolean;\n    isRoundable() {\n        return true;\n    }\n    /**\n     * Generic painting implementation.\n     * @param {mxAbstractCanvas2D} c\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     */\n    paintVertexShape(c, x, y, w, h) {\n        const hw = w / 2;\n        const hh = h / 2;\n        const arcSize = (this.style?.arcSize ?? LINE_ARCSIZE) / 2;\n        c.begin();\n        this.addPoints(c, [\n            new Point(x + hw, y),\n            new Point(x + w, y + hh),\n            new Point(x + hw, y + h),\n            new Point(x, y + hh),\n        ], this.isRounded, arcSize, true);\n        c.fillAndStroke();\n    }\n}\nexport default RhombusShape;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AAGA;AADA;AADA;;;;AAGA;;;;;CAKC,GACD,MAAM,qBAAqB,sKAAA,CAAA,UAAK;IAC5B,YAAY,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,cAAc,CAAC,CAAE;QAC/C,KAAK;QACL,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,WAAW,GAAG;IACvB;IACA;;KAEC,GACD,0BAA0B;IAC1B,cAAc;QACV,OAAO;IACX;IACA;;;;;;;KAOC,GACD,iBAAiB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QAC5B,MAAM,KAAK,IAAI;QACf,MAAM,KAAK,IAAI;QACf,MAAM,UAAU,CAAC,IAAI,CAAC,KAAK,EAAE,WAAW,8JAAA,CAAA,eAAY,IAAI;QACxD,EAAE,KAAK;QACP,IAAI,CAAC,SAAS,CAAC,GAAG;YACd,IAAI,sKAAA,CAAA,UAAK,CAAC,IAAI,IAAI;YAClB,IAAI,sKAAA,CAAA,UAAK,CAAC,IAAI,GAAG,IAAI;YACrB,IAAI,sKAAA,CAAA,UAAK,CAAC,IAAI,IAAI,IAAI;YACtB,IAAI,sKAAA,CAAA,UAAK,CAAC,GAAG,IAAI;SACpB,EAAE,IAAI,CAAC,SAAS,EAAE,SAAS;QAC5B,EAAE,aAAa;IACnB;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 3899, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3905, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/node/SwimlaneShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\nimport Rectangle from '../Rectangle';\nimport { DEFAULT_STARTSIZE, DIRECTION, LINE_ARCSIZE, NONE, RECTANGLE_ROUNDING_FACTOR, } from '../../../util/Constants';\n/**\n * Extends {@link Shape} to implement a swimlane shape.\n * This shape is registered by default under {@link SHAPE.SWIMLANE} in {@link CellRenderer}.\n *\n * Use:\n * - {@link CellStateStyle.startSize} to define the size of the title region,\n * - {@link CellStateStyle.swimlaneFillColor} for the content area fill,\n * - {@link CellStateStyle.separatorColor} to draw an additional vertical separator,\n * - {@link CellStateStyle.swimlaneLine} to hide the line between the title region and the content area\n *\n * {@link CellStateStyle.horizontal} affects the orientation of this shape, not only its label.\n *\n * @category Vertex Shapes\n */\nclass SwimlaneShape extends Shape {\n    constructor(bounds, fill, stroke, strokeWidth = 1) {\n        super();\n        /**\n         * Default imagewidth and imageheight if an image but no imagewidth\n         * and imageheight are defined in the style. Value is 16.\n         * @type {number}\n         * @default 16\n         */\n        this.imageSize = 16;\n        this.imageSrc = null;\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Adds roundable support.\n     * @param {mxAbstractCanvas2D} c\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     * @returns {boolean}\n     */\n    isRoundable(c, x, y, w, h) {\n        return true;\n    }\n    /**\n     * Returns the bounding box for the gradient box for this shape.\n     */\n    getTitleSize() {\n        return Math.max(0, this.style?.startSize ?? DEFAULT_STARTSIZE);\n    }\n    /**\n     * Returns the bounding box for the gradient box for this shape.\n     */\n    getLabelBounds(rect) {\n        const start = this.getTitleSize();\n        const bounds = new Rectangle(rect.x, rect.y, rect.width, rect.height);\n        const horizontal = this.isHorizontal();\n        const flipH = this.style?.flipH ?? false;\n        const flipV = this.style?.flipV ?? false;\n        // East is default\n        const shapeVertical = this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH;\n        const realHorizontal = horizontal == !shapeVertical;\n        const realFlipH = !realHorizontal &&\n            flipH !== (this.direction === DIRECTION.SOUTH || this.direction === DIRECTION.WEST);\n        const realFlipV = realHorizontal &&\n            flipV !== (this.direction === DIRECTION.SOUTH || this.direction === DIRECTION.WEST);\n        // Shape is horizontal\n        if (!shapeVertical) {\n            const tmp = Math.min(bounds.height, start * this.scale);\n            if (realFlipH || realFlipV) {\n                bounds.y += bounds.height - tmp;\n            }\n            bounds.height = tmp;\n        }\n        else {\n            const tmp = Math.min(bounds.width, start * this.scale);\n            if (realFlipH || realFlipV) {\n                bounds.x += bounds.width - tmp;\n            }\n            bounds.width = tmp;\n        }\n        return bounds;\n    }\n    /**\n     * Returns the bounding box for the gradient box for this shape.\n     */\n    getGradientBounds(c, x, y, w, h) {\n        let start = this.getTitleSize();\n        if (this.isHorizontal()) {\n            start = Math.min(start, h);\n            return new Rectangle(x, y, w, start);\n        }\n        start = Math.min(start, w);\n        return new Rectangle(x, y, start, h);\n    }\n    /**\n     * Returns the arcsize for the swimlane.\n     */\n    getSwimlaneArcSize(w, h, start) {\n        if (this.style?.absoluteArcSize ?? false) {\n            return Math.min(w / 2, Math.min(h / 2, this.style?.arcSize ?? LINE_ARCSIZE / 2));\n        }\n        const f = (this.style?.arcSize ?? RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n        return start * f * 3;\n    }\n    /**\n     * Paints the swimlane vertex shape.\n     */\n    isHorizontal() {\n        return this.style?.horizontal ?? true;\n    }\n    /**\n     * Paints the swimlane vertex shape.\n     */\n    paintVertexShape(c, x, y, w, h) {\n        let start = this.getTitleSize();\n        const fill = this.style?.swimlaneFillColor ?? NONE;\n        const swimlaneLine = this.style?.swimlaneLine ?? true;\n        let r = 0;\n        if (this.isHorizontal()) {\n            start = Math.min(start, h);\n        }\n        else {\n            start = Math.min(start, w);\n        }\n        c.translate(x, y);\n        if (!this.isRounded) {\n            this.paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine);\n        }\n        else {\n            r = this.getSwimlaneArcSize(w, h, start);\n            r = Math.min((this.isHorizontal() ? h : w) - start, Math.min(start, r));\n            this.paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine);\n        }\n        const sep = this.style?.separatorColor ?? NONE;\n        this.paintSeparator(c, x, y, w, h, start, sep);\n        if (this.imageSrc) {\n            const bounds = this.getImageBounds(x, y, w, h);\n            c.image(bounds.x - x, bounds.y - y, bounds.width, bounds.height, this.imageSrc, false, false, false);\n        }\n        if (this.glass) {\n            c.setShadow(false);\n            this.paintGlassEffect(c, 0, 0, w, start, r);\n        }\n    }\n    /**\n     * Paints the swimlane vertex shape.\n     */\n    paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine) {\n        c.begin();\n        let events = true;\n        if (this.style && this.style.pointerEvents != null) {\n            events = this.style.pointerEvents;\n        }\n        if (!events && this.fill === NONE) {\n            c.pointerEvents = false;\n        }\n        if (this.isHorizontal()) {\n            c.moveTo(0, start);\n            c.lineTo(0, 0);\n            c.lineTo(w, 0);\n            c.lineTo(w, start);\n            c.fillAndStroke();\n            if (start < h) {\n                if (fill === NONE || !events) {\n                    c.pointerEvents = false;\n                }\n                if (fill !== NONE) {\n                    c.setFillColor(fill);\n                }\n                c.begin();\n                c.moveTo(0, start);\n                c.lineTo(0, h);\n                c.lineTo(w, h);\n                c.lineTo(w, start);\n                if (fill === NONE) {\n                    c.stroke();\n                }\n                else {\n                    c.fillAndStroke();\n                }\n            }\n        }\n        else {\n            c.moveTo(start, 0);\n            c.lineTo(0, 0);\n            c.lineTo(0, h);\n            c.lineTo(start, h);\n            c.fillAndStroke();\n            if (start < w) {\n                if (fill === NONE || !events) {\n                    c.pointerEvents = false;\n                }\n                if (fill !== NONE) {\n                    c.setFillColor(fill);\n                }\n                c.begin();\n                c.moveTo(start, 0);\n                c.lineTo(w, 0);\n                c.lineTo(w, h);\n                c.lineTo(start, h);\n                if (fill === NONE) {\n                    c.stroke();\n                }\n                else {\n                    c.fillAndStroke();\n                }\n            }\n        }\n        if (swimlaneLine) {\n            this.paintDivider(c, x, y, w, h, start, fill === NONE);\n        }\n    }\n    /**\n     * Paints the swimlane vertex shape.\n     */\n    paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine) {\n        c.begin();\n        let events = true;\n        if (this.style && this.style.pointerEvents != null) {\n            events = this.style.pointerEvents;\n        }\n        if (!events && this.fill === NONE) {\n            c.pointerEvents = false;\n        }\n        if (this.isHorizontal()) {\n            c.moveTo(w, start);\n            c.lineTo(w, r);\n            c.quadTo(w, 0, w - Math.min(w / 2, r), 0);\n            c.lineTo(Math.min(w / 2, r), 0);\n            c.quadTo(0, 0, 0, r);\n            c.lineTo(0, start);\n            c.fillAndStroke();\n            if (start < h) {\n                if (fill === NONE || !events) {\n                    c.pointerEvents = false;\n                }\n                if (fill !== NONE) {\n                    c.setFillColor(fill);\n                }\n                c.begin();\n                c.moveTo(0, start);\n                c.lineTo(0, h - r);\n                c.quadTo(0, h, Math.min(w / 2, r), h);\n                c.lineTo(w - Math.min(w / 2, r), h);\n                c.quadTo(w, h, w, h - r);\n                c.lineTo(w, start);\n                if (fill === NONE) {\n                    c.stroke();\n                }\n                else {\n                    c.fillAndStroke();\n                }\n            }\n        }\n        else {\n            c.moveTo(start, 0);\n            c.lineTo(r, 0);\n            c.quadTo(0, 0, 0, Math.min(h / 2, r));\n            c.lineTo(0, h - Math.min(h / 2, r));\n            c.quadTo(0, h, r, h);\n            c.lineTo(start, h);\n            c.fillAndStroke();\n            if (start < w) {\n                if (fill === NONE || !events) {\n                    c.pointerEvents = false;\n                }\n                if (fill !== NONE) {\n                    c.setFillColor(fill);\n                }\n                c.begin();\n                c.moveTo(start, h);\n                c.lineTo(w - r, h);\n                c.quadTo(w, h, w, h - Math.min(h / 2, r));\n                c.lineTo(w, Math.min(h / 2, r));\n                c.quadTo(w, 0, w - r, 0);\n                c.lineTo(start, 0);\n                if (fill === NONE) {\n                    c.stroke();\n                }\n                else {\n                    c.fillAndStroke();\n                }\n            }\n        }\n        if (swimlaneLine) {\n            this.paintDivider(c, x, y, w, h, start, fill === NONE);\n        }\n    }\n    /**\n     * Paints the divider between swimlane title and content area.\n     */\n    paintDivider(c, x, y, w, h, start, shadow) {\n        if (!shadow) {\n            c.setShadow(false);\n        }\n        c.begin();\n        if (this.isHorizontal()) {\n            c.moveTo(0, start);\n            c.lineTo(w, start);\n        }\n        else {\n            c.moveTo(start, 0);\n            c.lineTo(start, h);\n        }\n        c.stroke();\n    }\n    /**\n     * Paints the vertical or horizontal separator line between swimlanes.\n     */\n    paintSeparator(c, x, y, w, h, start, color) {\n        if (color !== NONE) {\n            c.setStrokeColor(color);\n            c.setDashed(true);\n            c.begin();\n            if (this.isHorizontal()) {\n                c.moveTo(w, start);\n                c.lineTo(w, h);\n            }\n            else {\n                c.moveTo(start, 0);\n                c.lineTo(w, 0);\n            }\n            c.stroke();\n            c.setDashed(false);\n        }\n    }\n    /**\n     * Paints the swimlane vertex shape.\n     */\n    getImageBounds(x, y, w, h) {\n        if (this.isHorizontal()) {\n            return new Rectangle(x + w - this.imageSize, y, this.imageSize, this.imageSize);\n        }\n        return new Rectangle(x, y, this.imageSize, this.imageSize);\n    }\n}\nexport default SwimlaneShape;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4239, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4245, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40maxgraph/core/lib/view/geometry/node/TriangleShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../Point';\nimport ActorShape from '../ActorShape';\nimport { LINE_ARCSIZE } from '../../../util/Constants';\n/**\n * Implementation of the triangle shape.\n *\n * @category Vertex Shapes\n */\nclass TriangleShape extends ActorShape {\n    constructor() {\n        super();\n    }\n    /**\n     * Adds roundable support.\n     * @returns {boolean}\n     */\n    isRoundable() {\n        return true;\n    }\n    /**\n     * Draws the path for this shape.\n     * @param {mxAbstractCanvas2D} c\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     */\n    redrawPath(c, x, y, w, h) {\n        const arcSize = (this.style?.arcSize ?? LINE_ARCSIZE) / 2;\n        this.addPoints(c, [new Point(0, 0), new Point(w, 0.5 * h), new Point(0, h)], this.isRounded, arcSize, true);\n    }\n}\nexport default TriangleShape;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA;;;AAGA;AAFA;AACA;;;;AAEA;;;;CAIC,GACD,MAAM,sBAAsB,2KAAA,CAAA,UAAU;IAClC,aAAc;QACV,KAAK;IACT;IACA;;;KAGC,GACD,cAAc;QACV,OAAO;IACX;IACA;;;;;;;KAOC,GACD,WAAW,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;QACtB,MAAM,UAAU,CAAC,IAAI,CAAC,KAAK,EAAE,WAAW,8JAAA,CAAA,eAAY,IAAI;QACxD,IAAI,CAAC,SAAS,CAAC,GAAG;YAAC,IAAI,sKAAA,CAAA,UAAK,CAAC,GAAG;YAAI,IAAI,sKAAA,CAAA,UAAK,CAAC,GAAG,MAAM;YAAI,IAAI,sKAAA,CAAA,UAAK,CAAC,GAAG;SAAG,EAAE,IAAI,CAAC,SAAS,EAAE,SAAS;IAC1G;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 4301, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}