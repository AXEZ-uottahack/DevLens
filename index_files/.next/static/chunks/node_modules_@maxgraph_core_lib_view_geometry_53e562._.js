(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@maxgraph_core_lib_view_geometry_53e562._.js", {

"[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/MarkerShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__),
    "registerDefaultEdgeMarkers": (()=>registerDefaultEdgeMarkers)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
;
/**
 * A registry that stores all edge markers using .
 *
 * NOTE: The signatures in this class will change.
 */ class MarkerShape {
    /**
     * Adds a factory method that updates a given endpoint and returns a
     * function to paint the marker onto the given canvas.
     */ static addMarker(type, funct) {
        MarkerShape.markers[type] = funct;
    }
    /**
     * Returns a function to paint the given marker.
     */ static createMarker(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) {
        const markerFunction = MarkerShape.markers[type];
        return markerFunction ? markerFunction(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) : null;
    }
}
/**
 * Maps from markers names to functions to paint the markers.
 *
 * Mapping: the attribute name on the object is the marker type, the associated value is the function to paint the marker
 */ MarkerShape.markers = {};
const __TURBOPACK__default__export__ = MarkerShape;
/**
 * For the classic and block marker factory methods.
 */ function createArrow(widthFactor) {
    return (canvas, _shape, type, pe, unitX, unitY, size, _source, sw, filled)=>{
        // The angle of the forward facing arrow sides against the x axis is
        // 26.565 degrees, 1/sin(26.565) = 2.236 / 2 = 1.118 ( / 2 allows for
        // only half the strokewidth is processed ).
        const endOffsetX = unitX * sw * 1.118;
        const endOffsetY = unitY * sw * 1.118;
        unitX *= size + sw;
        unitY *= size + sw;
        const pt = pe.clone();
        pt.x -= endOffsetX;
        pt.y -= endOffsetY;
        const f = type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW"].CLASSIC && type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW"].CLASSIC_THIN ? 1 : 3 / 4;
        pe.x += -unitX * f - endOffsetX;
        pe.y += -unitY * f - endOffsetY;
        return ()=>{
            canvas.begin();
            canvas.moveTo(pt.x, pt.y);
            canvas.lineTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);
            if (type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW"].CLASSIC || type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW"].CLASSIC_THIN) {
                canvas.lineTo(pt.x - unitX * 3 / 4, pt.y - unitY * 3 / 4);
            }
            canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);
            canvas.close();
            if (filled) {
                canvas.fillAndStroke();
            } else {
                canvas.stroke();
            }
        };
    };
}
function createOpenArrow(widthFactor) {
    return (canvas, _shape, _type, pe, unitX, unitY, size, _source, sw, _filled)=>{
        // The angle of the forward facing arrow sides against the x axis is
        // 26.565 degrees, 1/sin(26.565) = 2.236 / 2 = 1.118 ( / 2 allows for
        // only half the strokewidth is processed ).
        const endOffsetX = unitX * sw * 1.118;
        const endOffsetY = unitY * sw * 1.118;
        unitX *= size + sw;
        unitY *= size + sw;
        const pt = pe.clone();
        pt.x -= endOffsetX;
        pt.y -= endOffsetY;
        pe.x += -endOffsetX * 2;
        pe.y += -endOffsetY * 2;
        return ()=>{
            canvas.begin();
            canvas.moveTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);
            canvas.lineTo(pt.x, pt.y);
            canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);
            canvas.stroke();
        };
    };
}
const oval = (canvas, _shape, _type, pe, unitX, unitY, size, _source, _sw, filled)=>{
    const a = size / 2;
    const pt = pe.clone();
    pe.x -= unitX * a;
    pe.y -= unitY * a;
    return ()=>{
        canvas.ellipse(pt.x - a, pt.y - a, size, size);
        if (filled) {
            canvas.fillAndStroke();
        } else {
            canvas.stroke();
        }
    };
};
function diamond(canvas, _shape, type, pe, unitX, unitY, size, _source, sw, filled) {
    // The angle of the forward facing arrow sides against the x axis is
    // 45 degrees, 1/sin(45) = 1.4142 / 2 = 0.7071 ( / 2 allows for
    // only half the strokewidth is processed ). Or 0.9862 for thin diamond.
    // Note these values and the tk variable below are dependent, update
    // both together (saves trig hard coding it).
    const swFactor = type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW"].DIAMOND ? 0.7071 : 0.9862;
    const endOffsetX = unitX * sw * swFactor;
    const endOffsetY = unitY * sw * swFactor;
    unitX *= size + sw;
    unitY *= size + sw;
    const pt = pe.clone();
    pt.x -= endOffsetX;
    pt.y -= endOffsetY;
    pe.x += -unitX - endOffsetX;
    pe.y += -unitY - endOffsetY;
    // thickness factor for diamond
    const tk = type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW"].DIAMOND ? 2 : 3.4;
    return ()=>{
        canvas.begin();
        canvas.moveTo(pt.x, pt.y);
        canvas.lineTo(pt.x - unitX / 2 - unitY / tk, pt.y + unitX / tk - unitY / 2);
        canvas.lineTo(pt.x - unitX, pt.y - unitY);
        canvas.lineTo(pt.x - unitX / 2 + unitY / tk, pt.y - unitY / 2 - unitX / tk);
        canvas.close();
        if (filled) {
            canvas.fillAndStroke();
        } else {
            canvas.stroke();
        }
    };
}
let isDefaultMarkersRegistered = false;
const registerDefaultEdgeMarkers = ()=>{
    if (!isDefaultMarkersRegistered) {
        MarkerShape.addMarker('classic', createArrow(2));
        MarkerShape.addMarker('classicThin', createArrow(3));
        MarkerShape.addMarker('block', createArrow(2));
        MarkerShape.addMarker('blockThin', createArrow(3));
        MarkerShape.addMarker('open', createOpenArrow(2));
        MarkerShape.addMarker('openThin', createOpenArrow(3));
        MarkerShape.addMarker('oval', oval);
        MarkerShape.addMarker('diamond', diamond);
        MarkerShape.addMarker('diamondThin', diamond);
        isDefaultMarkersRegistered = true;
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ /**
 * Implements a 2-dimensional vector with double precision coordinates.
 *
 * Constructor: mxPoint
 *
 * Constructs a new point for the optional x and y coordinates. If no
 * coordinates are given, then the default values for <x> and <y> are used.
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
class Point {
    constructor(x = 0, y = 0){
        /**
         * Holds the x-coordinate of the point. Default is 0.
         */ this._x = 0;
        /**
         * Holds the y-coordinate of the point. Default is 0.
         */ this._y = 0;
        this.x = x;
        this.y = y;
    }
    get x() {
        return this._x;
    }
    set x(x) {
        if (Number.isNaN(x)) throw new Error('Invalid x supplied.');
        this._x = x;
    }
    get y() {
        return this._y;
    }
    set y(y) {
        if (Number.isNaN(y)) throw new Error('Invalid y supplied.');
        this._y = y;
    }
    /**
     * Returns true if the given object equals this point.
     */ equals(p) {
        if (!p) return false;
        return p.x === this.x && p.y === this.y;
    }
    /**
     * Returns a clone of this {@link Point}.
     */ clone() {
        return new Point(this.x, this.y);
    }
}
const __TURBOPACK__default__export__ = Point;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
;
/**
 * Extends {@link Point} to implement a 2-dimensional rectangle with double
 * precision coordinates.
 *
 * Constructor: mxRectangle
 *
 * Constructs a new rectangle for the optional parameters. If no parameters
 * are given then the respective default values are used.
 */ class Rectangle extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(x = 0, y = 0, width = 0, height = 0){
        super(x, y);
        /**
         * Holds the width of the rectangle.
         * @default 0
         */ this._width = 0;
        /**
         * Holds the height of the rectangle.
         * @default 0
         */ this._height = 0;
        this.width = width;
        this.height = height;
    }
    get width() {
        return this._width;
    }
    set width(width) {
        if (Number.isNaN(width)) throw new Error('Invalid width supplied.');
        this._width = width;
    }
    get height() {
        return this._height;
    }
    set height(height) {
        if (Number.isNaN(height)) throw new Error('Invalid height supplied.');
        this._height = height;
    }
    /**
     * Sets this rectangle to the specified values
     */ setRect(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    /**
     * Returns the x-coordinate of the center point.
     */ getCenterX() {
        return this.x + this.width / 2;
    }
    /**
     * Returns the y-coordinate of the center point.
     */ getCenterY() {
        return this.y + this.height / 2;
    }
    /**
     * Adds the given rectangle to this rectangle.
     */ add(rect) {
        const minX = Math.min(this.x, rect.x);
        const minY = Math.min(this.y, rect.y);
        const maxX = Math.max(this.x + this.width, rect.x + rect.width);
        const maxY = Math.max(this.y + this.height, rect.y + rect.height);
        this.x = minX;
        this.y = minY;
        this.width = maxX - minX;
        this.height = maxY - minY;
    }
    /**
     * Changes this rectangle to where it overlaps with the given rectangle.
     */ intersect(rect) {
        const r1 = this.x + this.width;
        const r2 = rect.x + rect.width;
        const b1 = this.y + this.height;
        const b2 = rect.y + rect.height;
        this.x = Math.max(this.x, rect.x);
        this.y = Math.max(this.y, rect.y);
        this.width = Math.min(r1, r2) - this.x;
        this.height = Math.min(b1, b2) - this.y;
    }
    /**
     * Grows the rectangle by the given amount, that is, this method subtracts
     * the given amount from the x- and y-coordinates and adds twice the amount
     * to the width and height.
     */ grow(amount) {
        this.x -= amount;
        this.y -= amount;
        this.width += 2 * amount;
        this.height += 2 * amount;
    }
    /**
     * Returns the top, left corner as a new {@link Point}.
     */ getPoint() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.x, this.y);
    }
    /**
     * Rotates this rectangle by 90 degree around its center point.
     */ rotate90() {
        const t = (this.width - this.height) / 2;
        this.x += t;
        this.y -= t;
        const tmp = this.width;
        this.width = this.height;
        this.height = tmp;
    }
    /**
     * Returns true if the given object equals this rectangle.
     */ equals(rect) {
        if (!rect) return false;
        return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;
    }
    clone() {
        return new Rectangle(this.x, this.y, this.width, this.height);
    }
}
/**
 * Returns a new {@link Rectangle} which is a copy of the given rectangle.
 */ Rectangle.fromRectangle = (rect)=>{
    return new Rectangle(rect.x, rect.y, rect.width, rect.height);
};
const __TURBOPACK__default__export__ = Rectangle;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/Geometry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$arrayUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/arrayUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cloneUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/cloneUtils.js [app-client] (ecmascript)");
;
;
;
;
;
/**
 * For vertices, the geometry consists of the x- and y-location, and the width
 * and height. For edges, the geometry consists of the optional terminal- and
 * control points. The terminal points are only required if an edge is
 * unconnected, and are stored in the {@link sourcePoint} and {@link targetPoint}
 * variables, respectively.
 *
 * ### Example
 *
 * If an edge is unconnected, that is, it has no source or target terminal,
 * then a geometry with terminal points for a new edge can be defined as
 * follows.
 *
 * ```javascript
 * geometry.setTerminalPoint(new mxPoint(x1, y1), true);
 * geometry.points: [new mxPoint(x2, y2)];
 * geometry.setTerminalPoint(new mxPoint(x3, y3), false);
 * ```
 *
 * Control points are used regardless of the connected state of an edge and may
 * be ignored or interpreted differently depending on the edge's {@link edgeStyle}.
 *
 * To disable automatic reset of control points after a cell has been moved or
 * resized, {@link graph.resetEdgesOnMove} and {@link graph.resetEdgesOnResize} may be used.
 *
 * ### Edge Labels
 *
 * Using the x- and y-coordinates of a cell's geometry, it is possible to
 * position the label on edges on a specific location on the actual edge shape
 * as it appears on the screen. The x-coordinate of an edge's geometry is used
 * to describe the distance from the center of the edge from -1 to 1 with 0
 * being the center of the edge and the default value. The y-coordinate of an
 * edge's geometry is used to describe the absolute, orthogonal distance in
 * pixels from that point. In addition, the {@link Geometry.offset} is used as an
 * absolute offset vector from the resulting point.
 *
 * This coordinate system is applied if {@link relative} is true, otherwise the
 * offset defines the absolute vector from the edge's center point to the
 * label and the values for {@link x} and {@link y} are ignored.
 *
 * The width and height parameter for edge geometries can be used to set the
 * label width and height (eg. for word wrapping).
 *
 * ### Ports
 *
 * The term "port" refers to a relatively positioned, connectable child cell,
 * which is used to specify the connection between the parent and another cell
 * in the graph. Ports are typically modeled as vertices with relative
 * geometries.
 *
 * ### Offsets
 *
 * The {@link offset} field is interpreted in 3 different ways, depending on the cell
 * and the geometry. For edges, the offset defines the absolute offset for the
 * edge label. For relative geometries, the offset defines the absolute offset
 * for the origin (top, left corner) of the vertex, otherwise the offset
 * defines the absolute offset for the label inside the vertex or group.
 */ class Geometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(x = 0, y = 0, width = 0, height = 0){
        super(x, y, width, height);
        /**
         * Global switch to translate the points in translate. Default is true.
         */ this.TRANSLATE_CONTROL_POINTS = true;
        /**
         * Stores alternate values for x, y, width and height in a rectangle.
         * See {@link swap} to exchange the values. Default is null.
         *
         * @see {@link swap}
         */ this.alternateBounds = null;
        /**
         * Defines the source {@link Point} of the edge. This is used if the
         * corresponding edge does not have a source vertex. Otherwise, it is ignored.
         * @default null
         */ this.sourcePoint = null;
        /**
         * Defines the source {@link Point} of the edge. This is used if the
         * corresponding edge does not have a target vertex. Otherwise, it is ignored.
         * @default null
         */ this.targetPoint = null;
        /**
         * Array of {@link Point} which specifies the control points along the edge.
         * These points are the intermediate points on the edge, for the endpoints
         * use {@link targetPoint} and {@link sourcePoint} or set the terminals of the edge to
         * a non-null value.
         * @default null
         */ this.points = null;
        /**
         * For edges, this holds the offset (in pixels) from the position defined by {@link x} and {@link y} on the edge.
         *
         * For relative geometries (for vertices), this defines the absolute offset from the point defined by the relative
         * coordinates.
         *
         * For absolute geometries (for vertices), this defines the offset for the label.
         * @default null
         */ this.offset = null;
        /**
         * Specifies if the coordinates in the geometry are to be interpreted as relative coordinates.
         *
         * For edges, this is used to define the location of the edge label relative to the edge
         * as rendered on the display.
         *
         * For vertices, this specifies the relative location inside the bounds of the parent cell.
         *
         * If this is `false`, then the coordinates are relative to the origin of the parent cell or,
         * for edges, the edge label position is relative to the center of the edge as rendered on screen.
         *
         * @default false.
         */ this.relative = false;
    }
    setRelative(isRelative) {
        this.relative = isRelative;
    }
    /**
     * Swaps the x, y, width and height with the values stored in
     * {@link alternateBounds} and puts the previous values into {@link alternateBounds} as
     * a rectangle. This operation is carried-out in-place, that is, using the
     * existing geometry instance. If this operation is called during a graph
     * model transactional change, then the geometry should be cloned before
     * calling this method and setting the geometry of the cell using
     * {@link GraphDataModel.setGeometry}.
     */ swap() {
        if (this.alternateBounds) {
            const old = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.x, this.y, this.width, this.height);
            this.x = this.alternateBounds.x;
            this.y = this.alternateBounds.y;
            this.width = this.alternateBounds.width;
            this.height = this.alternateBounds.height;
            this.alternateBounds = old;
        }
    }
    /**
     * Returns the {@link Point} representing the source or target point of this
     * edge. This is only used if the edge has no source or target vertex.
     *
     * @param {Boolean} isSource that specifies if the source or target point should be returned.
     */ getTerminalPoint(isSource) {
        return isSource ? this.sourcePoint : this.targetPoint;
    }
    /**
     * Sets the {@link sourcePoint} or {@link targetPoint} to the given {@link Point} and
     * returns the new point.
     *
     * @param {Point} point to be used as the new source or target point.
     * @param {Boolean} isSource that specifies if the source or target point should be set.
     */ setTerminalPoint(point, isSource) {
        if (isSource) {
            this.sourcePoint = point;
        } else {
            this.targetPoint = point;
        }
        return point;
    }
    /**
     * Rotates the geometry by the given angle around the given center. That is,
     * {@link x} and {@link y} of the geometry, the {@link sourcePoint}, {@link targetPoint} and all
     * {@link points} are translated by the given amount. {@link x} and {@link y} are only
     * translated if {@link relative} is false.
     *
     * @param {Number} angle that specifies the rotation angle in degrees.
     * @param {Point} cx   that specifies the center of the rotation.
     */ rotate(angle, cx) {
        const rad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toRadians"])(angle);
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);
        // Rotates the geometry
        if (!this.relative) {
            const ct = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.getCenterX(), this.getCenterY());
            const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRotatedPoint"])(ct, cos, sin, cx);
            this.x = Math.round(pt.x - this.width / 2);
            this.y = Math.round(pt.y - this.height / 2);
        }
        // Rotates the source point
        if (this.sourcePoint) {
            const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRotatedPoint"])(this.sourcePoint, cos, sin, cx);
            this.sourcePoint.x = Math.round(pt.x);
            this.sourcePoint.y = Math.round(pt.y);
        }
        // Translates the target point
        if (this.targetPoint) {
            const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRotatedPoint"])(this.targetPoint, cos, sin, cx);
            this.targetPoint.x = Math.round(pt.x);
            this.targetPoint.y = Math.round(pt.y);
        }
        // Translate the control points
        if (this.points) {
            for(let i = 0; i < this.points.length; i += 1){
                if (this.points[i]) {
                    const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRotatedPoint"])(this.points[i], cos, sin, cx);
                    this.points[i].x = Math.round(pt.x);
                    this.points[i].y = Math.round(pt.y);
                }
            }
        }
    }
    /**
     * Translates the geometry by the specified amount. That is, {@link x} and {@link y} of the
     * geometry, the {@link sourcePoint}, {@link targetPoint} and all {@link points} are translated
     * by the given amount. {@link x} and {@link y} are only translated if {@link relative} is false.
     * If {@link TRANSLATE_CONTROL_POINTS} is false, then {@link points} are not modified by
     * this function.
     *
     * @param {Number} dx that specifies the x-coordinate of the translation.
     * @param {Number} dy that specifies the y-coordinate of the translation.
     */ translate(dx, dy) {
        // Translates the geometry
        if (!this.relative) {
            this.x += dx;
            this.y += dy;
        }
        // Translates the source point
        if (this.sourcePoint) {
            this.sourcePoint.x = this.sourcePoint.x + dx;
            this.sourcePoint.y = this.sourcePoint.y + dy;
        }
        // Translates the target point
        if (this.targetPoint) {
            this.targetPoint.x = this.targetPoint.x + dx;
            this.targetPoint.y = this.targetPoint.y + dy;
        }
        // Translate the control points
        if (this.TRANSLATE_CONTROL_POINTS && this.points) {
            for(let i = 0; i < this.points.length; i += 1){
                if (this.points[i]) {
                    this.points[i].x = this.points[i].x + dx;
                    this.points[i].y = this.points[i].y + dy;
                }
            }
        }
    }
    /**
     * Scales the geometry by the given amount. That is, {@link x} and {@link y} of the
     * geometry, the {@link sourcePoint}, {@link targetPoint} and all {@link points} are scaled
     * by the given amount. {@link x}, {@link y}, {@link width} and {@link height} are only scaled if
     * {@link relative} is false. If {@link fixedAspect} is true, then the smaller value
     * is used to scale the width and the height.
     *
     * @param {Number} sx that specifies the horizontal scale factor.
     * @param {Number} sy that specifies the vertical scale factor.
     * @param {Optional} fixedAspect boolean to keep the aspect ratio fixed.
     */ scale(sx, sy, fixedAspect) {
        // Translates the source point
        if (this.sourcePoint) {
            this.sourcePoint.x = this.sourcePoint.x * sx;
            this.sourcePoint.y = this.sourcePoint.y * sy;
        }
        // Translates the target point
        if (this.targetPoint) {
            this.targetPoint.x = this.targetPoint.x * sx;
            this.targetPoint.y = this.targetPoint.y * sy;
        }
        // Translate the control points
        if (this.points) {
            for(let i = 0; i < this.points.length; i += 1){
                if (this.points[i]) {
                    this.points[i].x = this.points[i].x * sx;
                    this.points[i].y = this.points[i].y * sy;
                }
            }
        }
        // Translates the geometry
        if (!this.relative) {
            this.x *= sx;
            this.y *= sy;
            if (fixedAspect) {
                sy = sx = Math.min(sx, sy);
            }
            this.width *= sx;
            this.height *= sy;
        }
    }
    /**
     * Returns true if the given object equals this geometry.
     */ equals(geom) {
        if (!geom) return false;
        return super.equals(geom) && this.relative === geom.relative && (this.sourcePoint === null && geom.sourcePoint === null || !!this.sourcePoint?.equals(geom.sourcePoint)) && (this.targetPoint === null && geom.targetPoint === null || !!this.targetPoint?.equals(geom.targetPoint)) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$arrayUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equalPoints"])(this.points, geom.points) && (this.alternateBounds === null && geom.alternateBounds === null || !!this.alternateBounds?.equals(geom.alternateBounds)) && (this.offset === null && geom.offset === null || !!this.offset?.equals(geom.offset));
    }
    clone() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cloneUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this);
    }
}
const __TURBOPACK__default__export__ = Geometry;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/Shape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$canvas$2f$SvgCanvas2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/canvas/SvgCanvas2D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/config.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
/**
 * Base class for all shapes.
 * A shape in mxGraph is a separate implementation for SVG, VML and HTML.
 * Which implementation to use is controlled by the dialect property which
 * is assigned from within the mxCellRenderer when the shape is created.
 * The dialect must be assigned for a shape, and it does normally depend on
 * the browser and the configuration of the graph (see mxGraph rendering hint).
 *
 * For each supported shape in SVG and VML, a corresponding shape exists in
 * mxGraph, namely for text, image, rectangle, rhombus, ellipse and polyline.
 * The other shapes are a combination of these shapes (eg. label and swimlane)
 * or they consist of one or more (filled) path objects (eg. actor and cylinder).
 * The HTML implementation is optional but may be required for a HTML-only view
 * of the graph.
 *
 * ### Custom Shapes
 * To extend from this class, the basic code looks as follows.
 * In the special case where the custom shape consists only of one filled region
 * or one filled region and an additional stroke the mxActor and mxCylinder
 * should be subclassed, respectively.
 * ```javascript
 * function CustomShape() { }
 *
 * CustomShape.prototype = new mxShape();
 * CustomShape.prototype.constructor = CustomShape;
 * ```
 * To register a custom shape in an existing graph instance, one must register the
 * shape under a new name in the graphâ€™s cell renderer as follows:
 * ```javascript
 * mxCellRenderer.registerShape('customShape', CustomShape);
 * ```
 * The second argument is the name of the constructor.
 * In order to use the shape you can refer to the given name above in a stylesheet.
 * For example, to change the shape for the default vertex style, the following code
 * is used:
 * ```javascript
 * var style = graph.getStylesheet().getDefaultVertexStyle();
 * style.shape = 'customShape';
 * ```
 */ class Shape {
    constructor(stencil = null){
        // Assigned in mxCellRenderer
        this.preserveImageAspect = false;
        this.overlay = null;
        this.indicator = null;
        this.indicatorShape = null;
        // Assigned in mxCellHighlight
        this.opacity = 100;
        this.isDashed = false;
        this.fill = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.gradient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.gradientDirection = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST;
        this.fillOpacity = 100;
        this.strokeOpacity = 100;
        this.stroke = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.strokeWidth = 1;
        this.spacing = 0;
        this.startSize = 1;
        this.endSize = 1;
        this.startArrow = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.endArrow = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.direction = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST;
        this.flipH = false;
        this.flipV = false;
        this.isShadow = false;
        this.isRounded = false;
        this.rotation = 0;
        this.cursor = '';
        this.verticalTextRotation = 0;
        this.oldGradients = {};
        this.glass = false;
        /**
         * Holds the dialect in which the shape is to be painted.
         * This can be one of the DIALECT constants in {@link Constants}.
         */ this.dialect = null;
        /**
         * Holds the scale in which the shape is being painted.
         */ this.scale = 1;
        /**
         * Rendering hint for configuring the canvas.
         */ this.antiAlias = true;
        /**
         * Minimum stroke width for SVG output.
         */ this.minSvgStrokeWidth = 1;
        /**
         * Holds the {@link Rectangle} that specifies the bounds of this shape.
         */ this.bounds = null;
        /**
         * Holds the array of <Point> that specify the points of this shape.
         */ this.points = [];
        /**
         * Optional reference to the corresponding <CellState>.
         */ this.state = null;
        /**
         * Optional reference to the style of the corresponding <CellState>.
         */ this.style = null;
        /**
         * Contains the bounding box of the shape, that is, the smallest rectangle
         * that includes all pixels of the shape.
         */ this.boundingBox = null;
        /**
         * Holds the {@link StencilShape} that defines the shape.
         */ this.stencil = null;
        /**
         * Event-tolerance for SVG strokes (in px).
         * This is only passed to the canvas in {@link createSvgCanvas} if {@link pointerEvents} is `true`.
         * @default 8
         */ this.svgStrokeTolerance = 8;
        /**
         * Specifies if pointer events should be handled. Default is true.
         */ this.pointerEvents = true;
        this.originalPointerEvents = null;
        /**
         * Specifies if pointer events should be handled. Default is true.
         */ this.svgPointerEvents = 'all';
        /**
         * Specifies if pointer events outside of shape should be handled. Default
         * is false.
         */ this.shapePointerEvents = false;
        /**
         * Specifies if pointer events outside of stencils should be handled. Default
         * is false. Set this to true for backwards compatibility with the 1.x branch.
         */ this.stencilPointerEvents = false;
        /**
         * Specifies if the shape should be drawn as an outline. This disables all
         * fill colors and can be used to disable other drawing states that should
         * not be painted for outlines. Default is false. This should be set before
         * calling <apply>.
         */ this.outline = false;
        /**
         * Specifies if the shape is visible. Default is true.
         */ this.visible = true;
        /**
         * Allows to use the SVG bounding box in SVG. Default is false for performance
         * reasons.
         */ this.useSvgBoundingBox = true;
        this.image = null;
        this.imageSrc = null;
        this.indicatorColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.indicatorStrokeColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.indicatorGradientColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.indicatorDirection = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST;
        this.indicatorImageSrc = null;
        // `stencil` is not null when instantiated directly,
        // but can be null when instantiated through a child class.
        if (stencil) {
            this.stencil = stencil;
        }
        // moved from init()
        this.node = this.create();
    }
    /**
     * Initializes the shape by creaing the DOM node using <create>
     * and adding it into the given container.
     *
     * @param container DOM node that will contain the shape.
     */ init(container) {
        if (!this.node.parentNode) {
            container.appendChild(this.node);
        }
    }
    /**
     * Sets the styles to their default values.
     */ initStyles() {
        this.strokeWidth = 1;
        this.rotation = 0;
        this.opacity = 100;
        this.fillOpacity = 100;
        this.strokeOpacity = 100;
        this.flipH = false;
        this.flipV = false;
    }
    /**
     * Returns true if HTML is allowed for this shape. This implementation always
     * returns false.
     */ isHtmlAllowed() {
        return false;
    }
    /**
     * Returns 0, or 0.5 if <strokewidth> % 2 == 1.
     */ getSvgScreenOffset() {
        const sw = this.stencil && this.stencil.strokeWidthValue !== 'inherit' ? Number(this.stencil.strokeWidthValue) : this.strokeWidth ?? 0;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mod"])(Math.max(1, Math.round(sw * this.scale)), 2) === 1 ? 0.5 : 0;
    }
    /**
     * Creates and returns the DOM node for the shape.
     * This implementation assumes that `maxGraph` produces SVG elements.
     */ create() {
        return document.createElementNS(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NS_SVG"], 'g');
    }
    redraw() {
        this.updateBoundsFromPoints();
        if (this.visible && this.checkBounds()) {
            this.node.style.visibility = 'visible';
            this.clear();
            this.redrawShape();
            this.updateBoundingBox();
        } else {
            this.node.style.visibility = 'hidden';
            this.boundingBox = null;
        }
    }
    /**
     * Removes all child nodes and resets all CSS.
     */ clear() {
        while(this.node.lastChild){
            this.node.removeChild(this.node.lastChild);
        }
    }
    /**
     * Updates the bounds based on the points.
     */ updateBoundsFromPoints() {
        const pts = this.points;
        if (pts.length > 0 && pts[0]) {
            this.bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](Math.round(pts[0].x), Math.round(pts[0].y), 1, 1);
            for (const pt of pts){
                if (pt) {
                    this.bounds.add(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](Math.round(pt.x), Math.round(pt.y), 1, 1));
                }
            }
        }
    }
    /**
     * Returns the {@link Rectangle} for the label bounds of this shape, based on the
     * given scaled and translated bounds of the shape. This method should not
     * change the rectangle in-place. This implementation returns the given rect.
     */ getLabelBounds(rect) {
        const d = this.style?.direction ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST;
        let bounds = rect.clone();
        // Normalizes argument for getLabelMargins hook
        if (d !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH && d !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH && this.state && this.state.text && this.state.text.isPaintBoundsInverted()) {
            bounds = bounds.clone();
            [bounds.width, bounds.height] = [
                bounds.height,
                bounds.width
            ];
        }
        let labelMargins = this.getLabelMargins(bounds);
        if (labelMargins) {
            labelMargins = labelMargins.clone();
            let flipH = this.style?.flipH ?? false;
            let flipV = this.style?.flipV ?? false;
            // Handles special case for vertical labels
            if (this.state && this.state.text && this.state.text.isPaintBoundsInverted()) {
                const tmp = labelMargins.x;
                labelMargins.x = labelMargins.height;
                labelMargins.height = labelMargins.width;
                labelMargins.width = labelMargins.y;
                labelMargins.y = tmp;
                [flipH, flipV] = [
                    flipV,
                    flipH
                ];
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDirectedBounds"])(rect, labelMargins, this.style, flipH, flipV);
        }
        return rect;
    }
    /**
     * Returns the scaled top, left, bottom and right margin to be used for
     * computing the label bounds as an {@link Rectangle}, where the bottom and right
     * margin are defined in the width and height of the rectangle, respectively.
     */ getLabelMargins(rect) {
        return null;
    }
    /**
     * Returns true if the bounds are not null and all of its variables are numeric.
     */ checkBounds() {
        return !Number.isNaN(this.scale) && Number.isFinite(this.scale) && this.scale > 0 && this.bounds && !Number.isNaN(this.bounds.x) && !Number.isNaN(this.bounds.y) && !Number.isNaN(this.bounds.width) && !Number.isNaN(this.bounds.height) && this.bounds.width > 0 && this.bounds.height > 0;
    }
    /**
     * Updates the SVG or VML shape.
     */ redrawShape() {
        const canvas = this.createCanvas();
        if (canvas) {
            // Specifies if events should be handled
            canvas.pointerEvents = this.pointerEvents;
            this.beforePaint(canvas);
            this.paint(canvas);
            this.afterPaint(canvas);
            if (this.node !== canvas.root && canvas.root) {
                // Forces parsing in IE8 standards mode - slow! avoid
                this.node.insertAdjacentHTML('beforeend', canvas.root.outerHTML);
            }
            this.destroyCanvas(canvas);
        }
    }
    /**
     * Creates a new canvas for drawing this shape. May return null.
     */ createCanvas() {
        const canvas = this.createSvgCanvas();
        if (canvas && this.outline) {
            canvas.setStrokeWidth(this.strokeWidth);
            canvas.setStrokeColor(this.stroke);
            if (this.isDashed) {
                canvas.setDashed(this.isDashed);
            }
            canvas.setStrokeWidth = ()=>{
                return;
            };
            canvas.setStrokeColor = ()=>{
                return;
            };
            canvas.setFillColor = ()=>{
                return;
            };
            canvas.setGradient = ()=>{
                return;
            };
            canvas.setDashed = ()=>{
                return;
            };
            canvas.text = ()=>{
                return;
            };
        }
        return canvas;
    }
    /**
     * Creates and returns an {@link SvgCanvas2D} for rendering this shape.
     */ createSvgCanvas() {
        if (!this.node) return null;
        const canvas = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$canvas$2f$SvgCanvas2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.node, false);
        canvas.strokeTolerance = this.pointerEvents ? this.svgStrokeTolerance : 0;
        canvas.pointerEventsValue = this.svgPointerEvents;
        const off = this.getSvgScreenOffset();
        if (off !== 0) {
            this.node.setAttribute('transform', `translate(${off},${off})`);
        } else {
            this.node.removeAttribute('transform');
        }
        canvas.minStrokeWidth = this.minSvgStrokeWidth;
        if (!this.antiAlias) {
            // Rounds all numbers in the SVG output to integers
            canvas.format = (value)=>{
                return Math.round(value);
            };
        }
        return canvas;
    }
    /**
     * Destroys the given canvas which was used for drawing. This implementation
     * increments the reference counts on all shared gradients used in the canvas.
     */ destroyCanvas(canvas) {
        // Manages reference counts
        if (canvas instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$canvas$2f$SvgCanvas2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
            // Increments ref counts
            for(const key in canvas.gradients){
                const gradient = canvas.gradients[key];
                if (gradient) {
                    gradient.mxRefCount = (gradient.mxRefCount || 0) + 1;
                }
            }
            this.releaseSvgGradients(this.oldGradients);
            this.oldGradients = canvas.gradients;
        }
    }
    /**
     * Invoked before paint is called.
     */ beforePaint(c) {
        return;
    }
    /**
     * Invokes after paint was called.
     */ afterPaint(c) {
        return;
    }
    /**
     * Generic rendering code.
     */ paint(c) {
        let strokeDrawn = false;
        if (c && this.outline) {
            const { stroke } = c;
            c.stroke = (...args)=>{
                strokeDrawn = true;
                stroke.apply(c, args);
            };
            const { fillAndStroke } = c;
            c.fillAndStroke = (...args)=>{
                strokeDrawn = true;
                fillAndStroke.apply(c, args);
            };
        }
        // Scale is passed-through to canvas
        const s = this.scale;
        const bounds = this.bounds;
        if (bounds) {
            let x = bounds.x / s;
            let y = bounds.y / s;
            let w = bounds.width / s;
            let h = bounds.height / s;
            if (this.isPaintBoundsInverted()) {
                const t = (w - h) / 2;
                x += t;
                y -= t;
                const tmp = w;
                w = h;
                h = tmp;
            }
            this.updateTransform(c, x, y, w, h);
            this.configureCanvas(c, x, y, w, h);
            // Adds background rectangle to capture events
            let bg = null;
            if (!this.stencil && this.points.length === 0 && this.shapePointerEvents || this.stencil && this.stencilPointerEvents) {
                const bb = this.createBoundingBox();
                if (bb && this.node) {
                    bg = this.createTransparentSvgRectangle(bb.x, bb.y, bb.width, bb.height);
                    this.node.appendChild(bg);
                }
            }
            if (this.stencil) {
                this.stencil.drawShape(c, this, x, y, w, h);
            } else {
                // Stencils have separate strokewidth
                c.setStrokeWidth(this.strokeWidth);
                if (this.points.length > 0) {
                    // Paints edge shape
                    const pts = [];
                    for(let i = 0; i < this.points.length; i += 1){
                        const p = this.points[i];
                        if (p) {
                            pts.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](p.x / s, p.y / s));
                        }
                    }
                    this.paintEdgeShape(c, pts);
                } else {
                    // Paints vertex shape
                    this.paintVertexShape(c, x, y, w, h);
                }
            }
            if (bg && c.state && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNotNullish"])(c.state.transform)) {
                bg.setAttribute('transform', c.state.transform);
            }
            // Draws highlight rectangle if no stroke was used
            if (c && this.outline && !strokeDrawn) {
                c.rect(x, y, w, h);
                c.stroke();
            }
        }
    }
    /**
     * Sets the state of the canvas for drawing the shape.
     */ configureCanvas(c, x, y, w, h) {
        let dash = null;
        if (this.style && this.style.dashPattern != null) {
            dash = this.style.dashPattern;
        }
        c.setAlpha(this.opacity / 100);
        c.setFillAlpha(this.fillOpacity / 100);
        c.setStrokeAlpha(this.strokeOpacity / 100);
        // Sets alpha, colors and gradients
        if (this.isShadow) {
            c.setShadow(this.isShadow);
        }
        // Dash pattern
        if (this.isDashed) {
            c.setDashed(this.isDashed, this.style?.fixDash ?? false);
        }
        if (dash) {
            c.setDashPattern(dash);
        }
        if (this.fill !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"] && this.gradient !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
            const b = this.getGradientBounds(c, x, y, w, h);
            c.setGradient(this.fill, this.gradient, b.x, b.y, b.width, b.height, this.gradientDirection);
        } else {
            c.setFillColor(this.fill);
        }
        c.setStrokeColor(this.stroke);
    }
    /**
     * Returns the bounding box for the gradient box for this shape.
     */ getGradientBounds(c, x, y, w, h) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y, w, h);
    }
    /**
     * Sets the scale and rotation on the given canvas.
     */ updateTransform(c, x, y, w, h) {
        // NOTE: Currently, scale is implemented in state and canvas. This will
        // move to canvas in a later version, so that the states are unscaled
        // and untranslated and do not need an update after zooming or panning.
        c.scale(this.scale);
        c.rotate(this.getShapeRotation(), this.flipH, this.flipV, x + w / 2, y + h / 2);
    }
    /**
     * Paints the vertex shape.
     */ paintVertexShape(c, x, y, w, h) {
        this.paintBackground(c, x, y, w, h);
        if (!this.outline || !this.style || !(this.style.backgroundOutline ?? false)) {
            c.setShadow(false);
            this.paintForeground(c, x, y, w, h);
        }
    }
    /**
     * Hook for subclassers. This implementation is empty.
     */ paintBackground(c, x, y, w, h) {
        return;
    }
    /**
     * Hook for subclassers. This implementation is empty.
     */ paintForeground(c, x, y, w, h) {
        return;
    }
    /**
     * Hook for subclassers. This implementation is empty.
     */ paintEdgeShape(c, pts) {
        return;
    }
    /**
     * Returns the arc size for the given dimension.
     */ getArcSize(w, h) {
        let r = 0;
        if (this.style?.absoluteArcSize ?? false) {
            r = Math.min(w / 2, Math.min(h / 2, (this.style?.arcSize ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_ARCSIZE"]) / 2));
        } else {
            const f = (this.style?.arcSize ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RECTANGLE_ROUNDING_FACTOR"] * 100) / 100;
            r = Math.min(w * f, h * f);
        }
        return r;
    }
    /**
     * Paints the glass gradient effect.
     */ paintGlassEffect(c, x, y, w, h, arc) {
        const sw = Math.ceil((this.strokeWidth ?? 0) / 2);
        const size = 0.4;
        c.setGradient('#ffffff', '#ffffff', x, y, w, h * 0.6, 'south', 0.9, 0.1);
        c.begin();
        arc += 2 * sw;
        if (this.isRounded) {
            c.moveTo(x - sw + arc, y - sw);
            c.quadTo(x - sw, y - sw, x - sw, y - sw + arc);
            c.lineTo(x - sw, y + h * size);
            c.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);
            c.lineTo(x + w + sw, y - sw + arc);
            c.quadTo(x + w + sw, y - sw, x + w + sw - arc, y - sw);
        } else {
            c.moveTo(x - sw, y - sw);
            c.lineTo(x - sw, y + h * size);
            c.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);
            c.lineTo(x + w + sw, y - sw);
        }
        c.close();
        c.fill();
    }
    /**
     * Paints the given points with rounded corners.
     */ addPoints(c, pts, rounded = false, arcSize, close = false, exclude = [], initialMove = true) {
        if (pts.length > 0) {
            const pe = pts[pts.length - 1];
            // Adds virtual waypoint in the center between start and end point
            if (close && rounded) {
                pts = pts.slice();
                const p0 = pts[0];
                const wp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](pe.x + (p0.x - pe.x) / 2, pe.y + (p0.y - pe.y) / 2);
                pts.splice(0, 0, wp);
            }
            let pt = pts[0];
            let i = 1;
            // Draws the line segments
            if (initialMove) {
                c.moveTo(pt.x, pt.y);
            } else {
                c.lineTo(pt.x, pt.y);
            }
            while(i < (close ? pts.length : pts.length - 1)){
                let tmp = pts[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mod"])(i, pts.length)];
                let dx = pt.x - tmp.x;
                let dy = pt.y - tmp.y;
                if (rounded && (dx !== 0 || dy !== 0) && exclude.indexOf(i - 1) < 0) {
                    // Draws a line from the last point to the current
                    // point with a spacing of size off the current point
                    // into direction of the last point
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    const nx1 = dx * Math.min(arcSize, dist / 2) / dist;
                    const ny1 = dy * Math.min(arcSize, dist / 2) / dist;
                    const x1 = tmp.x + nx1;
                    const y1 = tmp.y + ny1;
                    c.lineTo(x1, y1);
                    // Draws a curve from the last point to the current
                    // point with a spacing of size off the current point
                    // into direction of the next point
                    let next = pts[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mod"])(i + 1, pts.length)];
                    // Uses next non-overlapping point
                    while(i < pts.length - 2 && Math.round(next.x - tmp.x) === 0 && Math.round(next.y - tmp.y) === 0){
                        next = pts[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mod"])(i + 2, pts.length)];
                        i++;
                    }
                    dx = next.x - tmp.x;
                    dy = next.y - tmp.y;
                    dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
                    const nx2 = dx * Math.min(arcSize, dist / 2) / dist;
                    const ny2 = dy * Math.min(arcSize, dist / 2) / dist;
                    const x2 = tmp.x + nx2;
                    const y2 = tmp.y + ny2;
                    c.quadTo(tmp.x, tmp.y, x2, y2);
                    tmp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x2, y2);
                } else {
                    c.lineTo(tmp.x, tmp.y);
                }
                pt = tmp;
                i += 1;
            }
            if (close) {
                c.close();
            } else {
                c.lineTo(pe.x, pe.y);
            }
        }
    }
    /**
     * Resets all styles.
     */ resetStyles() {
        this.initStyles();
        this.spacing = 0;
        this.fill = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.gradient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.gradientDirection = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST;
        this.stroke = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.startSize = 1;
        this.endSize = 1;
        this.startArrow = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.endArrow = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.direction = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST;
        this.isShadow = false;
        this.isDashed = false;
        this.isRounded = false;
        this.glass = false;
    }
    /**
     * Applies the style of the given <CellState> to the shape. This
     * implementation assigns the following styles to local fields:
     *
     * - <'fillColor'> => fill
     * - <'gradientColor'> => gradient
     * - <'gradientDirection'> => gradientDirection
     * - <'opacity'> => opacity
     * - {@link Constants#STYLE_FILL_OPACITY} => fillOpacity
     * - {@link Constants#STYLE_STROKE_OPACITY} => strokeOpacity
     * - <'strokeColor'> => stroke
     * - <'strokeWidth'> => strokewidth
     * - <'shadow'> => isShadow
     * - <'dashed'> => isDashed
     * - <'spacing'> => spacing
     * - <'startSize'> => startSize
     * - <'endSize'> => endSize
     * - <'rounded'> => isRounded
     * - <'startArrow'> => startArrow
     * - <'endArrow'> => endArrow
     * - <'rotation'> => rotation
     * - <'direction'> => direction
     * - <'glass'> => glass
     *
     * This keeps a reference to the <style>. If you need to keep a reference to
     * the cell, you can override this method and store a local reference to
     * state.cell or the <CellState> itself. If <outline> should be true, make
     * sure to set it before calling this method.
     *
     * @param state <CellState> of the corresponding cell.
     */ apply(state) {
        this.state = state;
        this.style = state.style;
        if (this.style) {
            this.fill = this.style.fillColor ?? this.fill;
            this.gradient = this.style.gradientColor ?? this.gradient;
            this.gradientDirection = this.style.gradientDirection ?? this.gradientDirection;
            this.opacity = this.style.opacity ?? this.opacity;
            this.fillOpacity = this.style.fillOpacity ?? this.fillOpacity;
            this.strokeOpacity = this.style.strokeOpacity ?? this.strokeOpacity;
            this.stroke = this.style.strokeColor ?? this.stroke;
            this.strokeWidth = this.style.strokeWidth ?? this.strokeWidth;
            this.spacing = this.style.spacing ?? this.spacing;
            this.startSize = this.style.startSize ?? this.startSize;
            this.endSize = this.style.endSize ?? this.endSize;
            this.startArrow = this.style.startArrow ?? this.startArrow;
            this.endArrow = this.style.endArrow ?? this.endArrow;
            this.rotation = this.style.rotation ?? this.rotation;
            this.direction = this.style.direction ?? this.direction;
            this.flipH = !!this.style.flipH;
            this.flipV = !!this.style.flipV;
            if (this.direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH || this.direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) {
                const tmp = this.flipH;
                this.flipH = this.flipV;
                this.flipV = tmp;
            }
            this.isShadow = this.style.shadow ?? this.isShadow;
            this.isDashed = this.style.dashed ?? this.isDashed;
            this.isRounded = this.style.rounded ?? this.isRounded;
            this.glass = this.style.glass ?? this.glass;
        }
    }
    /**
     * Sets the cursor on the given shape.
     *
     * @param cursor The cursor to be used.
     */ setCursor(cursor) {
        this.cursor = cursor;
        this.node.style.cursor = cursor;
    }
    /**
     * Returns the current cursor.
     */ getCursor() {
        return this.cursor;
    }
    /**
     * Hook for subclassers.
     */ isRoundable(c, x, y, w, h) {
        return false;
    }
    /**
     * Updates the <boundingBox> for this shape using <createBoundingBox> and
     * <augmentBoundingBox> and stores the result in <boundingBox>.
     */ updateBoundingBox() {
        // Tries to get bounding box from SVG subsystem
        // LATER: Use getBoundingClientRect for fallback in VML
        if (this.useSvgBoundingBox && this.node.ownerSVGElement) {
            try {
                const b = this.node.getBBox();
                if (b.width > 0 && b.height > 0) {
                    this.boundingBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](b.x, b.y, b.width, b.height);
                    // Adds strokeWidth
                    this.boundingBox.grow((this.strokeWidth ?? 0) * this.scale / 2);
                    return;
                }
            } catch (e) {
            // fallback to code below
            }
        }
        if (this.bounds) {
            let bbox = this.createBoundingBox();
            if (bbox) {
                this.augmentBoundingBox(bbox);
                const rot = this.getShapeRotation();
                if (rot !== 0) {
                    bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBoundingBox"])(bbox, rot);
                }
            }
            this.boundingBox = bbox;
        }
    }
    /**
     * Returns a new rectangle that represents the bounding box of the bare shape
     * with no shadows or strokewidths.
     */ createBoundingBox() {
        if (!this.bounds) return null;
        const bb = this.bounds.clone();
        if (this.stencil && (this.direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH || this.direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) || this.isPaintBoundsInverted()) {
            bb.rotate90();
        }
        return bb;
    }
    /**
     * Augments the bounding box with the strokewidth and shadow offsets.
     */ augmentBoundingBox(bbox) {
        if (this.isShadow) {
            bbox.width += Math.ceil(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StyleDefaultsConfig"].shadowOffsetX * this.scale);
            bbox.height += Math.ceil(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StyleDefaultsConfig"].shadowOffsetX * this.scale);
        }
        // Adds strokeWidth
        bbox.grow((this.strokeWidth ?? 0) * this.scale / 2);
    }
    /**
     * Returns true if the bounds should be inverted.
     */ isPaintBoundsInverted() {
        // Stencil implements inversion via aspect
        return !this.stencil && (this.direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH || this.direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH);
    }
    /**
     * Returns the rotation from the style.
     */ getRotation() {
        return this.rotation ?? 0;
    }
    /**
     * Returns the rotation for the text label.
     */ getTextRotation() {
        let rot = this.getRotation();
        if (!(this.style?.horizontal ?? true)) {
            rot += this.verticalTextRotation || -90; // WARNING WARNING!!!! ===============================================================================================
        }
        return rot;
    }
    /**
     * Returns the actual rotation of the shape.
     */ getShapeRotation() {
        let rot = this.getRotation();
        if (this.direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH) {
            rot += 270;
        } else if (this.direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST) {
            rot += 180;
        } else if (this.direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) {
            rot += 90;
        }
        return rot;
    }
    /**
     * Adds a transparent rectangle that catches all events.
     */ createTransparentSvgRectangle(x, y, w, h) {
        const rect = document.createElementNS(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NS_SVG"], 'rect');
        rect.setAttribute('x', String(x));
        rect.setAttribute('y', String(y));
        rect.setAttribute('width', String(w));
        rect.setAttribute('height', String(h));
        rect.setAttribute('fill', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]);
        rect.setAttribute('stroke', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]);
        rect.setAttribute('pointer-events', 'all');
        return rect;
    }
    redrawHtmlShape() {
        return;
    }
    /**
     * Sets a transparent background CSS style to catch all events.
     *
     * Paints the line shape.
     */ setTransparentBackgroundImage(node) {
        node.style.backgroundImage = `url('${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].imageBasePath}/transparent.gif')`;
    }
    /**
     * Paints the line shape.
     */ releaseSvgGradients(grads) {
        for(const key in grads){
            const gradient = grads[key];
            if (gradient) {
                gradient.mxRefCount = (gradient.mxRefCount || 0) - 1;
                if (gradient.mxRefCount === 0 && gradient.parentNode) {
                    gradient.parentNode.removeChild(gradient);
                }
            }
        }
    }
    /**
     * Destroys the shape by removing it from the DOM and releasing the DOM
     * node associated with the shape using {@link Event#release}.
     */ destroy() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].release(this.node);
        if (this.node.parentNode) {
            this.node.parentNode.removeChild(this.node);
        }
        this.node.innerHTML = '';
        // Decrements refCount and removes unused
        this.releaseSvgGradients(this.oldGradients);
        this.oldGradients = {};
    }
}
const __TURBOPACK__default__export__ = Shape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/PolylineShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Shape.js [app-client] (ecmascript)");
;
;
/**
 * Extends {@link Shape} to implement a polyline (a line with multiple points).
 *
 * The shape is used to represent edges, not vertices.
 *
 * By default, this shape is not registered in {@link CellRenderer}.
 *
 * @category Edge Shapes
 */ class PolylineShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
     * Constructs a new polyline shape.
     *
     * @param points Array of <{@link Point} that define the points. This is stored in {@link Shape.points}.
     * @param stroke String that defines the stroke color. Default is 'black'. This is stored in {@link Shape.stroke}.
     * @param strokeWidth Optional integer that defines the stroke width. Default is 1. This is stored in {@link Shape.strokeWidth}.
     */ constructor(points, stroke, strokeWidth = 1){
        super();
        this.points = points;
        this.stroke = stroke;
        this.strokeWidth = strokeWidth;
    }
    /**
     * Returns 0.
     */ getRotation() {
        return 0;
    }
    /**
     * Returns 0.
     */ getShapeRotation() {
        return 0;
    }
    /**
     * Returns false.
     */ isPaintBoundsInverted() {
        return false;
    }
    /**
     * Paints the line shape.
     */ paintEdgeShape(c, pts) {
        const prev = c.pointerEventsValue;
        c.pointerEventsValue = 'stroke';
        if (!this.style || !this.style.curved) {
            this.paintLine(c, pts, this.isRounded);
        } else {
            this.paintCurvedLine(c, pts);
        }
        c.pointerEventsValue = prev;
    }
    /**
     * Paints the line shape.
     */ paintLine(c, pts, rounded) {
        const arcSize = this.style?.arcSize ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_ARCSIZE"];
        c.begin();
        this.addPoints(c, pts, rounded, arcSize, false);
        c.stroke();
    }
    /**
     * Paints the line shape.
     */ paintCurvedLine(c, pts) {
        c.begin();
        const pt = pts[0];
        const n = pts.length;
        c.moveTo(pt.x, pt.y);
        for(let i = 1; i < n - 2; i += 1){
            const p0 = pts[i];
            const p1 = pts[i + 1];
            const ix = (p0.x + p1.x) / 2;
            const iy = (p0.y + p1.y) / 2;
            c.quadTo(p0.x, p0.y, ix, iy);
        }
        const p0 = pts[n - 2];
        const p1 = pts[n - 1];
        c.quadTo(p0.x, p0.y, p1.x, p1.y);
        c.stroke();
    }
}
const __TURBOPACK__default__export__ = PolylineShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/ConnectorShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$MarkerShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/MarkerShape.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$PolylineShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/PolylineShape.js [app-client] (ecmascript)");
;
;
;
/**
 * Extends {@link PolylineShape} to implement a connector shape including a polyline (a line with multiple points)
 * that allows for arrow heads on either side.
 *
 * The shape is used to represent edges, not vertices.
 *
 * This shape is registered under {@link SHAPE.CONNECTOR} in {@link CellRenderer}.
 *
 * @category Edge Shapes
 */ class ConnectorShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$PolylineShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(points, stroke, strokewidth){
        super(points, stroke, strokewidth);
    }
    /**
     * Updates the <boundingBox> for this shape using <createBoundingBox>
     * and augmentBoundingBox and stores the result in <boundingBox>.
     */ updateBoundingBox() {
        this.useSvgBoundingBox = !!this.style?.curved;
        super.updateBoundingBox();
    }
    /**
     * Paints the line shape.
     */ paintEdgeShape(c, pts) {
        // The indirection via functions for markers is needed in
        // order to apply the offsets before painting the line and
        // paint the markers after painting the line.
        const sourceMarker = this.createMarker(c, pts, true);
        const targetMarker = this.createMarker(c, pts, false);
        super.paintEdgeShape(c, pts);
        // Disables shadows, dashed styles
        c.setShadow(false);
        c.setDashed(false);
        if (sourceMarker) {
            const strokeColor = this.style?.startStrokeColor ?? this.stroke;
            c.setStrokeColor(strokeColor);
            c.setFillColor(this.style?.startFillColor ?? strokeColor);
            sourceMarker();
        }
        if (targetMarker) {
            const strokeColor = this.style?.endStrokeColor ?? this.stroke;
            c.setStrokeColor(strokeColor);
            c.setFillColor(this.style?.endFillColor ?? strokeColor);
            targetMarker();
        }
    }
    /**
     * Prepares the marker by adding offsets in pts and returning a function to paint the marker.
     */ createMarker(c, pts, source) {
        if (!this.style) return null;
        let result = null;
        const n = pts.length;
        const type = (source ? this.style.startArrow : this.style.endArrow) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        let p0 = source ? pts[1] : pts[n - 2];
        const pe = source ? pts[0] : pts[n - 1];
        if (type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"] && p0 !== null && pe !== null) {
            let count = 1;
            // Uses next non-overlapping point
            while(count < n - 1 && Math.round(p0.x - pe.x) === 0 && Math.round(p0.y - pe.y) === 0){
                p0 = source ? pts[1 + count] : pts[n - 2 - count];
                count++;
            }
            // Computes the norm and the inverse norm
            const dx = pe.x - p0.x;
            const dy = pe.y - p0.y;
            const dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
            const unitX = dx / dist;
            const unitY = dy / dist;
            const size = (source ? this.style.startSize : this.style.endSize) ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_MARKERSIZE"];
            // Allow for stroke width in the end point used and the
            // orthogonal vectors describing the direction of the marker
            const filled = (source ? this.style.startFill : this.style.endFill) ?? true;
            result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$MarkerShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createMarker(c, this, type, pe, unitX, unitY, size, source, this.strokeWidth, filled);
        }
        return result;
    }
    /**
     * Augments the bounding box with the strokewidth and shadow offsets.
     */ augmentBoundingBox(bbox) {
        super.augmentBoundingBox(bbox);
        if (!this.style) return;
        // Adds marker sizes
        let size = 0;
        if (this.style.startArrow !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
            size = (this.style.startSize ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_MARKERSIZE"]) + 1;
        }
        if (this.style.endArrow !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
            size = Math.max(size, this.style.endSize ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_MARKERSIZE"]) + 1;
        }
        bbox.grow(size * this.scale);
    }
}
const __TURBOPACK__default__export__ = ConnectorShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/node/RectangleShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Shape.js [app-client] (ecmascript)");
;
;
/**
 * Extends {@link Shape} to implement a rectangle shape.
 * This shape is registered by default under {@link SHAPE.RECTANGLE} in {@link CellRenderer}.
 *
 * @category Vertex Shapes
 */ class RectangleShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(bounds, fill, stroke, strokeWidth = 1){
        super();
        this.bounds = bounds;
        this.fill = fill;
        this.stroke = stroke;
        this.strokeWidth = strokeWidth;
    }
    /**
     * Returns true for non-rounded, non-rotated shapes with no glass gradient.
     */ isHtmlAllowed() {
        let events = true;
        if (this.style && this.style.pointerEvents != null) {
            events = this.style.pointerEvents;
        }
        return !this.isRounded && !this.glass && this.rotation === 0 && (events || this.fill !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]);
    }
    /**
     * Generic background painting implementation.
     */ paintBackground(c, x, y, w, h) {
        let events = true;
        if (this.style && this.style.pointerEvents != null) {
            events = this.style.pointerEvents;
        }
        if (events || this.fill !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"] || this.stroke !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
            if (!events && this.fill === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
                c.pointerEvents = false;
            }
            if (this.isRounded) {
                let r = 0;
                if (this.style?.absoluteArcSize ?? false) {
                    r = Math.min(w / 2, Math.min(h / 2, (this.style?.arcSize ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_ARCSIZE"]) / 2));
                } else {
                    const f = (this.style?.arcSize ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RECTANGLE_ROUNDING_FACTOR"] * 100) / 100;
                    r = Math.min(w * f, h * f);
                }
                c.roundrect(x, y, w, h, r, r);
            } else {
                c.rect(x, y, w, h);
            }
            c.fillAndStroke();
        }
    }
    /**
     * Adds roundable support.
     */ isRoundable(c, x, y, w, h) {
        return true;
    }
    /**
     * Generic background painting implementation.
     */ paintForeground(c, x, y, w, h) {
        if (this.glass && !this.outline && this.fill !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
            this.paintGlassEffect(c, x, y, w, h, this.getArcSize(w + this.strokeWidth, h + this.strokeWidth));
        }
    }
}
const __TURBOPACK__default__export__ = RectangleShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/node/TextShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/domUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/StringUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$canvas$2f$SvgCanvas2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/canvas/SvgCanvas2D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Shape.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
/**
 * Extends {@link Shape} to implement a text shape.
 *
 * To change vertical text from "bottom to top" to "top to bottom", the following code can be used:
 * ```javascript
 * TextShape.prototype.verticalTextRotation = 90;
 * ```
 *
 * @category Vertex Shapes
 */ class TextShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(value, bounds, align = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER, valign = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE, color = 'black', family = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONTFAMILY"], size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONTSIZE"], fontStyle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONTSTYLE"], spacing = 2, spacingTop = 0, spacingRight = 0, spacingBottom = 0, spacingLeft = 0, horizontal = true, background = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"], border = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"], wrap = false, clipped = false, overflow = 'visible', labelPadding = 0, textDirection = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_TEXT_DIRECTION"]){
        super();
        this.margin = null;
        this.unrotatedBoundingBox = null;
        this.flipH = false;
        this.flipV = false;
        /**
         * Specifies the spacing to be added to the top spacing. Default is 0. Use the
         * value 5 here to get the same label positions as in mxGraph 1.x.
         */ this.baseSpacingTop = 0;
        /**
         * Specifies the spacing to be added to the bottom spacing. Default is 0. Use the
         * value 1 here to get the same label positions as in mxGraph 1.x.
         */ this.baseSpacingBottom = 0;
        /**
         * Specifies the spacing to be added to the left spacing. Default is 0.
         */ this.baseSpacingLeft = 0;
        /**
         * Specifies the spacing to be added to the right spacing. Default is 0.
         */ this.baseSpacingRight = 0;
        /**
         * Specifies if linefeeds in HTML labels should be replaced with BR tags.
         * Default is true.
         */ this.replaceLinefeeds = true;
        /**
         * Rotation for vertical text. Default is -90 (bottom to top).
         */ this.verticalTextRotation = -90;
        /**
         * Specifies if the string size should be measured in <updateBoundingBox> if
         * the label is clipped and the label position is center and middle. If this is
         * true, then the bounding box will be set to <bounds>. Default is true.
         * <ignoreStringSize> has precedence over this switch.
         */ this.ignoreClippedStringSize = true;
        /**
         * Specifies if the actual string size should be measured. If disabled the
         * boundingBox will not ignore the actual size of the string, otherwise
         * <bounds> will be used instead. Default is false.
         */ this.ignoreStringSize = false;
        /**
         * Contains the last rendered text value. Used for caching.
         */ this.lastValue = null;
        /**
         * Specifies if caching for HTML labels should be enabled. Default is true.
         */ this.cacheEnabled = true;
        this.value = value;
        this.bounds = bounds;
        this.color = color ?? 'black';
        this.align = align ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER;
        this.valign = valign ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE;
        this.family = family ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONTFAMILY"];
        this.size = size ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONTSIZE"];
        this.fontStyle = fontStyle ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONTSTYLE"];
        this.spacing = spacing ?? 2;
        this.spacingTop = this.spacing + (spacingTop ?? 0);
        this.spacingRight = this.spacing + (spacingRight ?? 0);
        this.spacingBottom = this.spacing + (spacingBottom ?? 0);
        this.spacingLeft = this.spacing + (spacingLeft ?? 0);
        this.horizontal = horizontal ?? true;
        this.background = background;
        this.border = border;
        this.wrap = wrap ?? false;
        this.clipped = clipped ?? false;
        this.overflow = overflow ?? 'visible';
        this.labelPadding = labelPadding ?? 0;
        this.textDirection = textDirection;
        this.rotation = 0;
        this.updateMargin();
    }
    /**
     * Disables offset in IE9 for crisper image output.
     */ getSvgScreenOffset() {
        return 0;
    }
    /**
     * Returns true if the bounds are not null and all of its variables are numeric.
     */ checkBounds() {
        return !isNaN(this.scale) && isFinite(this.scale) && this.scale > 0 && this.bounds && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) && !isNaN(this.bounds.width) && !isNaN(this.bounds.height);
    }
    /**
     * Generic rendering code.
     */ paint(c, update = false) {
        // Scale is passed-through to canvas
        const s = this.scale;
        const x = this.bounds.x / s;
        const y = this.bounds.y / s;
        const w = this.bounds.width / s;
        const h = this.bounds.height / s;
        this.updateTransform(c, x, y, w, h);
        this.configureCanvas(c, x, y, w, h);
        if (update) {
            c.updateText(x, y, w, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.getTextRotation(), this.node);
        } else {
            // Checks if text contains HTML markup
            const realHtml = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(this.value) || this.dialect === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIALECT"].STRICTHTML;
            // Always renders labels as HTML in VML
            const fmt = realHtml ? 'html' : '';
            let val = this.value;
            if (!realHtml && fmt === 'html') {
                // @ts-ignore
                val = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["htmlEntities"])(val, false);
            }
            if (fmt === 'html' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(this.value)) {
                val = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["replaceTrailingNewlines"])(val, '<div><br></div>');
            }
            // Handles trailing newlines to make sure they are visible in rendering output
            val = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(this.value) && this.replaceLinefeeds && fmt === 'html' ? val.replace(/\n/g, '<br/>') : val;
            let dir = this.textDirection;
            if (dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TEXT_DIRECTION"].AUTO && !realHtml) {
                dir = this.getAutoDirection();
            }
            if (dir !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TEXT_DIRECTION"].LTR && dir !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TEXT_DIRECTION"].RTL) {
                dir = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TEXT_DIRECTION"].DEFAULT;
            }
            c.text(x, y, w, h, val, this.align, this.valign, this.wrap, fmt, this.overflow, this.clipped, this.getTextRotation(), dir);
        }
    }
    /**
     * Renders the text using the given DOM nodes.
     */ redraw() {
        if (this.visible && this.checkBounds() && this.cacheEnabled && this.lastValue === this.value && ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(this.value) || this.dialect === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIALECT"].STRICTHTML)) {
            if (this.node.nodeName === 'DIV') {
                this.redrawHtmlShape();
                this.updateBoundingBox();
            } else {
                const canvas = this.createCanvas();
                if (canvas) {
                    // Specifies if events should be handled
                    canvas.pointerEvents = this.pointerEvents;
                    this.paint(canvas, true);
                    this.destroyCanvas(canvas);
                    this.updateBoundingBox();
                }
            }
        } else {
            super.redraw();
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(this.value) || this.dialect === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIALECT"].STRICTHTML) {
                this.lastValue = this.value;
            } else {
                this.lastValue = null;
            }
        }
    }
    /**
     * Resets all styles.
     */ resetStyles() {
        super.resetStyles();
        this.color = 'black';
        this.align = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER;
        this.valign = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE;
        this.family = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONTFAMILY"];
        this.size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONTSIZE"];
        this.fontStyle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONTSTYLE"];
        this.spacing = 2;
        this.spacingTop = 2;
        this.spacingRight = 2;
        this.spacingBottom = 2;
        this.spacingLeft = 2;
        this.horizontal = true;
        this.background = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.border = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.textDirection = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_TEXT_DIRECTION"];
        this.margin = null;
    }
    /**
     * Extends mxShape to update the text styles.
     *
     * @param state <CellState> of the corresponding cell.
     */ apply(state) {
        const old = this.spacing;
        super.apply(state);
        if (this.style) {
            this.fontStyle = this.style.fontStyle ?? this.fontStyle;
            this.family = this.style.fontFamily ?? this.family;
            this.size = this.style.fontSize ?? this.size;
            this.color = this.style.fontColor ?? this.color;
            this.align = this.style.align ?? this.align;
            this.valign = this.style.verticalAlign ?? this.valign;
            this.spacing = this.style.spacing ?? this.spacing;
            this.spacingTop = (this.style.spacingTop ?? this.spacingTop - old) + this.spacing;
            this.spacingRight = (this.style.spacingRight ?? this.spacingRight - old) + this.spacing;
            this.spacingBottom = (this.style.spacingBottom ?? this.spacingBottom - old) + this.spacing;
            this.spacingLeft = (this.style.spacingLeft ?? this.spacingLeft - old) + this.spacing;
            this.horizontal = this.style.horizontal ?? this.horizontal;
            this.background = this.style.labelBackgroundColor ?? this.background;
            this.border = this.style.labelBorderColor ?? this.border;
            this.textDirection = this.style.textDirection ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_TEXT_DIRECTION"];
            this.opacity = this.style.textOpacity ?? 100;
            this.updateMargin();
        }
        this.flipV = false;
        this.flipH = false;
    }
    /**
     * Used to determine the automatic text direction. Returns
     * {@link Constants#TEXT_DIRECTION_LTR} or {@link Constants#TEXT_DIRECTION_RTL}
     * depending on the contents of <value>. This is not invoked for HTML, wrapped
     * content or if <value> is a DOM node.
     */ getAutoDirection() {
        // Looks for strong (directional) characters
        const tmp = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(String(this.value));
        // Returns the direction defined by the character
        return tmp && tmp.length > 0 && tmp[0] > 'z' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TEXT_DIRECTION"].RTL : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TEXT_DIRECTION"].LTR;
    }
    /**
     * Returns the node that contains the rendered input.
     */ getContentNode() {
        let result = this.node;
        if (result) {
            // Rendered with no foreignObject
            if (!result.ownerSVGElement) {
                // @ts-ignore
                result = this.node.firstChild.firstChild;
            } else {
                // Innermost DIV that contains the actual content
                // @ts-ignore
                result = result.firstChild.firstChild.firstChild.firstChild.firstChild;
            }
        }
        return result;
    }
    /**
     * Updates the <boundingBox> for this shape using the given node and position.
     */ updateBoundingBox() {
        let { node } = this;
        this.boundingBox = this.bounds.clone();
        const rot = this.getTextRotation();
        const h = this.style?.labelPosition ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER;
        const v = this.style?.verticalLabelPosition ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE;
        if (!this.ignoreStringSize && node && this.overflow !== 'fill' && (!this.clipped || !this.ignoreClippedStringSize || h !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER || v !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE)) {
            let ow = null;
            let oh = null;
            if (node.firstChild && node.firstChild.firstChild && node.firstChild.firstChild.nodeName === 'foreignObject') {
                // Uses second inner DIV for font metrics
                // @ts-ignore
                node = node.firstChild.firstChild.firstChild.firstChild;
                // @ts-ignore
                oh = node.offsetHeight * this.scale;
                if (this.overflow === 'width') {
                    ow = this.boundingBox.width;
                } else {
                    // @ts-ignore
                    ow = node.offsetWidth * this.scale;
                }
            } else {
                try {
                    const b = node.getBBox();
                    // Workaround for bounding box of empty string
                    if (typeof this.value === 'string' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trim"])(this.value)?.length === 0) {
                        this.boundingBox = null;
                    } else if (b.width === 0 && b.height === 0) {
                        this.boundingBox = null;
                    } else {
                        this.boundingBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](b.x, b.y, b.width, b.height);
                    }
                    return;
                } catch (e) {
                // Ignores NS_ERROR_FAILURE in FF if container display is none.
                }
            }
            if (ow && oh) {
                this.boundingBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.bounds.x, this.bounds.y, ow, oh);
            }
        }
        if (this.boundingBox) {
            const margin = this.margin;
            if (rot !== 0) {
                // Accounts for pre-rotated x and y
                const bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBoundingBox"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](margin.x * this.boundingBox.width, margin.y * this.boundingBox.height, this.boundingBox.width, this.boundingBox.height), rot, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0));
                this.unrotatedBoundingBox = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromRectangle(this.boundingBox);
                this.unrotatedBoundingBox.x += margin.x * this.unrotatedBoundingBox.width;
                this.unrotatedBoundingBox.y += margin.y * this.unrotatedBoundingBox.height;
                this.boundingBox.x += bbox.x;
                this.boundingBox.y += bbox.y;
                this.boundingBox.width = bbox.width;
                this.boundingBox.height = bbox.height;
            } else {
                this.boundingBox.x += margin.x * this.boundingBox.width;
                this.boundingBox.y += margin.y * this.boundingBox.height;
                this.unrotatedBoundingBox = null;
            }
        }
    }
    /**
     * Returns 0 to avoid using rotation in the canvas via updateTransform.
     */ getShapeRotation() {
        return 0;
    }
    /**
     * Returns the rotation for the text label of the corresponding shape.
     */ getTextRotation() {
        return this.state && this.state.shape ? this.state.shape.getTextRotation() : 0;
    }
    /**
     * Inverts the bounds if {@link Shape#isBoundsInverted} returns true or if the
     * horizontal style is false.
     */ isPaintBoundsInverted() {
        return !this.horizontal && !!this.state && this.state.cell.isVertex();
    }
    /**
     * Sets the state of the canvas for drawing the shape.
     */ configureCanvas(c, x, y, w, h) {
        super.configureCanvas(c, x, y, w, h);
        c.setFontColor(this.color);
        c.setFontBackgroundColor(this.background);
        c.setFontBorderColor(this.border);
        c.setFontFamily(this.family);
        c.setFontSize(this.size);
        c.setFontStyle(this.fontStyle);
    }
    /**
     * Private helper function to create SVG elements
     */ getHtmlValue() {
        let val = this.value;
        if (this.dialect !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIALECT"].STRICTHTML) {
            // @ts-ignore
            val = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["htmlEntities"])(val, false);
        }
        // Handles trailing newlines to make sure they are visible in rendering output
        val = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["replaceTrailingNewlines"])(val, '<div><br></div>');
        val = this.replaceLinefeeds ? val.replace(/\n/g, '<br/>') : val;
        return val;
    }
    /**
     * Private helper function to create SVG elements
     */ getTextCss() {
        const lh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ABSOLUTE_LINE_HEIGHT"] ? `${this.size * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_HEIGHT"]}px` : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_HEIGHT"];
        let css = `display: inline-block; font-size: ${this.size}px; ` + `font-family: ${this.family}; color: ${this.color}; line-height: ${lh}; pointer-events: ${this.pointerEvents ? 'all' : 'none'}; `;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(this.fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].BOLD) && (css += 'font-weight: bold; ');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(this.fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].ITALIC) && (css += 'font-style: italic; ');
        const txtDecor = [];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(this.fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].UNDERLINE) && txtDecor.push('underline');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(this.fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].STRIKETHROUGH) && txtDecor.push('line-through');
        txtDecor.length > 0 && (css += `text-decoration: ${txtDecor.join(' ')}; `);
        return css;
    }
    /**
     * Updates the HTML node(s) to reflect the latest bounds and scale.
     */ redrawHtmlShape() {
        const w = Math.max(0, Math.round(this.bounds.width / this.scale));
        const h = Math.max(0, Math.round(this.bounds.height / this.scale));
        const flex = `position: absolute; left: ${Math.round(this.bounds.x)}px; ` + `top: ${Math.round(this.bounds.y)}px; pointer-events: none; `;
        const block = this.getTextCss();
        const margin = this.margin;
        const node = this.node;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$canvas$2f$SvgCanvas2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createCss(w + 2, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.background !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"] ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["htmlEntities"])(this.background, true) : null, this.border !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"] ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["htmlEntities"])(this.border, true) : null, flex, block, this.scale, (dx, dy, flex, item, block, ofl)=>{
            const r = this.getTextRotation();
            let tr = (this.scale !== 1 ? `scale(${this.scale}) ` : '') + (r !== 0 ? `rotate(${r}deg) ` : '') + (margin.x !== 0 || margin.y !== 0 ? `translate(${margin.x * 100}%,${margin.y * 100}%)` : '');
            if (tr !== '') {
                tr = `transform-origin: 0 0; transform: ${tr}; `;
            }
            if (ofl === '') {
                flex += item;
                item = `display:inline-block; min-width: 100%; ${tr}`;
            } else {
                item += tr;
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_SF) {
                    item += '-webkit-clip-path: content-box;';
                }
            }
            if (this.opacity < 100) {
                block += `opacity: ${this.opacity / 100}; `;
            }
            node.setAttribute('style', flex);
            const html = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(this.value) ? this.value.outerHTML : this.getHtmlValue();
            if (!node.firstChild) {
                node.innerHTML = `<div><div>${html}</div></div>`;
            }
            // @ts-ignore
            node.firstChild.firstChild.setAttribute('style', block);
            // @ts-ignore
            node.firstChild.setAttribute('style', item);
        });
    }
    /**
     * Sets the inner HTML of the given element to the <value>.
     */ updateInnerHtml(elt) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(this.value)) {
            // @ts-ignore
            elt.innerHTML = this.value.outerHTML;
        } else {
            let val = this.value;
            if (this.dialect !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIALECT"].STRICTHTML) {
                // LATER: Can be cached in updateValue
                val = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["htmlEntities"])(val, false);
            }
            // Handles trailing newlines to make sure they are visible in rendering output
            val = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["replaceTrailingNewlines"])(val, '<div>&nbsp;</div>');
            val = this.replaceLinefeeds ? val.replace(/\n/g, '<br/>') : val;
            val = `<div style="display:inline-block;_display:inline;">${val}</div>`;
            elt.innerHTML = val;
        }
    }
    /**
     * Updates the HTML node(s) to reflect the latest bounds and scale.
     */ updateValue() {
        const node = this.node;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(this.value)) {
            node.innerHTML = '';
            node.appendChild(this.value);
        } else {
            let val = this.value;
            if (this.dialect !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIALECT"].STRICTHTML) {
                val = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["htmlEntities"])(val, false);
            }
            // Handles trailing newlines to make sure they are visible in rendering output
            val = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["replaceTrailingNewlines"])(val, '<div><br></div>');
            val = this.replaceLinefeeds ? val.replace(/\n/g, '<br/>') : val;
            const bg = this.background !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"] ? this.background : null;
            const bd = this.border !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"] ? this.border : null;
            if (this.overflow === 'fill' || this.overflow === 'width') {
                if (bg) {
                    node.style.backgroundColor = bg;
                }
                if (bd) {
                    node.style.border = `1px solid ${bd}`;
                }
            } else {
                let css = '';
                if (bg) {
                    css += `background-color:${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["htmlEntities"])(bg, true)};`;
                }
                if (bd) {
                    css += `border:1px solid ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["htmlEntities"])(bd, true)};`;
                }
                // Wrapper DIV for background, zoom needed for inline in quirks
                // and to measure wrapped font sizes in all browsers
                // FIXME: Background size in quirks mode for wrapped text
                const lh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ABSOLUTE_LINE_HEIGHT"] ? `${this.size * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_HEIGHT"]}px` : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_HEIGHT"];
                val = `<div style="zoom:1;${css}display:inline-block;_display:inline;text-decoration:inherit;` + `padding-bottom:1px;padding-right:1px;line-height:${lh}">${val}</div>`;
            }
            node.innerHTML = val;
            // Sets text direction
            const divs = node.getElementsByTagName('div');
            if (divs.length > 0) {
                let dir = this.textDirection;
                if (dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TEXT_DIRECTION"].AUTO && this.dialect !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIALECT"].STRICTHTML) {
                    dir = this.getAutoDirection();
                }
                if (dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TEXT_DIRECTION"].LTR || dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TEXT_DIRECTION"].RTL) {
                    divs[divs.length - 1].setAttribute('dir', dir);
                } else {
                    divs[divs.length - 1].removeAttribute('dir');
                }
            }
        }
    }
    /**
     * Updates the HTML node(s) to reflect the latest bounds and scale.
     */ updateFont(node) {
        const { style } = node;
        // @ts-ignore
        style.lineHeight = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ABSOLUTE_LINE_HEIGHT"] ? `${this.size * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_HEIGHT"]}px` : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_HEIGHT"];
        style.fontSize = `${this.size}px`;
        style.fontFamily = this.family;
        style.verticalAlign = 'top';
        style.color = this.color;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(this.fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].BOLD) ? style.fontWeight = 'bold' : style.fontWeight = '';
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(this.fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].ITALIC) ? style.fontStyle = 'italic' : style.fontStyle = '';
        const txtDecor = [];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(this.fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].UNDERLINE) && txtDecor.push('underline');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(this.fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].STRIKETHROUGH) && txtDecor.push('line-through');
        txtDecor.length > 0 && (style.textDecoration = txtDecor.join(' '));
        if (this.align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER) {
            style.textAlign = 'center';
        } else if (this.align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT) {
            style.textAlign = 'right';
        } else {
            style.textAlign = 'left';
        }
    }
    /**
     * Updates the HTML node(s) to reflect the latest bounds and scale.
     */ updateSize(node, enableWrap = false) {
        const w = Math.max(0, Math.round(this.bounds.width / this.scale));
        const h = Math.max(0, Math.round(this.bounds.height / this.scale));
        const { style } = node;
        // NOTE: Do not use maxWidth here because wrapping will
        // go wrong if the cell is outside of the viewable area
        if (this.clipped) {
            style.overflow = 'hidden';
            style.maxHeight = `${h}px`;
            style.maxWidth = `${w}px`;
        } else if (this.overflow === 'fill') {
            style.width = `${w + 1}px`;
            style.height = `${h + 1}px`;
            style.overflow = 'hidden';
        } else if (this.overflow === 'width') {
            style.width = `${w + 1}px`;
            style.maxHeight = `${h + 1}px`;
            style.overflow = 'hidden';
        }
        if (this.wrap && w > 0) {
            style.wordWrap = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WORD_WRAP"];
            style.whiteSpace = 'normal';
            style.width = `${w}px`;
            if (enableWrap && this.overflow !== 'fill' && this.overflow !== 'width') {
                let sizeDiv = node;
                if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName === 'DIV') {
                    // @ts-ignore
                    sizeDiv = sizeDiv.firstChild;
                    if (node.style.wordWrap === 'break-word') {
                        sizeDiv.style.width = '100%';
                    }
                }
                let tmp = sizeDiv.offsetWidth;
                // Workaround for text measuring in hidden containers
                if (tmp === 0) {
                    const prev = node.parentNode;
                    node.style.visibility = 'hidden';
                    document.body.appendChild(node);
                    tmp = sizeDiv.offsetWidth;
                    node.style.visibility = '';
                    prev.appendChild(node);
                }
                tmp += 3;
                if (this.clipped) {
                    tmp = Math.min(tmp, w);
                }
                style.width = `${tmp}px`;
            }
        } else {
            style.whiteSpace = 'nowrap';
        }
    }
    /**
     * Returns the spacing as an {@link Point}.
     */ updateMargin() {
        this.margin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAlignmentAsPoint"])(this.align, this.valign);
    }
    /**
     * Returns the spacing as an {@link Point}.
     */ getSpacing() {
        let dx = 0;
        let dy = 0;
        if (this.align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER) {
            dx = (this.spacingLeft - this.spacingRight) / 2;
        } else if (this.align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT) {
            dx = -this.spacingRight - this.baseSpacingRight;
        } else {
            dx = this.spacingLeft + this.baseSpacingLeft;
        }
        if (this.valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE) {
            dy = (this.spacingTop - this.spacingBottom) / 2;
        } else if (this.valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].BOTTOM) {
            dy = -this.spacingBottom - this.baseSpacingBottom;
        } else {
            dy = this.spacingTop + this.baseSpacingTop;
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](dx, dy);
    }
}
const __TURBOPACK__default__export__ = TextShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/node/StencilShapeRegistry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ /**
 * A singleton class that provides a registry for stencils and the methods
 * for painting those stencils onto a canvas or into a DOM.
 *
 * Code to add stencils:
 * ```javascript
 * let req = mxUtils.load('test/stencils.xml');
 * let root = req.getDocumentElement();
 * let shape = root.firstChild;
 *
 * while (shape != null)
 * {
 *   if (shape.nodeType === mxConstants.NODETYPE_ELEMENT)
 *  {
 *    mxStencilRegistry.addStencil(shape.getAttribute('name'), new mxStencil(shape));
 *  }
 *
 *  shape = shape.nextSibling;
 * }
 * ```
 * @class StencilShapeRegistry
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
class StencilShapeRegistry {
    /**
     * Adds the given {@link Stencil}.
     * @static
     * @param {string} name
     * @param {StencilShape} stencil
     */ static addStencil(name, stencil) {
        StencilShapeRegistry.stencils[name] = stencil;
    }
    /**
     * Returns the {@link Stencil} for the given name.
     * @static
     * @param {string} name
     * @returns {StencilShape}
     */ static getStencil(name) {
        return StencilShapeRegistry.stencils[name];
    }
}
StencilShapeRegistry.stencils = {};
const __TURBOPACK__default__export__ = StencilShapeRegistry;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/node/ImageShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/RectangleShape.js [app-client] (ecmascript)");
;
;
/**
 * Extends {@link RectangleShape} to implement an image shape.
 * This shape is registered by default under {@link SHAPE.IMAGE} in {@link CellRenderer}.
 *
 * @category Vertex Shapes
 */ class ImageShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(bounds, imageSrc, fill = '#FFFFFF', stroke = '#000000', strokeWidth = 1){
        super(bounds, fill, stroke, strokeWidth);
        // Used in mxCellRenderer
        this.overlay = null;
        /**
         * Switch to preserve image aspect. Default is true.
         * @default true
         */ // preserveImageAspect: boolean;
        this.preserveImageAspect = true;
        this.imageSrc = imageSrc;
        this.shadow = false;
    }
    /**
     * Disables offset in IE9 for crisper image output.
     */ getSvgScreenOffset() {
        return 0;
    }
    /**
     * Overrides to replace the fill and stroke colors with the respective values from {@link imageBackground} and {@link imageBorder}.
     *
     * Applies the style of the given {@link CellState} to the shape. This implementation assigns the following styles to local fields:
     *
     * - {@link imageBackground} => fill
     * - {@link imageBorder} => stroke
     *
     * @param {CellState} state   {@link CellState} of the corresponding cell.
     */ apply(state) {
        super.apply(state);
        this.fill = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.stroke = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.gradient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        if (this.style && this.style.imageAspect != null) {
            this.preserveImageAspect = this.style.imageAspect;
        }
    }
    /**
     * Returns true if HTML is allowed for this shape. This implementation always
     * returns false.
     */ isHtmlAllowed() {
        return !this.preserveImageAspect;
    }
    /**
     * Disables inherited roundable support.
     */ isRoundable(c, x, y, w, h) {
        return false;
    }
    /**
     * Generic background painting implementation.
     */ paintVertexShape(c, x, y, w, h) {
        if (this.imageSrc) {
            const fill = this.style?.imageBackground ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
            const stroke = this.style?.imageBorder ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
            if (fill !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
                // Stroke rendering required for shadow
                c.setFillColor(fill);
                c.setStrokeColor(stroke);
                c.rect(x, y, w, h);
                c.fillAndStroke();
            }
            // FlipH/V are implicit via mxShape.updateTransform
            c.image(x, y, w, h, this.imageSrc, this.preserveImageAspect, false, false);
            if (stroke !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
                c.setShadow(false);
                c.setStrokeColor(stroke);
                c.rect(x, y, w, h);
                c.stroke();
            }
        } else {
            this.paintBackground(c, x, y, w, h);
        }
    }
}
const __TURBOPACK__default__export__ = ImageShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/node/EllipseShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Shape.js [app-client] (ecmascript)");
;
/**
 * Extends {@link Shape} to implement an ellipse shape.
 * This shape is registered by default under {@link SHAPE.ELLIPSE} in {@link CellRenderer}.
 *
 * @category Vertex Shapes
 */ class EllipseShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(bounds, fill, stroke, strokeWidth = 1){
        super();
        this.bounds = bounds;
        this.fill = fill;
        this.stroke = stroke;
        this.strokeWidth = strokeWidth;
    }
    /**
     * Paints the ellipse shape.
     */ paintVertexShape(c, x, y, w, h) {
        c.ellipse(x, y, w, h);
        c.fillAndStroke();
    }
}
const __TURBOPACK__default__export__ = EllipseShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/ActorShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Shape.js [app-client] (ecmascript)");
;
;
/**
 * Extends {@link Shape} to implement an actor shape.
 * This shape is registered by default under {@link SHAPE.ACTOR} in {@link CellRenderer}.
 *
 * If a custom shape with one filled area is needed, then this shape's {@link redrawPath} method should be overridden
 * like in the following example:
 *
 * ```typescript
 * class SampleShape extends ActorShape {
 *   redrawPath(c: AbstractCanvas2D, x: number, y: number, w: number, h: number) {
 *     path.moveTo(0, 0);
 *     path.lineTo(w, h);
 *     // ...
 *     path.close();
 *   }
 * }
 * ```
 *
 * @category Vertex Shapes
 */ class ActorShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(bounds = null, fill = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"], stroke = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"], strokeWidth = 1){
        super();
        this.bounds = bounds;
        this.fill = fill;
        this.stroke = stroke;
        this.strokeWidth = strokeWidth;
    }
    /**
     * Redirects to redrawPath for subclasses to work.
     */ paintVertexShape(c, x, y, w, h) {
        c.translate(x, y);
        c.begin();
        this.redrawPath(c, x, y, w, h);
        c.fillAndStroke();
    }
    /**
     * Draws the path for this shape.
     */ redrawPath(c, x, y, w, h) {
        const width = w / 3;
        c.moveTo(0, h);
        c.curveTo(0, 3 * h / 5, 0, 2 * h / 5, w / 2, 2 * h / 5);
        c.curveTo(w / 2 - width, 2 * h / 5, w / 2 - width, 0, w / 2, 0);
        c.curveTo(w / 2 + width, 0, w / 2 + width, 2 * h / 5, w / 2, 2 * h / 5);
        c.curveTo(w, 2 * h / 5, w, 3 * h / 5, w, h);
        c.close();
    }
}
const __TURBOPACK__default__export__ = ActorShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/ArrowShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Shape.js [app-client] (ecmascript)");
;
;
/**
 * Extends {@link Shape} to implement an arrow shape. The shape is used to represent edges, not vertices.
 *
 * By default, this shape is registered under {@link SHAPE.ARROW} in {@link CellRenderer}.
 *
 * @category Edge Shapes
 */ class ArrowShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(points, fill, stroke, strokeWidth = 1, arrowWidth = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW_WIDTH"], spacing = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW_SPACING"], endSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW_SIZE"]){
        super();
        this.points = points;
        this.fill = fill;
        this.stroke = stroke;
        this.strokeWidth = strokeWidth;
        this.arrowWidth = arrowWidth;
        this.spacing = spacing;
        this.endSize = endSize;
    }
    /**
     * Augments the bounding box with the edge width and markers.
     */ augmentBoundingBox(bbox) {
        super.augmentBoundingBox(bbox);
        const w = Math.max(this.arrowWidth, this.endSize);
        bbox.grow((w / 2 + this.strokeWidth) * this.scale);
    }
    /**
     * Paints the line shape.
     */ paintEdgeShape(c, pts) {
        // Geometry of arrow
        const spacing = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW_SPACING"];
        const width = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW_WIDTH"];
        const arrow = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW_SIZE"];
        // Base vector (between end points)
        const p0 = pts[0];
        const pe = pts[pts.length - 1];
        const dx = pe.x - p0.x;
        const dy = pe.y - p0.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const length = dist - 2 * spacing - arrow;
        // Computes the norm and the inverse norm
        const nx = dx / dist;
        const ny = dy / dist;
        const basex = length * nx;
        const basey = length * ny;
        const floorx = width * ny / 3;
        const floory = -width * nx / 3;
        // Computes points
        const p0x = p0.x - floorx / 2 + spacing * nx;
        const p0y = p0.y - floory / 2 + spacing * ny;
        const p1x = p0x + floorx;
        const p1y = p0y + floory;
        const p2x = p1x + basex;
        const p2y = p1y + basey;
        const p3x = p2x + floorx;
        const p3y = p2y + floory;
        // p4 not necessary
        const p5x = p3x - 3 * floorx;
        const p5y = p3y - 3 * floory;
        c.begin();
        c.moveTo(p0x, p0y);
        c.lineTo(p1x, p1y);
        c.lineTo(p2x, p2y);
        c.lineTo(p3x, p3y);
        c.lineTo(pe.x - spacing * nx, pe.y - spacing * ny);
        c.lineTo(p5x, p5y);
        c.lineTo(p5x + floorx, p5y + floory);
        c.close();
        c.fillAndStroke();
    }
}
const __TURBOPACK__default__export__ = ArrowShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/ArrowConnectorShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Shape.js [app-client] (ecmascript)");
;
;
;
/**
 * Extends {@link Shape} to implement a new rounded arrow shape with support for waypoints and double arrows.
 *
 * The shape is used to represent edges, not vertices.
 *
 * By default, this shape is registered under {@link SHAPE.ARROW_CONNECTOR} in {@link CellRenderer}.
 *
 * @category Edge Shapes
 */ class ArrowConnectorShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(points, fill, stroke, strokeWidth = 1, arrowWidth = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW_WIDTH"], spacing = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW_SPACING"], endSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW_SIZE"] / 5){
        super();
        /**
         * Allows to use the SVG bounding box in SVG.
         * @defaultValue `false` for performance reasons.
         */ this.useSvgBoundingBox = true;
        this.points = points;
        this.fill = fill;
        this.stroke = stroke;
        this.strokeWidth = strokeWidth;
        this.arrowWidth = arrowWidth;
        this.arrowSpacing = spacing;
        this.startSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW_SIZE"] / 5;
        this.endSize = endSize;
    }
    /**
     * Hook for subclassers.
     */ isRoundable() {
        return true;
    }
    /**
     * Overrides mxShape to reset spacing.
     */ resetStyles() {
        super.resetStyles();
        this.arrowSpacing = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW_SPACING"];
    }
    /**
     * Overrides apply to get smooth transition from default start- and endsize.
     */ apply(state) {
        super.apply(state);
        if (this.style && this.style.startSize != null && this.style.endSize != null) {
            this.startSize = this.style.startSize * 3;
            this.endSize = this.style.endSize * 3;
        }
    }
    /**
     * Augments the bounding box with the edge width and markers.
     */ augmentBoundingBox(bbox) {
        super.augmentBoundingBox(bbox);
        let w = this.getEdgeWidth();
        if (this.isMarkerStart()) {
            w = Math.max(w, this.getStartArrowWidth());
        }
        if (this.isMarkerEnd()) {
            w = Math.max(w, this.getEndArrowWidth());
        }
        bbox.grow((w / 2 + this.strokeWidth) * this.scale);
    }
    /**
     * Paints the line shape.
     */ paintEdgeShape(c, pts) {
        // Geometry of arrow
        let strokeWidth = this.strokeWidth;
        if (this.outline) {
            strokeWidth = Math.max(1, this.style?.strokeWidth ?? 0);
        }
        const startWidth = this.getStartArrowWidth() + strokeWidth;
        const endWidth = this.getEndArrowWidth() + strokeWidth;
        const edgeWidth = this.outline ? this.getEdgeWidth() + strokeWidth : this.getEdgeWidth();
        const openEnded = this.isOpenEnded();
        const markerStart = this.isMarkerStart();
        const markerEnd = this.isMarkerEnd();
        const spacing = openEnded ? 0 : this.arrowSpacing + strokeWidth / 2;
        const startSize = this.startSize + strokeWidth;
        const endSize = this.endSize + strokeWidth;
        const isRounded = this.isArrowRounded();
        // Base vector (between first points)
        const pe = pts[pts.length - 1];
        // Finds first non-overlapping point
        let i0 = 1;
        while(i0 < pts.length - 1 && pts[i0].x === pts[0].x && pts[i0].y === pts[0].y){
            i0++;
        }
        const dx = pts[i0].x - pts[0].x;
        const dy = pts[i0].y - pts[0].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist === 0) {
            return;
        }
        // Computes the norm and the inverse norm
        let nx = dx / dist;
        let nx2;
        let nx1 = nx;
        let ny = dy / dist;
        let ny2;
        let ny1 = ny;
        let orthx = edgeWidth * ny;
        let orthy = -edgeWidth * nx;
        // Stores the inbound function calls in reverse order in fns
        const fns = [];
        if (isRounded) {
            c.setLineJoin('round');
        } else if (pts.length > 2) {
            // Only mitre if there are waypoints
            c.setMiterLimit(1.42);
        }
        c.begin();
        const startNx = nx;
        const startNy = ny;
        if (markerStart && !openEnded) {
            this.paintMarker(c, pts[0].x, pts[0].y, nx, ny, startSize, startWidth, edgeWidth, spacing, true);
        } else {
            const outStartX = pts[0].x + orthx / 2 + spacing * nx;
            const outStartY = pts[0].y + orthy / 2 + spacing * ny;
            const inEndX = pts[0].x - orthx / 2 + spacing * nx;
            const inEndY = pts[0].y - orthy / 2 + spacing * ny;
            if (openEnded) {
                c.moveTo(outStartX, outStartY);
                fns.push(()=>{
                    c.lineTo(inEndX, inEndY);
                });
            } else {
                c.moveTo(inEndX, inEndY);
                c.lineTo(outStartX, outStartY);
            }
        }
        let dx1 = 0;
        let dy1 = 0;
        let dist1 = 0;
        for(let i = 0; i < pts.length - 2; i += 1){
            // Work out in which direction the line is bending
            const pos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["relativeCcw"])(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, pts[i + 2].x, pts[i + 2].y);
            dx1 = pts[i + 2].x - pts[i + 1].x;
            dy1 = pts[i + 2].y - pts[i + 1].y;
            dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            if (dist1 !== 0) {
                nx1 = dx1 / dist1;
                ny1 = dy1 / dist1;
                const tmp1 = nx * nx1 + ny * ny1;
                const tmp = Math.max(Math.sqrt((tmp1 + 1) / 2), 0.04);
                // Work out the normal orthogonal to the line through the control point and the edge sides intersection
                nx2 = nx + nx1;
                ny2 = ny + ny1;
                const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);
                if (dist2 !== 0) {
                    nx2 /= dist2;
                    ny2 /= dist2;
                    // Higher strokewidths require a larger minimum bend, 0.35 covers all but the most extreme cases
                    const strokeWidthFactor = Math.max(tmp, Math.min(this.strokeWidth / 200 + 0.04, 0.35));
                    const angleFactor = pos !== 0 && isRounded ? Math.max(0.1, strokeWidthFactor) : Math.max(tmp, 0.06);
                    const outX = pts[i + 1].x + ny2 * edgeWidth / 2 / angleFactor;
                    const outY = pts[i + 1].y - nx2 * edgeWidth / 2 / angleFactor;
                    const inX = pts[i + 1].x - ny2 * edgeWidth / 2 / angleFactor;
                    const inY = pts[i + 1].y + nx2 * edgeWidth / 2 / angleFactor;
                    if (pos === 0 || !isRounded) {
                        // If the two segments are aligned, or if we're not drawing curved sections between segments
                        // just draw straight to the intersection point
                        c.lineTo(outX, outY);
                        ((x, y)=>{
                            fns.push(()=>{
                                c.lineTo(x, y);
                            });
                        })(inX, inY);
                    } else if (pos === -1) {
                        const c1x = inX + ny * edgeWidth;
                        const c1y = inY - nx * edgeWidth;
                        const c2x = inX + ny1 * edgeWidth;
                        const c2y = inY - nx1 * edgeWidth;
                        c.lineTo(c1x, c1y);
                        c.quadTo(outX, outY, c2x, c2y);
                        ((x, y)=>{
                            fns.push(()=>{
                                c.lineTo(x, y);
                            });
                        })(inX, inY);
                    } else {
                        c.lineTo(outX, outY);
                        ((x, y)=>{
                            const c1x = outX - ny * edgeWidth;
                            const c1y = outY + nx * edgeWidth;
                            const c2x = outX - ny1 * edgeWidth;
                            const c2y = outY + nx1 * edgeWidth;
                            fns.push(()=>{
                                c.quadTo(x, y, c1x, c1y);
                            });
                            fns.push(()=>{
                                c.lineTo(c2x, c2y);
                            });
                        })(inX, inY);
                    }
                    nx = nx1;
                    ny = ny1;
                }
            }
        }
        orthx = edgeWidth * ny1;
        orthy = -edgeWidth * nx1;
        if (markerEnd && !openEnded) {
            this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, false);
        } else {
            c.lineTo(pe.x - spacing * nx1 + orthx / 2, pe.y - spacing * ny1 + orthy / 2);
            const inStartX = pe.x - spacing * nx1 - orthx / 2;
            const inStartY = pe.y - spacing * ny1 - orthy / 2;
            if (!openEnded) {
                c.lineTo(inStartX, inStartY);
            } else {
                c.moveTo(inStartX, inStartY);
                fns.splice(0, 0, ()=>{
                    c.moveTo(inStartX, inStartY);
                });
            }
        }
        for(let i = fns.length - 1; i >= 0; i--){
            fns[i]();
        }
        if (openEnded) {
            c.end();
            c.stroke();
        } else {
            c.close();
            c.fillAndStroke();
        }
        // Workaround for shadow on top of base arrow
        c.setShadow(false);
        // Need to redraw the markers without the low miter limit
        c.setMiterLimit(4);
        if (isRounded) {
            c.setLineJoin('flat');
        }
        if (pts.length > 2) {
            // Only to repaint markers if no waypoints
            // Need to redraw the markers without the low miter limit
            c.setMiterLimit(4);
            if (markerStart && !openEnded) {
                c.begin();
                this.paintMarker(c, pts[0].x, pts[0].y, startNx, startNy, startSize, startWidth, edgeWidth, spacing, true);
                c.stroke();
                c.end();
            }
            if (markerEnd && !openEnded) {
                c.begin();
                this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, true);
                c.stroke();
                c.end();
            }
        }
    }
    /**
     * Paints the marker.
     */ paintMarker(c, ptX, ptY, nx, ny, size, arrowWidth, edgeWidth, spacing, initialMove) {
        const widthArrowRatio = edgeWidth / arrowWidth;
        const orthx = edgeWidth * ny / 2;
        const orthy = -edgeWidth * nx / 2;
        const spaceX = (spacing + size) * nx;
        const spaceY = (spacing + size) * ny;
        if (initialMove) {
            c.moveTo(ptX - orthx + spaceX, ptY - orthy + spaceY);
        } else {
            c.lineTo(ptX - orthx + spaceX, ptY - orthy + spaceY);
        }
        c.lineTo(ptX - orthx / widthArrowRatio + spaceX, ptY - orthy / widthArrowRatio + spaceY);
        c.lineTo(ptX + spacing * nx, ptY + spacing * ny);
        c.lineTo(ptX + orthx / widthArrowRatio + spaceX, ptY + orthy / widthArrowRatio + spaceY);
        c.lineTo(ptX + orthx + spaceX, ptY + orthy + spaceY);
    }
    /**
     * @returns whether the arrow is rounded
     */ isArrowRounded() {
        return this.isRounded;
    }
    /**
     * @returns the width of the start arrow
     */ getStartArrowWidth() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW_WIDTH"];
    }
    /**
     * @returns the width of the end arrow
     */ getEndArrowWidth() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW_WIDTH"];
    }
    /**
     * @returns the width of the body of the edge
     */ getEdgeWidth() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW_WIDTH"] / 3;
    }
    /**
     * @returns whether the ends of the shape are drawn
     */ isOpenEnded() {
        return false;
    }
    /**
     * @returns whether the start marker is drawn
     */ isMarkerStart() {
        return (this.style?.startArrow ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
    }
    /**
     * @returns whether the end marker is drawn
     */ isMarkerEnd() {
        return (this.style?.endArrow ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
    }
}
const __TURBOPACK__default__export__ = ArrowConnectorShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/node/CloudShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$ActorShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/ActorShape.js [app-client] (ecmascript)");
;
/**
 * Extends {@link ActorShape} to implement a cloud shape.
 * This shape is registered by default under {@link SHAPE.CLOUD} in {@link CellRenderer}.
 *
 * @category Vertex Shapes
 */ class CloudShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$ActorShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(bounds, fill, stroke, strokeWidth = 1){
        super();
        this.bounds = bounds;
        this.fill = fill;
        this.stroke = stroke;
        this.strokeWidth = strokeWidth;
    }
    /**
     * Draws the path for this shape.
     */ redrawPath(c, x, y, w, h) {
        c.moveTo(0.25 * w, 0.25 * h);
        c.curveTo(0.05 * w, 0.25 * h, 0, 0.5 * h, 0.16 * w, 0.55 * h);
        c.curveTo(0, 0.66 * h, 0.18 * w, 0.9 * h, 0.31 * w, 0.8 * h);
        c.curveTo(0.4 * w, h, 0.7 * w, h, 0.8 * w, 0.8 * h);
        c.curveTo(w, 0.8 * h, w, 0.6 * h, 0.875 * w, 0.5 * h);
        c.curveTo(w, 0.3 * h, 0.8 * w, 0.1 * h, 0.625 * w, 0.2 * h);
        c.curveTo(0.5 * w, 0.05 * h, 0.3 * w, 0.05 * h, 0.25 * w, 0.25 * h);
        c.close();
    }
}
const __TURBOPACK__default__export__ = CloudShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/node/CylinderShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Shape.js [app-client] (ecmascript)");
;
;
/**
 * Extends {@link Shape} to implement a cylinder shape.
 * This shape is registered by default under {@link SHAPE.CYLINDER} in {@link CellRenderer}.
 *
 * If a custom shape with one filled area and an overlay path is needed, then this shape's {@link redrawPath} should be overridden.
 *
 * @category Vertex Shapes
 */ class CylinderShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(bounds, fill, stroke, strokeWidth = 1){
        super();
        /**
         * Defines the maximum height of the top and bottom part of the cylinder shape.
         */ this.maxHeight = 40;
        /**
         * Sets stroke tolerance to 0 for SVG.
         */ this.svgStrokeTolerance = 0;
        this.bounds = bounds;
        this.fill = fill;
        this.stroke = stroke;
        this.strokeWidth = strokeWidth;
    }
    /**
     * Redirects to redrawPath for subclasses to work.
     */ paintVertexShape(c, x, y, w, h) {
        c.translate(x, y);
        c.begin();
        this.redrawPath(c, x, y, w, h, false);
        c.fillAndStroke();
        if (!this.outline || !this.style || !(this.style.backgroundOutline ?? false)) {
            c.setShadow(false);
            c.begin();
            this.redrawPath(c, x, y, w, h, true);
            c.stroke();
        }
    }
    /**
     * Redirects to redrawPath for subclasses to work.
     */ getCylinderSize(x, y, w, h) {
        return Math.min(this.maxHeight, Math.round(h / 5));
    }
    /**
     * Draws the path for this shape.
     */ redrawPath(c, x, y, w, h, isForeground = false) {
        const dy = this.getCylinderSize(x, y, w, h);
        if (isForeground && this.fill !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"] || !isForeground && this.fill === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
            c.moveTo(0, dy);
            c.curveTo(0, 2 * dy, w, 2 * dy, w, dy);
            // Needs separate shapes for correct hit-detection
            if (!isForeground) {
                c.stroke();
                c.begin();
            }
        }
        if (!isForeground) {
            c.moveTo(0, dy);
            c.curveTo(0, -dy / 3, w, -dy / 3, w, dy);
            c.lineTo(w, h - dy);
            c.curveTo(w, h + dy / 3, 0, h + dy / 3, 0, h - dy);
            c.close();
        }
    }
}
const __TURBOPACK__default__export__ = CylinderShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/node/DoubleEllipseShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Shape.js [app-client] (ecmascript)");
;
;
/**
 * Extends {@link Shape} to implement a double ellipse shape.
 * This shape is registered by default under {@link SHAPE.DOUBLE_ELLIPSE} in {@link CellRenderer}.
 *
 * If a custom shape is needed to only fill the inner ellipse, then this shape's {@link paintVertexShape} method should be overridden
 * like in the following example:
 *
 * ```typescript
 * class SampleShape extends DoubleEllipseShape {
 *   paintVertexShape(c: AbstractCanvas2D, x: number, y: number, w: number, h: number) {
 *     c.ellipse(x, y, w, h);
 *     c.stroke();
 *
 *     const inset = this.style.margin ?? Math.min(3 + this.strokewidth, Math.min(w / 5, h / 5));
 *     x += inset;
 *     y += inset;
 *     w -= 2 * inset;
 *     h -= 2 * inset;
 *
 *     if (w > 0 && h > 0) {
 *       c.ellipse(x, y, w, h);
 *     }
 *
 *     c.fillAndStroke();
 *   }
 * }
 * ```
 *
 * @category Vertex Shapes
 */ class DoubleEllipseShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(bounds, fill, stroke, strokeWidth = 1){
        super();
        this.bounds = bounds;
        this.fill = fill;
        this.stroke = stroke;
        this.strokeWidth = strokeWidth;
    }
    /**
     * Paints the background.
     */ paintBackground(c, x, y, w, h) {
        c.ellipse(x, y, w, h);
        c.fillAndStroke();
    }
    /**
     * Paints the foreground.
     */ paintForeground(c, x, y, w, h) {
        if (!this.outline) {
            const margin = this.style?.margin ?? Math.min(3 + this.strokeWidth, Math.min(w / 5, h / 5));
            x += margin;
            y += margin;
            w -= 2 * margin;
            h -= 2 * margin;
            // FIXME: Rounding issues in IE8 standards mode (not in 1.x)
            if (w > 0 && h > 0) {
                c.ellipse(x, y, w, h);
            }
            c.stroke();
        }
    }
    /**
     * @returns the bounds for the label.
     */ getLabelBounds(rect) {
        const margin = this.style?.margin ?? Math.min(3 + this.strokeWidth, Math.min(rect.width / 5 / this.scale, rect.height / 5 / this.scale)) * this.scale;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](rect.x + margin, rect.y + margin, rect.width - 2 * margin, rect.height - 2 * margin);
    }
}
const __TURBOPACK__default__export__ = DoubleEllipseShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/node/HexagonShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$ActorShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/ActorShape.js [app-client] (ecmascript)");
;
;
;
/**
 * Implementation of the hexagon shape.
 *
 * @category Vertex Shapes
 */ class HexagonShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$ActorShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(){
        super();
    }
    /**
     * Draws the path for this shape.
     */ redrawPath(c, x, y, w, h) {
        const arcSize = (this.style?.arcSize ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_ARCSIZE"]) / 2;
        this.addPoints(c, [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0.25 * w, 0),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0.75 * w, 0),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](w, 0.5 * h),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0.75 * w, h),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0.25 * w, h),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0.5 * h)
        ], this.isRounded, arcSize, true);
    }
}
const __TURBOPACK__default__export__ = HexagonShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/node/LabelShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/RectangleShape.js [app-client] (ecmascript)");
;
;
;
/**
 * Extends {@link RectangleShape} to implement an image shape with a label.
 * This shape is registered by default under {@link SHAPE.LABEL} in {@link CellRenderer}.
 *
 * @category Vertex Shapes
 */ class LabelShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
     * Constructs a new label shape.
     *
     * @param bounds {@link Rectangle} that defines the bounds. This is stored in {@link bounds}.
     * @param fill String that defines the fill color. This is stored in {@link fill}.
     * @param stroke String that defines the stroke color. This is stored in {@link stroke}.
     * @param strokeWidth Optional integer that defines the stroke width. Default is 1. This is stored in {@link strokeWidth}.
     */ constructor(bounds, fill, stroke, strokeWidth){
        super(bounds, fill, stroke, strokeWidth);
        /**
         * Default width and height for the image.
         * @default mxConstants.DEFAULT_IMAGESIZE
         */ this.imageSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_IMAGESIZE"];
        this.imageSrc = null;
        /**
         * Default value for image spacing
         * @type {number}
         * @default 2
         */ this.spacing = 2;
        /**
         * Default width and height for the indicicator.
         * @type {number}
         * @default 10
         */ this.indicatorSize = 10;
        /**
         * Default spacing between image and indicator
         * @default 2
         * @type {number}
         */ this.indicatorSpacing = 2;
        this.indicatorImageSrc = null;
    }
    /**
     * Initializes the shape and the <indicator>.
     */ init(container) {
        super.init(container);
        if (this.indicatorShape) {
            this.indicator = new this.indicatorShape();
            this.indicator.dialect = this.dialect;
            this.indicator.init(this.node);
        }
    }
    /**
     * Reconfigures this shape. This will update the colors of the indicator
     * and reconfigure it if required.
     */ redraw() {
        if (this.indicator) {
            this.indicator.fill = this.indicatorColor;
            this.indicator.stroke = this.indicatorStrokeColor;
            this.indicator.gradient = this.indicatorGradientColor;
            this.indicator.direction = this.indicatorDirection;
            this.indicator.redraw();
        }
        super.redraw();
    }
    /**
     * Returns true for non-rounded, non-rotated shapes with no glass gradient and
     * no indicator shape.
     */ isHtmlAllowed() {
        return super.isHtmlAllowed() && this.indicatorColor === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"] && !!this.indicatorShape;
    }
    /**
     * Generic background painting implementation.
     * @param {mxAbstractCanvas2D} c
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */ paintForeground(c, x, y, w, h) {
        this.paintImage(c, x, y, w, h);
        this.paintIndicator(c, x, y, w, h);
        super.paintForeground(c, x, y, w, h);
    }
    /**
     * Generic background painting implementation.
     * @param {mxAbstractCanvas2D} c
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */ paintImage(c, x, y, w, h) {
        if (this.imageSrc) {
            const bounds = this.getImageBounds(x, y, w, h);
            c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.imageSrc, false, false, false);
        }
    }
    /**
     * Generic background painting implementation.
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */ getImageBounds(x, y, w, h) {
        const align = this.style?.imageAlign ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].LEFT;
        const valign = this.style?.verticalAlign ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE;
        const width = this.style?.imageWidth ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_IMAGESIZE"];
        const height = this.style?.imageHeight ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_IMAGESIZE"];
        const spacing = this.style?.spacing ?? this.spacing + 5;
        if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER) {
            x += (w - width) / 2;
        } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT) {
            x += w - width - spacing;
        } else {
            x += spacing;
        }
        if (valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].TOP) {
            y += spacing;
        } else if (valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].BOTTOM) {
            y += h - height - spacing;
        } else {
            y += (h - height) / 2;
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y, width, height);
    }
    /**
     * Generic background painting implementation.
     * @param {mxAbstractCanvas2D} c
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */ paintIndicator(c, x, y, w, h) {
        if (this.indicator) {
            this.indicator.bounds = this.getIndicatorBounds(x, y, w, h);
            this.indicator.paint(c);
        } else if (this.indicatorImageSrc) {
            const bounds = this.getIndicatorBounds(x, y, w, h);
            c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.indicatorImageSrc, false, false, false);
        }
    }
    /**
     * Generic background painting implementation.
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @returns {Rectangle}
     */ getIndicatorBounds(x, y, w, h) {
        const align = this.style?.imageAlign ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].LEFT;
        const valign = this.style?.verticalAlign ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE;
        const width = this.style?.indicatorWidth ?? this.indicatorSize;
        const height = this.style?.indicatorHeight ?? this.indicatorSize;
        const spacing = this.spacing + 5;
        if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT) {
            x += w - width - spacing;
        } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER) {
            x += (w - width) / 2;
        } else {
            x += spacing;
        }
        if (valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].BOTTOM) {
            y += h - height - spacing;
        } else if (valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].TOP) {
            y += spacing;
        } else {
            y += (h - height) / 2;
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y, width, height);
    }
    /**
     * Generic background painting implementation.
     */ redrawHtmlShape() {
        super.redrawHtmlShape();
        // Removes all children
        while(this.node.hasChildNodes()){
            this.node.removeChild(this.node.lastChild);
        }
        if (this.imageSrc && this.bounds) {
            const node = document.createElement('img');
            node.style.position = 'relative';
            node.setAttribute('border', '0');
            const bounds = this.getImageBounds(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
            bounds.x -= this.bounds.x;
            bounds.y -= this.bounds.y;
            node.style.left = `${Math.round(bounds.x)}px`;
            node.style.top = `${Math.round(bounds.y)}px`;
            node.style.width = `${Math.round(bounds.width)}px`;
            node.style.height = `${Math.round(bounds.height)}px`;
            node.src = this.imageSrc;
            this.node.appendChild(node);
        }
    }
}
const __TURBOPACK__default__export__ = LabelShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/LineShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Shape.js [app-client] (ecmascript)");
;
/**
 * Extends {@link Shape} to implement a horizontal line shape.
 *
 * The shape is used to represent edges, not vertices.
 *
 * By default, this shape is registered under {@link SHAPE.LINE} in {@link CellRenderer}.
 *
 * @category Edge Shapes
 */ class LineShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(bounds, stroke, strokeWidth = 1, vertical = false){
        super();
        this.bounds = bounds;
        this.stroke = stroke;
        this.strokeWidth = strokeWidth;
        this.vertical = vertical;
    }
    /**
     * Redirects to redrawPath for subclasses to work.
     * @param {AbstractCanvas2D} c
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */ paintVertexShape(c, x, y, w, h) {
        c.begin();
        if (this.vertical) {
            const mid = x + w / 2;
            c.moveTo(mid, y);
            c.lineTo(mid, y + h);
        } else {
            const mid = y + h / 2;
            c.moveTo(x, mid);
            c.lineTo(x + w, mid);
        }
        c.stroke();
    }
}
const __TURBOPACK__default__export__ = LineShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/node/RhombusShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Shape.js [app-client] (ecmascript)");
;
;
;
/**
 * Extends {@link Shape} to implement a rhombus (aka diamond) shape.
 * This shape is registered by default under {@link SHAPE.RHOMBUS} in {@link CellRenderer}.
 *
 * @category Vertex Shapes
 */ class RhombusShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(bounds, fill, stroke, strokewidth = 1){
        super();
        this.bounds = bounds;
        this.fill = fill;
        this.stroke = stroke;
        this.strokeWidth = strokewidth;
    }
    /**
     * Adds roundable support.
     */ // isRoundable(): boolean;
    isRoundable() {
        return true;
    }
    /**
     * Generic painting implementation.
     * @param {mxAbstractCanvas2D} c
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */ paintVertexShape(c, x, y, w, h) {
        const hw = w / 2;
        const hh = h / 2;
        const arcSize = (this.style?.arcSize ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_ARCSIZE"]) / 2;
        c.begin();
        this.addPoints(c, [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + hw, y),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + hh),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + hw, y + h),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + hh)
        ], this.isRounded, arcSize, true);
        c.fillAndStroke();
    }
}
const __TURBOPACK__default__export__ = RhombusShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/node/SwimlaneShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Shape.js [app-client] (ecmascript)");
;
;
;
/**
 * Extends {@link Shape} to implement a swimlane shape.
 * This shape is registered by default under {@link SHAPE.SWIMLANE} in {@link CellRenderer}.
 *
 * Use:
 * - {@link CellStateStyle.startSize} to define the size of the title region,
 * - {@link CellStateStyle.swimlaneFillColor} for the content area fill,
 * - {@link CellStateStyle.separatorColor} to draw an additional vertical separator,
 * - {@link CellStateStyle.swimlaneLine} to hide the line between the title region and the content area
 *
 * {@link CellStateStyle.horizontal} affects the orientation of this shape, not only its label.
 *
 * @category Vertex Shapes
 */ class SwimlaneShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Shape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(bounds, fill, stroke, strokeWidth = 1){
        super();
        /**
         * Default imagewidth and imageheight if an image but no imagewidth
         * and imageheight are defined in the style. Value is 16.
         * @type {number}
         * @default 16
         */ this.imageSize = 16;
        this.imageSrc = null;
        this.bounds = bounds;
        this.fill = fill;
        this.stroke = stroke;
        this.strokeWidth = strokeWidth;
    }
    /**
     * Adds roundable support.
     * @param {mxAbstractCanvas2D} c
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @returns {boolean}
     */ isRoundable(c, x, y, w, h) {
        return true;
    }
    /**
     * Returns the bounding box for the gradient box for this shape.
     */ getTitleSize() {
        return Math.max(0, this.style?.startSize ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_STARTSIZE"]);
    }
    /**
     * Returns the bounding box for the gradient box for this shape.
     */ getLabelBounds(rect) {
        const start = this.getTitleSize();
        const bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](rect.x, rect.y, rect.width, rect.height);
        const horizontal = this.isHorizontal();
        const flipH = this.style?.flipH ?? false;
        const flipV = this.style?.flipV ?? false;
        // East is default
        const shapeVertical = this.direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH || this.direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH;
        const realHorizontal = horizontal == !shapeVertical;
        const realFlipH = !realHorizontal && flipH !== (this.direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH || this.direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST);
        const realFlipV = realHorizontal && flipV !== (this.direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH || this.direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST);
        // Shape is horizontal
        if (!shapeVertical) {
            const tmp = Math.min(bounds.height, start * this.scale);
            if (realFlipH || realFlipV) {
                bounds.y += bounds.height - tmp;
            }
            bounds.height = tmp;
        } else {
            const tmp = Math.min(bounds.width, start * this.scale);
            if (realFlipH || realFlipV) {
                bounds.x += bounds.width - tmp;
            }
            bounds.width = tmp;
        }
        return bounds;
    }
    /**
     * Returns the bounding box for the gradient box for this shape.
     */ getGradientBounds(c, x, y, w, h) {
        let start = this.getTitleSize();
        if (this.isHorizontal()) {
            start = Math.min(start, h);
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y, w, start);
        }
        start = Math.min(start, w);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y, start, h);
    }
    /**
     * Returns the arcsize for the swimlane.
     */ getSwimlaneArcSize(w, h, start) {
        if (this.style?.absoluteArcSize ?? false) {
            return Math.min(w / 2, Math.min(h / 2, this.style?.arcSize ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_ARCSIZE"] / 2));
        }
        const f = (this.style?.arcSize ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RECTANGLE_ROUNDING_FACTOR"] * 100) / 100;
        return start * f * 3;
    }
    /**
     * Paints the swimlane vertex shape.
     */ isHorizontal() {
        return this.style?.horizontal ?? true;
    }
    /**
     * Paints the swimlane vertex shape.
     */ paintVertexShape(c, x, y, w, h) {
        let start = this.getTitleSize();
        const fill = this.style?.swimlaneFillColor ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        const swimlaneLine = this.style?.swimlaneLine ?? true;
        let r = 0;
        if (this.isHorizontal()) {
            start = Math.min(start, h);
        } else {
            start = Math.min(start, w);
        }
        c.translate(x, y);
        if (!this.isRounded) {
            this.paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine);
        } else {
            r = this.getSwimlaneArcSize(w, h, start);
            r = Math.min((this.isHorizontal() ? h : w) - start, Math.min(start, r));
            this.paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine);
        }
        const sep = this.style?.separatorColor ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.paintSeparator(c, x, y, w, h, start, sep);
        if (this.imageSrc) {
            const bounds = this.getImageBounds(x, y, w, h);
            c.image(bounds.x - x, bounds.y - y, bounds.width, bounds.height, this.imageSrc, false, false, false);
        }
        if (this.glass) {
            c.setShadow(false);
            this.paintGlassEffect(c, 0, 0, w, start, r);
        }
    }
    /**
     * Paints the swimlane vertex shape.
     */ paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine) {
        c.begin();
        let events = true;
        if (this.style && this.style.pointerEvents != null) {
            events = this.style.pointerEvents;
        }
        if (!events && this.fill === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
            c.pointerEvents = false;
        }
        if (this.isHorizontal()) {
            c.moveTo(0, start);
            c.lineTo(0, 0);
            c.lineTo(w, 0);
            c.lineTo(w, start);
            c.fillAndStroke();
            if (start < h) {
                if (fill === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"] || !events) {
                    c.pointerEvents = false;
                }
                if (fill !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
                    c.setFillColor(fill);
                }
                c.begin();
                c.moveTo(0, start);
                c.lineTo(0, h);
                c.lineTo(w, h);
                c.lineTo(w, start);
                if (fill === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
                    c.stroke();
                } else {
                    c.fillAndStroke();
                }
            }
        } else {
            c.moveTo(start, 0);
            c.lineTo(0, 0);
            c.lineTo(0, h);
            c.lineTo(start, h);
            c.fillAndStroke();
            if (start < w) {
                if (fill === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"] || !events) {
                    c.pointerEvents = false;
                }
                if (fill !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
                    c.setFillColor(fill);
                }
                c.begin();
                c.moveTo(start, 0);
                c.lineTo(w, 0);
                c.lineTo(w, h);
                c.lineTo(start, h);
                if (fill === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
                    c.stroke();
                } else {
                    c.fillAndStroke();
                }
            }
        }
        if (swimlaneLine) {
            this.paintDivider(c, x, y, w, h, start, fill === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]);
        }
    }
    /**
     * Paints the swimlane vertex shape.
     */ paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine) {
        c.begin();
        let events = true;
        if (this.style && this.style.pointerEvents != null) {
            events = this.style.pointerEvents;
        }
        if (!events && this.fill === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
            c.pointerEvents = false;
        }
        if (this.isHorizontal()) {
            c.moveTo(w, start);
            c.lineTo(w, r);
            c.quadTo(w, 0, w - Math.min(w / 2, r), 0);
            c.lineTo(Math.min(w / 2, r), 0);
            c.quadTo(0, 0, 0, r);
            c.lineTo(0, start);
            c.fillAndStroke();
            if (start < h) {
                if (fill === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"] || !events) {
                    c.pointerEvents = false;
                }
                if (fill !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
                    c.setFillColor(fill);
                }
                c.begin();
                c.moveTo(0, start);
                c.lineTo(0, h - r);
                c.quadTo(0, h, Math.min(w / 2, r), h);
                c.lineTo(w - Math.min(w / 2, r), h);
                c.quadTo(w, h, w, h - r);
                c.lineTo(w, start);
                if (fill === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
                    c.stroke();
                } else {
                    c.fillAndStroke();
                }
            }
        } else {
            c.moveTo(start, 0);
            c.lineTo(r, 0);
            c.quadTo(0, 0, 0, Math.min(h / 2, r));
            c.lineTo(0, h - Math.min(h / 2, r));
            c.quadTo(0, h, r, h);
            c.lineTo(start, h);
            c.fillAndStroke();
            if (start < w) {
                if (fill === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"] || !events) {
                    c.pointerEvents = false;
                }
                if (fill !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
                    c.setFillColor(fill);
                }
                c.begin();
                c.moveTo(start, h);
                c.lineTo(w - r, h);
                c.quadTo(w, h, w, h - Math.min(h / 2, r));
                c.lineTo(w, Math.min(h / 2, r));
                c.quadTo(w, 0, w - r, 0);
                c.lineTo(start, 0);
                if (fill === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
                    c.stroke();
                } else {
                    c.fillAndStroke();
                }
            }
        }
        if (swimlaneLine) {
            this.paintDivider(c, x, y, w, h, start, fill === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]);
        }
    }
    /**
     * Paints the divider between swimlane title and content area.
     */ paintDivider(c, x, y, w, h, start, shadow) {
        if (!shadow) {
            c.setShadow(false);
        }
        c.begin();
        if (this.isHorizontal()) {
            c.moveTo(0, start);
            c.lineTo(w, start);
        } else {
            c.moveTo(start, 0);
            c.lineTo(start, h);
        }
        c.stroke();
    }
    /**
     * Paints the vertical or horizontal separator line between swimlanes.
     */ paintSeparator(c, x, y, w, h, start, color) {
        if (color !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
            c.setStrokeColor(color);
            c.setDashed(true);
            c.begin();
            if (this.isHorizontal()) {
                c.moveTo(w, start);
                c.lineTo(w, h);
            } else {
                c.moveTo(start, 0);
                c.lineTo(w, 0);
            }
            c.stroke();
            c.setDashed(false);
        }
    }
    /**
     * Paints the swimlane vertex shape.
     */ getImageBounds(x, y, w, h) {
        if (this.isHorizontal()) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w - this.imageSize, y, this.imageSize, this.imageSize);
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y, this.imageSize, this.imageSize);
    }
}
const __TURBOPACK__default__export__ = SwimlaneShape;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/geometry/node/TriangleShape.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$ActorShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/ActorShape.js [app-client] (ecmascript)");
;
;
;
/**
 * Implementation of the triangle shape.
 *
 * @category Vertex Shapes
 */ class TriangleShape extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$ActorShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(){
        super();
    }
    /**
     * Adds roundable support.
     * @returns {boolean}
     */ isRoundable() {
        return true;
    }
    /**
     * Draws the path for this shape.
     * @param {mxAbstractCanvas2D} c
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */ redrawPath(c, x, y, w, h) {
        const arcSize = (this.style?.arcSize ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_ARCSIZE"]) / 2;
        this.addPoints(c, [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](w, 0.5 * h),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, h)
        ], this.isRounded, arcSize, true);
    }
}
const __TURBOPACK__default__export__ = TriangleShape;
}}),
}]);

//# sourceMappingURL=node_modules_%40maxgraph_core_lib_view_geometry_53e562._.js.map