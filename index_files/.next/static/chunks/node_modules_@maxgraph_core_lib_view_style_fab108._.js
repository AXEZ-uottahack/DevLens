(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@maxgraph_core_lib_view_style_fab108._.js", {

"[project]/node_modules/@maxgraph/core/lib/view/style/edge/EntityRelation.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "EntityRelation": (()=>EntityRelation)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/CellState.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
;
;
;
;
;
const EntityRelation = (state, source, target, _points, result)=>{
    const { view } = state;
    const segment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getValue"])(state.style, 'segment', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ENTITY_SEGMENT"]) * view.scale;
    const pts = state.absolutePoints;
    const p0 = pts[0];
    const pe = pts[pts.length - 1];
    let isSourceLeft = false;
    if (source != null) {
        const sourceGeometry = source.cell.getGeometry();
        if (sourceGeometry.relative) {
            isSourceLeft = sourceGeometry.x <= 0.5;
        } else if (target != null) {
            isSourceLeft = (pe != null ? pe.x : target.x + target.width) < (p0 != null ? p0.x : source.x);
        }
    }
    if (p0 != null) {
        source = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        source.x = p0.x;
        source.y = p0.y;
    } else if (source != null) {
        const constraint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPortConstraints"])(source, state, true, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].NONE);
        if (constraint !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].NONE && constraint !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].WEST + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].EAST) {
            isSourceLeft = constraint === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].WEST;
        }
    } else {
        return;
    }
    let isTargetLeft = true;
    if (target != null) {
        const targetGeometry = target.cell.getGeometry();
        if (targetGeometry.relative) {
            isTargetLeft = targetGeometry.x <= 0.5;
        } else if (source != null) {
            isTargetLeft = (p0 != null ? p0.x : source.x + source.width) < (pe != null ? pe.x : target.x);
        }
    }
    if (pe != null) {
        target = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        target.x = pe.x;
        target.y = pe.y;
    } else if (target != null) {
        const constraint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPortConstraints"])(target, state, false, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].NONE);
        if (constraint !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].NONE && constraint != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].WEST + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].EAST) {
            isTargetLeft = constraint === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].WEST;
        }
    }
    if (source != null && target != null) {
        const x0 = isSourceLeft ? source.x : source.x + source.width;
        const y0 = view.getRoutingCenterY(source);
        const xe = isTargetLeft ? target.x : target.x + target.width;
        const ye = view.getRoutingCenterY(target);
        const seg = segment;
        let dx = isSourceLeft ? -seg : seg;
        const dep = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x0 + dx, y0);
        dx = isTargetLeft ? -seg : seg;
        const arr = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](xe + dx, ye);
        // Adds intermediate points if both go out on same side
        if (isSourceLeft === isTargetLeft) {
            const x = isSourceLeft ? Math.min(x0, xe) - segment : Math.max(x0, xe) + segment;
            result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y0));
            result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, ye));
        } else if (dep.x < arr.x === isSourceLeft) {
            const midY = y0 + (ye - y0) / 2;
            result.push(dep);
            result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](dep.x, midY));
            result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](arr.x, midY));
            result.push(arr);
        } else {
            result.push(dep);
            result.push(arr);
        }
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/style/edge/Loop.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "Loop": (()=>Loop)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
;
;
;
;
const Loop = (state, source, _target, points, result)=>{
    const pts = state.absolutePoints;
    const p0 = pts[0];
    const pe = pts[pts.length - 1];
    if (p0 != null && pe != null) {
        if (points != null && points.length > 0) {
            for(let i = 0; i < points.length; i += 1){
                let pt = points[i];
                pt = state.view.transformControlPoint(state, pt);
                result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](pt.x, pt.y));
            }
        }
        return;
    }
    if (source != null) {
        const { view } = state;
        const { graph } = view;
        let pt = points != null && points.length > 0 ? points[0] : null;
        if (pt != null) {
            pt = view.transformControlPoint(state, pt);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(source, pt.x, pt.y)) {
                pt = null;
            }
        }
        let x = 0;
        let dx = 0;
        let y = 0;
        let dy = 0;
        const seg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getValue"])(state.style, 'segment', graph.gridSize) * view.scale;
        const dir = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getValue"])(state.style, 'direction', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST);
        if (dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH || dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) {
            x = view.getRoutingCenterX(source);
            dx = seg;
        } else {
            y = view.getRoutingCenterY(source);
            dy = seg;
        }
        if (pt == null || pt.x < source.x || pt.x > source.x + source.width) {
            if (pt != null) {
                x = pt.x;
                dy = Math.max(Math.abs(y - pt.y), dy);
            } else if (dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH) {
                y = source.y - 2 * dx;
            } else if (dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) {
                y = source.y + source.height + 2 * dx;
            } else if (dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST) {
                x = source.x - 2 * dy;
            } else {
                x = source.x + source.width + 2 * dy;
            }
        } else if (pt !== null) {
            x = view.getRoutingCenterX(source);
            dx = Math.max(Math.abs(x - pt.x), dy);
            y = pt.y;
            dy = 0;
        }
        result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x - dx, y - dy));
        result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + dx, y + dy));
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/style/edge/SideToSide.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "SideToSide": (()=>SideToSide)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/CellState.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
;
;
;
const SideToSide = (state, source, target, points, result)=>{
    const { view } = state;
    let pt = points != null && points.length > 0 ? points[0] : null;
    const pts = state.absolutePoints;
    const p0 = pts[0];
    const pe = pts[pts.length - 1];
    if (pt != null) {
        pt = view.transformControlPoint(state, pt);
    }
    if (p0 != null) {
        source = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        source.x = p0.x;
        source.y = p0.y;
    }
    if (pe != null) {
        target = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        target.x = pe.x;
        target.y = pe.y;
    }
    if (source != null && target != null) {
        const l = Math.max(source.x, target.x);
        const r = Math.min(source.x + source.width, target.x + target.width);
        const x = pt != null ? pt.x : Math.round(r + (l - r) / 2);
        let y1 = view.getRoutingCenterY(source);
        let y2 = view.getRoutingCenterY(target);
        if (pt != null) {
            if (pt.y >= source.y && pt.y <= source.y + source.height) {
                y1 = pt.y;
            }
            if (pt.y >= target.y && pt.y <= target.y + target.height) {
                y2 = pt.y;
            }
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(target, x, y1) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(source, x, y1)) {
            result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y1));
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(target, x, y2) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(source, x, y2)) {
            result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y2));
        }
        if (result.length === 1) {
            if (pt != null) {
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(target, x, pt.y) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(source, x, pt.y)) {
                    result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, pt.y));
                }
            } else {
                const t = Math.max(source.y, target.y);
                const b = Math.min(source.y + source.height, target.y + target.height);
                result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, t + (b - t) / 2));
            }
        }
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/style/edge/TopToBottom.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "TopToBottom": (()=>TopToBottom)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/CellState.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
;
;
;
const TopToBottom = (state, source, target, points, result)=>{
    const { view } = state;
    let pt = points != null && points.length > 0 ? points[0] : null;
    const pts = state.absolutePoints;
    const p0 = pts[0];
    const pe = pts[pts.length - 1];
    if (pt != null) {
        pt = view.transformControlPoint(state, pt);
    }
    if (p0 != null) {
        source = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        source.x = p0.x;
        source.y = p0.y;
    }
    if (pe != null) {
        target = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        target.x = pe.x;
        target.y = pe.y;
    }
    if (source != null && target != null) {
        const t = Math.max(source.y, target.y);
        const b = Math.min(source.y + source.height, target.y + target.height);
        let x = view.getRoutingCenterX(source);
        if (pt != null && pt.x >= source.x && pt.x <= source.x + source.width) {
            x = pt.x;
        }
        const y = pt != null ? pt.y : Math.round(b + (t - b) / 2);
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(target, x, y) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(source, x, y)) {
            result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y));
        }
        if (pt != null && pt.x >= target.x && pt.x <= target.x + target.width) {
            x = pt.x;
        } else {
            x = view.getRoutingCenterX(target);
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(target, x, y) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(source, x, y)) {
            result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y));
        }
        if (result.length === 1) {
            if (pt != null && result.length === 1) {
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(target, pt.x, y) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(source, pt.x, y)) {
                    result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](pt.x, y));
                }
            } else {
                const l = Math.max(source.x, target.x);
                const r = Math.min(source.x + source.width, target.x + target.width);
                result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](l + (r - l) / 2, y));
            }
        }
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/style/edge/Elbow.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "ElbowConnector": (()=>ElbowConnector)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$SideToSide$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/edge/SideToSide.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$TopToBottom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/edge/TopToBottom.js [app-client] (ecmascript)");
;
;
;
const ElbowConnector = (state, source, target, points, result)=>{
    let pt = points != null && points.length > 0 ? points[0] : null;
    let vertical = false;
    let horizontal = false;
    if (source != null && target != null) {
        if (pt != null) {
            const left = Math.min(source.x, target.x);
            const right = Math.max(source.x + source.width, target.x + target.width);
            const top = Math.min(source.y, target.y);
            const bottom = Math.max(source.y + source.height, target.y + target.height);
            pt = state.view.transformControlPoint(state, pt);
            vertical = pt.y < top || pt.y > bottom;
            horizontal = pt.x < left || pt.x > right;
        } else {
            const left = Math.max(source.x, target.x);
            const right = Math.min(source.x + source.width, target.x + target.width);
            vertical = left === right;
            if (!vertical) {
                const top = Math.max(source.y, target.y);
                const bottom = Math.min(source.y + source.height, target.y + target.height);
                horizontal = top === bottom;
            }
        }
    }
    if (!horizontal && (vertical || state.style.elbow === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ELBOW"].VERTICAL)) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$TopToBottom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TopToBottom"])(state, source, target, points, result);
    } else {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$SideToSide$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SideToSide"])(state, source, target, points, result);
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/style/edge/shared.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "scaleCellState": (()=>scaleCellState),
    "scalePointArray": (()=>scalePointArray)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
;
function scalePointArray(points, scale) {
    let result = [];
    if (points != null) {
        for(let i = 0; i < points.length; i += 1){
            if (points[i] != null) {
                result[i] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](Math.round(points[i].x / scale * 10) / 10, Math.round(points[i].y / scale * 10) / 10);
            } else {
                result[i] = null;
            }
        }
    } else {
        result = null;
    }
    return result;
}
function scaleCellState(state, scale) {
    let result = null;
    if (state != null) {
        result = state.clone();
        result.setRect(Math.round(state.x / scale * 10) / 10, Math.round(state.y / scale * 10) / 10, Math.round(state.width / scale * 10) / 10, Math.round(state.height / scale * 10) / 10);
    }
    return result;
}
}}),
"[project]/node_modules/@maxgraph/core/lib/view/style/edge/Segment.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "SegmentConnector": (()=>SegmentConnector)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/edge/shared.js [app-client] (ecmascript)");
;
;
;
const SegmentConnector = (state, sourceScaled, targetScaled, controlHints, result)=>{
    // Creates array of all way- and terminal points
    // TODO: Figure out what to do when there are nulls in `pts`!
    const pts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scalePointArray"])(state.absolutePoints, state.view.scale);
    const source = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scaleCellState"])(sourceScaled, state.view.scale);
    const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scaleCellState"])(targetScaled, state.view.scale);
    const tol = 1;
    // Whether the first segment outgoing from the source end is horizontal
    let lastPushed = result.length > 0 ? result[0] : null;
    let horizontal = true;
    let hint = null;
    // Adds waypoints only if outside of tolerance
    function pushPoint(pt) {
        pt.x = Math.round(pt.x * state.view.scale * 10) / 10;
        pt.y = Math.round(pt.y * state.view.scale * 10) / 10;
        if (lastPushed == null || Math.abs(lastPushed.x - pt.x) >= tol || Math.abs(lastPushed.y - pt.y) >= Math.max(1, state.view.scale)) {
            result.push(pt);
            lastPushed = pt;
        }
        return lastPushed;
    }
    // Adds the first point
    let pt = pts[0];
    if (pt == null && source != null) {
        pt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](state.view.getRoutingCenterX(source), state.view.getRoutingCenterY(source));
    } else if (pt != null) {
        pt = pt.clone();
    }
    const lastInx = pts.length - 1;
    let pe = null;
    // Adds the waypoints
    if (controlHints != null && controlHints.length > 0) {
        // Converts all hints and removes nulls
        let hints = [];
        for(let i = 0; i < controlHints.length; i += 1){
            const tmp = state.view.transformControlPoint(state, controlHints[i], true);
            if (tmp != null) {
                hints.push(tmp);
            }
        }
        if (hints.length === 0) {
            return;
        }
        // Aligns source and target hint to fixed points
        if (pt != null && hints[0] != null) {
            if (Math.abs(hints[0].x - pt.x) < tol) {
                hints[0].x = pt.x;
            }
            if (Math.abs(hints[0].y - pt.y) < tol) {
                hints[0].y = pt.y;
            }
        }
        pe = pts[lastInx];
        if (pe != null && hints[hints.length - 1] != null) {
            if (Math.abs(hints[hints.length - 1].x - pe.x) < tol) {
                hints[hints.length - 1].x = pe.x;
            }
            if (Math.abs(hints[hints.length - 1].y - pe.y) < tol) {
                hints[hints.length - 1].y = pe.y;
            }
        }
        hint = hints[0];
        let currentTerm = source;
        let currentPt = pts[0];
        let hozChan = false;
        let vertChan = false;
        let currentHint = hint;
        if (currentPt != null) {
            currentTerm = null;
        }
        // Check for alignment with fixed points and with channels
        // at source and target segments only
        for(let i = 0; i < 2; i += 1){
            const fixedVertAlign = currentPt != null && currentPt.x === currentHint.x;
            const fixedHozAlign = currentPt != null && currentPt.y === currentHint.y;
            const inHozChan = currentTerm != null && currentHint.y >= currentTerm.y && currentHint.y <= currentTerm.y + currentTerm.height;
            const inVertChan = currentTerm != null && currentHint.x >= currentTerm.x && currentHint.x <= currentTerm.x + currentTerm.width;
            hozChan = fixedHozAlign || currentPt == null && inHozChan;
            vertChan = fixedVertAlign || currentPt == null && inVertChan;
            // If the current hint falls in both the hor and vert channels in the case
            // of a floating port, or if the hint is exactly co-incident with a
            // fixed point, ignore the source and try to work out the orientation
            // from the target end
            if (!(i == 0 && (hozChan && vertChan || fixedVertAlign && fixedHozAlign))) {
                if (currentPt != null && !fixedHozAlign && !fixedVertAlign && (inHozChan || inVertChan)) {
                    horizontal = !inHozChan;
                    break;
                }
                if (vertChan || hozChan) {
                    horizontal = hozChan;
                    if (i === 1) {
                        // Work back from target end
                        horizontal = hints.length % 2 === 0 ? hozChan : vertChan;
                    }
                    break;
                }
            }
            currentTerm = target;
            currentPt = pts[lastInx];
            if (currentPt != null) {
                currentTerm = null;
            }
            currentHint = hints[hints.length - 1];
            if (fixedVertAlign && fixedHozAlign) {
                hints = hints.slice(1);
            }
        }
        if (horizontal && (pts[0] != null && pts[0].y !== hint.y || pts[0] == null && source != null && (hint.y < source.y || hint.y > source.y + source.height))) {
            pushPoint(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](pt.x, hint.y));
        } else if (!horizontal && (pts[0] != null && pts[0].x !== hint.x || pts[0] == null && source != null && (hint.x < source.x || hint.x > source.x + source.width))) {
            pushPoint(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](hint.x, pt.y));
        }
        if (horizontal) {
            pt.y = hint.y;
        } else {
            pt.x = hint.x;
        }
        for(let i = 0; i < hints.length; i += 1){
            horizontal = !horizontal;
            hint = hints[i];
            if (horizontal) {
                pt.y = hint.y;
            } else {
                pt.x = hint.x;
            }
            pushPoint(pt.clone());
        }
    } else {
        hint = pt;
        // FIXME: First click in connect preview toggles orientation
        horizontal = true;
    }
    // Adds the last point
    pt = pts[lastInx];
    if (pt == null && target != null) {
        pt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](state.view.getRoutingCenterX(target), state.view.getRoutingCenterY(target));
    }
    if (pt != null) {
        if (hint != null) {
            if (horizontal && (pts[lastInx] != null && pts[lastInx].y !== hint.y || pts[lastInx] == null && target != null && (hint.y < target.y || hint.y > target.y + target.height))) {
                pushPoint(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](pt.x, hint.y));
            } else if (!horizontal && (pts[lastInx] != null && pts[lastInx].x !== hint.x || pts[lastInx] == null && target != null && (hint.x < target.x || hint.x > target.x + target.width))) {
                pushPoint(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](hint.x, pt.y));
            }
        }
    }
    // Removes bends inside the source terminal for floating ports
    if (pts[0] == null && source != null) {
        while(result.length > 1 && result[1] != null && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(source, result[1].x, result[1].y)){
            result.splice(1, 1);
        }
    }
    // Removes bends inside the target terminal
    if (pts[lastInx] == null && target != null) {
        while(result.length > 1 && result[result.length - 1] != null && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(target, result[result.length - 1].x, result[result.length - 1].y)){
            result.splice(result.length - 1, 1);
        }
    }
    // Removes last point if inside tolerance with end point
    if (pe != null && result[result.length - 1] != null && Math.abs(pe.x - result[result.length - 1].x) <= tol && Math.abs(pe.y - result[result.length - 1].y) <= tol) {
        result.splice(result.length - 1, 1);
        // Lines up second last point in result with end point
        if (result[result.length - 1] != null) {
            if (Math.abs(result[result.length - 1].x - pe.x) < tol) {
                result[result.length - 1].x = pe.x;
            }
            if (Math.abs(result[result.length - 1].y - pe.y) < tol) {
                result[result.length - 1].y = pe.y;
            }
        }
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/style/EdgeStyle.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/StringUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$EntityRelation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/edge/EntityRelation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$Loop$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/edge/Loop.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$Elbow$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/edge/Elbow.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$SideToSide$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/edge/SideToSide.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$TopToBottom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/edge/TopToBottom.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$Segment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/edge/Segment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/edge/shared.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Geometry.js [app-client] (ecmascript)");
var _a;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * Provides various edge styles to be used as the values for `edgeStyle` in a cell style.
 *
 * The following example sets the default edge style to `ElbowConnector`:
 *
 * ```javascript
 * const style = stylesheet.getDefaultEdgeStyle();
 * style.edgeStyle = EdgeStyle.ElbowConnector;
 * ```
 *
 * To write a custom edge style, a function can be added to the `EdgeStyle` object as follows.
 * In the example below, a right angle is created using a point on the horizontal center of the target vertex and the vertical center of the source vertex.
 * The code checks if that point intersects the source vertex and makes the edge straight if it does.
 * The point is then added into the result array, which acts as the return value of the function.
 *
 * ```javascript
 * EdgeStyle.MyStyle = (state, source, target, points, result) => {
 *   if (source && target) {
 *     const pt = new Point(target.getCenterX(), source.getCenterY());
 *
 *     if (mathUtils.contains(source, pt.x, pt.y)) {
 *       pt.y = source.y + source.height;
 *     }
 *
 *     result.push(pt);
 *   }
 * };
 * ```
 *
 * The new edge style can then be registered in the {@link StyleRegistry} as follows:
 * ```javascript
 * StyleRegistry.putValue('myEdgeStyle', EdgeStyle.MyStyle);
 * ```
 *
 * The custom edge style above can now be used in a specific edge as follows:
 * ```javascript
 * style.edgeStyle = 'myEdgeStyle';
 * ```
 *
 * The key of the {@link StyleRegistry} entry for the function should be used in the {@link CellState.edgeStyle} values, unless {@link GraphView#allowEval} is `true.
 * In this case, you can also use the `'EdgeStyle.MyStyle'` string for the value in the cell style above.
 *
 * The custom EdgeStyle can be used for all edges in the graph as follows:
 *
 * ```javascript
 * let style = graph.getStylesheet().getDefaultEdgeStyle();
 * style.edgeStyle = EdgeStyle.MyStyle;
 * ```
 *
 * It can also be used directly when setting the value of the `edgeStyle` key in a style of a specific edge as follows:
 * ```javascript
 * style.edgeStyle = EdgeStyle.MyStyle;
 * ```
 */ class EdgeStyle {
    // mxEdgeStyle.SOURCE_MASK | mxEdgeStyle.TARGET_MASK,
    static getJettySize(state, isSource) {
        let value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getValue"])(state.style, isSource ? 'sourceJettySize' : 'targetJettySize', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getValue"])(state.style, 'jettySize', _a.orthBuffer));
        if (value === 'auto') {
            // Computes the automatic jetty size
            const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getValue"])(state.style, isSource ? 'startArrow' : 'endArrow', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]);
            if (type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
                const size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNumber"])(state.style, isSource ? 'startSize' : 'endSize', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_MARKERSIZE"]);
                value = Math.max(2, Math.ceil((size + _a.orthBuffer) / _a.orthBuffer)) * _a.orthBuffer;
            } else {
                value = 2 * _a.orthBuffer;
            }
        }
        return value;
    }
    static getRoutePattern(dir, quad, dx, dy) {
        let sourceIndex = dir[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].EAST ? 3 : dir[0];
        let targetIndex = dir[1] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].EAST ? 3 : dir[1];
        sourceIndex -= quad;
        targetIndex -= quad;
        if (sourceIndex < 1) {
            sourceIndex += 4;
        }
        if (targetIndex < 1) {
            targetIndex += 4;
        }
        let result = _a.routePatterns[sourceIndex - 1][targetIndex - 1];
        if (dx === 0 || dy === 0) {
            if (_a.inlineRoutePatterns[sourceIndex - 1][targetIndex - 1] != null) {
                result = _a.inlineRoutePatterns[sourceIndex - 1][targetIndex - 1];
            }
        }
        return result;
    }
}
_a = EdgeStyle;
/**
 * Implements an entity relation style for edges (as used in database
 * schema diagrams). At the time the function is called, the result
 * array contains a placeholder (null) for the first absolute point,
 * that is, the point where the edge and source terminal are connected.
 * The implementation of the style then adds all intermediate waypoints
 * except for the last point, that is, the connection point between the
 * edge and the target terminal. The first ant the last point in the
 * result array are then replaced with Point that take into account
 * the terminal's perimeter and next point on the edge.
 *
 * @param state {@link CellState} that represents the edge to be updated.
 * @param source {@link CellState} that represents the source terminal.
 * @param target {@link CellState} that represents the target terminal.
 * @param points List of relative control points.
 * @param result Array of {@link Point} that represent the actual points of the edge.
 */ EdgeStyle.EntityRelation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$EntityRelation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EntityRelation"];
/**
 * Implements a self-reference, aka. loop.
 */ EdgeStyle.Loop = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$Loop$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loop"];
/**
 * Uses either {@link SideToSide} or {@link TopToBottom} depending on the horizontal flag in the cell style.
 * {@link SideToSide} is used if horizontal is `true` or unspecified.
 */ EdgeStyle.ElbowConnector = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$Elbow$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElbowConnector"];
/**
 * Implements a vertical elbow edge.
 */ EdgeStyle.SideToSide = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$SideToSide$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SideToSide"];
/**
 * Implements a horizontal elbow edge.
 */ EdgeStyle.TopToBottom = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$TopToBottom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TopToBottom"];
/**
 * Implements an orthogonal edge style. Use {@link EdgeSegmentHandler}
 * as an interactive handler for this style.
 *
 * @param state {@link CellState} that represents the edge to be updated.
 * @param sourceScaled {@link CellState} that represents the source terminal.
 * @param targetScaled {@link CellState} that represents the target terminal.
 * @param controlHints List of relative control points.
 * @param result Array of {@link Point} that represent the actual points of the edge.
 */ EdgeStyle.SegmentConnector = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$Segment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SegmentConnector"];
EdgeStyle.orthBuffer = 10;
EdgeStyle.orthPointsFallback = true;
EdgeStyle.dirVectors = [
    [
        -1,
        0
    ],
    [
        0,
        -1
    ],
    [
        1,
        0
    ],
    [
        0,
        1
    ],
    [
        -1,
        0
    ],
    [
        0,
        -1
    ],
    [
        1,
        0
    ]
];
EdgeStyle.wayPoints1 = [
    [
        0,
        0
    ],
    [
        0,
        0
    ],
    [
        0,
        0
    ],
    [
        0,
        0
    ],
    [
        0,
        0
    ],
    [
        0,
        0
    ],
    [
        0,
        0
    ],
    [
        0,
        0
    ],
    [
        0,
        0
    ],
    [
        0,
        0
    ],
    [
        0,
        0
    ],
    [
        0,
        0
    ]
];
EdgeStyle.routePatterns = [
    [
        [
            513,
            2308,
            2081,
            2562
        ],
        [
            513,
            1090,
            514,
            2184,
            2114,
            2561
        ],
        [
            513,
            1090,
            514,
            2564,
            2184,
            2562
        ],
        [
            513,
            2308,
            2561,
            1090,
            514,
            2568,
            2308
        ]
    ],
    [
        [
            514,
            1057,
            513,
            2308,
            2081,
            2562
        ],
        [
            514,
            2184,
            2114,
            2561
        ],
        [
            514,
            2184,
            2562,
            1057,
            513,
            2564,
            2184
        ],
        [
            514,
            1057,
            513,
            2568,
            2308,
            2561
        ]
    ],
    [
        [
            1090,
            514,
            1057,
            513,
            2308,
            2081,
            2562
        ],
        [
            2114,
            2561
        ],
        [
            1090,
            2562,
            1057,
            513,
            2564,
            2184
        ],
        [
            1090,
            514,
            1057,
            513,
            2308,
            2561,
            2568
        ]
    ],
    [
        [
            2081,
            2562
        ],
        [
            1057,
            513,
            1090,
            514,
            2184,
            2114,
            2561
        ],
        [
            1057,
            513,
            1090,
            514,
            2184,
            2562,
            2564
        ],
        [
            1057,
            2561,
            1090,
            514,
            2568,
            2308
        ]
    ]
];
EdgeStyle.inlineRoutePatterns = [
    [
        null,
        [
            2114,
            2568
        ],
        null,
        null
    ],
    [
        null,
        [
            514,
            2081,
            2114,
            2568
        ],
        null,
        null
    ],
    [
        null,
        [
            2114,
            2561
        ],
        null,
        null
    ],
    [
        [
            2081,
            2562
        ],
        [
            1057,
            2114,
            2568
        ],
        [
            2184,
            2562
        ],
        null
    ]
];
EdgeStyle.vertexSeperations = [];
EdgeStyle.limits = [
    [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ],
    [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ]
];
EdgeStyle.LEFT_MASK = 32;
EdgeStyle.TOP_MASK = 64;
EdgeStyle.RIGHT_MASK = 128;
EdgeStyle.BOTTOM_MASK = 256;
EdgeStyle.LEFT = 1;
EdgeStyle.TOP = 2;
EdgeStyle.RIGHT = 4;
EdgeStyle.BOTTOM = 8;
// TODO remove magic numbers
EdgeStyle.SIDE_MASK = 480;
// mxEdgeStyle.LEFT_MASK | mxEdgeStyle.TOP_MASK | mxEdgeStyle.RIGHT_MASK
// | mxEdgeStyle.BOTTOM_MASK,
EdgeStyle.CENTER_MASK = 512;
EdgeStyle.SOURCE_MASK = 1024;
EdgeStyle.TARGET_MASK = 2048;
EdgeStyle.VERTEX_MASK = 3072;
/**
 * Implements a local orthogonal router between the given cells.
 *
 * @param state {@link CellState} that represents the edge to be updated.
 * @param sourceScaled {@link CellState} that represents the source terminal.
 * @param targetScaled {@link CellState} that represents the target terminal.
 * @param controlHints List of relative control {@link Point}s.
 * @param result Array of {@link Point}s that represent the actual points of the
 * edge.
 */ EdgeStyle.OrthConnector = (state, sourceScaled, targetScaled, controlHints, result)=>{
    // TODO: Figure out what to do when there are nulls in `pts`!
    const pts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scalePointArray"])(state.absolutePoints, state.view.scale);
    const source = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scaleCellState"])(sourceScaled, state.view.scale);
    const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$edge$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scaleCellState"])(targetScaled, state.view.scale);
    const sourceEdge = source == null ? false : source.cell.isEdge();
    const targetEdge = target == null ? false : target.cell.isEdge();
    const p0 = pts[0];
    const pe = pts[pts.length - 1];
    let sourceX = source != null ? source.x : p0.x;
    let sourceY = source != null ? source.y : p0.y;
    let sourceWidth = source != null ? source.width : 0;
    let sourceHeight = source != null ? source.height : 0;
    let targetX = target != null ? target.x : pe.x;
    let targetY = target != null ? target.y : pe.y;
    let targetWidth = target != null ? target.width : 0;
    let targetHeight = target != null ? target.height : 0;
    let sourceBuffer = _a.getJettySize(state, true);
    let targetBuffer = _a.getJettySize(state, false);
    // Workaround for loop routing within buffer zone
    if (source != null && target === source) {
        targetBuffer = Math.max(sourceBuffer, targetBuffer);
        sourceBuffer = targetBuffer;
    }
    const totalBuffer = targetBuffer + sourceBuffer;
    let tooShort = false;
    // Checks minimum distance for fixed points and falls back to segment connector
    if (p0 != null && pe != null) {
        const dx = pe.x - p0.x;
        const dy = pe.y - p0.y;
        tooShort = dx * dx + dy * dy < totalBuffer * totalBuffer;
    }
    if (tooShort || _a.orthPointsFallback && controlHints != null && controlHints.length > 0 || sourceEdge || targetEdge) {
        _a.SegmentConnector(state, sourceScaled, targetScaled, controlHints, result);
        return;
    }
    // Determine the side(s) of the source and target vertices
    // that the edge may connect to
    // portConstraint [source, target]
    const portConstraint = [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].ALL,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].ALL
    ];
    let rotation = 0;
    if (source != null) {
        portConstraint[0] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPortConstraints"])(source, state, true, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].ALL);
        rotation = source.style.rotation ?? 0;
        if (rotation !== 0) {
            const newRect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBoundingBox"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](sourceX, sourceY, sourceWidth, sourceHeight), rotation);
            sourceX = newRect.x;
            sourceY = newRect.y;
            sourceWidth = newRect.width;
            sourceHeight = newRect.height;
        }
    }
    if (target != null) {
        portConstraint[1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPortConstraints"])(target, state, false, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].ALL);
        rotation = target.style.rotation ?? 0;
        if (rotation !== 0) {
            const newRect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBoundingBox"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](targetX, targetY, targetWidth, targetHeight), rotation);
            targetX = newRect.x;
            targetY = newRect.y;
            targetWidth = newRect.width;
            targetHeight = newRect.height;
        }
    }
    const dir = [
        0,
        0
    ];
    // Work out which faces of the vertices present against each other
    // in a way that would allow a 3-segment connection if port constraints
    // permitted.
    // geo -> [source, target] [x, y, width, height]
    const geo = [
        [
            sourceX,
            sourceY,
            sourceWidth,
            sourceHeight
        ],
        [
            targetX,
            targetY,
            targetWidth,
            targetHeight
        ]
    ];
    const buffer = [
        sourceBuffer,
        targetBuffer
    ];
    for(let i = 0; i < 2; i += 1){
        _a.limits[i][1] = geo[i][0] - buffer[i];
        _a.limits[i][2] = geo[i][1] - buffer[i];
        _a.limits[i][4] = geo[i][0] + geo[i][2] + buffer[i];
        _a.limits[i][8] = geo[i][1] + geo[i][3] + buffer[i];
    }
    // Work out which quad the target is in
    const sourceCenX = geo[0][0] + geo[0][2] / 2.0;
    const sourceCenY = geo[0][1] + geo[0][3] / 2.0;
    const targetCenX = geo[1][0] + geo[1][2] / 2.0;
    const targetCenY = geo[1][1] + geo[1][3] / 2.0;
    const dx = sourceCenX - targetCenX;
    const dy = sourceCenY - targetCenY;
    let quad = 0;
    // 0 | 1
    // -----
    // 3 | 2
    if (dx < 0) {
        if (dy < 0) {
            quad = 2;
        } else {
            quad = 1;
        }
    } else if (dy <= 0) {
        quad = 3;
        // Special case on x = 0 and negative y
        if (dx === 0) {
            quad = 2;
        }
    }
    // Check for connection constraints
    let currentTerm = null;
    if (source != null) {
        currentTerm = p0;
    }
    const constraint = [
        [
            0.5,
            0.5
        ],
        [
            0.5,
            0.5
        ]
    ];
    for(let i = 0; i < 2; i += 1){
        if (currentTerm != null) {
            constraint[i][0] = (currentTerm.x - geo[i][0]) / geo[i][2];
            if (Math.abs(currentTerm.x - geo[i][0]) <= 1) {
                dir[i] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].WEST;
            } else if (Math.abs(currentTerm.x - geo[i][0] - geo[i][2]) <= 1) {
                dir[i] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].EAST;
            }
            constraint[i][1] = (currentTerm.y - geo[i][1]) / geo[i][3];
            if (Math.abs(currentTerm.y - geo[i][1]) <= 1) {
                dir[i] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].NORTH;
            } else if (Math.abs(currentTerm.y - geo[i][1] - geo[i][3]) <= 1) {
                dir[i] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].SOUTH;
            }
        }
        currentTerm = null;
        if (target != null) {
            currentTerm = pe;
        }
    }
    const sourceTopDist = geo[0][1] - (geo[1][1] + geo[1][3]);
    const sourceLeftDist = geo[0][0] - (geo[1][0] + geo[1][2]);
    const sourceBottomDist = geo[1][1] - (geo[0][1] + geo[0][3]);
    const sourceRightDist = geo[1][0] - (geo[0][0] + geo[0][2]);
    _a.vertexSeperations[1] = Math.max(sourceLeftDist - totalBuffer, 0);
    _a.vertexSeperations[2] = Math.max(sourceTopDist - totalBuffer, 0);
    _a.vertexSeperations[4] = Math.max(sourceBottomDist - totalBuffer, 0);
    _a.vertexSeperations[3] = Math.max(sourceRightDist - totalBuffer, 0);
    //= =============================================================
    // Start of source and target direction determination
    // Work through the preferred orientations by relative positioning
    // of the vertices and list them in preferred and available order
    const dirPref = [];
    const horPref = [];
    const vertPref = [];
    horPref[0] = sourceLeftDist >= sourceRightDist ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].WEST : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].EAST;
    vertPref[0] = sourceTopDist >= sourceBottomDist ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].NORTH : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].SOUTH;
    horPref[1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reversePortConstraints"])(horPref[0]);
    vertPref[1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reversePortConstraints"])(vertPref[0]);
    const preferredHorizDist = sourceLeftDist >= sourceRightDist ? sourceLeftDist : sourceRightDist;
    const preferredVertDist = sourceTopDist >= sourceBottomDist ? sourceTopDist : sourceBottomDist;
    const prefOrdering = [
        [
            0,
            0
        ],
        [
            0,
            0
        ]
    ];
    let preferredOrderSet = false;
    // If the preferred port isn't available, switch it
    for(let i = 0; i < 2; i += 1){
        if (dir[i] !== 0x0) {
            continue;
        }
        if ((horPref[i] & portConstraint[i]) === 0) {
            horPref[i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reversePortConstraints"])(horPref[i]);
        }
        if ((vertPref[i] & portConstraint[i]) === 0) {
            vertPref[i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reversePortConstraints"])(vertPref[i]);
        }
        prefOrdering[i][0] = vertPref[i];
        prefOrdering[i][1] = horPref[i];
    }
    if (preferredVertDist > 0 && preferredHorizDist > 0) {
        // Possibility of two segment edge connection
        if ((horPref[0] & portConstraint[0]) > 0 && (vertPref[1] & portConstraint[1]) > 0) {
            prefOrdering[0][0] = horPref[0];
            prefOrdering[0][1] = vertPref[0];
            prefOrdering[1][0] = vertPref[1];
            prefOrdering[1][1] = horPref[1];
            preferredOrderSet = true;
        } else if ((vertPref[0] & portConstraint[0]) > 0 && (horPref[1] & portConstraint[1]) > 0) {
            prefOrdering[0][0] = vertPref[0];
            prefOrdering[0][1] = horPref[0];
            prefOrdering[1][0] = horPref[1];
            prefOrdering[1][1] = vertPref[1];
            preferredOrderSet = true;
        }
    }
    if (preferredVertDist > 0 && !preferredOrderSet) {
        prefOrdering[0][0] = vertPref[0];
        prefOrdering[0][1] = horPref[0];
        prefOrdering[1][0] = vertPref[1];
        prefOrdering[1][1] = horPref[1];
        preferredOrderSet = true;
    }
    if (preferredHorizDist > 0 && !preferredOrderSet) {
        prefOrdering[0][0] = horPref[0];
        prefOrdering[0][1] = vertPref[0];
        prefOrdering[1][0] = horPref[1];
        prefOrdering[1][1] = vertPref[1];
        preferredOrderSet = true;
    }
    // The source and target prefs are now an ordered list of
    // the preferred port selections
    // If the list contains gaps, compact it
    for(let i = 0; i < 2; i += 1){
        if (dir[i] !== 0x0) {
            continue;
        }
        if ((prefOrdering[i][0] & portConstraint[i]) === 0) {
            prefOrdering[i][0] = prefOrdering[i][1];
        }
        dirPref[i] = prefOrdering[i][0] & portConstraint[i];
        dirPref[i] |= (prefOrdering[i][1] & portConstraint[i]) << 8;
        dirPref[i] |= (prefOrdering[1 - i][i] & portConstraint[i]) << 16;
        dirPref[i] |= (prefOrdering[1 - i][1 - i] & portConstraint[i]) << 24;
        if ((dirPref[i] & 0xf) === 0) {
            dirPref[i] = dirPref[i] << 8;
        }
        if ((dirPref[i] & 0xf00) === 0) {
            dirPref[i] = dirPref[i] & 0xf | dirPref[i] >> 8;
        }
        if ((dirPref[i] & 0xf0000) === 0) {
            dirPref[i] = dirPref[i] & 0xffff | (dirPref[i] & 0xf000000) >> 8;
        }
        dir[i] = dirPref[i] & 0xf;
        if (portConstraint[i] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].WEST || portConstraint[i] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].NORTH || portConstraint[i] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].EAST || portConstraint[i] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].SOUTH) {
            dir[i] = portConstraint[i];
        }
    }
    //= =============================================================
    // End of source and target direction determination
    let sourceIndex = dir[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].EAST ? 3 : dir[0];
    let targetIndex = dir[1] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].EAST ? 3 : dir[1];
    sourceIndex -= quad;
    targetIndex -= quad;
    if (sourceIndex < 1) {
        sourceIndex += 4;
    }
    if (targetIndex < 1) {
        targetIndex += 4;
    }
    const routePattern = _a.routePatterns[sourceIndex - 1][targetIndex - 1];
    _a.wayPoints1[0][0] = geo[0][0];
    _a.wayPoints1[0][1] = geo[0][1];
    switch(dir[0]){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].WEST:
            _a.wayPoints1[0][0] -= sourceBuffer;
            _a.wayPoints1[0][1] += constraint[0][1] * geo[0][3];
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].SOUTH:
            _a.wayPoints1[0][0] += constraint[0][0] * geo[0][2];
            _a.wayPoints1[0][1] += geo[0][3] + sourceBuffer;
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].EAST:
            _a.wayPoints1[0][0] += geo[0][2] + sourceBuffer;
            _a.wayPoints1[0][1] += constraint[0][1] * geo[0][3];
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].NORTH:
            _a.wayPoints1[0][0] += constraint[0][0] * geo[0][2];
            _a.wayPoints1[0][1] -= sourceBuffer;
            break;
    }
    let currentIndex = 0;
    // Orientation, 0 horizontal, 1 vertical
    let lastOrientation = (dir[0] & (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].EAST | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].WEST)) > 0 ? 0 : 1;
    const initialOrientation = lastOrientation;
    let currentOrientation = 0;
    for(let i = 0; i < routePattern.length; i += 1){
        const nextDirection = routePattern[i] & 0xf;
        // Rotate the index of this direction by the quad
        // to get the real direction
        let directionIndex = nextDirection === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].EAST ? 3 : nextDirection;
        directionIndex += quad;
        if (directionIndex > 4) {
            directionIndex -= 4;
        }
        const direction = _a.dirVectors[directionIndex - 1];
        currentOrientation = directionIndex % 2 > 0 ? 0 : 1;
        // Only update the current index if the point moved
        // in the direction of the current segment move,
        // otherwise the same point is moved until there is
        // a segment direction change
        if (currentOrientation !== lastOrientation) {
            currentIndex++;
            // Copy the previous way point into the new one
            // We can't base the new position on index - 1
            // because sometime elbows turn out not to exist,
            // then we'd have to rewind.
            _a.wayPoints1[currentIndex][0] = _a.wayPoints1[currentIndex - 1][0];
            _a.wayPoints1[currentIndex][1] = _a.wayPoints1[currentIndex - 1][1];
        }
        const tar = (routePattern[i] & _a.TARGET_MASK) > 0;
        const sou = (routePattern[i] & _a.SOURCE_MASK) > 0;
        let side = (routePattern[i] & _a.SIDE_MASK) >> 5;
        side <<= quad;
        if (side > 0xf) {
            side >>= 4;
        }
        const center = (routePattern[i] & _a.CENTER_MASK) > 0;
        if ((sou || tar) && side < 9) {
            let limit = 0;
            const souTar = sou ? 0 : 1;
            if (center && currentOrientation === 0) {
                limit = geo[souTar][0] + constraint[souTar][0] * geo[souTar][2];
            } else if (center) {
                limit = geo[souTar][1] + constraint[souTar][1] * geo[souTar][3];
            } else {
                limit = _a.limits[souTar][side];
            }
            if (currentOrientation === 0) {
                const lastX = _a.wayPoints1[currentIndex][0];
                const deltaX = (limit - lastX) * direction[0];
                if (deltaX > 0) {
                    _a.wayPoints1[currentIndex][0] += direction[0] * deltaX;
                }
            } else {
                const lastY = _a.wayPoints1[currentIndex][1];
                const deltaY = (limit - lastY) * direction[1];
                if (deltaY > 0) {
                    _a.wayPoints1[currentIndex][1] += direction[1] * deltaY;
                }
            }
        } else if (center) {
            // Which center we're travelling to depend on the current direction
            _a.wayPoints1[currentIndex][0] += direction[0] * Math.abs(_a.vertexSeperations[directionIndex] / 2);
            _a.wayPoints1[currentIndex][1] += direction[1] * Math.abs(_a.vertexSeperations[directionIndex] / 2);
        }
        if (currentIndex > 0 && _a.wayPoints1[currentIndex][currentOrientation] === _a.wayPoints1[currentIndex - 1][currentOrientation]) {
            currentIndex--;
        } else {
            lastOrientation = currentOrientation;
        }
    }
    for(let i = 0; i <= currentIndex; i += 1){
        if (i === currentIndex) {
            // Last point can cause last segment to be in
            // same direction as jetty/approach. If so,
            // check the number of points is consistent
            // with the relative orientation of source and target
            // jx. Same orientation requires an even
            // number of turns (points), different requires
            // odd.
            const targetOrientation = (dir[1] & (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].EAST | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION_MASK"].WEST)) > 0 ? 0 : 1;
            const sameOrient = targetOrientation === initialOrientation ? 0 : 1;
            // (currentIndex + 1) % 2 is 0 for even number of points,
            // 1 for odd
            if (sameOrient !== (currentIndex + 1) % 2) {
                break;
            }
        }
        result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](Math.round(_a.wayPoints1[i][0] * state.view.scale * 10) / 10, Math.round(_a.wayPoints1[i][1] * state.view.scale * 10) / 10));
    }
    // Removes duplicates
    let index = 1;
    while(index < result.length){
        if (result[index - 1] == null || result[index] == null || result[index - 1].x !== result[index].x || result[index - 1].y !== result[index].y) {
            index++;
        } else {
            result.splice(index, 1);
        }
    }
};
// Size of the step to find a route
EdgeStyle.MANHATTAN_STEP = 12;
// If number of route finding loops exceed the maximum, stops searching and returns
// fallback route
EdgeStyle.MANHATTAN_MAXIMUM_LOOPS = 2000;
// Possible starting directions from an element
EdgeStyle.MANHATTAN_START_DIRECTIONS = [
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST
];
// Possible ending directions to an element
EdgeStyle.MANHATTAN_END_DIRECTIONS = [
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST
];
// Limit for directions change when searching route
EdgeStyle.MANHATTAN_MAX_ALLOWED_DIRECTION_CHANGE = 90;
EdgeStyle.MANHATTAN_PADDING_BOX = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](-_a.MANHATTAN_STEP, -_a.MANHATTAN_STEP, _a.MANHATTAN_STEP * 2, _a.MANHATTAN_STEP * 2);
/**
 * ManhattanConnector code is based on code from https://github.com/mwangm/mxgraph-manhattan-connector
 *
 * Implements router to find the shortest route that avoids cells using manhattan distance as metric.
 */ EdgeStyle.ManhattanConnector = (state, source, target, points, result)=>{
    /**
     * Adds all values from source geometry to target.
     * Used to create padding box around cell geometry.
     * @param target
     * @param source
     * @returns
     */ function moveAndExpand(target, source) {
        target.x += source.x || 0;
        target.y += source.y || 0;
        target.width += source.width || 0;
        target.height += source.height || 0;
        return target;
    }
    function snapCoordinateToGrid(value, gridSize) {
        return gridSize * Math.round(value / gridSize);
    }
    function snapPointToGrid(p, gx, gy) {
        p.x = snapCoordinateToGrid(p.x, gx);
        p.y = snapCoordinateToGrid(p.y, gy || gx);
        return p;
    }
    function isPointInRectangle(rect, p) {
        return p.x >= rect.x && p.x <= rect.x + rect.width && p.y >= rect.y && p.y <= rect.y + rect.height;
    }
    function getRectangleCenter(rect) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](rect.x + rect.width / 2, rect.y + rect.height / 2);
    }
    function getDifferencePoint(p1, p2) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](p1.x - p2.x, p1.y - p2.y);
    }
    function movePoint(p, moveX, moveY) {
        p.x += moveX || 0;
        p.y += moveY || 0;
        return p;
    }
    function getPointTheta(p1, p2) {
        const p = p2.clone();
        const y = -(p.y - p1.y);
        const x = p.x - p1.x;
        const PRECISION = 10;
        const rad = y.toFixed(PRECISION) == '0' && x.toFixed(PRECISION) == '0' ? 0 : Math.atan2(y, x);
        return 180 * rad / Math.PI;
    }
    function normalizePoint(point) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);
    }
    function getManhattanDistance(p1, p2) {
        return Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y);
    }
    function toPointFromString(pointString) {
        const xy = pointString.split(pointString.indexOf('@') === -1 ? ' ' : '@');
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](parseInt(xy[0], 10), parseInt(xy[1], 10));
    }
    function pointToString(point) {
        return `${point.x}@${point.y}`;
    }
    function getCellAbsoluteBounds(cellState) {
        const graph = cellState.view.graph;
        const cellBounds = graph.getCellBounds(cellState.cell, false, false)?.clone();
        if (!cellBounds) return undefined;
        const view = graph.view;
        const { scale, translate } = view;
        const { x, y } = translate;
        const round = (v)=>Math.round(v * 10) / 10;
        const res = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](round(cellBounds.x / scale - x), round(cellBounds.y / scale - y), round(cellBounds.width / scale), round(cellBounds.height / scale));
        return res;
    }
    const mStep = _a.MANHATTAN_STEP;
    const config = {
        // Padding applied on the element bounding boxes
        paddingBox: _a.MANHATTAN_PADDING_BOX,
        // An array of directions to find next points on the route
        directions: [
            {
                offsetX: mStep,
                offsetY: 0,
                cost: mStep,
                angle: normalizeAngle(getPointTheta(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](mStep, 0)))
            },
            {
                offsetX: 0,
                offsetY: mStep,
                cost: mStep,
                angle: normalizeAngle(getPointTheta(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, mStep)))
            },
            {
                offsetX: -mStep,
                offsetY: 0,
                cost: mStep,
                angle: normalizeAngle(getPointTheta(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](-mStep, 0)))
            },
            {
                offsetX: 0,
                offsetY: -mStep,
                cost: mStep,
                angle: normalizeAngle(getPointTheta(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, -mStep)))
            }
        ],
        directionMap: {
            east: {
                x: 1,
                y: 0
            },
            south: {
                x: 0,
                y: 1
            },
            west: {
                x: -1,
                y: 0
            },
            north: {
                x: 0,
                y: -1
            }
        },
        // A penalty received for direction change
        penaltiesGenerator: (angle)=>{
            if (angle == 45 || angle == 90 || angle == 180) return _a.MANHATTAN_STEP / 2;
            return 0;
        },
        // If a function is provided, it's used to route the link while dragging an end
        // i.e. function(from, to, opts) { return []; }
        draggingRoute: null,
        previousDirAngle: 0
    };
    /**
     * Map of obstacles
     * Helper structure to identify whether a point lies in an obstacle.
     */ class ObstacleMap {
        constructor(opt){
            this.options = opt;
            this.mapGridSize = 100;
            this.map = new Map();
        }
        // Builds a map of all elements for quicker obstacle queries
        // The svg is divided to  cells, where each of them holds an information which
        // elements belong to it. When we query whether a point is in an obstacle we don't need
        // to go through all obstacles, we check only those in a particular cell.
        build(source, target) {
            const graph = source?.view.graph || target?.view.graph;
            if (!graph) return;
            return Array.from(graph.getView().getCellStates()).filter((s)=>s.cell && s.cell.isVertex() && !s.cell.isEdge()).map((s)=>getCellAbsoluteBounds(s)).map((bbox)=>bbox ? moveAndExpand(bbox, this.options.paddingBox) : null).forEach((bbox)=>{
                if (!bbox) return;
                const origin = snapPointToGrid(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](bbox.x, bbox.y), this.mapGridSize);
                const corner = snapPointToGrid(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](bbox.x + bbox.width, bbox.y + bbox.height), this.mapGridSize);
                for(let x = origin.x; x <= corner.x; x += this.mapGridSize){
                    for(let y = origin.y; y <= corner.y; y += this.mapGridSize){
                        const gridKey = x + '@' + y;
                        const rectArr = this.map.get(gridKey) || [];
                        if (!this.map.has(gridKey)) this.map.set(gridKey, rectArr);
                        rectArr.push(bbox);
                    }
                }
            });
        }
        isPointAccessible(point) {
            const mapKey = pointToString(snapPointToGrid(point.clone(), this.mapGridSize));
            const obstacles = this.map.get(mapKey);
            if (obstacles) {
                return obstacles.every((obstacle)=>!isPointInRectangle(obstacle, point));
            }
            return true;
        }
    }
    class SortedSet {
        constructor(){
            this.items = [];
            this.hash = new Map();
        }
        add(key, value) {
            const hashItem = this.hash.get(key);
            if (hashItem) {
                hashItem.value = value;
                this.items.splice(this.items.indexOf(key), 1);
            } else {
                this.hash.set(key, {
                    value,
                    open: true
                });
            }
            this.items.push(key);
            this.items.sort((i1, i2)=>{
                const hashItem1 = this.hash.get(i1);
                const hashItem2 = this.hash.get(i2);
                if (!hashItem1 || !hashItem2) return 0;
                return hashItem1.value - hashItem2.value;
            });
        }
        remove(key) {
            const hashItem = this.hash.get(key);
            if (hashItem) hashItem.open = false;
        }
        isOpen(key) {
            const hashItem = this.hash.get(key);
            return hashItem && hashItem.open == true;
        }
        isClose(key) {
            const hashItem = this.hash.get(key);
            return hashItem && hashItem.open == false;
        }
        isEmpty() {
            return this.items.length == 0;
        }
        pop() {
            const key = this.items.shift();
            if (key) this.remove(key);
            return key;
        }
    }
    function reconstructRoute(parents, endPoint, startCenter, endCenter) {
        const route = [];
        let previousDirection = normalizePoint(getDifferencePoint(endCenter, endPoint));
        let current = endPoint;
        let parent;
        while(parents[pointToString(current)]){
            parent = parents[pointToString(current)];
            if (!parent) continue;
            const direction = normalizePoint(getDifferencePoint(current, parent));
            // Add point in when direction change
            if (!direction.equals(previousDirection)) {
                route.unshift(current);
                previousDirection = direction;
            }
            current = parent;
        }
        const startDirection = normalizePoint(getDifferencePoint(current, startCenter));
        if (!startDirection.equals(previousDirection)) {
            route.unshift(current);
        }
        return route;
    }
    function getRectPoints(bbox, directionList, opt) {
        const step = _a.MANHATTAN_STEP;
        const center = getRectangleCenter(bbox);
        const res = [];
        for (const direction of directionList){
            const directionPoint = opt.directionMap[direction];
            const x = directionPoint.x * bbox.width / 2;
            const y = directionPoint.y * bbox.height / 2;
            const point = movePoint(center.clone(), x, y);
            if (isPointInRectangle(bbox, point)) {
                movePoint(point, directionPoint.x * step, directionPoint.y * step);
            }
            res.push(snapPointToGrid(point, step));
        }
        return res;
    }
    function normalizeAngle(angle) {
        return angle % 360 + (angle < 0 ? 360 : 0);
    }
    function getDirectionAngle(start, end, directionLength) {
        const q = 360 / directionLength;
        return Math.floor(normalizeAngle(getPointTheta(start, end) + q / 2) / q) * q;
    }
    function getDirectionChange(angle1, angle2) {
        const dirChange = Math.abs(angle1 - angle2);
        return dirChange > 180 ? 360 - dirChange : dirChange;
    }
    function estimateCost(from, endPoints) {
        let min = Infinity;
        for(let i = 0, len = endPoints.length; i < len; i++){
            const cost = getManhattanDistance(from, endPoints[i]);
            if (cost < min) min = cost;
        }
        return min;
    }
    function alignPointToCell(point, edgeState, cellState, isSourceCell) {
        const cellBounds = getCellAbsoluteBounds(cellState);
        const y = isSourceCell ? edgeState.style.exitY : edgeState.style.entryY;
        const onlyHorizontalDirections = isSourceCell ? _a.MANHATTAN_START_DIRECTIONS.every((d)=>d != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH && d != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) : _a.MANHATTAN_END_DIRECTIONS.every((d)=>d != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH && d != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH);
        if (y != undefined && onlyHorizontalDirections) {
            const cellHeight = cellBounds?.height || 0;
            point.y = cellBounds?.y != undefined ? cellBounds?.y + cellHeight * y : point.y - cellHeight / 2 + cellHeight * y;
        }
        const x = isSourceCell ? edgeState.style.exitX : edgeState.style.entryX;
        const onlyVerticalDirections = isSourceCell ? _a.MANHATTAN_START_DIRECTIONS.every((d)=>d != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST && d != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST) : _a.MANHATTAN_END_DIRECTIONS.every((d)=>d != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST && d != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST);
        if (x != undefined && onlyVerticalDirections) {
            const cellWidth = cellBounds?.width || 0;
            point.x = cellBounds?.x != undefined ? cellBounds?.x + cellWidth * x : point.x - cellWidth / 2 + cellWidth * (x || 0);
        }
    }
    function findRoute(start, end, obstacleMap, opt) {
        // Caculate start points and end points
        const step = _a.MANHATTAN_STEP;
        const startPoints = getRectPoints(start, _a.MANHATTAN_START_DIRECTIONS, opt).filter((p)=>obstacleMap.isPointAccessible(p));
        const startCenter = snapPointToGrid(getRectangleCenter(start), step);
        const endPoints = getRectPoints(end, _a.MANHATTAN_END_DIRECTIONS, opt).filter((p)=>obstacleMap.isPointAccessible(p));
        const endCenter = snapPointToGrid(getRectangleCenter(end), step);
        if (startPoints.length > 0 && endPoints.length > 0) {
            // The set of possible  points to be evaluated, initially containing the start points.
            const openSet = new SortedSet();
            // Keeps predecessor of given element.
            const parents = {};
            // Cost from start to a point along best known path.
            const costs = {};
            startPoints.forEach((p)=>{
                const key = pointToString(p);
                openSet.add(key, estimateCost(p, endPoints));
                costs[key] = 0;
            });
            let loopsRemain = _a.MANHATTAN_MAXIMUM_LOOPS;
            const endPointsKeys = endPoints.map((p)=>pointToString(p));
            let currentDirectionAngle;
            let previousDirectionAngle;
            // Main route finding loop
            while(!openSet.isEmpty() && loopsRemain > 0){
                const currentKey = openSet.pop();
                if (currentKey == undefined) {
                    continue;
                }
                const currentPoint = toPointFromString(currentKey);
                const currentCost = costs[currentKey];
                previousDirectionAngle = currentDirectionAngle;
                currentDirectionAngle = parents[currentKey] ? getDirectionAngle(parents[currentKey], currentPoint, opt.directions.length) : opt.previousDirAngle != 0 ? opt.previousDirAngle : getDirectionAngle(startCenter, currentPoint, opt.directions.length);
                // if get the endpoint
                if (endPointsKeys.indexOf(currentKey) >= 0) {
                    // stop route to enter the end point in opposite direction.
                    const directionChangedAngle = getDirectionChange(currentDirectionAngle, getDirectionAngle(currentPoint, endCenter, opt.directions.length));
                    if (currentPoint.equals(endCenter) || directionChangedAngle < 180) {
                        opt.previousDirAngle = currentDirectionAngle;
                        return reconstructRoute(parents, currentPoint, startCenter, endCenter);
                    }
                }
                // Go over all possible directions and find neighbors.
                for(let i = 0; i < opt.directions.length; i++){
                    const direction = opt.directions[i];
                    const directionChangedAngle = getDirectionChange(currentDirectionAngle, direction.angle);
                    if (previousDirectionAngle && directionChangedAngle > _a.MANHATTAN_MAX_ALLOWED_DIRECTION_CHANGE) {
                        continue;
                    }
                    const neighborPoint = movePoint(currentPoint.clone(), direction.offsetX, direction.offsetY);
                    const neighborKey = pointToString(neighborPoint);
                    if (openSet.isClose(neighborKey) || !obstacleMap.isPointAccessible(neighborPoint)) {
                        continue;
                    }
                    const costFromStart = currentCost + direction.cost + opt.penaltiesGenerator(directionChangedAngle);
                    if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {
                        // Neighbor point has not been processed yet or the cost of the path
                        // from start is lesser than previously calcluated.
                        parents[neighborKey] = currentPoint;
                        costs[neighborKey] = costFromStart;
                        openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));
                    }
                }
                loopsRemain--;
            }
            return null;
        }
        return null;
    }
    function router(state, source, target, points, result, opt) {
        // If edge is dragged after calculation, points will be filled, so fallback to SegmentConnector
        if (points != null && points.length > 0 || source == null || target == null) {
            _a.SegmentConnector(state, source, target, points, result);
            return;
        }
        let sourceBBox = getCellAbsoluteBounds(source);
        sourceBBox = sourceBBox ? moveAndExpand(sourceBBox, opt.paddingBox) : undefined;
        let targetBBox = getCellAbsoluteBounds(target);
        targetBBox = targetBBox ? moveAndExpand(targetBBox, opt.paddingBox) : undefined;
        const obstacleMap = new ObstacleMap(opt);
        obstacleMap.build(source, target);
        if (!sourceBBox || !targetBBox) {
            // Fallback to OrthConnector
            return _a.OrthConnector(state, source, target, points, result);
        }
        const routePoints = findRoute(sourceBBox, targetBBox, obstacleMap, opt);
        if (routePoints == null || routePoints.length == 0) {
            // Fallback to OrthConnector
            return _a.OrthConnector(state, source, target, points, result);
        }
        if (state.style) {
            if (state.visibleSourceState && routePoints.length > 0) {
                // If there are at least one point, align it to source cell
                alignPointToCell(routePoints[0], state, state.visibleSourceState, true);
            }
            if (state.visibleTargetState && routePoints.length > 1) {
                // If there are more than one point, align last point to target cell
                alignPointToCell(routePoints[routePoints.length - 1], state, state.visibleTargetState, false);
            }
        }
        // Scaling and translating result points
        const scale = state.view.scale;
        routePoints.forEach((pt)=>result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](Math.round((pt.x + state.view.translate.x) * scale * 10) / 10, Math.round((pt.y + state.view.translate.y) * scale * 10) / 10)));
    }
    router(state, source, target, points, result, config);
};
const __TURBOPACK__default__export__ = EdgeStyle;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/style/StyleRegistry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ /**
 * Singleton class that acts as a global converter from string to object values
 * in a style. This is currently only used to perimeters and edge styles.
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
class StyleRegistry {
    /**
     * Puts the given object into the registry under the given name.
     */ static putValue(name, obj) {
        StyleRegistry.values[name] = obj;
    }
    /**
     * Returns the value associated with the given name.
     */ static getValue(name) {
        return StyleRegistry.values[name];
    }
    /**
     * Returns the name for the given value.
     */ static getName(value) {
        for(const key in StyleRegistry.values){
            if (StyleRegistry.values[key] === value) {
                return key;
            }
        }
        return null;
    }
}
/**
 * Maps from strings to objects.
 */ StyleRegistry.values = {};
const __TURBOPACK__default__export__ = StyleRegistry;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/style/Stylesheet.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "Stylesheet": (()=>Stylesheet)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
;
class Stylesheet {
    constructor(){
        this.styles = new Map();
        this.putDefaultVertexStyle(this.createDefaultVertexStyle());
        this.putDefaultEdgeStyle(this.createDefaultEdgeStyle());
    }
    /**
     * Creates and returns the default vertex style.
     */ createDefaultVertexStyle() {
        const style = {};
        style.shape = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHAPE"].RECTANGLE;
        style.perimeter = 'rectanglePerimeter';
        style.verticalAlign = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE;
        style.align = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER;
        style.fillColor = '#C3D9FF';
        style.strokeColor = '#6482B9';
        style.fontColor = '#774400';
        return style;
    }
    /**
     * Creates and returns the default edge style.
     */ createDefaultEdgeStyle() {
        const style = {};
        style.shape = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHAPE"].CONNECTOR;
        style.endArrow = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARROW"].CLASSIC;
        style.verticalAlign = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE;
        style.align = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER;
        style.strokeColor = '#6482B9';
        style.fontColor = '#446299';
        return style;
    }
    /**
     * Sets the default style for vertices using `defaultVertex` as the style name.
     * @param style The style to be stored.
     */ putDefaultVertexStyle(style) {
        this.putCellStyle('defaultVertex', style);
    }
    /**
     * Sets the default style for edges using `defaultEdge` as the style name.
     * @param style The style to be stored.
     */ putDefaultEdgeStyle(style) {
        this.putCellStyle('defaultEdge', style);
    }
    /**
     * Returns the default style for vertices.
     */ getDefaultVertexStyle() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- the style is set in the constructor
        return this.styles.get('defaultVertex');
    }
    /**
     * Returns the default style for edges.
     */ getDefaultEdgeStyle() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- the style is set in the constructor
        return this.styles.get('defaultEdge');
    }
    /**
     * Stores the given {@link CellStateStyle} under the given name in {@link styles}.
     *
     * ### Example
     *
     * The following example adds a new style called `rounded` into an existing stylesheet:
     *
     * ```javascript
     * const style = {} as CellStateStyle;
     * style.shape = SHAPE.RECTANGLE;
     * style.perimeter = PERIMETER.RECTANGLE;
     * style.rounded = true;
     * graph.getStylesheet().putCellStyle('rounded', style);
     * ```
     *
     * ### Description
     *
     * Note that not all properties will be interpreted by all shapes. For example, the 'line' shape ignores the fill color.
     * The final call to this method associates the style with a name in the stylesheet.
     *
     * The style is used in a cell with the following code:
     * ```javascript
     * // model is an instance of GraphDataModel
     * // style is an instance of CellStyle
     * model.setStyle(cell, { baseStyleNames: ['rounded'] });
     * ```
     *
     * @param name Name for the style to be stored.
     * @param style The instance of the style to be stored.
     */ putCellStyle(name, style) {
        this.styles.set(name, style);
    }
    /**
     * Returns a {@link CellStateStyle} computed by merging the default style, styles referenced in the specified `baseStyleNames`
     * and the properties of the `cellStyle` parameter.
     *
     * The properties are merged by taking the properties from various styles in the following order:
     *   - default style (if {@link CellStyle.ignoreDefaultStyle} is not set to `true`, otherwise it is ignored)
     *   - registered styles referenced in `baseStyleNames`, in the order of the array
     *   - `cellStyle` parameter
     *
     * To fully unset a style property i.e. the property is not set even if a value is set in the default style or in the referenced styles,
     * set the `cellStyle` property to `none`. For example. `cellStyle.fillColor = 'none'`
     *
     * @param cellStyle An object that represents the style.
     * @param defaultStyle Default style used as reference to compute the returned style.
     */ getCellStyle(cellStyle, defaultStyle) {
        let style = cellStyle.ignoreDefaultStyle ? {} : {
            ...defaultStyle
        };
        if (cellStyle.baseStyleNames) {
            // creates style with the given baseStyleNames. (merges from left to right)
            style = cellStyle.baseStyleNames.reduce((acc, styleName)=>{
                return {
                    ...acc,
                    ...this.styles.get(styleName)
                };
            }, style);
        }
        // Merges cellStyle into style
        for (const key of Object.keys(cellStyle)){
            // @ts-ignore
            if (cellStyle[key] !== undefined) {
                // @ts-ignore
                cellStyle[key] == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"] ? delete style[key] : style[key] = cellStyle[key];
            }
        }
        // Remove the specific CellStyle properties that may have been copied from the cellStyle parameter to match the method signature
        'baseStyleNames' in style && delete style.baseStyleNames;
        'ignoreDefaultStyle' in style && delete style.ignoreDefaultStyle;
        return style;
    }
}
}}),
"[project]/node_modules/@maxgraph/core/lib/view/style/perimeter/RectanglePerimeter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "RectanglePerimeter": (()=>RectanglePerimeter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
;
const RectanglePerimeter = (bounds, _vertex, next, orthogonal = false)=>{
    const cx = bounds.getCenterX();
    const cy = bounds.getCenterY();
    const dx = next.x - cx;
    const dy = next.y - cy;
    const alpha = Math.atan2(dy, dx);
    const p = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0);
    const pi = Math.PI;
    const pi2 = Math.PI / 2;
    const beta = pi2 - alpha;
    const t = Math.atan2(bounds.height, bounds.width);
    if (alpha < -pi + t || alpha > pi - t) {
        // Left edge
        p.x = bounds.x;
        p.y = cy - bounds.width * Math.tan(alpha) / 2;
    } else if (alpha < -t) {
        // Top Edge
        p.y = bounds.y;
        p.x = cx - bounds.height * Math.tan(beta) / 2;
    } else if (alpha < t) {
        // Right Edge
        p.x = bounds.x + bounds.width;
        p.y = cy + bounds.width * Math.tan(alpha) / 2;
    } else {
        // Bottom Edge
        p.y = bounds.y + bounds.height;
        p.x = cx + bounds.height * Math.tan(beta) / 2;
    }
    if (orthogonal) {
        if (next.x >= bounds.x && next.x <= bounds.x + bounds.width) {
            p.x = next.x;
        } else if (next.y >= bounds.y && next.y <= bounds.y + bounds.height) {
            p.y = next.y;
        }
        if (next.x < bounds.x) {
            p.x = bounds.x;
        } else if (next.x > bounds.x + bounds.width) {
            p.x = bounds.x + bounds.width;
        }
        if (next.y < bounds.y) {
            p.y = bounds.y;
        } else if (next.y > bounds.y + bounds.height) {
            p.y = bounds.y + bounds.height;
        }
    }
    return p;
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/style/perimeter/EllipsePerimeter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "EllipsePerimeter": (()=>EllipsePerimeter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
;
const EllipsePerimeter = (bounds, _vertex, next, orthogonal = false)=>{
    const { x } = bounds;
    const { y } = bounds;
    const a = bounds.width / 2;
    const b = bounds.height / 2;
    const cx = x + a;
    const cy = y + b;
    const px = next.x;
    const py = next.y;
    // Calculates straight line equation through
    // point and ellipse center y = d * x + h
    const dx = parseInt(String(px - cx));
    const dy = parseInt(String(py - cy));
    if (dx === 0 && dy !== 0) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](cx, cy + b * dy / Math.abs(dy));
    }
    if (dx === 0 && dy === 0) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](px, py);
    }
    if (orthogonal) {
        if (py >= y && py <= y + bounds.height) {
            const ty = py - cy;
            let tx = Math.sqrt(a * a * (1 - ty * ty / (b * b))) || 0;
            if (px <= x) {
                tx = -tx;
            }
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](cx + tx, py);
        }
        if (px >= x && px <= x + bounds.width) {
            const tx = px - cx;
            let ty = Math.sqrt(b * b * (1 - tx * tx / (a * a))) || 0;
            if (py <= y) {
                ty = -ty;
            }
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](px, cy + ty);
        }
    }
    // Calculates intersection
    const d = dy / dx;
    const h = cy - d * cx;
    const e = a * a * d * d + b * b;
    const f = -2 * cx * e;
    const g = a * a * d * d * cx * cx + b * b * cx * cx - a * a * b * b;
    const det = Math.sqrt(f * f - 4 * e * g);
    // Two solutions (perimeter points)
    const xout1 = (-f + det) / (2 * e);
    const xout2 = (-f - det) / (2 * e);
    const yout1 = d * xout1 + h;
    const yout2 = d * xout2 + h;
    const dist1 = Math.sqrt(Math.pow(xout1 - px, 2) + Math.pow(yout1 - py, 2));
    const dist2 = Math.sqrt(Math.pow(xout2 - px, 2) + Math.pow(yout2 - py, 2));
    // Correct solution
    let xout = 0;
    let yout = 0;
    if (dist1 < dist2) {
        xout = xout1;
        yout = yout1;
    } else {
        xout = xout2;
        yout = yout2;
    }
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](xout, yout);
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/style/perimeter/RhombusPerimeter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "RhombusPerimeter": (()=>RhombusPerimeter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
;
;
const RhombusPerimeter = (bounds, _vertex, next, orthogonal = false)=>{
    const { x } = bounds;
    const { y } = bounds;
    const w = bounds.width;
    const h = bounds.height;
    const cx = x + w / 2;
    const cy = y + h / 2;
    const px = next.x;
    const py = next.y;
    // Special case for intersecting the diamond's corners
    if (cx === px) {
        if (cy > py) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](cx, y); // top
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](cx, y + h); // bottom
    }
    if (cy === py) {
        if (cx > px) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, cy); // left
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, cy); // right
    }
    let tx = cx;
    let ty = cy;
    if (orthogonal) {
        if (px >= x && px <= x + w) {
            tx = px;
        } else if (py >= y && py <= y + h) {
            ty = py;
        }
    }
    // In which quadrant will the intersection be?
    // set the slope and offset of the border line accordingly
    if (px < cx) {
        if (py < cy) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersection"])(px, py, tx, ty, cx, y, x, cy);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersection"])(px, py, tx, ty, cx, y + h, x, cy);
    }
    if (py < cy) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersection"])(px, py, tx, ty, cx, y, x + w, cy);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersection"])(px, py, tx, ty, cx, y + h, x + w, cy);
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/style/perimeter/TrianglePerimeter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "TrianglePerimeter": (()=>TrianglePerimeter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
;
;
;
const TrianglePerimeter = (bounds, vertex, next, orthogonal = false)=>{
    const direction = vertex != null ? vertex.style.direction : null;
    const vertical = direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH || direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH;
    const { x } = bounds;
    const { y } = bounds;
    const w = bounds.width;
    const h = bounds.height;
    let cx = x + w / 2;
    let cy = y + h / 2;
    let start = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y);
    let corner = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, cy);
    let end = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + h);
    if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH) {
        start = end;
        corner = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](cx, y);
        end = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + h);
    } else if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) {
        corner = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](cx, y + h);
        end = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y);
    } else if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST) {
        start = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y);
        corner = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, cy);
        end = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + h);
    }
    let dx = next.x - cx;
    let dy = next.y - cy;
    const alpha = vertical ? Math.atan2(dx, dy) : Math.atan2(dy, dx);
    const t = vertical ? Math.atan2(w, h) : Math.atan2(h, w);
    let base = false;
    if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH || direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST) {
        base = alpha > -t && alpha < t;
    } else {
        base = alpha < -Math.PI + t || alpha > Math.PI - t;
    }
    let result = null;
    if (base) {
        if (orthogonal && (vertical && next.x >= start.x && next.x <= end.x || !vertical && next.y >= start.y && next.y <= end.y)) {
            if (vertical) {
                result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](next.x, start.y);
            } else {
                result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](start.x, next.y);
            }
        } else if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH) {
            result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w / 2 + h * Math.tan(alpha) / 2, y + h);
        } else if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) {
            result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w / 2 - h * Math.tan(alpha) / 2, y);
        } else if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST) {
            result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + h / 2 + w * Math.tan(alpha) / 2);
        } else {
            result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + h / 2 - w * Math.tan(alpha) / 2);
        }
    } else {
        if (orthogonal) {
            const pt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](cx, cy);
            if (next.y >= y && next.y <= y + h) {
                pt.x = vertical ? cx : direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST ? x + w : x;
                pt.y = next.y;
            } else if (next.x >= x && next.x <= x + w) {
                pt.x = next.x;
                pt.y = !vertical ? cy : direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH ? y + h : y;
            }
            // Compute angle
            dx = next.x - pt.x;
            dy = next.y - pt.y;
            cx = pt.x;
            cy = pt.y;
        }
        if (vertical && next.x <= x + w / 2 || !vertical && next.y <= y + h / 2) {
            result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersection"])(next.x, next.y, cx, cy, start.x, start.y, corner.x, corner.y);
        } else {
            result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersection"])(next.x, next.y, cx, cy, corner.x, corner.y, end.x, end.y);
        }
    }
    if (result == null) {
        result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](cx, cy);
    }
    return result;
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/style/perimeter/HexagonPerimeter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "HexagonPerimeter": (()=>HexagonPerimeter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
;
;
;
const HexagonPerimeter = (bounds, vertex, next, orthogonal = false)=>{
    const { x } = bounds;
    const { y } = bounds;
    const w = bounds.width;
    const h = bounds.height;
    const cx = bounds.getCenterX();
    const cy = bounds.getCenterY();
    const px = next.x;
    const py = next.y;
    const dx = px - cx;
    const dy = py - cy;
    const alpha = -Math.atan2(dy, dx);
    const pi = Math.PI;
    const pi2 = Math.PI / 2;
    let result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](cx, cy);
    const direction = vertex?.style?.direction ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST;
    const vertical = direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH || direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH;
    let a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    let b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    // Only consider corrects quadrants for the orthogonal case.
    if (px < x && py < y || px < x && py > y + h || px > x + w && py < y || px > x + w && py > y + h) {
        orthogonal = false;
    }
    if (orthogonal) {
        if (vertical) {
            // Special cases where intersects with hexagon corners
            if (px === cx) {
                if (py <= y) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](cx, y);
                }
                if (py >= y + h) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](cx, y + h);
                }
            } else if (px < x) {
                if (py === y + h / 4) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + h / 4);
                }
                if (py === y + 3 * h / 4) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + 3 * h / 4);
                }
            } else if (px > x + w) {
                if (py === y + h / 4) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + h / 4);
                }
                if (py === y + 3 * h / 4) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + 3 * h / 4);
                }
            } else if (px === x) {
                if (py < cy) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + h / 4);
                }
                if (py > cy) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + 3 * h / 4);
                }
            } else if (px === x + w) {
                if (py < cy) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + h / 4);
                }
                if (py > cy) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + 3 * h / 4);
                }
            }
            if (py === y) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](cx, y);
            }
            if (py === y + h) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](cx, y + h);
            }
            if (px < cx) {
                if (py > y + h / 4 && py < y + 3 * h / 4) {
                    a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y);
                    b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + h);
                } else if (py < y + h / 4) {
                    a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));
                    b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y - Math.floor(0.25 * h));
                } else if (py > y + 3 * h / 4) {
                    a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));
                    b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + Math.floor(1.25 * h));
                }
            } else if (px > cx) {
                if (py > y + h / 4 && py < y + 3 * h / 4) {
                    a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y);
                    b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + h);
                } else if (py < y + h / 4) {
                    a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y - Math.floor(0.25 * h));
                    b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));
                } else if (py > y + 3 * h / 4) {
                    a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));
                    b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + Math.floor(1.25 * h));
                }
            }
        } else {
            // Special cases where intersects with hexagon corners
            if (py === cy) {
                if (px <= x) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + h / 2);
                }
                if (px >= x + w) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + h / 2);
                }
            } else if (py < y) {
                if (px === x + w / 4) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w / 4, y);
                }
                if (px === x + 3 * w / 4) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + 3 * w / 4, y);
                }
            } else if (py > y + h) {
                if (px === x + w / 4) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w / 4, y + h);
                }
                if (px === x + 3 * w / 4) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + 3 * w / 4, y + h);
                }
            } else if (py === y) {
                if (px < cx) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w / 4, y);
                }
                if (px > cx) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + 3 * w / 4, y);
                }
            } else if (py === y + h) {
                if (px < cx) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w / 4, y + h);
                }
                if (py > cy) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + 3 * w / 4, y + h);
                }
            }
            if (px === x) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, cy);
            }
            if (px === x + w) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, cy);
            }
            if (py < cy) {
                if (px > x + w / 4 && px < x + 3 * w / 4) {
                    a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y);
                    b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y);
                } else if (px < x + w / 4) {
                    a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x - Math.floor(0.25 * w), y + h);
                    b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));
                } else if (px > x + 3 * w / 4) {
                    a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));
                    b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(1.25 * w), y + h);
                }
            } else if (py > cy) {
                if (px > x + w / 4 && px < x + 3 * w / 4) {
                    a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + h);
                    b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + h);
                } else if (px < x + w / 4) {
                    a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x - Math.floor(0.25 * w), y);
                    b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));
                } else if (px > x + 3 * w / 4) {
                    a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));
                    b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(1.25 * w), y);
                }
            }
        }
        let tx = cx;
        let ty = cy;
        if (px >= x && px <= x + w) {
            tx = px;
            if (py < cy) {
                ty = y + h;
            } else {
                ty = y;
            }
        } else if (py >= y && py <= y + h) {
            ty = py;
            if (px < cx) {
                tx = x + w;
            } else {
                tx = x;
            }
        }
        result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersection"])(tx, ty, next.x, next.y, a.x, a.y, b.x, b.y);
    } else {
        if (vertical) {
            const beta = Math.atan2(h / 4, w / 2);
            // Special cases where intersects with hexagon corners
            if (alpha === beta) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + Math.floor(0.25 * h));
            }
            if (alpha === pi2) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(0.5 * w), y);
            }
            if (alpha === pi - beta) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + Math.floor(0.25 * h));
            }
            if (alpha === -beta) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + Math.floor(0.75 * h));
            }
            if (alpha === -pi2) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(0.5 * w), y + h);
            }
            if (alpha === -pi + beta) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + Math.floor(0.75 * h));
            }
            if (alpha < beta && alpha > -beta) {
                a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y);
                b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + h);
            } else if (alpha > beta && alpha < pi2) {
                a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y - Math.floor(0.25 * h));
                b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));
            } else if (alpha > pi2 && alpha < pi - beta) {
                a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));
                b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y - Math.floor(0.25 * h));
            } else if (alpha > pi - beta && alpha <= pi || alpha < -pi + beta && alpha >= -pi) {
                a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y);
                b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + h);
            } else if (alpha < -beta && alpha > -pi2) {
                a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));
                b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + Math.floor(1.25 * h));
            } else if (alpha < -pi2 && alpha > -pi + beta) {
                a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));
                b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + Math.floor(1.25 * h));
            }
        } else {
            const beta = Math.atan2(h / 2, w / 4);
            // Special cases where intersects with hexagon corners
            if (alpha === beta) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(0.75 * w), y);
            }
            if (alpha === pi - beta) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(0.25 * w), y);
            }
            if (alpha === pi || alpha === -pi) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + Math.floor(0.5 * h));
            }
            if (alpha === 0) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + Math.floor(0.5 * h));
            }
            if (alpha === -beta) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(0.75 * w), y + h);
            }
            if (alpha === -pi + beta) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(0.25 * w), y + h);
            }
            if (alpha > 0 && alpha < beta) {
                a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));
                b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(1.25 * w), y + h);
            } else if (alpha > beta && alpha < pi - beta) {
                a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y);
                b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y);
            } else if (alpha > pi - beta && alpha < pi) {
                a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x - Math.floor(0.25 * w), y + h);
                b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));
            } else if (alpha < 0 && alpha > -beta) {
                a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));
                b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(1.25 * w), y);
            } else if (alpha < -beta && alpha > -pi + beta) {
                a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y + h);
                b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + w, y + h);
            } else if (alpha < -pi + beta && alpha > -pi) {
                a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x - Math.floor(0.25 * w), y);
                b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));
            }
        }
        result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersection"])(cx, cy, next.x, next.y, a.x, a.y, b.x, b.y);
    }
    if (result == null) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](cx, cy);
    }
    return result;
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/style/Perimeter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$perimeter$2f$RectanglePerimeter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/perimeter/RectanglePerimeter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$perimeter$2f$EllipsePerimeter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/perimeter/EllipsePerimeter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$perimeter$2f$RhombusPerimeter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/perimeter/RhombusPerimeter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$perimeter$2f$TrianglePerimeter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/perimeter/TrianglePerimeter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$perimeter$2f$HexagonPerimeter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/perimeter/HexagonPerimeter.js [app-client] (ecmascript)");
;
;
;
;
;
/**
 * Provides various perimeter functions to be used in a style as the value of {@link CellStateStyle.perimeter}.
 *
 * @category Perimeter
 */ const Perimeter = {
    /**
     * Describes a rectangular perimeter.
     */ RectanglePerimeter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$perimeter$2f$RectanglePerimeter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RectanglePerimeter"],
    /**
     * Describes an elliptic perimeter.
     */ EllipsePerimeter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$perimeter$2f$EllipsePerimeter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EllipsePerimeter"],
    /**
     * Describes a rhombus (aka diamond) perimeter.
     */ RhombusPerimeter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$perimeter$2f$RhombusPerimeter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RhombusPerimeter"],
    /**
     * Describes a triangle perimeter.
     */ TrianglePerimeter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$perimeter$2f$TrianglePerimeter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TrianglePerimeter"],
    /**
     * Describes a hexagon perimeter.
     */ HexagonPerimeter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$perimeter$2f$HexagonPerimeter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HexagonPerimeter"]
};
const __TURBOPACK__default__export__ = Perimeter;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/style/register.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2024-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "registerDefaultStyleElements": (()=>registerDefaultStyleElements)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/StyleRegistry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/EdgeStyle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$Perimeter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/Perimeter.js [app-client] (ecmascript)");
;
;
;
;
let isDefaultsRegistered = false;
const registerDefaultStyleElements = ()=>{
    if (!isDefaultsRegistered) {
        // Edge styles
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].putValue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDGESTYLE"].ELBOW, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ElbowConnector);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].putValue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDGESTYLE"].ENTITY_RELATION, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EntityRelation);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].putValue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDGESTYLE"].LOOP, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Loop);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].putValue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDGESTYLE"].MANHATTAN, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ManhattanConnector);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].putValue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDGESTYLE"].ORTHOGONAL, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OrthConnector);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].putValue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDGESTYLE"].SEGMENT, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SegmentConnector);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].putValue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDGESTYLE"].SIDETOSIDE, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SideToSide);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].putValue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EDGESTYLE"].TOPTOBOTTOM, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TopToBottom);
        // Perimeters
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].putValue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PERIMETER"].ELLIPSE, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$Perimeter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EllipsePerimeter);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].putValue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PERIMETER"].HEXAGON, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$Perimeter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].HexagonPerimeter);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].putValue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PERIMETER"].RECTANGLE, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$Perimeter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RectanglePerimeter);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].putValue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PERIMETER"].RHOMBUS, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$Perimeter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RhombusPerimeter);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].putValue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PERIMETER"].TRIANGLE, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$Perimeter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TrianglePerimeter);
        isDefaultsRegistered = true;
    }
};
}}),
}]);

//# sourceMappingURL=node_modules_%40maxgraph_core_lib_view_style_fab108._.js.map