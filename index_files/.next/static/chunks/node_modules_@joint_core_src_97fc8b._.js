(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@joint_core_src_97fc8b._.js", {

"[project]/node_modules/@joint/core/src/config/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "config": (()=>config)
});
const config = {
    // When set to `true` the cell selectors could be defined as CSS selectors.
    // If not, only JSON Markup selectors are taken into account.
    useCSSSelectors: false,
    // The class name prefix config is for advanced use only.
    // Be aware that if you change the prefix, the JointJS CSS will no longer function properly.
    classNamePrefix: 'joint-',
    defaultTheme: 'default',
    // The maximum delay required for two consecutive touchend events to be interpreted
    // as a double-tap.
    doubleTapInterval: 300
};
}}),
"[project]/node_modules/@joint/core/src/V/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// Vectorizer.
// -----------
// A tiny library for making your life easier when dealing with SVG.
// The only Vectorizer dependency is the Geometry library.
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/index.mjs [app-client] (ecmascript)");
;
const V = function() {
    var hasSvg = typeof window === 'object' && !!window.SVGAngle;
    // SVG support is required.
    if (!hasSvg) {
        // Return a function that throws an error when it is used.
        return function() {
            throw new Error('SVG is required to use Vectorizer.');
        };
    }
    // XML namespaces.
    var ns = {
        svg: 'http://www.w3.org/2000/svg',
        xmlns: 'http://www.w3.org/2000/xmlns/',
        xml: 'http://www.w3.org/XML/1998/namespace',
        xlink: 'http://www.w3.org/1999/xlink',
        xhtml: 'http://www.w3.org/1999/xhtml'
    };
    var SVGVersion = '1.1';
    // Declare shorthands to the most used math functions.
    var math = Math;
    var PI = math.PI;
    var atan2 = math.atan2;
    var sqrt = math.sqrt;
    var min = math.min;
    var max = math.max;
    var cos = math.cos;
    var sin = math.sin;
    var V = function(el, attrs, children) {
        // This allows using V() without the new keyword.
        if (!(this instanceof V)) {
            return V.apply(Object.create(V.prototype), arguments);
        }
        if (!el) return;
        if (V.isV(el)) {
            el = el.node;
        }
        attrs = attrs || {};
        if (V.isString(el)) {
            el = el.trim();
            if (el.toLowerCase() === 'svg') {
                // Create a new SVG canvas.
                el = V.createSvgDocument();
            } else if (el[0] === '<') {
                // Create element from an SVG string.
                // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.
                var svgDoc = V.createSvgDocument(el);
                // Note that `V()` might also return an array should the SVG string passed as
                // the first argument contain more than one root element.
                if (svgDoc.childNodes.length > 1) {
                    // Map child nodes to `V`s.
                    var arrayOfVels = [];
                    var i, len;
                    for(i = 0, len = svgDoc.childNodes.length; i < len; i++){
                        var childNode = svgDoc.childNodes[i];
                        arrayOfVels.push(new V(document.importNode(childNode, true)));
                    }
                    return arrayOfVels;
                }
                el = document.importNode(svgDoc.firstChild, true);
            } else {
                el = document.createElementNS(ns.svg, el);
            }
            V.ensureId(el);
        }
        this.node = el;
        this.setAttributes(attrs);
        if (children) {
            this.append(children);
        }
        return this;
    };
    var VPrototype = V.prototype;
    Object.defineProperty(VPrototype, 'id', {
        enumerable: true,
        get: function() {
            return this.node.id;
        },
        set: function(id) {
            this.node.id = id;
        }
    });
    /**
     * @param {SVGGElement} toElem
     * @returns {SVGMatrix}
     */ VPrototype.getTransformToElement = function(target) {
        var node = this.node;
        if (V.isSVGGraphicsElement(target) && V.isSVGGraphicsElement(node)) {
            var targetCTM = V.toNode(target).getScreenCTM();
            var nodeCTM = node.getScreenCTM();
            if (targetCTM && nodeCTM) {
                return targetCTM.inverse().multiply(nodeCTM);
            }
        }
        // Could not get actual transformation matrix
        return V.createSVGMatrix();
    };
    /**
     * @param {SVGMatrix} matrix
     * @param {Object=} opt
     * @returns {Vectorizer|SVGMatrix} Setter / Getter
     */ VPrototype.transform = function(matrix, opt) {
        var node = this.node;
        if (V.isUndefined(matrix)) {
            return V.transformStringToMatrix(this.attr('transform'));
        }
        if (opt && opt.absolute) {
            return this.attr('transform', V.matrixToTransformString(matrix));
        }
        var svgTransform = V.createSVGTransform(matrix);
        node.transform.baseVal.appendItem(svgTransform);
        return this;
    };
    VPrototype.translate = function(tx, ty, opt) {
        opt = opt || {};
        ty = ty || 0;
        var transformAttr = this.attr('transform') || '';
        var transform = V.parseTransformString(transformAttr);
        transformAttr = transform.value;
        // Is it a getter?
        if (V.isUndefined(tx)) {
            return transform.translate;
        }
        transformAttr = transformAttr.replace(/translate\([^)]*\)/g, '').trim();
        var newTx = opt.absolute ? tx : transform.translate.tx + tx;
        var newTy = opt.absolute ? ty : transform.translate.ty + ty;
        var newTranslate = 'translate(' + newTx + ',' + newTy + ')';
        // Note that `translate()` is always the first transformation. This is
        // usually the desired case.
        this.attr('transform', (newTranslate + ' ' + transformAttr).trim());
        return this;
    };
    VPrototype.rotate = function(angle, cx, cy, opt) {
        opt = opt || {};
        var transformAttr = this.attr('transform') || '';
        var transform = V.parseTransformString(transformAttr);
        transformAttr = transform.value;
        // Is it a getter?
        if (V.isUndefined(angle)) {
            return transform.rotate;
        }
        transformAttr = transformAttr.replace(/rotate\([^)]*\)/g, '').trim();
        angle %= 360;
        var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;
        var newOrigin = cx !== undefined && cy !== undefined ? ',' + cx + ',' + cy : '';
        var newRotate = 'rotate(' + newAngle + newOrigin + ')';
        this.attr('transform', (transformAttr + ' ' + newRotate).trim());
        return this;
    };
    // Note that `scale` as the only transformation does not combine with previous values.
    VPrototype.scale = function(sx, sy) {
        sy = V.isUndefined(sy) ? sx : sy;
        var transformAttr = this.attr('transform') || '';
        var transform = V.parseTransformString(transformAttr);
        transformAttr = transform.value;
        // Is it a getter?
        if (V.isUndefined(sx)) {
            return transform.scale;
        }
        transformAttr = transformAttr.replace(/scale\([^)]*\)/g, '').trim();
        var newScale = 'scale(' + sx + ',' + sy + ')';
        this.attr('transform', (transformAttr + ' ' + newScale).trim());
        return this;
    };
    // Get SVGRect that contains coordinates and dimension of the real bounding box,
    // i.e. after transformations are applied.
    // If `target` is specified, bounding box will be computed relatively to `target` element.
    VPrototype.bbox = function(withoutTransformations, target) {
        var box;
        var node = this.node;
        var ownerSVGElement = node.ownerSVGElement;
        // If the element is not in the live DOM, it does not have a bounding box defined and
        // so fall back to 'zero' dimension element.
        if (!ownerSVGElement) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect(0, 0, 0, 0);
        }
        try {
            box = node.getBBox();
        } catch (e) {
            // Fallback for IE.
            box = {
                x: node.clientLeft,
                y: node.clientTop,
                width: node.clientWidth,
                height: node.clientHeight
            };
        }
        if (withoutTransformations) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect(box);
        }
        var matrix = this.getTransformToElement(target || ownerSVGElement);
        return V.transformRect(box, matrix);
    };
    // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,
    // i.e. after transformations are applied.
    // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.
    // Takes an (Object) `opt` argument (optional) with the following attributes:
    // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this
    // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();
    VPrototype.getBBox = function(opt) {
        var options = {};
        var outputBBox;
        var node = this.node;
        var ownerSVGElement = node.ownerSVGElement;
        // If the element is not in the live DOM, it does not have a bounding box defined and
        // so fall back to 'zero' dimension element.
        // If the element is not an SVGGraphicsElement, we could not measure the bounding box either
        if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect(0, 0, 0, 0);
        }
        if (opt) {
            if (opt.target) {
                options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects
            }
            if (opt.recursive) {
                options.recursive = opt.recursive;
            }
        }
        if (!options.recursive) {
            try {
                outputBBox = node.getBBox();
            } catch (e) {
                // Fallback for IE.
                outputBBox = {
                    x: node.clientLeft,
                    y: node.clientTop,
                    width: node.clientWidth,
                    height: node.clientHeight
                };
            }
            if (!options.target) {
                // transform like this (that is, not at all)
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect(outputBBox);
            } else {
                // transform like target
                var matrix = this.getTransformToElement(options.target);
                return V.transformRect(outputBBox, matrix);
            }
        } else {
            // browsers report correct bbox around svg elements (one that envelops the path lines tightly)
            // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())
            // this happens even if we wrap a single svg element into a group!
            // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes
            var children = this.children();
            var n = children.length;
            if (n === 0) {
                return this.getBBox({
                    target: options.target,
                    recursive: false
                });
            }
            // recursion's initial pass-through setting:
            // recursive passes-through just keep the target as whatever was set up here during the initial pass-through
            if (!options.target) {
                // transform children/descendants like this (their parent/ancestor)
                options.target = this;
            } // else transform children/descendants like target
            for(var i = 0; i < n; i++){
                var currentChild = children[i];
                var childBBox;
                // if currentChild is not a group element, get its bbox with a nonrecursive call
                if (currentChild.children().length === 0) {
                    childBBox = currentChild.getBBox({
                        target: options.target,
                        recursive: false
                    });
                } else {
                    // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call
                    childBBox = currentChild.getBBox({
                        target: options.target,
                        recursive: true
                    });
                }
                if (!outputBBox) {
                    // if this is the first iteration
                    outputBBox = childBBox;
                } else {
                    // make a new bounding box rectangle that contains this child's bounding box and previous bounding box
                    outputBBox = outputBBox.union(childBBox);
                }
            }
            return outputBBox;
        }
    };
    // Text() helpers
    function createTextPathNode(attrs, vel) {
        attrs || (attrs = {});
        var textPathElement = V('textPath');
        var d = attrs.d;
        if (d && attrs['xlink:href'] === undefined) {
            // If `opt.attrs` is a plain string, consider it to be directly the
            // SVG path data for the text to go along (this is a shortcut).
            // Otherwise if it is an object and contains the `d` property, then this is our path.
            // Wrap the text in the SVG <textPath> element that points
            // to a path defined by `opt.attrs` inside the `<defs>` element.
            var linkedPath = V('path').attr('d', d).appendTo(vel.defs());
            textPathElement.attr('xlink:href', '#' + linkedPath.id);
        }
        if (V.isObject(attrs)) {
            // Set attributes on the `<textPath>`. The most important one
            // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.
            // Note that we also allow the following construct:
            // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.
            // In other words, one can completely skip the auto-creation of the path
            // and use any other arbitrary path that is in the document.
            textPathElement.attr(attrs);
        }
        return textPathElement.node;
    }
    function annotateTextLine(lineNode, lineAnnotations, opt) {
        opt || (opt = {});
        var includeAnnotationIndices = opt.includeAnnotationIndices;
        var eol = opt.eol;
        var lineHeight = opt.lineHeight;
        var baseSize = opt.baseSize;
        var maxFontSize = 0;
        var fontMetrics = {};
        var lastJ = lineAnnotations.length - 1;
        for(var j = 0; j <= lastJ; j++){
            var annotation = lineAnnotations[j];
            var fontSize = null;
            if (V.isObject(annotation)) {
                var annotationAttrs = annotation.attrs;
                var vTSpan = V('tspan', annotationAttrs);
                var tspanNode = vTSpan.node;
                var t = annotation.t;
                if (eol && j === lastJ) t += eol;
                tspanNode.textContent = t;
                // Per annotation className
                var annotationClass = annotationAttrs['class'];
                if (annotationClass) vTSpan.addClass(annotationClass);
                // If `opt.includeAnnotationIndices` is `true`,
                // set the list of indices of all the applied annotations
                // in the `annotations` attribute. This list is a comma
                // separated list of indices.
                if (includeAnnotationIndices) vTSpan.attr('annotations', annotation.annotations);
                // Check for max font size
                fontSize = parseFloat(annotationAttrs['font-size']);
                if (!isFinite(fontSize)) fontSize = baseSize;
                if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;
            } else {
                if (eol && j === lastJ) annotation += eol;
                tspanNode = document.createTextNode(annotation || ' ');
                if (baseSize && baseSize > maxFontSize) maxFontSize = baseSize;
            }
            lineNode.appendChild(tspanNode);
        }
        if (maxFontSize) fontMetrics.maxFontSize = maxFontSize;
        if (lineHeight) {
            fontMetrics.lineHeight = lineHeight;
        } else if (maxFontSize) {
            fontMetrics.lineHeight = maxFontSize * 1.2;
        }
        return fontMetrics;
    }
    var emRegex = /em$/;
    function convertEmToPx(em, fontSize) {
        var numerical = parseFloat(em);
        if (emRegex.test(em)) return numerical * fontSize;
        return numerical;
    }
    function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {
        if (!Array.isArray(linesMetrics)) return 0;
        var n = linesMetrics.length;
        if (!n) return 0;
        var lineMetrics = linesMetrics[0];
        var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
        var rLineHeights = 0;
        var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);
        for(var i = 1; i < n; i++){
            lineMetrics = linesMetrics[i];
            var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;
            rLineHeights += iLineHeight;
        }
        var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
        var dy;
        switch(alignment){
            case 'middle':
                dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;
                break;
            case 'bottom':
                dy = -(0.25 * llMaxFont) - rLineHeights;
                break;
            case 'top':
            default:
                dy = 0.8 * flMaxFont;
                break;
        }
        return dy;
    }
    VPrototype.text = function(content, opt) {
        if (content && typeof content !== 'string') throw new Error('Vectorizer: text() expects the first argument to be a string.');
        // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).
        // IE would otherwise collapse all spaces into one.
        content = V.sanitizeText(content);
        opt || (opt = {});
        // Should we allow the text to be selected?
        var displayEmpty = opt.displayEmpty;
        // End of Line character
        var eol = opt.eol;
        // Text along path
        var textPath = opt.textPath;
        // Vertical shift
        var verticalAnchor = opt.textVerticalAnchor;
        var namedVerticalAnchor = verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top';
        // Horizontal shift applied to all the lines but the first.
        var x = opt.x;
        if (x === undefined) x = this.attr('x') || 0;
        // Annotations
        var iai = opt.includeAnnotationIndices;
        var annotations = opt.annotations;
        if (annotations && !V.isArray(annotations)) annotations = [
            annotations
        ];
        // Shift all the <tspan> but first by one line (`1em`)
        var defaultLineHeight = opt.lineHeight;
        var autoLineHeight = defaultLineHeight === 'auto';
        var lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';
        // Clearing the element
        this.empty();
        this.attr({
            // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.
            'xml:space': 'preserve',
            // An empty text gets rendered into the DOM in webkit-based browsers.
            // In order to unify this behaviour across all browsers
            // we rather hide the text element when it's empty.
            'display': content || displayEmpty ? null : 'none'
        });
        // Set default font-size if none
        var fontSize = parseFloat(this.attr('font-size'));
        if (!fontSize) {
            fontSize = 16;
            if (namedVerticalAnchor || annotations) this.attr('font-size', fontSize);
        }
        var doc = document;
        var containerNode;
        if (textPath) {
            // Now all the `<tspan>`s will be inside the `<textPath>`.
            if (typeof textPath === 'string') textPath = {
                d: textPath
            };
            containerNode = createTextPathNode(textPath, this);
        } else {
            containerNode = doc.createDocumentFragment();
        }
        var offset = 0;
        var lines = content.split('\n');
        var linesMetrics = [];
        var annotatedY;
        for(var i = 0, lastI = lines.length - 1; i <= lastI; i++){
            var dy = lineHeight;
            var lineClassName = 'v-line';
            var lineNode = doc.createElementNS(ns.svg, 'tspan');
            var line = lines[i];
            var lineMetrics;
            if (line) {
                if (annotations) {
                    // Find the *compacted* annotations for this line.
                    var lineAnnotations = V.annotateString(line, annotations, {
                        offset: -offset,
                        includeAnnotationIndices: iai
                    });
                    lineMetrics = annotateTextLine(lineNode, lineAnnotations, {
                        includeAnnotationIndices: iai,
                        eol: i !== lastI && eol,
                        lineHeight: autoLineHeight ? null : lineHeight,
                        baseSize: fontSize
                    });
                    // Get the line height based on the biggest font size in the annotations for this line.
                    var iLineHeight = lineMetrics.lineHeight;
                    if (iLineHeight && autoLineHeight && i !== 0) dy = iLineHeight;
                    if (i === 0) annotatedY = lineMetrics.maxFontSize * 0.8;
                } else {
                    if (eol && i !== lastI) line += eol;
                    lineNode.textContent = line;
                }
            } else {
                // Make sure the textContent is never empty. If it is, add a dummy
                // character and make it invisible, making the following lines correctly
                // relatively positioned. `dy=1em` won't work with empty lines otherwise.
                lineNode.textContent = '-';
                lineClassName += ' v-empty-line';
                // 'opacity' needs to be specified with fill, stroke. Opacity without specification
                // is not applied in Firefox
                var lineNodeStyle = lineNode.style;
                lineNodeStyle.fillOpacity = 0;
                lineNodeStyle.strokeOpacity = 0;
                if (annotations) {
                    // Empty line with annotations.
                    lineMetrics = {};
                    lineAnnotations = V.findAnnotationsAtIndex(annotations, offset);
                    let lineFontSize = fontSize;
                    // Check if any of the annotations overrides the font size.
                    for(let j = lineAnnotations.length; j > 0; j--){
                        const attrs = lineAnnotations[j - 1].attrs;
                        if (!attrs || !('font-size' in attrs)) continue;
                        const fs = parseFloat(attrs['font-size']);
                        if (isFinite(fs)) {
                            lineFontSize = fs;
                            break;
                        }
                    }
                    if (autoLineHeight) {
                        if (i > 0) {
                            dy = lineFontSize * 1.2;
                        } else {
                            annotatedY = lineFontSize * 0.8;
                        }
                    }
                    // The font size is important for the native selection box height.
                    lineNode.setAttribute('font-size', lineFontSize);
                    lineMetrics.maxFontSize = lineFontSize;
                }
            }
            if (lineMetrics) linesMetrics.push(lineMetrics);
            if (i > 0) lineNode.setAttribute('dy', dy);
            // Firefox requires 'x' to be set on the first line when inside a text path
            if (i > 0 || textPath) lineNode.setAttribute('x', x);
            lineNode.className.baseVal = lineClassName;
            containerNode.appendChild(lineNode);
            offset += line.length + 1; // + 1 = newline character.
        }
        // Y Alignment calculation
        if (namedVerticalAnchor) {
            if (annotations) {
                dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);
            } else if (verticalAnchor === 'top') {
                // A shortcut for top alignment. It does not depend on font-size nor line-height
                dy = '0.8em';
            } else {
                var rh; // remaining height
                if (lastI > 0) {
                    rh = parseFloat(lineHeight) || 1;
                    rh *= lastI;
                    if (!emRegex.test(lineHeight)) rh /= fontSize;
                } else {
                    // Single-line text
                    rh = 0;
                }
                switch(verticalAnchor){
                    case 'middle':
                        dy = 0.3 - rh / 2 + 'em';
                        break;
                    case 'bottom':
                        dy = -rh - 0.3 + 'em';
                        break;
                }
            }
        } else {
            if (verticalAnchor === 0) {
                dy = '0em';
            } else if (verticalAnchor) {
                dy = verticalAnchor;
            } else {
                // No vertical anchor is defined
                dy = 0;
                // Backwards compatibility - we change the `y` attribute instead of `dy`.
                if (this.attr('y') === null) this.attr('y', annotatedY || '0.8em');
            }
        }
        containerNode.firstChild.setAttribute('dy', dy);
        // Appending lines to the element.
        this.append(containerNode);
        return this;
    };
    /**
     * @public
     * @param {string} name
     * @returns {Vectorizer}
     */ VPrototype.removeAttr = function(name) {
        const trueName = attributeNames[name];
        const { ns, local } = V.qualifyAttr(trueName);
        const el = this.node;
        if (ns) {
            if (el.hasAttributeNS(ns, local)) {
                el.removeAttributeNS(ns, local);
            }
        } else if (el.hasAttribute(trueName)) {
            el.removeAttribute(trueName);
        }
        return this;
    };
    VPrototype.attr = function(name, value) {
        if (V.isUndefined(name)) {
            // Return all attributes.
            var attributes = this.node.attributes;
            var attrs = {};
            for(var i = 0; i < attributes.length; i++){
                attrs[attributes[i].name] = attributes[i].value;
            }
            return attrs;
        }
        if (V.isString(name) && V.isUndefined(value)) {
            return this.node.getAttribute(attributeNames[name]);
        }
        if (typeof name === 'object') {
            for(var attrName in name){
                if (name.hasOwnProperty(attrName)) {
                    this.setAttribute(attrName, name[attrName]);
                }
            }
        } else {
            this.setAttribute(name, value);
        }
        return this;
    };
    VPrototype.normalizePath = function() {
        var tagName = this.tagName();
        if (tagName === 'PATH') {
            this.attr('d', V.normalizePathData(this.attr('d')));
        }
        return this;
    };
    VPrototype.remove = function() {
        if (this.node.parentNode) {
            this.node.parentNode.removeChild(this.node);
        }
        return this;
    };
    VPrototype.empty = function() {
        while(this.node.firstChild){
            this.node.removeChild(this.node.firstChild);
        }
        return this;
    };
    /**
     * @private
     * @param {object} attrs
     * @returns {Vectorizer}
     */ VPrototype.setAttributes = function(attrs) {
        for(var key in attrs){
            if (attrs.hasOwnProperty(key)) {
                this.setAttribute(key, attrs[key]);
            }
        }
        return this;
    };
    VPrototype.append = function(els) {
        if (!V.isArray(els)) {
            els = [
                els
            ];
        }
        for(var i = 0, len = els.length; i < len; i++){
            this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]
        }
        return this;
    };
    VPrototype.prepend = function(els) {
        var child = this.node.firstChild;
        return child ? V(child).before(els) : this.append(els);
    };
    VPrototype.before = function(els) {
        var node = this.node;
        var parent = node.parentNode;
        if (parent) {
            if (!V.isArray(els)) {
                els = [
                    els
                ];
            }
            for(var i = 0, len = els.length; i < len; i++){
                parent.insertBefore(V.toNode(els[i]), node);
            }
        }
        return this;
    };
    VPrototype.appendTo = function(node) {
        V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]
        return this;
    };
    VPrototype.svg = function() {
        return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);
    };
    VPrototype.tagName = function() {
        return this.node.tagName.toUpperCase();
    };
    VPrototype.defs = function() {
        var context = this.svg() || this;
        var defsNode = context.node.getElementsByTagName('defs')[0];
        if (defsNode) return V(defsNode);
        return V('defs').appendTo(context);
    };
    VPrototype.clone = function() {
        var clone = V(this.node.cloneNode(true));
        // Note that clone inherits also ID. Therefore, we need to change it here.
        clone.node.id = V.uniqueId();
        return clone;
    };
    VPrototype.findOne = function(selector) {
        var found = this.node.querySelector(selector);
        return found ? V(found) : undefined;
    };
    VPrototype.find = function(selector) {
        var vels = [];
        var nodes = this.node.querySelectorAll(selector);
        if (nodes) {
            // Map DOM elements to `V`s.
            for(var i = 0; i < nodes.length; i++){
                vels.push(V(nodes[i]));
            }
        }
        return vels;
    };
    // Returns an array of V elements made from children of this.node.
    VPrototype.children = function() {
        var children = this.node.childNodes;
        var outputArray = [];
        for(var i = 0; i < children.length; i++){
            var currentChild = children[i];
            if (currentChild.nodeType === 1) {
                outputArray.push(V(children[i]));
            }
        }
        return outputArray;
    };
    // Returns the V element from parentNode of this.node.
    VPrototype.parent = function() {
        return V(this.node.parentNode) || null;
    }, // Find an index of an element inside its container.
    VPrototype.index = function() {
        var index = 0;
        var node = this.node.previousSibling;
        while(node){
            // nodeType 1 for ELEMENT_NODE
            if (node.nodeType === 1) index++;
            node = node.previousSibling;
        }
        return index;
    };
    VPrototype.findParentByClass = function(className, terminator) {
        var ownerSVGElement = this.node.ownerSVGElement;
        var node = this.node.parentNode;
        while(node && node !== terminator && node !== ownerSVGElement){
            var vel = V(node);
            if (vel.hasClass(className)) {
                return vel;
            }
            node = node.parentNode;
        }
        return null;
    };
    // https://jsperf.com/get-common-parent
    VPrototype.contains = function(el) {
        var a = this.node;
        var b = V.toNode(el);
        var bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && a.compareDocumentPosition(bup) & 16);
    };
    // Convert global point into the coordinate space of this element.
    VPrototype.toLocalPoint = function(x, y) {
        var svg = this.svg().node;
        var p = svg.createSVGPoint();
        p.x = x;
        p.y = y;
        try {
            var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());
            var globalToLocalMatrix = this.getTransformToElement(svg).inverse();
        } catch (e) {
            // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)
            // We have to make do with the original coordianates.
            return p;
        }
        return globalPoint.matrixTransform(globalToLocalMatrix);
    };
    VPrototype.translateCenterToPoint = function(p) {
        var bbox = this.getBBox({
            target: this.svg()
        });
        var center = bbox.center();
        this.translate(p.x - center.x, p.y - center.y);
        return this;
    };
    // Efficiently auto-orient an element. This basically implements the orient=auto attribute
    // of markers. The easiest way of understanding on what this does is to imagine the element is an
    // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while
    // being auto-oriented (properly rotated) towards the `reference` point.
    // `target` is the element relative to which the transformations are applied. Usually a viewport.
    VPrototype.translateAndAutoOrient = function(position, reference, target) {
        position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(position);
        reference = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(reference);
        target || (target = this.svg());
        // Clean-up previously set transformations except the scale. If we didn't clean up the
        // previous transformations then they'd add up with the old ones. Scale is an exception as
        // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the
        // element is scaled by the factor 2, not 8.
        var scale = this.scale();
        this.attr('transform', '');
        var bbox = this.getBBox({
            target: target
        }).scale(scale.sx, scale.sy);
        // 1. Translate to origin.
        var translateToOrigin = V.createSVGTransform();
        translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);
        // 2. Rotate around origin.
        var rotateAroundOrigin = V.createSVGTransform();
        var angle = position.angleBetween(reference, position.clone().offset(1, 0));
        if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);
        // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.
        var translateFromOrigin = V.createSVGTransform();
        var finalPosition = position.clone().move(reference, bbox.width / 2);
        translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y);
        // 4. Get the current transformation matrix of this node
        var ctm = this.getTransformToElement(target);
        // 5. Apply transformations and the scale
        var transform = V.createSVGTransform();
        transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(scale.sx, scale.sy)))));
        this.attr('transform', V.matrixToTransformString(transform.matrix));
        return this;
    };
    VPrototype.animateAlongPath = function(attrs, path) {
        path = V.toNode(path);
        var id = V.ensureId(path);
        var animateMotion = V('animateMotion', attrs);
        var mpath = V('mpath', {
            'xlink:href': '#' + id
        });
        animateMotion.append(mpath);
        this.append(animateMotion);
        try {
            animateMotion.node.beginElement();
        } catch (e) {
            // Fallback for IE 9.
            // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present
            if (document.documentElement.getAttribute('smiling') === 'fake') {
                /* global getTargets:true, Animator:true, animators:true id2anim:true */ // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)
                var animation = animateMotion.node;
                animation.animators = [];
                var animationID = animation.getAttribute('id');
                if (animationID) id2anim[animationID] = animation;
                var targets = getTargets(animation);
                for(var i = 0, len = targets.length; i < len; i++){
                    var target = targets[i];
                    var animator = new Animator(animation, target, i);
                    animators.push(animator);
                    animation.animators[i] = animator;
                    animator.register();
                }
            }
        }
        return this;
    };
    // Split a string into an array of tokens.
    // https://infra.spec.whatwg.org/#ascii-whitespace
    const noHTMLWhitespaceRegex = /[^\x20\t\r\n\f]+/g;
    function getTokenList(str) {
        if (!V.isString(str)) return [];
        return str.trim().match(noHTMLWhitespaceRegex) || [];
    }
    VPrototype.hasClass = function(className) {
        if (!V.isString(className)) return false;
        return this.node.classList.contains(className.trim());
    };
    VPrototype.addClass = function(className) {
        this.node.classList.add(...getTokenList(className));
        return this;
    };
    VPrototype.removeClass = function(className) {
        this.node.classList.remove(...getTokenList(className));
        return this;
    };
    VPrototype.toggleClass = function(className, toAdd) {
        const tokens = getTokenList(className);
        for(let i = 0; i < tokens.length; i++){
            this.node.classList.toggle(tokens[i], toAdd);
        }
        return this;
    };
    // Interpolate path by discrete points. The precision of the sampling
    // is controlled by `interval`. In other words, `sample()` will generate
    // a point on the path starting at the beginning of the path going to the end
    // every `interval` pixels.
    // The sampler can be very useful for e.g. finding intersection between two
    // paths (finding the two closest points from two samples).
    VPrototype.sample = function(interval) {
        interval = interval || 1;
        var node = this.node;
        var length = node.getTotalLength();
        var samples = [];
        var distance = 0;
        var sample;
        while(distance < length){
            sample = node.getPointAtLength(distance);
            samples.push({
                x: sample.x,
                y: sample.y,
                distance: distance
            });
            distance += interval;
        }
        return samples;
    };
    VPrototype.convertToPath = function() {
        var path = V('path');
        path.attr(this.attr());
        var d = this.convertToPathData();
        if (d) {
            path.attr('d', d);
        }
        return path;
    };
    VPrototype.convertToPathData = function() {
        var tagName = this.tagName();
        switch(tagName){
            case 'PATH':
                return this.attr('d');
            case 'LINE':
                return V.convertLineToPathData(this.node);
            case 'POLYGON':
                return V.convertPolygonToPathData(this.node);
            case 'POLYLINE':
                return V.convertPolylineToPathData(this.node);
            case 'ELLIPSE':
                return V.convertEllipseToPathData(this.node);
            case 'CIRCLE':
                return V.convertCircleToPathData(this.node);
            case 'RECT':
                return V.convertRectToPathData(this.node);
        }
        throw new Error(tagName + ' cannot be converted to PATH.');
    };
    V.prototype.toGeometryShape = function() {
        var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;
        switch(this.tagName()){
            case 'RECT':
                x = parseFloat(this.attr('x')) || 0;
                y = parseFloat(this.attr('y')) || 0;
                width = parseFloat(this.attr('width')) || 0;
                height = parseFloat(this.attr('height')) || 0;
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect(x, y, width, height);
            case 'CIRCLE':
                cx = parseFloat(this.attr('cx')) || 0;
                cy = parseFloat(this.attr('cy')) || 0;
                r = parseFloat(this.attr('r')) || 0;
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Ellipse({
                    x: cx,
                    y: cy
                }, r, r);
            case 'ELLIPSE':
                cx = parseFloat(this.attr('cx')) || 0;
                cy = parseFloat(this.attr('cy')) || 0;
                rx = parseFloat(this.attr('rx')) || 0;
                ry = parseFloat(this.attr('ry')) || 0;
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Ellipse({
                    x: cx,
                    y: cy
                }, rx, ry);
            case 'POLYLINE':
                points = V.getPointsFromSvgNode(this);
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Polyline(points);
            case 'POLYGON':
                points = V.getPointsFromSvgNode(this);
                if (points.length > 1) points.push(points[0]);
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Polyline(points);
            case 'PATH':
                d = this.attr('d');
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.isDataSupported(d)) d = V.normalizePathData(d);
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path(d);
            case 'LINE':
                x1 = parseFloat(this.attr('x1')) || 0;
                y1 = parseFloat(this.attr('y1')) || 0;
                x2 = parseFloat(this.attr('x2')) || 0;
                y2 = parseFloat(this.attr('y2')) || 0;
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line({
                    x: x1,
                    y: y1
                }, {
                    x: x2,
                    y: y2
                });
        }
        // Anything else is a rectangle
        return this.getBBox();
    };
    // Find the intersection of a line starting in the center
    // of the SVG `node` ending in the point `ref`.
    // `target` is an SVG element to which `node`s transformations are relative to.
    // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.
    // Returns a point in the `target` coordinate system (the same system as `ref` is in) if
    // an intersection is found. Returns `undefined` otherwise.
    VPrototype.findIntersection = function(ref, target) {
        var svg = this.svg().node;
        target = target || svg;
        var bbox = this.getBBox({
            target: target
        });
        var center = bbox.center();
        if (!bbox.intersectionWithLineFromCenterToPoint(ref)) return undefined;
        var spot;
        var tagName = this.tagName();
        // Little speed up optimization for `<rect>` element. We do not do conversion
        // to path element and sampling but directly calculate the intersection through
        // a transformed geometrical rectangle.
        if (tagName === 'RECT') {
            var gRect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect(parseFloat(this.attr('x') || 0), parseFloat(this.attr('y') || 0), parseFloat(this.attr('width')), parseFloat(this.attr('height')));
            // Get the rect transformation matrix with regards to the SVG document.
            var rectMatrix = this.getTransformToElement(target);
            // Decompose the matrix to find the rotation angle.
            var rectMatrixComponents = V.decomposeMatrix(rectMatrix);
            // Now we want to rotate the rectangle back so that we
            // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.
            var resetRotation = svg.createSVGTransform();
            resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);
            var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));
            spot = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect(rect).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);
        } else if (tagName === 'PATH' || tagName === 'POLYGON' || tagName === 'POLYLINE' || tagName === 'CIRCLE' || tagName === 'ELLIPSE') {
            var pathNode = tagName === 'PATH' ? this : this.convertToPath();
            var samples = pathNode.sample();
            var minDistance = Infinity;
            var closestSamples = [];
            var i, sample, gp, centerDistance, refDistance, distance;
            for(i = 0; i < samples.length; i++){
                sample = samples[i];
                // Convert the sample point in the local coordinate system to the global coordinate system.
                gp = V.createSVGPoint(sample.x, sample.y);
                gp = gp.matrixTransform(this.getTransformToElement(target));
                sample = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(gp);
                centerDistance = sample.distance(center);
                // Penalize a higher distance to the reference point by 10%.
                // This gives better results. This is due to
                // inaccuracies introduced by rounding errors and getPointAtLength() returns.
                refDistance = sample.distance(ref) * 1.1;
                distance = centerDistance + refDistance;
                if (distance < minDistance) {
                    minDistance = distance;
                    closestSamples = [
                        {
                            sample: sample,
                            refDistance: refDistance
                        }
                    ];
                } else if (distance < minDistance + 1) {
                    closestSamples.push({
                        sample: sample,
                        refDistance: refDistance
                    });
                }
            }
            closestSamples.sort(function(a, b) {
                return a.refDistance - b.refDistance;
            });
            if (closestSamples[0]) {
                spot = closestSamples[0].sample;
            }
        }
        return spot;
    };
    /**
     * @private
     * @param {string} name
     * @param {string} value
     * @returns {Vectorizer}
     */ VPrototype.setAttribute = function(name, value) {
        const el = this.node;
        if (value === null) {
            this.removeAttr(name);
            return this;
        }
        const trueName = attributeNames[name];
        const { ns } = V.qualifyAttr(trueName);
        if (ns) {
            // Attribute names can be namespaced. E.g. `image` elements
            // have a `xlink:href` attribute to set the source of the image.
            el.setAttributeNS(ns, trueName, value);
        } else if (trueName === 'id') {
            el.id = value;
        } else {
            el.setAttribute(trueName, value);
        }
        return this;
    };
    // Create an SVG document element.
    // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.
    V.createSvgDocument = function(content) {
        if (content) {
            const XMLString = `<svg xmlns="${ns.svg}" xmlns:xlink="${ns.xlink}" version="${SVGVersion}">${content}</svg>`;
            const { documentElement } = V.parseXML(XMLString, {
                async: false
            });
            return documentElement;
        }
        const svg = document.createElementNS(ns.svg, 'svg');
        svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);
        svg.setAttribute('version', SVGVersion);
        return svg;
    };
    V.createSVGStyle = function(stylesheet) {
        const { node } = V('style', {
            type: 'text/css'
        }, [
            V.createCDATASection(stylesheet)
        ]);
        return node;
    }, V.createCDATASection = function(data = '') {
        const xml = document.implementation.createDocument(null, 'xml', null);
        return xml.createCDATASection(data);
    };
    V.idCounter = 0;
    // A function returning a unique identifier for this client session with every call.
    V.uniqueId = function() {
        return 'v-' + ++V.idCounter;
    };
    V.toNode = function(el) {
        return V.isV(el) ? el.node : el.nodeName && el || el[0];
    };
    V.ensureId = function(node) {
        node = V.toNode(node);
        return node.id || (node.id = V.uniqueId());
    };
    // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).
    // IE would otherwise collapse all spaces into one. This is used in the text() method but it is
    // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests
    // when you want to compare the actual DOM text content without having to add the unicode character in
    // the place of all spaces.
    V.sanitizeText = function(text) {
        return (text || '').replace(/ /g, '\u00A0');
    };
    V.isUndefined = function(value) {
        return typeof value === 'undefined';
    };
    V.isString = function(value) {
        return typeof value === 'string';
    };
    V.isObject = function(value) {
        return value && typeof value === 'object';
    };
    V.isArray = Array.isArray;
    V.parseXML = function(data, opt) {
        opt = opt || {};
        var xml;
        try {
            var parser = new DOMParser();
            if (!V.isUndefined(opt.async)) {
                parser.async = opt.async;
            }
            xml = parser.parseFromString(data, 'text/xml');
        } catch (error) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName('parsererror').length) {
            throw new Error('Invalid XML: ' + data);
        }
        return xml;
    };
    // Create an empty object which does not inherit any properties from `Object.prototype`.
    // This is useful when we want to use an object as a dictionary without having to
    // worry about inherited properties such as `toString`, `valueOf` etc.
    const _attributeNames = Object.create(null);
    // List of attributes for which not to split camel case words.
    // It contains known SVG attribute names and may be extended with user-defined attribute names.
    [
        'baseFrequency',
        'baseProfile',
        'clipPathUnits',
        'contentScriptType',
        'contentStyleType',
        'diffuseConstant',
        'edgeMode',
        'externalResourcesRequired',
        'filterRes',
        'filterUnits',
        'gradientTransform',
        'gradientUnits',
        'kernelMatrix',
        'kernelUnitLength',
        'keyPoints',
        'lengthAdjust',
        'limitingConeAngle',
        'markerHeight',
        'markerUnits',
        'markerWidth',
        'maskContentUnits',
        'maskUnits',
        'numOctaves',
        'pathLength',
        'patternContentUnits',
        'patternTransform',
        'patternUnits',
        'pointsAtX',
        'pointsAtY',
        'pointsAtZ',
        'preserveAlpha',
        'preserveAspectRatio',
        'primitiveUnits',
        'refX',
        'refY',
        'requiredExtensions',
        'requiredFeatures',
        'specularConstant',
        'specularExponent',
        'spreadMethod',
        'startOffset',
        'stdDeviation',
        'stitchTiles',
        'surfaceScale',
        'systemLanguage',
        'tableValues',
        'targetX',
        'targetY',
        'textLength',
        'viewBox',
        'viewTarget',
        'xChannelSelector',
        'yChannelSelector',
        'zoomAndPan' // deprecated
    ].forEach((name)=>_attributeNames[name] = name);
    _attributeNames['xlinkShow'] = 'xlink:show';
    _attributeNames['xlinkRole'] = 'xlink:role';
    _attributeNames['xlinkActuate'] = 'xlink:actuate';
    _attributeNames['xlinkHref'] = 'xlink:href';
    _attributeNames['xlinkType'] = 'xlink:type';
    _attributeNames['xlinkTitle'] = 'xlink:title';
    _attributeNames['xmlBase'] = 'xml:base';
    _attributeNames['xmlLang'] = 'xml:lang';
    _attributeNames['xmlSpace'] = 'xml:space';
    const attributeNames = new Proxy(_attributeNames, {
        get (cache, name) {
            // The cache is a dictionary of attribute names. See `_attributeNames` above.
            // If the attribute name is not in the cache, it means that it is not
            // a camel-case attribute name. In that case, we need to convert
            // the attribute name to dash-separated words.
            if (!V.supportCamelCaseAttributes) return name;
            if (name in cache) {
                return cache[name];
            }
            // Convert camel case to dash-separated words.
            return cache[name] = name.replace(/[A-Z]/g, '-$&').toLowerCase();
        }
    });
    // Dictionary of attribute names
    Object.defineProperty(V, 'attributeNames', {
        enumerable: true,
        value: attributeNames,
        writable: false
    });
    // Should camel case attributes be supported?
    Object.defineProperty(V, 'supportCamelCaseAttributes', {
        enumerable: true,
        value: true,
        writable: true
    });
    /**
     * @param {string} name
     * @returns {{ns: string|null, local: string}} namespace and attribute name
     */ V.qualifyAttr = function(name) {
        if (name.indexOf(':') !== -1) {
            var combinedKey = name.split(':');
            return {
                ns: ns[combinedKey[0]],
                local: combinedKey[1]
            };
        }
        return {
            ns: null,
            local: name
        };
    };
    // Note: This regex allows multiple commas as separator which is incorrect in SVG
    // This regex is used by `split()`, so it doesn't need to use /g
    V.transformSeparatorRegex = /[ ,]+/;
    // Note: All following regexes are more restrictive than SVG specification
    // ReDoS mitigation: Use an anchor at the beginning of the match
    // ReDoS mitigation: Avoid backtracking (uses `[^()]+` instead of `.*?`)
    // ReDoS mitigation: Don't match initial `(` inside repeated part
    // The following regex needs to use /g (= cannot use capturing groups)
    V.transformRegex = /\b\w+\([^()]+\)/g;
    // The following regexes need to use capturing groups (= cannot use /g)
    V.transformFunctionRegex = /\b(\w+)\(([^()]+)\)/;
    V.transformTranslateRegex = /\btranslate\(([^()]+)\)/;
    V.transformRotateRegex = /\brotate\(([^()]+)\)/;
    V.transformScaleRegex = /\bscale\(([^()]+)\)/;
    V.transformStringToMatrix = function(transform) {
        // Initialize result matrix as identity matrix
        let transformationMatrix = V.createSVGMatrix();
        // Note: Multiple transform functions are allowed in `transform` string
        // `match()` returns `null` if none found
        const transformMatches = transform && transform.match(V.transformRegex);
        if (!transformMatches) {
            // Return identity matrix
            return transformationMatrix;
        }
        const numMatches = transformMatches.length;
        for(let i = 0; i < numMatches; i++){
            const transformMatch = transformMatches[i];
            // Use same regex as above, but with capturing groups
            // `match()` returns values of capturing groups as `[1]`, `[2]`
            const transformFunctionMatch = transformMatch.match(V.transformFunctionRegex);
            if (transformFunctionMatch) {
                let sx, sy, tx, ty, angle;
                let ctm = V.createSVGMatrix();
                const transformFunction = transformFunctionMatch[1].toLowerCase();
                const args = transformFunctionMatch[2].split(V.transformSeparatorRegex);
                switch(transformFunction){
                    case 'scale':
                        sx = parseFloat(args[0]);
                        sy = args[1] === undefined ? sx : parseFloat(args[1]);
                        ctm = ctm.scaleNonUniform(sx, sy);
                        break;
                    case 'translate':
                        tx = parseFloat(args[0]);
                        ty = parseFloat(args[1]);
                        ctm = ctm.translate(tx, ty);
                        break;
                    case 'rotate':
                        angle = parseFloat(args[0]);
                        tx = parseFloat(args[1]) || 0;
                        ty = parseFloat(args[2]) || 0;
                        if (tx !== 0 || ty !== 0) {
                            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);
                        } else {
                            ctm = ctm.rotate(angle);
                        }
                        break;
                    case 'skewx':
                        angle = parseFloat(args[0]);
                        ctm = ctm.skewX(angle);
                        break;
                    case 'skewy':
                        angle = parseFloat(args[0]);
                        ctm = ctm.skewY(angle);
                        break;
                    case 'matrix':
                        ctm.a = parseFloat(args[0]);
                        ctm.b = parseFloat(args[1]);
                        ctm.c = parseFloat(args[2]);
                        ctm.d = parseFloat(args[3]);
                        ctm.e = parseFloat(args[4]);
                        ctm.f = parseFloat(args[5]);
                        break;
                    default:
                        continue;
                }
                // Multiply current transformation into result matrix
                transformationMatrix = transformationMatrix.multiply(ctm);
            }
        }
        return transformationMatrix;
    };
    V.matrixToTransformString = function(matrix) {
        matrix || (matrix = true);
        return 'matrix(' + (matrix.a !== undefined ? matrix.a : 1) + ',' + (matrix.b !== undefined ? matrix.b : 0) + ',' + (matrix.c !== undefined ? matrix.c : 0) + ',' + (matrix.d !== undefined ? matrix.d : 1) + ',' + (matrix.e !== undefined ? matrix.e : 0) + ',' + (matrix.f !== undefined ? matrix.f : 0) + ')';
    };
    V.parseTransformString = function(transform) {
        var translate, rotate, scale;
        if (transform) {
            var separator = V.transformSeparatorRegex;
            // Special handling for `transform` with one or more matrix functions
            if (transform.trim().indexOf('matrix') >= 0) {
                // Convert EVERYTHING in `transform` string to a matrix
                // Will combine ALL matrixes * ALL translates * ALL scales * ALL rotates
                // Note: In non-matrix case, we only take first one of each (if any)
                var matrix = V.transformStringToMatrix(transform);
                var decomposedMatrix = V.decomposeMatrix(matrix);
                // Extract `translate`, `scale`, `rotate` from matrix
                translate = [
                    decomposedMatrix.translateX,
                    decomposedMatrix.translateY
                ];
                scale = [
                    decomposedMatrix.scaleX,
                    decomposedMatrix.scaleY
                ];
                rotate = [
                    decomposedMatrix.rotation
                ];
                // Rewrite `transform` string in `translate scale rotate` format
                var transformations = [];
                if (translate[0] !== 0 || translate[1] !== 0) {
                    transformations.push('translate(' + translate + ')');
                }
                if (scale[0] !== 1 || scale[1] !== 1) {
                    transformations.push('scale(' + scale + ')');
                }
                if (rotate[0] !== 0) {
                    transformations.push('rotate(' + rotate + ')');
                }
                transform = transformations.join(' ');
            } else {
                // Extract `translate`, `rotate`, `scale` functions from `transform` string
                // Note: We only detect the first match of each (if any)
                // `match()` returns value of capturing group as `[1]`
                const translateMatch = transform.match(V.transformTranslateRegex);
                if (translateMatch) {
                    translate = translateMatch[1].split(separator);
                }
                const rotateMatch = transform.match(V.transformRotateRegex);
                if (rotateMatch) {
                    rotate = rotateMatch[1].split(separator);
                }
                const scaleMatch = transform.match(V.transformScaleRegex);
                if (scaleMatch) {
                    scale = scaleMatch[1].split(separator);
                }
            }
        }
        var sx = scale && scale[0] ? parseFloat(scale[0]) : 1;
        return {
            value: transform,
            translate: {
                tx: translate && translate[0] ? parseInt(translate[0], 10) : 0,
                ty: translate && translate[1] ? parseInt(translate[1], 10) : 0
            },
            rotate: {
                angle: rotate && rotate[0] ? parseInt(rotate[0], 10) : 0,
                cx: rotate && rotate[1] ? parseInt(rotate[1], 10) : undefined,
                cy: rotate && rotate[2] ? parseInt(rotate[2], 10) : undefined
            },
            scale: {
                sx: sx,
                sy: scale && scale[1] ? parseFloat(scale[1]) : sx
            }
        };
    };
    V.deltaTransformPoint = function(matrix, point) {
        var dx = point.x * matrix.a + point.y * matrix.c + 0;
        var dy = point.x * matrix.b + point.y * matrix.d + 0;
        return {
            x: dx,
            y: dy
        };
    };
    V.decomposeMatrix = function(matrix) {
        // @see https://gist.github.com/2052247
        // calculate delta transform point
        var px = V.deltaTransformPoint(matrix, {
            x: 0,
            y: 1
        });
        var py = V.deltaTransformPoint(matrix, {
            x: 1,
            y: 0
        });
        // calculate skew
        var skewX = 180 / PI * atan2(px.y, px.x) - 90;
        var skewY = 180 / PI * atan2(py.y, py.x);
        return {
            translateX: matrix.e,
            translateY: matrix.f,
            scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),
            scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),
            skewX: skewX,
            skewY: skewY,
            rotation: skewX // rotation is the same as skew x
        };
    };
    // Return the `scale` transformation from the following equation:
    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`
    V.matrixToScale = function(matrix) {
        var a, b, c, d;
        if (matrix) {
            a = V.isUndefined(matrix.a) ? 1 : matrix.a;
            d = V.isUndefined(matrix.d) ? 1 : matrix.d;
            b = matrix.b;
            c = matrix.c;
        } else {
            a = d = 1;
        }
        return {
            sx: b ? sqrt(a * a + b * b) : a,
            sy: c ? sqrt(c * c + d * d) : d
        };
    };
    // Return the `rotate` transformation from the following equation:
    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`
    V.matrixToRotate = function(matrix) {
        var p = {
            x: 0,
            y: 1
        };
        if (matrix) {
            p = V.deltaTransformPoint(matrix, p);
        }
        return {
            angle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.normalizeAngle(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toDeg(atan2(p.y, p.x)) - 90)
        };
    };
    // Return the `translate` transformation from the following equation:
    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`
    V.matrixToTranslate = function(matrix) {
        return {
            tx: matrix && matrix.e || 0,
            ty: matrix && matrix.f || 0
        };
    };
    V.isV = function(object) {
        return object instanceof V;
    };
    // For backwards compatibility:
    V.isVElement = V.isV;
    // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`
    // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement
    V.isSVGGraphicsElement = function(node) {
        if (!node) return false;
        node = V.toNode(node);
        // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below
        return node instanceof SVGElement && typeof node.getScreenCTM === 'function';
    };
    var svgDocument = V('svg').node;
    V.createSVGMatrix = function(matrix) {
        var svgMatrix = svgDocument.createSVGMatrix();
        for(var component in matrix){
            svgMatrix[component] = matrix[component];
        }
        return svgMatrix;
    };
    V.createSVGTransform = function(matrix) {
        if (!V.isUndefined(matrix)) {
            if (!(matrix instanceof SVGMatrix)) {
                matrix = V.createSVGMatrix(matrix);
            }
            return svgDocument.createSVGTransformFromMatrix(matrix);
        }
        return svgDocument.createSVGTransform();
    };
    V.createSVGPoint = function(x, y) {
        var p = svgDocument.createSVGPoint();
        p.x = x;
        p.y = y;
        return p;
    };
    V.transformRect = function(r, matrix) {
        var p = svgDocument.createSVGPoint();
        p.x = r.x;
        p.y = r.y;
        var corner1 = p.matrixTransform(matrix);
        p.x = r.x + r.width;
        p.y = r.y;
        var corner2 = p.matrixTransform(matrix);
        p.x = r.x + r.width;
        p.y = r.y + r.height;
        var corner3 = p.matrixTransform(matrix);
        p.x = r.x;
        p.y = r.y + r.height;
        var corner4 = p.matrixTransform(matrix);
        var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);
        var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);
        var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);
        var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect(minX, minY, maxX - minX, maxY - minY);
    };
    V.transformPoint = function(p, matrix) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));
    };
    V.transformLine = function(l, matrix) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(V.transformPoint(l.start, matrix), V.transformPoint(l.end, matrix));
    };
    V.transformPolyline = function(p, matrix) {
        var inPoints = p instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Polyline ? p.points : p;
        if (!V.isArray(inPoints)) inPoints = [];
        var outPoints = [];
        for(var i = 0, n = inPoints.length; i < n; i++)outPoints[i] = V.transformPoint(inPoints[i], matrix);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Polyline(outPoints);
    };
    // Convert a style represented as string (e.g. `'fill="blue"; stroke="red"'`) to
    // an object (`{ fill: 'blue', stroke: 'red' }`).
    V.styleToObject = function(styleString) {
        var ret = {};
        var styles = styleString.split(';');
        for(var i = 0; i < styles.length; i++){
            var style = styles[i];
            var pair = style.split('=');
            ret[pair[0].trim()] = pair[1].trim();
        }
        return ret;
    };
    // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js
    V.createSlicePathData = function(innerRadius, outerRadius, startAngle, endAngle) {
        var svgArcMax = 2 * PI - 1e-6;
        var r0 = innerRadius;
        var r1 = outerRadius;
        var a0 = startAngle;
        var a1 = endAngle;
        var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);
        var df = da < PI ? '0' : '1';
        var c0 = cos(a0);
        var s0 = sin(a0);
        var c1 = cos(a1);
        var s1 = sin(a1);
        return da >= svgArcMax ? r0 ? 'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1 + 'M0,' + r0 + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + -r0 + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + r0 + 'Z' : 'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1 + 'Z' : r0 ? 'M' + r1 * c0 + ',' + r1 * s0 + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1 + 'L' + r0 * c1 + ',' + r0 * s1 + 'A' + r0 + ',' + r0 + ' 0 ' + df + ',0 ' + r0 * c0 + ',' + r0 * s0 + 'Z' : 'M' + r1 * c0 + ',' + r1 * s0 + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1 + 'L0,0' + 'Z';
    };
    // Merge attributes from object `b` with attributes in object `a`.
    // Note that this modifies the object `a`.
    // Also important to note that attributes are merged but CSS classes are concatenated.
    V.mergeAttrs = function(a, b) {
        for(var attr in b){
            if (attr === 'class') {
                // Concatenate classes.
                a[attr] = a[attr] ? a[attr] + ' ' + b[attr] : b[attr];
            } else if (attr === 'style') {
                // `style` attribute can be an object.
                if (V.isObject(a[attr]) && V.isObject(b[attr])) {
                    // `style` stored in `a` is an object.
                    a[attr] = V.mergeAttrs(a[attr], b[attr]);
                } else if (V.isObject(a[attr])) {
                    // `style` in `a` is an object but it's a string in `b`.
                    // Convert the style represented as a string to an object in `b`.
                    a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));
                } else if (V.isObject(b[attr])) {
                    // `style` in `a` is a string, in `b` it's an object.
                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);
                } else {
                    // Both styles are strings.
                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));
                }
            } else {
                a[attr] = b[attr];
            }
        }
        return a;
    };
    V.annotateString = function(t, annotations, opt) {
        annotations = annotations || [];
        opt = opt || {};
        var offset = opt.offset || 0;
        var compacted = [];
        var batch;
        var ret = [];
        var item;
        var prev;
        for(var i = 0; i < t.length; i++){
            item = ret[i] = t[i];
            for(var j = 0; j < annotations.length; j++){
                var annotation = annotations[j];
                var start = annotation.start + offset;
                var end = annotation.end + offset;
                if (i >= start && i < end) {
                    // Annotation applies.
                    if (V.isObject(item)) {
                        // There is more than one annotation to be applied => Merge attributes.
                        item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);
                    } else {
                        item = ret[i] = {
                            t: t[i],
                            attrs: annotation.attrs
                        };
                    }
                    if (opt.includeAnnotationIndices) {
                        (item.annotations || (item.annotations = [])).push(j);
                    }
                }
            }
            prev = ret[i - 1];
            if (!prev) {
                batch = item;
            } else if (V.isObject(item) && V.isObject(prev)) {
                // Both previous item and the current one are annotations. If the attributes
                // didn't change, merge the text.
                if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {
                    batch.t += item.t;
                } else {
                    compacted.push(batch);
                    batch = item;
                }
            } else if (V.isObject(item)) {
                // Previous item was a string, current item is an annotation.
                compacted.push(batch);
                batch = item;
            } else if (V.isObject(prev)) {
                // Previous item was an annotation, current item is a string.
                compacted.push(batch);
                batch = item;
            } else {
                // Both previous and current item are strings.
                batch = (batch || '') + item;
            }
        }
        if (batch) {
            compacted.push(batch);
        }
        return compacted;
    };
    V.findAnnotationsAtIndex = function(annotations, index) {
        var found = [];
        if (annotations) {
            annotations.forEach(function(annotation) {
                if (annotation.start < index && index <= annotation.end) {
                    found.push(annotation);
                }
            });
        }
        return found;
    };
    V.findAnnotationsBetweenIndexes = function(annotations, start, end) {
        var found = [];
        if (annotations) {
            annotations.forEach(function(annotation) {
                if (start >= annotation.start && start < annotation.end || end > annotation.start && end <= annotation.end || annotation.start >= start && annotation.end < end) {
                    found.push(annotation);
                }
            });
        }
        return found;
    };
    // Shift all the text annotations after character `index` by `offset` positions.
    V.shiftAnnotations = function(annotations, index, offset) {
        if (annotations) {
            annotations.forEach(function(annotation) {
                if (annotation.start < index && annotation.end >= index) {
                    annotation.end += offset;
                } else if (annotation.start >= index) {
                    annotation.start += offset;
                    annotation.end += offset;
                }
            });
        }
        return annotations;
    };
    V.convertLineToPathData = function(line) {
        line = V(line);
        var d = [
            'M',
            line.attr('x1'),
            line.attr('y1'),
            'L',
            line.attr('x2'),
            line.attr('y2')
        ].join(' ');
        return d;
    };
    V.convertPolygonToPathData = function(polygon) {
        var points = V.getPointsFromSvgNode(polygon);
        if (points.length === 0) return null;
        return V.svgPointsToPath(points) + ' Z';
    };
    V.convertPolylineToPathData = function(polyline) {
        var points = V.getPointsFromSvgNode(polyline);
        if (points.length === 0) return null;
        return V.svgPointsToPath(points);
    };
    V.svgPointsToPath = function(points) {
        for(var i = 0, n = points.length; i < n; i++){
            points[i] = points[i].x + ' ' + points[i].y;
        }
        return 'M ' + points.join(' L');
    };
    V.getPointsFromSvgNode = function(node) {
        node = V.toNode(node);
        var points = [];
        var nodePoints = node.points;
        if (nodePoints) {
            for(var i = 0, n = nodePoints.numberOfItems; i < n; i++){
                points.push(nodePoints.getItem(i));
            }
        }
        return points;
    };
    V.KAPPA = 0.551784;
    V.convertCircleToPathData = function(circle) {
        circle = V(circle);
        var cx = parseFloat(circle.attr('cx')) || 0;
        var cy = parseFloat(circle.attr('cy')) || 0;
        var r = parseFloat(circle.attr('r'));
        var cd = r * V.KAPPA; // Control distance.
        var d = [
            'M',
            cx,
            cy - r,
            'C',
            cx + cd,
            cy - r,
            cx + r,
            cy - cd,
            cx + r,
            cy,
            'C',
            cx + r,
            cy + cd,
            cx + cd,
            cy + r,
            cx,
            cy + r,
            'C',
            cx - cd,
            cy + r,
            cx - r,
            cy + cd,
            cx - r,
            cy,
            'C',
            cx - r,
            cy - cd,
            cx - cd,
            cy - r,
            cx,
            cy - r,
            'Z'
        ].join(' ');
        return d;
    };
    V.convertEllipseToPathData = function(ellipse) {
        ellipse = V(ellipse);
        var cx = parseFloat(ellipse.attr('cx')) || 0;
        var cy = parseFloat(ellipse.attr('cy')) || 0;
        var rx = parseFloat(ellipse.attr('rx'));
        var ry = parseFloat(ellipse.attr('ry')) || rx;
        var cdx = rx * V.KAPPA; // Control distance x.
        var cdy = ry * V.KAPPA; // Control distance y.
        var d = [
            'M',
            cx,
            cy - ry,
            'C',
            cx + cdx,
            cy - ry,
            cx + rx,
            cy - cdy,
            cx + rx,
            cy,
            'C',
            cx + rx,
            cy + cdy,
            cx + cdx,
            cy + ry,
            cx,
            cy + ry,
            'C',
            cx - cdx,
            cy + ry,
            cx - rx,
            cy + cdy,
            cx - rx,
            cy,
            'C',
            cx - rx,
            cy - cdy,
            cx - cdx,
            cy - ry,
            cx,
            cy - ry,
            'Z'
        ].join(' ');
        return d;
    };
    V.convertRectToPathData = function(rect) {
        rect = V(rect);
        return V.rectToPath({
            x: parseFloat(rect.attr('x')) || 0,
            y: parseFloat(rect.attr('y')) || 0,
            width: parseFloat(rect.attr('width')) || 0,
            height: parseFloat(rect.attr('height')) || 0,
            rx: parseFloat(rect.attr('rx')) || 0,
            ry: parseFloat(rect.attr('ry')) || 0
        });
    };
    // Convert a rectangle to SVG path commands. `r` is an object of the form:
    // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,
    // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for
    // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle
    // that has only `rx` and `ry` attributes).
    V.rectToPath = function(r) {
        var d;
        var x = r.x;
        var y = r.y;
        var width = r.width;
        var height = r.height;
        var topRx = min(r.rx || r['top-rx'] || 0, width / 2);
        var bottomRx = min(r.rx || r['bottom-rx'] || 0, width / 2);
        var topRy = min(r.ry || r['top-ry'] || 0, height / 2);
        var bottomRy = min(r.ry || r['bottom-ry'] || 0, height / 2);
        if (topRx || bottomRx || topRy || bottomRy) {
            d = [
                'M',
                x,
                y + topRy,
                'v',
                height - topRy - bottomRy,
                'a',
                bottomRx,
                bottomRy,
                0,
                0,
                0,
                bottomRx,
                bottomRy,
                'h',
                width - 2 * bottomRx,
                'a',
                bottomRx,
                bottomRy,
                0,
                0,
                0,
                bottomRx,
                -bottomRy,
                'v',
                -(height - bottomRy - topRy),
                'a',
                topRx,
                topRy,
                0,
                0,
                0,
                -topRx,
                -topRy,
                'h',
                -(width - 2 * topRx),
                'a',
                topRx,
                topRy,
                0,
                0,
                0,
                -topRx,
                topRy,
                'Z'
            ];
        } else {
            d = [
                'M',
                x,
                y,
                'H',
                x + width,
                'V',
                y + height,
                'H',
                x,
                'V',
                y,
                'Z'
            ];
        }
        return d.join(' ');
    };
    // Take a path data string
    // Return a normalized path data string
    // If data cannot be parsed, return 'M 0 0'
    // Highly inspired by Raphael Library (www.raphael.com)
    V.normalizePathData = function() {
        var spaces = '\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029';
        var pathCommand = new RegExp('([a-z])[' + spaces + ',]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[' + spaces + ']*,?[' + spaces + ']*)+)', 'ig');
        var pathValues = new RegExp('(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[' + spaces + ']*,?[' + spaces + ']*', 'ig');
        var math = Math;
        var PI = math.PI;
        var sin = math.sin;
        var cos = math.cos;
        var tan = math.tan;
        var asin = math.asin;
        var sqrt = math.sqrt;
        var abs = math.abs;
        function q2c(x1, y1, ax, ay, x2, y2) {
            var _13 = 1 / 3;
            var _23 = 2 / 3;
            return [
                _13 * x1 + _23 * ax,
                _13 * y1 + _23 * ay,
                _13 * x2 + _23 * ax,
                _13 * y2 + _23 * ay,
                x2,
                y2
            ];
        }
        function rotate(x, y, rad) {
            var X = x * cos(rad) - y * sin(rad);
            var Y = x * sin(rad) + y * cos(rad);
            return {
                x: X,
                y: Y
            };
        }
        function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
            // for more information of where this math came from visit:
            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
            var _120 = PI * 120 / 180;
            var rad = PI / 180 * (+angle || 0);
            var res = [];
            var xy;
            if (!recursive) {
                xy = rotate(x1, y1, -rad);
                x1 = xy.x;
                y1 = xy.y;
                xy = rotate(x2, y2, -rad);
                x2 = xy.x;
                y2 = xy.y;
                var x = (x1 - x2) / 2;
                var y = (y1 - y2) / 2;
                var h = x * x / (rx * rx) + y * y / (ry * ry);
                if (h > 1) {
                    h = sqrt(h);
                    rx = h * rx;
                    ry = h * ry;
                }
                var rx2 = rx * rx;
                var ry2 = ry * ry;
                var k = (large_arc_flag == sweep_flag ? -1 : 1) * sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
                if (!Number.isFinite(k)) {
                    // Arc is a single point
                    return [
                        x1,
                        y1,
                        x2,
                        y2,
                        x2,
                        y2
                    ];
                }
                var cx = k * rx * y / ry + (x1 + x2) / 2;
                var cy = k * -ry * x / rx + (y1 + y2) / 2;
                var f1 = asin(((y1 - cy) / ry).toFixed(9));
                var f2 = asin(((y2 - cy) / ry).toFixed(9));
                f1 = x1 < cx ? PI - f1 : f1;
                f2 = x2 < cx ? PI - f2 : f2;
                if (f1 < 0) f1 = PI * 2 + f1;
                if (f2 < 0) f2 = PI * 2 + f2;
                if (sweep_flag && f1 > f2) f1 = f1 - PI * 2;
                if (!sweep_flag && f2 > f1) f2 = f2 - PI * 2;
            } else {
                f1 = recursive[0];
                f2 = recursive[1];
                cx = recursive[2];
                cy = recursive[3];
            }
            var df = f2 - f1;
            if (abs(df) > _120) {
                var f2old = f2;
                var x2old = x2;
                var y2old = y2;
                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                x2 = cx + rx * cos(f2);
                y2 = cy + ry * sin(f2);
                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
                    f2,
                    f2old,
                    cx,
                    cy
                ]);
            }
            df = f2 - f1;
            var c1 = cos(f1);
            var s1 = sin(f1);
            var c2 = cos(f2);
            var s2 = sin(f2);
            var t = tan(df / 4);
            var hx = 4 / 3 * (rx * t);
            var hy = 4 / 3 * (ry * t);
            var m1 = [
                x1,
                y1
            ];
            var m2 = [
                x1 + hx * s1,
                y1 - hy * c1
            ];
            var m3 = [
                x2 + hx * s2,
                y2 - hy * c2
            ];
            var m4 = [
                x2,
                y2
            ];
            m2[0] = 2 * m1[0] - m2[0];
            m2[1] = 2 * m1[1] - m2[1];
            if (recursive) {
                return [
                    m2,
                    m3,
                    m4
                ].concat(res);
            } else {
                res = [
                    m2,
                    m3,
                    m4
                ].concat(res).join().split(',');
                var newres = [];
                var ii = res.length;
                for(var i = 0; i < ii; i++){
                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                }
                return newres;
            }
        }
        function parsePathString(pathString) {
            if (!pathString) return null;
            var paramCounts = {
                a: 7,
                c: 6,
                h: 1,
                l: 2,
                m: 2,
                q: 4,
                s: 4,
                t: 2,
                v: 1,
                z: 0
            };
            var data = [];
            String(pathString).replace(pathCommand, function(a, b, c) {
                var params = [];
                var name = b.toLowerCase();
                c.replace(pathValues, function(a, b) {
                    if (b) params.push(+b);
                });
                if (name === 'm' && params.length > 2) {
                    data.push([
                        b
                    ].concat(params.splice(0, 2)));
                    name = 'l';
                    b = b === 'm' ? 'l' : 'L';
                }
                while(params.length >= paramCounts[name]){
                    data.push([
                        b
                    ].concat(params.splice(0, paramCounts[name])));
                    if (!paramCounts[name]) break;
                }
            });
            return data;
        }
        function pathToAbsolute(pathArray) {
            if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) {
                pathArray = parsePathString(pathArray);
            }
            // if invalid string, return 'M 0 0'
            if (!pathArray || !pathArray.length) return [
                [
                    'M',
                    0,
                    0
                ]
            ];
            var res = [];
            var x = 0;
            var y = 0;
            var mx = 0;
            var my = 0;
            var start = 0;
            var pa0;
            var ii = pathArray.length;
            for(var i = start; i < ii; i++){
                var r = [];
                res.push(r);
                var pa = pathArray[i];
                pa0 = pa[0];
                if (pa0 != pa0.toUpperCase()) {
                    r[0] = pa0.toUpperCase();
                    var jj;
                    var j;
                    switch(r[0]){
                        case 'A':
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +pa[6] + x;
                            r[7] = +pa[7] + y;
                            break;
                        case 'V':
                            r[1] = +pa[1] + y;
                            break;
                        case 'H':
                            r[1] = +pa[1] + x;
                            break;
                        case 'M':
                            mx = +pa[1] + x;
                            my = +pa[2] + y;
                            jj = pa.length;
                            for(j = 1; j < jj; j++){
                                r[j] = +pa[j] + (j % 2 ? x : y);
                            }
                            break;
                        default:
                            jj = pa.length;
                            for(j = 1; j < jj; j++){
                                r[j] = +pa[j] + (j % 2 ? x : y);
                            }
                            break;
                    }
                } else {
                    var kk = pa.length;
                    for(var k = 0; k < kk; k++){
                        r[k] = pa[k];
                    }
                }
                switch(r[0]){
                    case 'Z':
                        x = +mx;
                        y = +my;
                        break;
                    case 'H':
                        x = r[1];
                        break;
                    case 'V':
                        y = r[1];
                        break;
                    case 'M':
                        mx = r[r.length - 2];
                        my = r[r.length - 1];
                        x = r[r.length - 2];
                        y = r[r.length - 1];
                        break;
                    default:
                        x = r[r.length - 2];
                        y = r[r.length - 1];
                        break;
                }
            }
            return res;
        }
        function normalize(path) {
            var p = pathToAbsolute(path);
            var attrs = {
                x: 0,
                y: 0,
                bx: 0,
                by: 0,
                X: 0,
                Y: 0,
                qx: null,
                qy: null
            };
            function processPath(path, d, pcom) {
                var nx, ny;
                if (!path) return [
                    'C',
                    d.x,
                    d.y,
                    d.x,
                    d.y,
                    d.x,
                    d.y
                ];
                if (!(path[0] in {
                    T: 1,
                    Q: 1
                })) {
                    d.qx = null;
                    d.qy = null;
                }
                switch(path[0]){
                    case 'M':
                        d.X = path[1];
                        d.Y = path[2];
                        break;
                    case 'A':
                        if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {
                            // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters
                            // "If either rx or ry is 0, then this arc is treated as a
                            // straight line segment (a "lineto") joining the endpoints."
                            path = [
                                'L',
                                path[6],
                                path[7]
                            ];
                        } else {
                            path = [
                                'C'
                            ].concat(a2c.apply(0, [
                                d.x,
                                d.y
                            ].concat(path.slice(1))));
                        }
                        break;
                    case 'S':
                        if (pcom === 'C' || pcom === 'S') {
                            nx = d.x * 2 - d.bx; // And reflect the previous
                            ny = d.y * 2 - d.by; // command's control point relative to the current point.
                        } else {
                            nx = d.x;
                            ny = d.y;
                        }
                        path = [
                            'C',
                            nx,
                            ny
                        ].concat(path.slice(1));
                        break;
                    case 'T':
                        if (pcom === 'Q' || pcom === 'T') {
                            d.qx = d.x * 2 - d.qx; // And make a reflection similar
                            d.qy = d.y * 2 - d.qy; // to case 'S'.
                        } else {
                            d.qx = d.x;
                            d.qy = d.y;
                        }
                        path = [
                            'C'
                        ].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                        break;
                    case 'Q':
                        d.qx = path[1];
                        d.qy = path[2];
                        path = [
                            'C'
                        ].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                        break;
                    case 'H':
                        path = [
                            'L'
                        ].concat(path[1], d.y);
                        break;
                    case 'V':
                        path = [
                            'L'
                        ].concat(d.x, path[1]);
                        break;
                    case 'L':
                        break;
                    case 'Z':
                        break;
                }
                return path;
            }
            function fixArc(pp, i) {
                if (pp[i].length > 7) {
                    pp[i].shift();
                    var pi = pp[i];
                    while(pi.length){
                        pcoms[i] = 'A'; // if created multiple 'C's, their original seg is saved
                        pp.splice(i++, 0, [
                            'C'
                        ].concat(pi.splice(0, 6)));
                    }
                    pp.splice(i, 1);
                    ii = p.length;
                }
            }
            var pcoms = []; // path commands of original path p
            var pfirst = ''; // temporary holder for original path command
            var pcom = ''; // holder for previous path command of original path
            var ii = p.length;
            for(var i = 0; i < ii; i++){
                if (p[i]) pfirst = p[i][0]; // save current path command
                if (pfirst !== 'C') {
                    pcoms[i] = pfirst; // Save current path command
                    if (i > 0) pcom = pcoms[i - 1]; // Get previous path command pcom
                }
                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath
                if (pcoms[i] !== 'A' && pfirst === 'C') pcoms[i] = 'C'; // 'A' is the only command
                // which may produce multiple 'C's
                // so we have to make sure that 'C' is also 'C' in original path
                fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms
                var seg = p[i];
                var seglen = seg.length;
                attrs.x = seg[seglen - 2];
                attrs.y = seg[seglen - 1];
                attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
                attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
            }
            // make sure normalized path data string starts with an M segment
            if (!p[0][0] || p[0][0] !== 'M') {
                p.unshift([
                    'M',
                    0,
                    0
                ]);
            }
            return p;
        }
        return function(pathData) {
            return normalize(pathData).join(',').split(',').join(' ');
        };
    }();
    V.namespace = ns;
    V.g = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__;
    return V;
}();
const __TURBOPACK__default__export__ = V;
}}),
"[project]/node_modules/@joint/core/src/layout/ports/port.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "absolute": (()=>absolute),
    "bottom": (()=>bottom),
    "ellipse": (()=>ellipse),
    "ellipseSpread": (()=>ellipseSpread),
    "fn": (()=>fn),
    "left": (()=>left),
    "line": (()=>line),
    "right": (()=>right),
    "top": (()=>top)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/index.mjs [app-client] (ecmascript)");
;
;
function portTransformAttrs(point, angle, opt) {
    var trans = point.toJSON();
    trans.angle = angle || 0;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.defaults({}, opt, trans);
}
function lineLayout(ports, p1, p2, elBBox) {
    return ports.map(function(port, index, ports) {
        var p = this.pointAt((index + 0.5) / ports.length);
        // `dx`,`dy` per port offset option
        if (port.dx || port.dy) {
            p.offset(port.dx || 0, port.dy || 0);
        }
        return portTransformAttrs(p.round(), 0, argTransform(elBBox, port));
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.line(p1, p2));
}
function ellipseLayout(ports, elBBox, startAngle, stepFn) {
    var center = elBBox.center();
    var ratio = elBBox.width / elBBox.height;
    var p1 = elBBox.topMiddle();
    var ellipse = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Ellipse.fromRect(elBBox);
    return ports.map(function(port, index, ports) {
        var angle = startAngle + stepFn(index, ports.length);
        var p2 = p1.clone().rotate(center, -angle).scale(ratio, 1, center);
        var theta = port.compensateRotation ? -ellipse.tangentTheta(p2) : 0;
        // `dx`,`dy` per port offset option
        if (port.dx || port.dy) {
            p2.offset(port.dx || 0, port.dy || 0);
        }
        // `dr` delta radius option
        if (port.dr) {
            p2.move(center, port.dr);
        }
        return portTransformAttrs(p2.round(), theta, argTransform(elBBox, port));
    });
}
function argTransform(bbox, args) {
    let { x, y, angle } = args;
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isPercentage(x)) {
        x = parseFloat(x) / 100 * bbox.width;
    } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isCalcExpression(x)) {
        x = Number(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.evalCalcExpression(x, bbox));
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isPercentage(y)) {
        y = parseFloat(y) / 100 * bbox.height;
    } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isCalcExpression(y)) {
        y = Number(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.evalCalcExpression(y, bbox));
    }
    return {
        x,
        y,
        angle
    };
}
// Creates a point stored in arguments
function argPoint(bbox, args) {
    const { x, y } = argTransform(bbox, args);
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(x || 0, y || 0);
}
const absolute = function(ports, elBBox) {
    return ports.map((port)=>{
        const transformation = argPoint(elBBox, port).round().toJSON();
        transformation.angle = port.angle || 0;
        return transformation;
    });
};
const fn = function(ports, elBBox, opt) {
    return opt.fn(ports, elBBox, opt);
};
const line = function(ports, elBBox, opt) {
    var start = argPoint(elBBox, opt.start || elBBox.origin());
    var end = argPoint(elBBox, opt.end || elBBox.corner());
    return lineLayout(ports, start, end, elBBox);
};
const left = function(ports, elBBox, opt) {
    return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft(), elBBox);
};
const right = function(ports, elBBox, opt) {
    return lineLayout(ports, elBBox.topRight(), elBBox.corner(), elBBox);
};
const top = function(ports, elBBox, opt) {
    return lineLayout(ports, elBBox.origin(), elBBox.topRight(), elBBox);
};
const bottom = function(ports, elBBox, opt) {
    return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner(), elBBox);
};
const ellipseSpread = function(ports, elBBox, opt) {
    var startAngle = opt.startAngle || 0;
    var stepAngle = opt.step || 360 / ports.length;
    return ellipseLayout(ports, elBBox, startAngle, function(index) {
        return index * stepAngle;
    });
};
const ellipse = function(ports, elBBox, opt) {
    var startAngle = opt.startAngle || 0;
    var stepAngle = opt.step || 20;
    return ellipseLayout(ports, elBBox, startAngle, function(index, count) {
        return (index + 0.5 - count / 2) * stepAngle;
    });
};
}}),
"[project]/node_modules/@joint/core/src/layout/ports/portLabel.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "bottom": (()=>bottom),
    "inside": (()=>inside),
    "insideOriented": (()=>insideOriented),
    "left": (()=>left),
    "manual": (()=>manual),
    "outside": (()=>outside),
    "outsideOriented": (()=>outsideOriented),
    "radial": (()=>radial),
    "radialOriented": (()=>radialOriented),
    "right": (()=>right),
    "top": (()=>top)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/index.mjs [app-client] (ecmascript)");
;
;
function labelAttributes(opt1, opt2) {
    // use value from `opt2` if it is missing in `opt1`
    // use value from this object if it is missing in `opt2` as well
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.defaultsDeep({}, opt1, opt2, {
        x: 0,
        y: 0,
        angle: 0,
        attrs: {}
    });
}
function getBBoxAngles(elBBox) {
    var center = elBBox.center();
    var tl = center.theta(elBBox.origin());
    var bl = center.theta(elBBox.bottomLeft());
    var br = center.theta(elBBox.corner());
    var tr = center.theta(elBBox.topRight());
    return [
        tl,
        tr,
        br,
        bl
    ];
}
function outsideLayout(portPosition, elBBox, autoOrient, opt) {
    opt = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.defaults({}, opt, {
        offset: 15
    });
    var angle = elBBox.center().theta(portPosition);
    var tx, ty, y, textAnchor;
    var offset = opt.offset;
    var orientAngle = 0;
    const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);
    if (angle < bottomLeftAngle || angle > bottomRightAngle) {
        y = '.3em';
        tx = offset;
        ty = 0;
        textAnchor = 'start';
    } else if (angle < topLeftAngle) {
        tx = 0;
        ty = -offset;
        if (autoOrient) {
            orientAngle = -90;
            textAnchor = 'start';
            y = '.3em';
        } else {
            textAnchor = 'middle';
            y = '0';
        }
    } else if (angle < topRightAngle) {
        y = '.3em';
        tx = -offset;
        ty = 0;
        textAnchor = 'end';
    } else {
        tx = 0;
        ty = offset;
        if (autoOrient) {
            orientAngle = 90;
            textAnchor = 'start';
            y = '.3em';
        } else {
            textAnchor = 'middle';
            y = '.6em';
        }
    }
    var round = Math.round;
    return labelAttributes(opt, {
        x: round(tx),
        y: round(ty),
        angle: orientAngle,
        attrs: {
            labelText: {
                y,
                textAnchor
            }
        }
    });
}
function insideLayout(portPosition, elBBox, autoOrient, opt) {
    opt = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.defaults({}, opt, {
        offset: 15
    });
    var angle = elBBox.center().theta(portPosition);
    var tx, ty, y, textAnchor;
    var offset = opt.offset;
    var orientAngle = 0;
    const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);
    if (angle < bottomLeftAngle || angle > bottomRightAngle) {
        y = '.3em';
        tx = -offset;
        ty = 0;
        textAnchor = 'end';
    } else if (angle < topLeftAngle) {
        tx = 0;
        ty = offset;
        if (autoOrient) {
            orientAngle = 90;
            textAnchor = 'start';
            y = '.3em';
        } else {
            textAnchor = 'middle';
            y = '.6em';
        }
    } else if (angle < topRightAngle) {
        y = '.3em';
        tx = offset;
        ty = 0;
        textAnchor = 'start';
    } else {
        tx = 0;
        ty = -offset;
        if (autoOrient) {
            orientAngle = -90;
            textAnchor = 'start';
            y = '.3em';
        } else {
            textAnchor = 'middle';
            y = '0';
        }
    }
    var round = Math.round;
    return labelAttributes(opt, {
        x: round(tx),
        y: round(ty),
        angle: orientAngle,
        attrs: {
            labelText: {
                y,
                textAnchor
            }
        }
    });
}
function radialLayout(portCenterOffset, autoOrient, opt) {
    opt = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.defaults({}, opt, {
        offset: 20
    });
    var origin = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.point(0, 0);
    var angle = -portCenterOffset.theta(origin);
    var orientAngle = angle;
    var offset = portCenterOffset.clone().move(origin, opt.offset).difference(portCenterOffset).round();
    var y = '.3em';
    var textAnchor;
    if ((angle + 90) % 180 === 0) {
        textAnchor = autoOrient ? 'end' : 'middle';
        if (!autoOrient && angle === -270) {
            y = '0em';
        }
    } else if (angle > -270 && angle < -90) {
        textAnchor = 'start';
        orientAngle = angle - 180;
    } else {
        textAnchor = 'end';
    }
    var round = Math.round;
    return labelAttributes(opt, {
        x: round(offset.x),
        y: round(offset.y),
        angle: autoOrient ? orientAngle : 0,
        attrs: {
            labelText: {
                y,
                textAnchor
            }
        }
    });
}
const manual = function(_portPosition, _elBBox, opt) {
    return labelAttributes(opt);
};
const left = function(portPosition, elBBox, opt) {
    return labelAttributes(opt, {
        x: -15,
        attrs: {
            labelText: {
                y: '.3em',
                textAnchor: 'end'
            }
        }
    });
};
const right = function(portPosition, elBBox, opt) {
    return labelAttributes(opt, {
        x: 15,
        attrs: {
            labelText: {
                y: '.3em',
                textAnchor: 'start'
            }
        }
    });
};
const top = function(portPosition, elBBox, opt) {
    return labelAttributes(opt, {
        y: -15,
        attrs: {
            labelText: {
                y: '0',
                textAnchor: 'middle'
            }
        }
    });
};
const bottom = function(portPosition, elBBox, opt) {
    return labelAttributes(opt, {
        y: 15,
        attrs: {
            labelText: {
                y: '.6em',
                textAnchor: 'middle'
            }
        }
    });
};
const outsideOriented = function(portPosition, elBBox, opt) {
    return outsideLayout(portPosition, elBBox, true, opt);
};
const outside = function(portPosition, elBBox, opt) {
    return outsideLayout(portPosition, elBBox, false, opt);
};
const insideOriented = function(portPosition, elBBox, opt) {
    return insideLayout(portPosition, elBBox, true, opt);
};
const inside = function(portPosition, elBBox, opt) {
    return insideLayout(portPosition, elBBox, false, opt);
};
const radial = function(portPosition, elBBox, opt) {
    return radialLayout(portPosition.difference(elBBox.center()), false, opt);
};
const radialOriented = function(portPosition, elBBox, opt) {
    return radialLayout(portPosition.difference(elBBox.center()), true, opt);
};
}}),
"[project]/node_modules/@joint/core/src/env/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "env": (()=>env)
});
const env = {
    _results: {},
    _tests: {
        svgforeignobject: function() {
            return !!document.createElementNS && /SVGForeignObject/.test(({}).toString.call(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')));
        },
        // works for iOS browsers too
        isSafari: function() {
            return /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);
        }
    },
    addTest: function(name, fn) {
        return this._tests[name] = fn;
    },
    test: function(name) {
        var fn = this._tests[name];
        if (!fn) {
            throw new Error('Test not defined ("' + name + '"). Use `joint.env.addTest(name, fn) to add a new test.`');
        }
        var result = this._results[name];
        if (typeof result !== 'undefined') {
            return result;
        }
        try {
            result = fn();
        } catch (error) {
            result = false;
        }
        // Cache the test result.
        this._results[name] = result;
        return result;
    }
};
}}),
"[project]/node_modules/@joint/core/src/connectors/index.mjs [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
;
;
;
;
;
}}),
"[project]/node_modules/@joint/core/src/connectors/index.mjs [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/connectors/index.mjs [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@joint/core/src/connectors/straight.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "straight": (()=>straight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/index.mjs [app-client] (ecmascript)");
;
const CornerTypes = {
    POINT: 'point',
    CUBIC: 'cubic',
    LINE: 'line',
    GAP: 'gap'
};
const DEFINED_CORNER_TYPES = Object.values(CornerTypes);
const CORNER_RADIUS = 10;
const PRECISION = 1;
const straight = function(sourcePoint, targetPoint, routePoints = [], opt = {}) {
    const { cornerType = CornerTypes.POINT, cornerRadius = CORNER_RADIUS, cornerPreserveAspectRatio = false, precision = PRECISION, raw = false } = opt;
    if (DEFINED_CORNER_TYPES.indexOf(cornerType) === -1) {
        // unknown `cornerType` provided => error
        throw new Error('Invalid `cornerType` provided to `straight` connector.');
    }
    let path;
    if (cornerType === CornerTypes.POINT || !cornerRadius) {
        // default option => normal connector
        // simply connect all points with straight lines
        const points = [
            sourcePoint
        ].concat(routePoints).concat([
            targetPoint
        ]);
        const polyline = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Polyline(points);
        path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path(polyline);
    } else {
        // `cornerType` is not unknown and not 'point' (default) => must be one of other valid types
        path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path();
        // add initial gap segment = to source point
        path.appendSegment(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('M', sourcePoint));
        let nextDistance;
        const routePointsLength = routePoints.length;
        for(let i = 0; i < routePointsLength; i++){
            const curr = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(routePoints[i]);
            const prev = routePoints[i - 1] || sourcePoint;
            const next = routePoints[i + 1] || targetPoint;
            const prevDistance = nextDistance || curr.distance(prev) / 2; // try to re-use previously-computed `nextDistance`
            nextDistance = curr.distance(next) / 2;
            let startMove, endMove;
            if (!cornerPreserveAspectRatio) {
                // `startMove` and `endMove` may be different
                // (this happens when next or previous path point is closer than `2 * cornerRadius`)
                startMove = -Math.min(cornerRadius, prevDistance);
                endMove = -Math.min(cornerRadius, nextDistance);
            } else {
                // force `startMove` and `endMove` to be the same
                startMove = endMove = -Math.min(cornerRadius, prevDistance, nextDistance);
            }
            // to find `cornerStart` and `cornerEnd`, the logic is as follows (using `cornerStart` as example):
            // - find a point lying on the line `prev - startMove` such that...
            // - ...the point lies `abs(startMove)` distance away from `curr`...
            // - ...and its coordinates are rounded to whole numbers
            const cornerStart = curr.clone().move(prev, startMove).round(precision);
            const cornerEnd = curr.clone().move(next, endMove).round(precision);
            // add in-between straight segment = from previous route point to corner start point
            // (may have zero length)
            path.appendSegment(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('L', cornerStart));
            // add corner segment = from corner start point to corner end point
            switch(cornerType){
                case CornerTypes.CUBIC:
                    {
                        // corner is rounded
                        const _13 = 1 / 3;
                        const _23 = 2 / 3;
                        const control1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(_13 * cornerStart.x + _23 * curr.x, _23 * curr.y + _13 * cornerStart.y);
                        const control2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(_13 * cornerEnd.x + _23 * curr.x, _23 * curr.y + _13 * cornerEnd.y);
                        path.appendSegment(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('C', control1, control2, cornerEnd));
                        break;
                    }
                case CornerTypes.LINE:
                    {
                        // corner has bevel
                        path.appendSegment(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('L', cornerEnd));
                        break;
                    }
                case CornerTypes.GAP:
                    {
                        // corner has empty space
                        path.appendSegment(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('M', cornerEnd));
                        break;
                    }
            }
        }
        // add final straight segment = from last corner end point to target point
        // (= or from start point to end point, if there are no route points)
        // (may have zero length)
        path.appendSegment(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('L', targetPoint));
    }
    return raw ? path : path.serialize();
};
}}),
"[project]/node_modules/@joint/core/src/connectors/jumpover.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "jumpover": (()=>jumpover)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/index.mjs [app-client] (ecmascript)");
;
;
// default size of jump if not specified in options
var JUMP_SIZE = 5;
// available jump types
// first one taken as default
var JUMP_TYPES = [
    'arc',
    'gap',
    'cubic'
];
// default radius
var RADIUS = 0;
// takes care of math. error for case when jump is too close to end of line
var CLOSE_PROXIMITY_PADDING = 1;
// list of connector types not to jump over.
var IGNORED_CONNECTORS = [
    'smooth'
];
// internal constants for round segment
var _13 = 1 / 3;
var _23 = 2 / 3;
function sortPointsAscending(p1, p2) {
    let { x: x1, y: y1 } = p1;
    let { x: x2, y: y2 } = p2;
    if (x1 > x2) {
        let swap = x1;
        x1 = x2;
        x2 = swap;
        swap = y1;
        y1 = y2;
        y2 = swap;
    }
    if (y1 > y2) {
        let swap = x1;
        x1 = x2;
        x2 = swap;
        swap = y1;
        y1 = y2;
        y2 = swap;
    }
    return [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(x1, y1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(x2, y2)
    ];
}
function overlapExists(line1, line2) {
    const [{ x: x1, y: y1 }, { x: x2, y: y2 }] = sortPointsAscending(line1.start, line1.end);
    const [{ x: x3, y: y3 }, { x: x4, y: y4 }] = sortPointsAscending(line2.start, line2.end);
    const xMatch = x1 <= x4 && x3 <= x2;
    const yMatch = y1 <= y4 && y3 <= y2;
    return xMatch && yMatch;
}
/**
 * Transform start/end and route into series of lines
 * @param {g.point} sourcePoint start point
 * @param {g.point} targetPoint end point
 * @param {g.point[]} route optional list of route
 * @return {g.line[]} [description]
 */ function createLines(sourcePoint, targetPoint, route) {
    // make a flattened array of all points
    var points = [].concat(sourcePoint, route, targetPoint);
    return points.reduce(function(resultLines, point, idx) {
        // if there is a next point, make a line with it
        var nextPoint = points[idx + 1];
        if (nextPoint != null) {
            resultLines[idx] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.line(point, nextPoint);
        }
        return resultLines;
    }, []);
}
function setupUpdating(jumpOverLinkView) {
    var paper = jumpOverLinkView.paper;
    var updateList = paper._jumpOverUpdateList;
    // first time setup for this paper
    if (updateList == null) {
        updateList = paper._jumpOverUpdateList = [];
        var graph = paper.model;
        graph.on('batch:stop', function() {
            if (this.hasActiveBatch()) return;
            updateJumpOver(paper);
        });
        graph.on('reset', function() {
            updateList = paper._jumpOverUpdateList = [];
        });
    }
    // add this link to a list so it can be updated when some other link is updated
    if (updateList.indexOf(jumpOverLinkView) < 0) {
        updateList.push(jumpOverLinkView);
        // watch for change of connector type or removal of link itself
        // to remove the link from a list of jump over connectors
        jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function() {
            updateList.splice(updateList.indexOf(jumpOverLinkView), 1);
        });
    }
}
/**
 * Handler for a batch:stop event to force
 * update of all registered links with jump over connector
 * @param {object} batchEvent optional object with info about batch
 */ function updateJumpOver(paper) {
    var updateList = paper._jumpOverUpdateList;
    for(var i = 0; i < updateList.length; i++){
        const linkView = updateList[i];
        const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);
        linkView.requestUpdate(updateFlag);
    }
}
/**
 * Utility function to collect all intersection points of a single
 * line against group of other lines.
 * @param {g.line} line where to find points
 * @param {g.line[]} crossCheckLines lines to cross
 * @return {g.point[]} list of intersection points
 */ function findLineIntersections(line, crossCheckLines) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(crossCheckLines).reduce(function(res, crossCheckLine) {
        var intersection = line.intersection(crossCheckLine);
        if (intersection) {
            res.push(intersection);
        }
        return res;
    }, []);
}
/**
 * Sorting function for list of points by their distance.
 * @param {g.point} p1 first point
 * @param {g.point} p2 second point
 * @return {number} squared distance between points
 */ function sortPoints(p1, p2) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.line(p1, p2).squaredLength();
}
/**
 * Split input line into multiple based on intersection points.
 * @param {g.line} line input line to split
 * @param {g.point[]} intersections points where to split the line
 * @param {number} jumpSize the size of jump arc (length empty spot on a line)
 * @return {g.line[]} list of lines being split
 */ function createJumps(line, intersections, jumpSize) {
    return intersections.reduce(function(resultLines, point, idx) {
        // skipping points that were merged with the previous line
        // to make bigger arc over multiple lines that are close to each other
        if (point.skip === true) {
            return resultLines;
        }
        // always grab the last line from buffer and modify it
        var lastLine = resultLines.pop() || line;
        // calculate start and end of jump by moving by a given size of jump
        var jumpStart = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.point(point).move(lastLine.start, -jumpSize);
        var jumpEnd = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.point(point).move(lastLine.start, +jumpSize);
        // now try to look at the next intersection point
        var nextPoint = intersections[idx + 1];
        if (nextPoint != null) {
            var distance = jumpEnd.distance(nextPoint);
            if (distance <= jumpSize) {
                // next point is close enough, move the jump end by this
                // difference and mark the next point to be skipped
                jumpEnd = nextPoint.move(lastLine.start, distance);
                nextPoint.skip = true;
            }
        } else {
            // this block is inside of `else` as an optimization so the distance is
            // not calculated when we know there are no other intersection points
            var endDistance = jumpStart.distance(lastLine.end);
            // if the end is too close to possible jump, draw remaining line instead of a jump
            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
                resultLines.push(lastLine);
                return resultLines;
            }
        }
        var startDistance = jumpEnd.distance(lastLine.start);
        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
            // if the start of line is too close to jump, draw that line instead of a jump
            resultLines.push(lastLine);
            return resultLines;
        }
        // finally create a jump line
        var jumpLine = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.line(jumpStart, jumpEnd);
        // it's just simple line but with a `isJump` property
        jumpLine.isJump = true;
        resultLines.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.line(lastLine.start, jumpStart), jumpLine, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.line(jumpEnd, lastLine.end));
        return resultLines;
    }, []);
}
/**
 * Assemble `D` attribute of a SVG path by iterating given lines.
 * @param {g.line[]} lines source lines to use
 * @param {number} jumpSize the size of jump arc (length empty spot on a line)
 * @param {number} radius the radius
 * @return {string}
 */ function buildPath(lines, jumpSize, jumpType, radius) {
    var path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path();
    var segment;
    // first move to the start of a first line
    segment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('M', lines[0].start);
    path.appendSegment(segment);
    // make a paths from lines
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(lines).forEach(function(line, index) {
        if (line.isJump) {
            var angle, diff;
            var control1, control2;
            if (jumpType === 'arc') {
                angle = -90;
                // determine rotation of arc based on difference between points
                diff = line.start.difference(line.end);
                // make sure the arc always points up (or right)
                var xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);
                if (xAxisRotate) angle += 180;
                var midpoint = line.midpoint();
                var centerLine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(midpoint, line.end).rotate(midpoint, angle);
                var halfLine;
                // first half
                halfLine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(line.start, midpoint);
                control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);
                control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);
                segment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('C', control1, control2, centerLine.end);
                path.appendSegment(segment);
                // second half
                halfLine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(midpoint, line.end);
                control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);
                control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);
                segment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('C', control1, control2, line.end);
                path.appendSegment(segment);
            } else if (jumpType === 'gap') {
                segment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('M', line.end);
                path.appendSegment(segment);
            } else if (jumpType === 'cubic') {
                angle = line.start.theta(line.end);
                var xOffset = jumpSize * 0.6;
                var yOffset = jumpSize * 1.35;
                // determine rotation of arc based on difference between points
                diff = line.start.difference(line.end);
                // make sure the arc always points up (or right)
                xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);
                if (xAxisRotate) yOffset *= -1;
                control1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);
                control2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);
                segment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('C', control1, control2, line.end);
                path.appendSegment(segment);
            }
        } else {
            var nextLine = lines[index + 1];
            if (radius == 0 || !nextLine || nextLine.isJump) {
                segment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('L', line.end);
                path.appendSegment(segment);
            } else {
                buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);
            }
        }
    });
    return path;
}
function buildRoundedSegment(offset, path, curr, prev, next) {
    var prevDistance = curr.distance(prev) / 2;
    var nextDistance = curr.distance(next) / 2;
    var startMove = -Math.min(offset, prevDistance);
    var endMove = -Math.min(offset, nextDistance);
    var roundedStart = curr.clone().move(prev, startMove).round();
    var roundedEnd = curr.clone().move(next, endMove).round();
    var control1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(_13 * roundedStart.x + _23 * curr.x, _23 * curr.y + _13 * roundedStart.y);
    var control2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(_13 * roundedEnd.x + _23 * curr.x, _23 * curr.y + _13 * roundedEnd.y);
    var segment;
    segment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('L', roundedStart);
    path.appendSegment(segment);
    segment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('C', control1, control2, roundedEnd);
    path.appendSegment(segment);
}
const jumpover = function(sourcePoint, targetPoint, route, opt) {
    setupUpdating(this);
    var raw = opt.raw;
    var jumpSize = opt.size || JUMP_SIZE;
    var jumpType = opt.jump && ('' + opt.jump).toLowerCase();
    var radius = opt.radius || RADIUS;
    var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;
    // grab the first jump type as a default if specified one is invalid
    if (JUMP_TYPES.indexOf(jumpType) === -1) {
        jumpType = JUMP_TYPES[0];
    }
    var paper = this.paper;
    var graph = paper.model;
    var allLinks = graph.getLinks();
    // there is just one link, draw it directly
    if (allLinks.length === 1) {
        return buildPath(createLines(sourcePoint, targetPoint, route), jumpSize, jumpType, radius);
    }
    var thisModel = this.model;
    var thisIndex = allLinks.indexOf(thisModel);
    var defaultConnector = paper.options.defaultConnector || {};
    // not all links are meant to be jumped over.
    var links = allLinks.filter(function(link, idx) {
        var connector = link.get('connector') || defaultConnector;
        // avoid jumping over links with connector type listed in `ignored connectors`.
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(ignoreConnectors).includes(connector.name)) {
            return false;
        }
        // filter out links that are above this one and  have the same connector type
        // otherwise there would double hoops for each intersection
        if (idx > thisIndex) {
            return connector.name !== 'jumpover';
        }
        return true;
    });
    // find views for all links
    var linkViews = links.map(function(link) {
        return paper.findViewByModel(link);
    });
    // create lines for this link
    var thisLines = createLines(sourcePoint, targetPoint, route);
    // create lines for all other links
    var linkLines = linkViews.map(function(linkView) {
        if (linkView == null) {
            return [];
        }
        if (linkView === this) {
            return thisLines;
        }
        return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.route);
    }, this);
    // transform lines for this link by splitting with jump lines at
    // points of intersection with other links
    var jumpingLines = thisLines.reduce(function(resultLines, thisLine) {
        // iterate all links and grab the intersections with this line
        // these are then sorted by distance so the line can be split more easily
        var intersections = links.reduce(function(res, link, i) {
            // don't intersection with itself
            if (link !== thisModel) {
                const linkLinesToTest = linkLines[i].slice();
                const overlapIndex = linkLinesToTest.findIndex((line)=>overlapExists(thisLine, line));
                // Overlap occurs and the end point of one segment lies on thisLine
                if (overlapIndex > -1 && thisLine.containsPoint(linkLinesToTest[overlapIndex].end)) {
                    // Remove the next segment because there will never be a jump
                    linkLinesToTest.splice(overlapIndex + 1, 1);
                }
                const lineIntersections = findLineIntersections(thisLine, linkLinesToTest);
                res.push.apply(res, lineIntersections);
            }
            return res;
        }, []).sort(function(a, b) {
            return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);
        });
        if (intersections.length > 0) {
            // split the line based on found intersection points
            resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));
        } else {
            // without any intersection the line goes uninterrupted
            resultLines.push(thisLine);
        }
        return resultLines;
    }, []);
    var path = buildPath(jumpingLines, jumpSize, jumpType, radius);
    return raw ? path : path.serialize();
};
}}),
"[project]/node_modules/@joint/core/src/connectors/normal.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "normal": (()=>normal)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$straight$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/connectors/straight.mjs [app-client] (ecmascript)");
;
const normal = function(sourcePoint, targetPoint, route = [], opt = {}) {
    const { raw } = opt;
    const localOpt = {
        cornerType: 'point',
        raw
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$straight$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["straight"])(sourcePoint, targetPoint, route, localOpt);
};
}}),
"[project]/node_modules/@joint/core/src/connectors/rounded.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "rounded": (()=>rounded)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$straight$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/connectors/straight.mjs [app-client] (ecmascript)");
;
const CORNER_RADIUS = 10;
const PRECISION = 0;
const rounded = function(sourcePoint, targetPoint, route = [], opt = {}) {
    const { radius = CORNER_RADIUS, raw } = opt;
    const localOpt = {
        cornerType: 'cubic',
        cornerRadius: radius,
        precision: PRECISION,
        raw
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$straight$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["straight"])(sourcePoint, targetPoint, route, localOpt);
};
}}),
"[project]/node_modules/@joint/core/src/connectors/smooth.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "smooth": (()=>smooth)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/index.mjs [app-client] (ecmascript)");
;
const smooth = function(sourcePoint, targetPoint, route, opt) {
    var raw = opt && opt.raw;
    var path;
    if (route && route.length !== 0) {
        var points = [
            sourcePoint
        ].concat(route).concat([
            targetPoint
        ]);
        var curves = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Curve.throughPoints(points);
        path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path(curves);
    } else {
        // if we have no route, use a default cubic bezier curve
        // cubic bezier requires two control points
        // the control points have `x` midway between source and target
        // this produces an S-like curve
        path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path();
        var segment;
        segment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('M', sourcePoint);
        path.appendSegment(segment);
        if (Math.abs(sourcePoint.x - targetPoint.x) >= Math.abs(sourcePoint.y - targetPoint.y)) {
            var controlPointX = (sourcePoint.x + targetPoint.x) / 2;
            segment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y);
            path.appendSegment(segment);
        } else {
            var controlPointY = (sourcePoint.y + targetPoint.y) / 2;
            segment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y);
            path.appendSegment(segment);
        }
    }
    return raw ? path : path.serialize();
};
}}),
"[project]/node_modules/@joint/core/src/connectors/curve.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "curve": (()=>curve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/point.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$path$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/path.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$curve$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/curve.mjs [app-client] (ecmascript)");
;
const Directions = {
    AUTO: 'auto',
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical',
    CLOSEST_POINT: 'closest-point',
    OUTWARDS: 'outwards'
};
const TangentDirections = {
    UP: 'up',
    DOWN: 'down',
    LEFT: 'left',
    RIGHT: 'right',
    AUTO: 'auto',
    CLOSEST_POINT: 'closest-point',
    OUTWARDS: 'outwards'
};
const curve = function(sourcePoint, targetPoint, route = [], opt = {}, linkView) {
    const raw = Boolean(opt.raw);
    // distanceCoefficient - a coefficient of the tangent vector length relative to the distance between points.
    // angleTangentCoefficient - a coefficient of the end tangents length in the case of angles larger than 45 degrees.
    // tension - a Catmull-Rom curve tension parameter.
    // sourceTangent - a tangent vector along the curve at the sourcePoint.
    // sourceDirection - a unit direction vector along the curve at the sourcePoint.
    // targetTangent - a tangent vector along the curve at the targetPoint.
    // targetDirection - a unit direction vector along the curve at the targetPoint.
    // precision - a rounding precision for path values.
    const { direction = Directions.AUTO, precision = 3 } = opt;
    const options = {
        coeff: opt.distanceCoefficient || 0.6,
        angleTangentCoefficient: opt.angleTangentCoefficient || 80,
        tau: opt.tension || 0.5,
        sourceTangent: opt.sourceTangent ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](opt.sourceTangent) : null,
        targetTangent: opt.targetTangent ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](opt.targetTangent) : null,
        rotate: Boolean(opt.rotate)
    };
    if (typeof opt.sourceDirection === 'string') options.sourceDirection = opt.sourceDirection;
    else if (typeof opt.sourceDirection === 'number') options.sourceDirection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](1, 0).rotate(null, opt.sourceDirection);
    else options.sourceDirection = opt.sourceDirection ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](opt.sourceDirection).normalize() : null;
    if (typeof opt.targetDirection === 'string') options.targetDirection = opt.targetDirection;
    else if (typeof opt.targetDirection === 'number') options.targetDirection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](1, 0).rotate(null, opt.targetDirection);
    else options.targetDirection = opt.targetDirection ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](opt.targetDirection).normalize() : null;
    const completeRoute = [
        sourcePoint,
        ...route,
        targetPoint
    ].map((p)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](p));
    // The calculation of a sourceTangent
    let sourceTangent;
    if (options.sourceTangent) {
        sourceTangent = options.sourceTangent;
    } else {
        const sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);
        const tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;
        const pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();
        const angle = angleBetweenVectors(sourceDirection, pointsVector);
        if (angle > Math.PI / 4) {
            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;
            sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);
        } else {
            sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);
        }
    }
    // The calculation of a targetTangent
    let targetTangent;
    if (options.targetTangent) {
        targetTangent = options.targetTangent;
    } else {
        const targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);
        const last = completeRoute.length - 1;
        const tangentLength = completeRoute[last - 1].distance(completeRoute[last]) * options.coeff;
        const pointsVector = completeRoute[last - 1].difference(completeRoute[last]).normalize();
        const angle = angleBetweenVectors(targetDirection, pointsVector);
        if (angle > Math.PI / 4) {
            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;
            targetTangent = targetDirection.clone().scale(updatedLength, updatedLength);
        } else {
            targetTangent = targetDirection.clone().scale(tangentLength, tangentLength);
        }
    }
    const catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);
    const bezierCurves = catmullRomCurves.map((curve)=>catmullRomToBezier(curve, options));
    const path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$path$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"](bezierCurves).round(precision);
    return raw ? path : path.serialize();
};
curve.Directions = Directions;
curve.TangentDirections = TangentDirections;
function getHorizontalSourceDirection(linkView, route, options) {
    const { sourceBBox } = linkView;
    let sourceSide;
    let rotation;
    if (!linkView.sourceView) {
        if (sourceBBox.x > route[1].x) sourceSide = 'right';
        else sourceSide = 'left';
    } else {
        rotation = linkView.sourceView.model.angle();
        if (options.rotate && rotation) {
            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);
            const sourcePoint = route[0].clone();
            sourcePoint.rotate(sourceBBox.center(), rotation);
            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);
        } else {
            sourceSide = sourceBBox.sideNearestToPoint(route[0]);
        }
    }
    let direction;
    switch(sourceSide){
        case 'left':
            direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](-1, 0);
            break;
        case 'right':
        default:
            direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](1, 0);
            break;
    }
    if (options.rotate && rotation) {
        direction.rotate(null, -rotation);
    }
    return direction;
}
function getHorizontalTargetDirection(linkView, route, options) {
    const { targetBBox } = linkView;
    let targetSide;
    let rotation;
    if (!linkView.targetView) {
        if (targetBBox.x > route[route.length - 2].x) targetSide = 'left';
        else targetSide = 'right';
    } else {
        rotation = linkView.targetView.model.angle();
        if (options.rotate && rotation) {
            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);
            const targetPoint = route[route.length - 1].clone();
            targetPoint.rotate(targetBBox.center(), rotation);
            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);
        } else {
            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);
        }
    }
    let direction;
    switch(targetSide){
        case 'left':
            direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](-1, 0);
            break;
        case 'right':
        default:
            direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](1, 0);
            break;
    }
    if (options.rotate && rotation) {
        direction.rotate(null, -rotation);
    }
    return direction;
}
function getVerticalSourceDirection(linkView, route, options) {
    const { sourceBBox } = linkView;
    let sourceSide;
    let rotation;
    if (!linkView.sourceView) {
        if (sourceBBox.y > route[1].y) sourceSide = 'bottom';
        else sourceSide = 'top';
    } else {
        rotation = linkView.sourceView.model.angle();
        if (options.rotate && rotation) {
            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);
            const sourcePoint = route[0].clone();
            sourcePoint.rotate(sourceBBox.center(), rotation);
            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);
        } else {
            sourceSide = sourceBBox.sideNearestToPoint(route[0]);
        }
    }
    let direction;
    switch(sourceSide){
        case 'top':
            direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](0, -1);
            break;
        case 'bottom':
        default:
            direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](0, 1);
            break;
    }
    if (options.rotate && rotation) {
        direction.rotate(null, -rotation);
    }
    return direction;
}
function getVerticalTargetDirection(linkView, route, options) {
    const { targetBBox } = linkView;
    let targetSide;
    let rotation;
    if (!linkView.targetView) {
        if (targetBBox.y > route[route.length - 2].y) targetSide = 'top';
        else targetSide = 'bottom';
    } else {
        rotation = linkView.targetView.model.angle();
        if (options.rotate && rotation) {
            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);
            const targetPoint = route[route.length - 1].clone();
            targetPoint.rotate(targetBBox.center(), rotation);
            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);
        } else {
            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);
        }
    }
    let direction;
    switch(targetSide){
        case 'top':
            direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](0, -1);
            break;
        case 'bottom':
        default:
            direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](0, 1);
            break;
    }
    if (options.rotate && rotation) {
        direction.rotate(null, -rotation);
    }
    return direction;
}
function getAutoSourceDirection(linkView, route, options) {
    const { sourceBBox } = linkView;
    let sourceSide;
    let rotation;
    if (!linkView.sourceView) {
        sourceSide = sourceBBox.sideNearestToPoint(route[1]);
    } else {
        rotation = linkView.sourceView.model.angle();
        if (options.rotate && rotation) {
            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);
            const sourcePoint = route[0].clone();
            sourcePoint.rotate(sourceBBox.center(), rotation);
            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);
        } else {
            sourceSide = sourceBBox.sideNearestToPoint(route[0]);
        }
    }
    let direction;
    switch(sourceSide){
        case 'top':
            direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](0, -1);
            break;
        case 'bottom':
            direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](0, 1);
            break;
        case 'right':
            direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](1, 0);
            break;
        case 'left':
            direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](-1, 0);
            break;
    }
    if (options.rotate && rotation) {
        direction.rotate(null, -rotation);
    }
    return direction;
}
function getAutoTargetDirection(linkView, route, options) {
    const { targetBBox } = linkView;
    let targetSide;
    let rotation;
    if (!linkView.targetView) {
        targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);
    } else {
        rotation = linkView.targetView.model.angle();
        if (options.rotate && rotation) {
            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);
            const targetPoint = route[route.length - 1].clone();
            targetPoint.rotate(targetBBox.center(), rotation);
            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);
        } else {
            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);
        }
    }
    let direction;
    switch(targetSide){
        case 'top':
            direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](0, -1);
            break;
        case 'bottom':
            direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](0, 1);
            break;
        case 'right':
            direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](1, 0);
            break;
        case 'left':
            direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](-1, 0);
            break;
    }
    if (options.rotate && rotation) {
        direction.rotate(null, -rotation);
    }
    return direction;
}
function getClosestPointSourceDirection(linkView, route, options) {
    return route[1].difference(route[0]).normalize();
}
function getClosestPointTargetDirection(linkView, route, options) {
    const last = route.length - 1;
    return route[last - 1].difference(route[last]).normalize();
}
function getOutwardsSourceDirection(linkView, route, options) {
    const { sourceBBox } = linkView;
    const sourceCenter = sourceBBox.center();
    return route[0].difference(sourceCenter).normalize();
}
function getOutwardsTargetDirection(linkView, route, options) {
    const { targetBBox } = linkView;
    const targetCenter = targetBBox.center();
    return route[route.length - 1].difference(targetCenter).normalize();
}
function getSourceTangentDirection(linkView, route, direction, options) {
    if (options.sourceDirection) {
        switch(options.sourceDirection){
            case TangentDirections.UP:
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](0, -1);
            case TangentDirections.DOWN:
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](0, 1);
            case TangentDirections.LEFT:
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](-1, 0);
            case TangentDirections.RIGHT:
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](1, 0);
            case TangentDirections.AUTO:
                return getAutoSourceDirection(linkView, route, options);
            case TangentDirections.CLOSEST_POINT:
                return getClosestPointSourceDirection(linkView, route, options);
            case TangentDirections.OUTWARDS:
                return getOutwardsSourceDirection(linkView, route, options);
            default:
                return options.sourceDirection;
        }
    }
    switch(direction){
        case Directions.HORIZONTAL:
            return getHorizontalSourceDirection(linkView, route, options);
        case Directions.VERTICAL:
            return getVerticalSourceDirection(linkView, route, options);
        case Directions.CLOSEST_POINT:
            return getClosestPointSourceDirection(linkView, route, options);
        case Directions.OUTWARDS:
            return getOutwardsSourceDirection(linkView, route, options);
        case Directions.AUTO:
        default:
            return getAutoSourceDirection(linkView, route, options);
    }
}
function getTargetTangentDirection(linkView, route, direction, options) {
    if (options.targetDirection) {
        switch(options.targetDirection){
            case TangentDirections.UP:
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](0, -1);
            case TangentDirections.DOWN:
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](0, 1);
            case TangentDirections.LEFT:
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](-1, 0);
            case TangentDirections.RIGHT:
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](1, 0);
            case TangentDirections.AUTO:
                return getAutoTargetDirection(linkView, route, options);
            case TangentDirections.CLOSEST_POINT:
                return getClosestPointTargetDirection(linkView, route, options);
            case TangentDirections.OUTWARDS:
                return getOutwardsTargetDirection(linkView, route, options);
            default:
                return options.targetDirection;
        }
    }
    switch(direction){
        case Directions.HORIZONTAL:
            return getHorizontalTargetDirection(linkView, route, options);
        case Directions.VERTICAL:
            return getVerticalTargetDirection(linkView, route, options);
        case Directions.CLOSEST_POINT:
            return getClosestPointTargetDirection(linkView, route, options);
        case Directions.OUTWARDS:
            return getOutwardsTargetDirection(linkView, route, options);
        case Directions.AUTO:
        default:
            return getAutoTargetDirection(linkView, route, options);
    }
}
function rotateVector(vector, angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const x = cos * vector.x - sin * vector.y;
    const y = sin * vector.x + cos * vector.y;
    vector.x = x;
    vector.y = y;
}
function angleBetweenVectors(v1, v2) {
    let cos = v1.dot(v2) / (v1.magnitude() * v2.magnitude());
    if (cos < -1) cos = -1;
    if (cos > 1) cos = 1;
    return Math.acos(cos);
}
function determinant(v1, v2) {
    return v1.x * v2.y - v1.y * v2.x;
}
function createCatmullRomCurves(points, sourceTangent, targetTangent, options) {
    const { tau, coeff } = options;
    const distances = [];
    const tangents = [];
    const catmullRomCurves = [];
    const n = points.length - 1;
    for(let i = 0; i < n; i++){
        distances[i] = points[i].distance(points[i + 1]);
    }
    tangents[0] = sourceTangent;
    tangents[n] = targetTangent;
    // The calculation of tangents of vertices
    for(let i = 1; i < n; i++){
        let tpPrev;
        let tpNext;
        if (i === 1) {
            tpPrev = points[i - 1].clone().offset(tangents[i - 1].x, tangents[i - 1].y);
        } else {
            tpPrev = points[i - 1].clone();
        }
        if (i === n - 1) {
            tpNext = points[i + 1].clone().offset(tangents[i + 1].x, tangents[i + 1].y);
        } else {
            tpNext = points[i + 1].clone();
        }
        const v1 = tpPrev.difference(points[i]).normalize();
        const v2 = tpNext.difference(points[i]).normalize();
        const vAngle = angleBetweenVectors(v1, v2);
        let rot = (Math.PI - vAngle) / 2;
        let t;
        const vectorDeterminant = determinant(v1, v2);
        let pointsDeterminant;
        pointsDeterminant = determinant(points[i].difference(points[i + 1]), points[i].difference(points[i - 1]));
        if (vectorDeterminant < 0) {
            rot = -rot;
        }
        if (vAngle < Math.PI / 2 && (rot < 0 && pointsDeterminant < 0 || rot > 0 && pointsDeterminant > 0)) {
            rot = rot - Math.PI;
        }
        t = v2.clone();
        rotateVector(t, rot);
        const t1 = t.clone();
        const t2 = t.clone();
        const scaleFactor1 = distances[i - 1] * coeff;
        const scaleFactor2 = distances[i] * coeff;
        t1.scale(scaleFactor1, scaleFactor1);
        t2.scale(scaleFactor2, scaleFactor2);
        tangents[i] = [
            t1,
            t2
        ];
    }
    // The building of a Catmull-Rom curve based of tangents of points
    for(let i = 0; i < n; i++){
        let p0;
        let p3;
        if (i === 0) {
            p0 = points[i + 1].difference(tangents[i].x / tau, tangents[i].y / tau);
        } else {
            p0 = points[i + 1].difference(tangents[i][1].x / tau, tangents[i][1].y / tau);
        }
        if (i === n - 1) {
            p3 = points[i].clone().offset(tangents[i + 1].x / tau, tangents[i + 1].y / tau);
        } else {
            p3 = points[i].difference(tangents[i + 1][0].x / tau, tangents[i + 1][0].y / tau);
        }
        catmullRomCurves[i] = [
            p0,
            points[i],
            points[i + 1],
            p3
        ];
    }
    return catmullRomCurves;
}
// The function to convert Catmull-Rom curve to Bezier curve using the tension (tau)
function catmullRomToBezier(points, options) {
    const { tau } = options;
    const bcp1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]();
    bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);
    bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);
    const bcp2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]();
    bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);
    bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$curve$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"](points[1], bcp1, bcp2, points[2]);
}
}}),
"[project]/node_modules/@joint/core/src/connectors/index.mjs [app-client] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "curve": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$curve$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["curve"]),
    "jumpover": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$jumpover$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jumpover"]),
    "normal": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$normal$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normal"]),
    "rounded": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$rounded$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rounded"]),
    "smooth": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$smooth$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["smooth"]),
    "straight": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$straight$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["straight"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$straight$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/connectors/straight.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$jumpover$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/connectors/jumpover.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$normal$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/connectors/normal.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$rounded$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/connectors/rounded.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$smooth$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/connectors/smooth.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$curve$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/connectors/curve.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/connectors/index.mjs [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@joint/core/src/connectors/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "curve": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["curve"]),
    "jumpover": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["jumpover"]),
    "normal": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["normal"]),
    "rounded": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["rounded"]),
    "smooth": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["smooth"]),
    "straight": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["straight"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/connectors/index.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/connectors/index.mjs [app-client] (ecmascript) <exports>");
}}),
"[project]/node_modules/@joint/core/src/highlighters/index.mjs [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
;
;
;
;
}}),
"[project]/node_modules/@joint/core/src/highlighters/index.mjs [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/highlighters/index.mjs [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@joint/core/src/highlighters/stroke.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "stroke": (()=>stroke)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/HighlighterView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/V/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/utilHelpers.mjs [app-client] (ecmascript)");
;
;
;
const stroke = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HighlighterView"].extend({
    tagName: 'path',
    className: 'highlight-stroke',
    attributes: {
        'pointer-events': 'none',
        'fill': 'none'
    },
    options: {
        padding: 3,
        rx: 0,
        ry: 0,
        useFirstSubpath: false,
        attrs: {
            'stroke-width': 3,
            'stroke': '#FEB663'
        }
    },
    getPathData (cellView, node) {
        const { options } = this;
        const { useFirstSubpath } = options;
        let d;
        try {
            const vNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(node);
            d = vNode.convertToPathData().trim();
            if (vNode.tagName() === 'PATH' && useFirstSubpath) {
                const secondSubpathIndex = d.search(/.M/i) + 1;
                if (secondSubpathIndex > 0) {
                    d = d.substr(0, secondSubpathIndex);
                }
            }
        } catch (error) {
            // Failed to get path data from magnet element.
            // Draw a rectangle around the node instead.
            const nodeBBox = cellView.getNodeBoundingRect(node);
            d = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].rectToPath((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])({}, options, nodeBBox.toJSON()));
        }
        return d;
    },
    highlightConnection (cellView) {
        this.vel.attr('d', cellView.getSerializedConnection());
    },
    highlightNode (cellView, node) {
        const { vel, options } = this;
        const { padding, layer } = options;
        let highlightMatrix = this.getNodeMatrix(cellView, node);
        // Add padding to the highlight element.
        if (padding) {
            if (!layer && node === cellView.el) {
                // If the highlighter is appended to the cellView
                // and we measure the size of the cellView wrapping group
                // it's necessary to remove the highlighter first
                vel.remove();
            }
            let nodeBBox = cellView.getNodeBoundingRect(node);
            const cx = nodeBBox.x + nodeBBox.width / 2;
            const cy = nodeBBox.y + nodeBBox.height / 2;
            nodeBBox = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformRect(nodeBBox, highlightMatrix);
            const width = Math.max(nodeBBox.width, 1);
            const height = Math.max(nodeBBox.height, 1);
            const sx = (width + padding) / width;
            const sy = (height + padding) / height;
            const paddingMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createSVGMatrix({
                a: sx,
                b: 0,
                c: 0,
                d: sy,
                e: cx - sx * cx,
                f: cy - sy * cy
            });
            highlightMatrix = highlightMatrix.multiply(paddingMatrix);
        }
        vel.attr({
            'd': this.getPathData(cellView, node),
            'transform': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].matrixToTransformString(highlightMatrix)
        });
    },
    highlight (cellView, node) {
        const { vel, options } = this;
        vel.attr(options.attrs);
        if (options.nonScalingStroke) {
            vel.attr('vector-effect', 'non-scaling-stroke');
        }
        if (cellView.isNodeConnection(node)) {
            this.highlightConnection(cellView);
        } else {
            this.highlightNode(cellView, node);
        }
    }
});
}}),
"[project]/node_modules/@joint/core/src/highlighters/mask.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "mask": (()=>mask)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/HighlighterView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/V/index.mjs [app-client] (ecmascript)");
;
;
const MASK_CLIP = 20;
function forEachDescendant(vel, fn) {
    const descendants = vel.children();
    while(descendants.length > 0){
        const descendant = descendants.shift();
        if (fn(descendant)) {
            descendants.push(...descendant.children());
        }
    }
}
const mask = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HighlighterView"].extend({
    tagName: 'rect',
    className: 'highlight-mask',
    attributes: {
        'pointer-events': 'none'
    },
    options: {
        padding: 3,
        maskClip: MASK_CLIP,
        deep: false,
        attrs: {
            'stroke': '#FEB663',
            'stroke-width': 3,
            'stroke-linecap': 'butt',
            'stroke-linejoin': 'miter'
        }
    },
    VISIBLE: 'white',
    INVISIBLE: 'black',
    MASK_ROOT_ATTRIBUTE_BLACKLIST: [
        'marker-start',
        'marker-end',
        'marker-mid',
        'transform',
        'stroke-dasharray',
        'class'
    ],
    MASK_CHILD_ATTRIBUTE_BLACKLIST: [
        'stroke',
        'fill',
        'stroke-width',
        'stroke-opacity',
        'stroke-dasharray',
        'fill-opacity',
        'marker-start',
        'marker-end',
        'marker-mid',
        'class'
    ],
    // TODO: change the list to a function callback
    MASK_REPLACE_TAGS: [
        'FOREIGNOBJECT',
        'IMAGE',
        'USE',
        'TEXT',
        'TSPAN',
        'TEXTPATH'
    ],
    // TODO: change the list to a function callback
    MASK_REMOVE_TAGS: [
        'TEXT',
        'TSPAN',
        'TEXTPATH'
    ],
    transformMaskChild (cellView, childEl) {
        const { MASK_CHILD_ATTRIBUTE_BLACKLIST, MASK_REPLACE_TAGS, MASK_REMOVE_TAGS } = this;
        const childTagName = childEl.tagName();
        // Do not include the element in the mask's image
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {
            childEl.remove();
            return false;
        }
        // Replace the element with a rectangle
        if (MASK_REPLACE_TAGS.includes(childTagName)) {
            // Note: clone() method does not change the children ids
            const originalChild = cellView.vel.findOne(`#${childEl.id}`);
            if (originalChild) {
                const { node: originalNode } = originalChild;
                let childBBox = cellView.getNodeBoundingRect(originalNode);
                if (cellView.model.isElement()) {
                    childBBox = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformRect(childBBox, cellView.getNodeMatrix(originalNode));
                }
                const replacement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('rect', childBBox.toJSON());
                const { x: ox, y: oy } = childBBox.center();
                const { angle, cx = ox, cy = oy } = originalChild.rotate();
                if (angle) replacement.rotate(angle, cx, cy);
                // Note: it's not important to keep the same sibling index since all subnodes are filled
                childEl.parent().append(replacement);
            }
            childEl.remove();
            return false;
        }
        // Keep the element, but clean it from certain attributes
        MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach((attrName)=>{
            if (attrName === 'fill' && childEl.attr('fill') === 'none') return;
            childEl.removeAttr(attrName);
        });
        return true;
    },
    transformMaskRoot (_cellView, rootEl) {
        const { MASK_ROOT_ATTRIBUTE_BLACKLIST } = this;
        MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach((attrName)=>{
            rootEl.removeAttr(attrName);
        });
    },
    getMaskShape (cellView, vel) {
        const { options, MASK_REPLACE_TAGS } = this;
        const { deep } = options;
        const tagName = vel.tagName();
        let maskRoot;
        if (tagName === 'G') {
            if (!deep) return null;
            maskRoot = vel.clone();
            forEachDescendant(maskRoot, (maskChild)=>this.transformMaskChild(cellView, maskChild));
        } else {
            if (MASK_REPLACE_TAGS.includes(tagName)) return null;
            maskRoot = vel.clone();
        }
        this.transformMaskRoot(cellView, maskRoot);
        return maskRoot;
    },
    getMaskId () {
        return `highlight-mask-${this.cid}`;
    },
    getMask (cellView, vNode) {
        const { VISIBLE, INVISIBLE, options } = this;
        const { padding, attrs } = options;
        // support both `strokeWidth` and `stroke-width` attribute names
        const strokeWidth = parseFloat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('g').attr(attrs).attr('stroke-width'));
        const hasNodeFill = vNode.attr('fill') !== 'none';
        let magnetStrokeWidth = parseFloat(vNode.attr('stroke-width'));
        if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1;
        // stroke of the invisible shape
        const minStrokeWidth = magnetStrokeWidth + padding * 2;
        // stroke of the visible shape
        const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;
        let maskEl = this.getMaskShape(cellView, vNode);
        if (!maskEl) {
            const nodeBBox = cellView.getNodeBoundingRect(vNode.node);
            // Make sure the rect is visible
            nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);
            maskEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('rect', nodeBBox.toJSON());
        }
        maskEl.attr(attrs);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('mask', {
            'id': this.getMaskId()
        }).append([
            maskEl.clone().attr({
                'fill': hasNodeFill ? VISIBLE : 'none',
                'stroke': VISIBLE,
                'stroke-width': maxStrokeWidth
            }),
            maskEl.clone().attr({
                'fill': hasNodeFill ? INVISIBLE : 'none',
                'stroke': INVISIBLE,
                'stroke-width': minStrokeWidth
            })
        ]);
    },
    removeMask (paper) {
        const maskNode = paper.svg.getElementById(this.getMaskId());
        if (maskNode) {
            paper.defs.removeChild(maskNode);
        }
    },
    addMask (paper, maskEl) {
        paper.defs.appendChild(maskEl.node);
    },
    highlight (cellView, node) {
        const { options, vel } = this;
        const { padding, attrs, maskClip = MASK_CLIP, layer } = options;
        const color = 'stroke' in attrs ? attrs['stroke'] : '#000000';
        if (!layer && node === cellView.el) {
            // If the highlighter is appended to the cellView
            // and we measure the size of the cellView wrapping group
            // it's necessary to remove the highlighter first
            vel.remove();
        }
        const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);
        const highlightMatrix = this.getNodeMatrix(cellView, node);
        const maskEl = this.getMask(cellView, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(node));
        this.addMask(cellView.paper, maskEl);
        vel.attr(highlighterBBox.toJSON());
        vel.attr({
            'transform': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].matrixToTransformString(highlightMatrix),
            'mask': `url(#${maskEl.id})`,
            'fill': color
        });
    },
    unhighlight (cellView) {
        this.removeMask(cellView.paper);
    }
});
}}),
"[project]/node_modules/@joint/core/src/highlighters/opacity.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "opacity": (()=>opacity)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/HighlighterView.mjs [app-client] (ecmascript)");
;
const opacity = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HighlighterView"].extend({
    UPDATABLE: false,
    MOUNTABLE: false,
    highlight: function(_cellView, node) {
        const { alphaValue = 0.3 } = this.options;
        node.style.opacity = alphaValue;
    },
    unhighlight: function(_cellView, node) {
        node.style.opacity = '';
    }
});
}}),
"[project]/node_modules/@joint/core/src/highlighters/addClass.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "addClass": (()=>addClass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/HighlighterView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/V/index.mjs [app-client] (ecmascript)");
;
;
;
const className = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.addClassNamePrefix('highlighted');
const addClass = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HighlighterView"].extend({
    UPDATABLE: false,
    MOUNTABLE: false,
    options: {
        className
    },
    highlight: function(_cellView, node) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(node).addClass(this.options.className);
    },
    unhighlight: function(_cellView, node) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(node).removeClass(this.options.className);
    }
}, {
    // Backwards Compatibility
    className
});
}}),
"[project]/node_modules/@joint/core/src/highlighters/list.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "list": (()=>list)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/HighlighterView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/utilHelpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/util.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/rect.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$getRectPoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/getRectPoint.mjs [app-client] (ecmascript)");
;
;
;
;
const Directions = {
    ROW: 'row',
    COLUMN: 'column'
};
const list = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HighlighterView"].extend({
    tagName: 'g',
    MOUNTABLE: true,
    UPDATE_ATTRIBUTES: function() {
        return [
            this.options.attribute
        ];
    },
    _prevItems: null,
    highlight (elementView, node) {
        const element = elementView.model;
        const { attribute, size = 20, gap = 5, direction = Directions.ROW } = this.options;
        if (!attribute) throw new Error('List: attribute is required');
        const normalizedSize = typeof size === 'number' ? {
            width: size,
            height: size
        } : size;
        const isRowDirection = direction === Directions.ROW;
        const itemWidth = isRowDirection ? normalizedSize.width : normalizedSize.height;
        let items = element.get(attribute);
        if (!Array.isArray(items)) items = [];
        const prevItems = this._prevItems || [];
        const comparison = items.map((item, index)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEqual"])(prevItems[index], items[index]));
        if (prevItems.length !== items.length || comparison.some((unchanged)=>!unchanged)) {
            const prevEls = this.vel.children();
            const itemsEls = items.map((item, index)=>{
                const prevEl = index in prevEls ? prevEls[index].node : null;
                if (comparison[index]) return prevEl;
                const itemEl = this.createListItem(item, normalizedSize, prevEl);
                if (!itemEl) return null;
                if (!(itemEl instanceof SVGElement)) throw new Error('List: item must be an SVGElement');
                itemEl.dataset.index = index;
                itemEl.dataset.attribute = attribute;
                const offset = index * (itemWidth + gap);
                itemEl.setAttribute('transform', isRowDirection ? `translate(${offset}, 0)` : `translate(0, ${offset})`);
                return itemEl;
            });
            this.vel.empty().append(itemsEls);
            this._prevItems = items;
        }
        const itemsCount = items.length;
        const length = itemsCount === 0 ? 0 : itemsCount * itemWidth + (itemsCount - 1) * gap;
        const listSize = isRowDirection ? {
            width: length,
            height: normalizedSize.height
        } : {
            width: normalizedSize.width,
            height: length
        };
        this.position(element, listSize);
    },
    position (element, listSize) {
        const { vel, options } = this;
        const { margin = 5, position = 'top-left' } = options;
        const { width, height } = element.size();
        const { left, right, top, bottom } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeSides"])(margin);
        const bbox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](left, top, width - (left + right), height - (top + bottom));
        let { x, y } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$getRectPoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRectPoint"])(bbox, position);
        // x
        switch(position){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$getRectPoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Positions"].CENTER:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$getRectPoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Positions"].TOP:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$getRectPoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Positions"].BOTTOM:
                {
                    x -= listSize.width / 2;
                    break;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$getRectPoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Positions"].RIGHT:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$getRectPoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Positions"].BOTTOM_RIGHT:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$getRectPoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Positions"].TOP_RIGHT:
                {
                    x -= listSize.width;
                    break;
                }
        }
        // y
        switch(position){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$getRectPoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Positions"].CENTER:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$getRectPoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Positions"].RIGHT:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$getRectPoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Positions"].LEFT:
                {
                    y -= listSize.height / 2;
                    break;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$getRectPoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Positions"].BOTTOM:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$getRectPoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Positions"].BOTTOM_RIGHT:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$getRectPoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Positions"].BOTTOM_LEFT:
                {
                    y -= listSize.height;
                    break;
                }
        }
        vel.attr('transform', `translate(${x}, ${y})`);
    }
}, {
    Directions,
    Positions: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$getRectPoint$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Positions"]
});
}}),
"[project]/node_modules/@joint/core/src/highlighters/index.mjs [app-client] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "addClass": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$addClass$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addClass"]),
    "list": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$list$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["list"]),
    "mask": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$mask$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mask"]),
    "opacity": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$opacity$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["opacity"]),
    "stroke": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$stroke$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stroke"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$stroke$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/highlighters/stroke.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$mask$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/highlighters/mask.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$opacity$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/highlighters/opacity.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$addClass$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/highlighters/addClass.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$list$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/highlighters/list.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/highlighters/index.mjs [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@joint/core/src/highlighters/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "addClass": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["addClass"]),
    "list": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["list"]),
    "mask": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["mask"]),
    "opacity": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["opacity"]),
    "stroke": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["stroke"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/highlighters/index.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/highlighters/index.mjs [app-client] (ecmascript) <exports>");
}}),
"[project]/node_modules/@joint/core/src/linkAnchors/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "connectionClosest": (()=>connectionClosest),
    "connectionLength": (()=>connectionLength),
    "connectionPerpendicular": (()=>connectionPerpendicular),
    "connectionRatio": (()=>connectionRatio),
    "resolveRef": (()=>resolveRef)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$line$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/line.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/point.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/util.mjs [app-client] (ecmascript) <locals>");
;
;
function connectionRatio(view, _magnet, _refPoint, opt) {
    var ratio = 'ratio' in opt ? opt.ratio : 0.5;
    return view.getPointAtRatio(ratio);
}
function connectionLength(view, _magnet, _refPoint, opt) {
    var length = 'length' in opt ? opt.length : 20;
    return view.getPointAtLength(length);
}
function _connectionPerpendicular(view, _magnet, refPoint, opt) {
    var OFFSET = 1e6;
    var path = view.getConnection();
    var segmentSubdivisions = view.getConnectionSubdivisions();
    var verticalLine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$line$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"](refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));
    var horizontalLine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$line$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"](refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));
    var verticalIntersections = verticalLine.intersect(path, {
        segmentSubdivisions: segmentSubdivisions
    });
    var horizontalIntersections = horizontalLine.intersect(path, {
        segmentSubdivisions: segmentSubdivisions
    });
    var intersections = [];
    if (verticalIntersections) Array.prototype.push.apply(intersections, verticalIntersections);
    if (horizontalIntersections) Array.prototype.push.apply(intersections, horizontalIntersections);
    if (intersections.length > 0) return refPoint.chooseClosest(intersections);
    if ('fallbackAt' in opt) {
        return getPointAtLink(view, opt.fallbackAt);
    }
    return connectionClosest(view, _magnet, refPoint, opt);
}
function _connectionClosest(view, _magnet, refPoint, _opt) {
    var closestPoint = view.getClosestPoint(refPoint);
    if (!closestPoint) return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]();
    return closestPoint;
}
function resolveRef(fn) {
    return function(view, magnet, ref, opt) {
        if (ref instanceof Element) {
            var refView = this.paper.findView(ref);
            var refPoint;
            if (refView) {
                if (refView.isNodeConnection(ref)) {
                    var distance = 'fixedAt' in opt ? opt.fixedAt : '50%';
                    refPoint = getPointAtLink(refView, distance);
                } else {
                    refPoint = refView.getNodeBBox(ref).center();
                }
            } else {
                // Something went wrong
                refPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]();
            }
            return fn.call(this, view, magnet, refPoint, opt);
        }
        return fn.apply(this, arguments);
    };
}
function getPointAtLink(view, value) {
    var parsedValue = parseFloat(value);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isPercentage"])(value)) {
        return view.getPointAtRatio(parsedValue / 100);
    } else {
        return view.getPointAtLength(parsedValue);
    }
}
;
const connectionPerpendicular = resolveRef(_connectionPerpendicular);
const connectionClosest = resolveRef(_connectionClosest);
}}),
"[project]/node_modules/@joint/core/src/anchors/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "bottom": (()=>bottom),
    "bottomLeft": (()=>bottomLeft),
    "bottomRight": (()=>bottomRight),
    "center": (()=>center),
    "left": (()=>left),
    "midSide": (()=>midSide),
    "modelCenter": (()=>modelCenter),
    "perpendicular": (()=>perpendicular),
    "right": (()=>right),
    "top": (()=>top),
    "topLeft": (()=>topLeft),
    "topRight": (()=>topRight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$linkAnchors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/linkAnchors/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$geometry$2e$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/geometry.helpers.mjs [app-client] (ecmascript)");
;
;
;
function bboxWrapper(method) {
    return function(view, magnet, ref, opt) {
        var rotate = !!opt.rotate;
        var bbox = rotate ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);
        var anchor = bbox[method]();
        var dx = opt.dx;
        if (dx) {
            var dxPercentage = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isPercentage(dx);
            dx = parseFloat(dx);
            if (isFinite(dx)) {
                if (dxPercentage) {
                    dx /= 100;
                    dx *= bbox.width;
                }
                anchor.x += dx;
            }
        }
        var dy = opt.dy;
        if (dy) {
            var dyPercentage = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isPercentage(dy);
            dy = parseFloat(dy);
            if (isFinite(dy)) {
                if (dyPercentage) {
                    dy /= 100;
                    dy *= bbox.height;
                }
                anchor.y += dy;
            }
        }
        return rotate ? anchor.rotate(view.model.getBBox().center(), -view.model.angle()) : anchor;
    };
}
function _perpendicular(view, magnet, refPoint, opt) {
    var angle = view.model.angle();
    var bbox = view.getNodeBBox(magnet);
    var anchor = bbox.center();
    var topLeft = bbox.origin();
    var bottomRight = bbox.corner();
    var padding = opt.padding;
    if (!isFinite(padding)) padding = 0;
    if (topLeft.y + padding <= refPoint.y && refPoint.y <= bottomRight.y - padding) {
        var dy = refPoint.y - anchor.y;
        anchor.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$geometry$2e$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toRad"])(angle));
        anchor.y += dy;
    } else if (topLeft.x + padding <= refPoint.x && refPoint.x <= bottomRight.x - padding) {
        var dx = refPoint.x - anchor.x;
        anchor.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$geometry$2e$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toRad"])(angle));
        anchor.x += dx;
    }
    return anchor;
}
function _midSide(view, magnet, refPoint, opt) {
    var rotate = !!opt.rotate;
    var bbox, angle, center;
    if (rotate) {
        bbox = view.getNodeUnrotatedBBox(magnet);
        center = view.model.getBBox().center();
        angle = view.model.angle();
    } else {
        bbox = view.getNodeBBox(magnet);
    }
    var padding = opt.padding;
    if (isFinite(padding)) bbox.inflate(padding);
    if (rotate) refPoint.rotate(center, angle);
    var side = bbox.sideNearestToPoint(refPoint);
    var anchor;
    switch(side){
        case 'left':
            anchor = bbox.leftMiddle();
            break;
        case 'right':
            anchor = bbox.rightMiddle();
            break;
        case 'top':
            anchor = bbox.topMiddle();
            break;
        case 'bottom':
            anchor = bbox.bottomMiddle();
            break;
    }
    return rotate ? anchor.rotate(center, -angle) : anchor;
}
// Can find anchor from model, when there is no selector or the link end
// is connected to a port
function _modelCenter(view, _magnet, _refPoint, opt, endType) {
    return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);
}
const center = bboxWrapper('center');
const top = bboxWrapper('topMiddle');
const bottom = bboxWrapper('bottomMiddle');
const left = bboxWrapper('leftMiddle');
const right = bboxWrapper('rightMiddle');
const topLeft = bboxWrapper('origin');
const topRight = bboxWrapper('topRight');
const bottomLeft = bboxWrapper('bottomLeft');
const bottomRight = bboxWrapper('corner');
const perpendicular = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$linkAnchors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveRef"])(_perpendicular);
const midSide = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$linkAnchors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveRef"])(_midSide);
const modelCenter = _modelCenter;
}}),
"[project]/node_modules/@joint/core/src/connectionPoints/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anchor": (()=>anchor),
    "bbox": (()=>bbox),
    "boundary": (()=>boundary),
    "rectangle": (()=>rectangle)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/V/index.mjs [app-client] (ecmascript)");
;
;
;
function offsetPoint(p1, p2, offset) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isPlainObject(offset)) {
        const { x, y } = offset;
        if (isFinite(y)) {
            const line = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(p2, p1);
            const { start, end } = line.parallel(y);
            p2 = start;
            p1 = end;
        }
        offset = x;
    }
    if (!isFinite(offset)) return p1;
    var length = p1.distance(p2);
    if (offset === 0 && length > 0) return p1;
    return p1.move(p2, -Math.min(offset, length - 1));
}
function stroke(magnet) {
    var stroke = magnet.getAttribute('stroke-width');
    if (stroke === null) return 0;
    return parseFloat(stroke) || 0;
}
function alignLine(line, type, offset = 0) {
    let coordinate, a, b, direction;
    const { start, end } = line;
    switch(type){
        case 'left':
            coordinate = 'x';
            a = end;
            b = start;
            direction = -1;
            break;
        case 'right':
            coordinate = 'x';
            a = start;
            b = end;
            direction = 1;
            break;
        case 'top':
            coordinate = 'y';
            a = end;
            b = start;
            direction = -1;
            break;
        case 'bottom':
            coordinate = 'y';
            a = start;
            b = end;
            direction = 1;
            break;
        default:
            return;
    }
    if (start[coordinate] < end[coordinate]) {
        a[coordinate] = b[coordinate];
    } else {
        b[coordinate] = a[coordinate];
    }
    if (isFinite(offset)) {
        a[coordinate] += direction * offset;
        b[coordinate] += direction * offset;
    }
}
// Connection Points
function anchorConnectionPoint(line, _view, _magnet, opt) {
    let { offset, alignOffset, align } = opt;
    if (align) alignLine(line, align, alignOffset);
    return offsetPoint(line.end, line.start, offset);
}
function bboxIntersection(line, view, magnet, opt) {
    var bbox = view.getNodeBBox(magnet);
    if (opt.stroke) bbox.inflate(stroke(magnet) / 2);
    var intersections = line.intersect(bbox);
    var cp = intersections ? line.start.chooseClosest(intersections) : line.end;
    return offsetPoint(cp, line.start, opt.offset);
}
function rectangleIntersection(line, view, magnet, opt) {
    var angle = view.model.angle();
    if (angle === 0) {
        return bboxIntersection(line, view, magnet, opt);
    }
    var bboxWORotation = view.getNodeUnrotatedBBox(magnet);
    if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);
    var center = bboxWORotation.center();
    var lineWORotation = line.clone().rotate(center, angle);
    var intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);
    var cp = intersections ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle) : line.end;
    return offsetPoint(cp, line.start, opt.offset);
}
function findShapeNode(magnet) {
    if (!magnet) return null;
    var node = magnet;
    do {
        var tagName = node.tagName;
        if (typeof tagName !== 'string') return null;
        tagName = tagName.toUpperCase();
        if (tagName === 'G') {
            node = node.firstElementChild;
        } else if (tagName === 'TITLE') {
            node = node.nextElementSibling;
        } else break;
    }while (node)
    return node;
}
var BNDR_SUBDIVISIONS = 'segmentSubdivisons';
var BNDR_SHAPE_BBOX = 'shapeBBox';
function boundaryIntersection(line, view, magnet, opt) {
    var node, intersection;
    var selector = opt.selector;
    var anchor = line.end;
    if (typeof selector === 'string') {
        node = view.findNode(selector);
    } else if (selector === false) {
        node = magnet;
    } else if (Array.isArray(selector)) {
        node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.getByPath(magnet, selector);
    } else {
        node = findShapeNode(magnet);
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isSVGGraphicsElement(node)) {
        if (node === magnet || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isSVGGraphicsElement(magnet)) return anchor;
        node = magnet;
    }
    var localShape = view.getNodeShape(node);
    var magnetMatrix = view.getNodeMatrix(node);
    var translateMatrix = view.getRootTranslateMatrix();
    var rotateMatrix = view.getRootRotateMatrix();
    var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);
    var localMatrix = targetMatrix.inverse();
    var localLine = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformLine(line, localMatrix);
    var localRef = localLine.start.clone();
    var data = view.getNodeData(node);
    if (opt.insideout === false) {
        if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();
        var localBBox = data[BNDR_SHAPE_BBOX];
        if (localBBox.containsPoint(localRef)) return anchor;
    }
    // Caching segment subdivisions for paths
    var pathOpt;
    if (localShape instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Path) {
        var precision = opt.precision || 2;
        if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({
            precision: precision
        });
        pathOpt = {
            precision: precision,
            segmentSubdivisions: data[BNDR_SUBDIVISIONS]
        };
    }
    if (opt.extrapolate === true) localLine.setLength(1e6);
    intersection = localLine.intersect(localShape, pathOpt);
    if (intersection) {
        // More than one intersection
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isArray(intersection)) intersection = localRef.chooseClosest(intersection);
    } else if (opt.sticky === true) {
        // No intersection, find the closest point instead
        if (localShape instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect) {
            intersection = localShape.pointNearestToPoint(localRef);
        } else if (localShape instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Ellipse) {
            intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);
        } else {
            intersection = localShape.closestPoint(localRef, pathOpt);
        }
    }
    var cp = intersection ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformPoint(intersection, targetMatrix) : anchor;
    var cpOffset = opt.offset || 0;
    if (opt.stroke) cpOffset += stroke(node) / 2;
    return offsetPoint(cp, line.start, cpOffset);
}
const anchor = anchorConnectionPoint;
const bbox = bboxIntersection;
const rectangle = rectangleIntersection;
const boundary = boundaryIntersection;
}}),
"[project]/node_modules/@joint/core/src/shapes/index.mjs [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
;
}}),
"[project]/node_modules/@joint/core/src/shapes/index.mjs [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$shapes$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/shapes/index.mjs [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@joint/core/src/shapes/standard.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BorderedImage": (()=>BorderedImage),
    "Circle": (()=>Circle),
    "Cylinder": (()=>Cylinder),
    "DoubleLink": (()=>DoubleLink),
    "Ellipse": (()=>Ellipse),
    "EmbeddedImage": (()=>EmbeddedImage),
    "HeaderedRectangle": (()=>HeaderedRectangle),
    "Image": (()=>Image),
    "InscribedImage": (()=>InscribedImage),
    "Link": (()=>Link),
    "Path": (()=>Path),
    "Polygon": (()=>Polygon),
    "Polyline": (()=>Polyline),
    "Rectangle": (()=>Rectangle),
    "ShadowLink": (()=>ShadowLink),
    "TextBlock": (()=>TextBlock)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/Element.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/util.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/V/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$env$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/env/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/utilHelpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/attributes/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Link$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/Link.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
const Rectangle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].define('standard.Rectangle', {
    attrs: {
        root: {
            cursor: 'move'
        },
        body: {
            width: 'calc(w)',
            height: 'calc(h)',
            strokeWidth: 2,
            stroke: '#000000',
            fill: '#FFFFFF'
        },
        label: {
            textVerticalAnchor: 'middle',
            textAnchor: 'middle',
            x: 'calc(w/2)',
            y: 'calc(h/2)',
            fontSize: 14,
            fill: '#333333'
        }
    }
}, {
    markup: [
        {
            tagName: 'rect',
            selector: 'body'
        },
        {
            tagName: 'text',
            selector: 'label'
        }
    ]
});
const Circle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].define('standard.Circle', {
    attrs: {
        root: {
            cursor: 'move'
        },
        body: {
            cx: 'calc(s/2)',
            cy: 'calc(s/2)',
            r: 'calc(s/2)',
            strokeWidth: 2,
            stroke: '#333333',
            fill: '#FFFFFF'
        },
        label: {
            textVerticalAnchor: 'middle',
            textAnchor: 'middle',
            x: 'calc(w/2)',
            y: 'calc(h/2)',
            fontSize: 14,
            fill: '#333333'
        }
    }
}, {
    markup: [
        {
            tagName: 'circle',
            selector: 'body'
        },
        {
            tagName: 'text',
            selector: 'label'
        }
    ]
});
const Ellipse = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].define('standard.Ellipse', {
    attrs: {
        root: {
            cursor: 'move'
        },
        body: {
            cx: 'calc(w/2)',
            cy: 'calc(h/2)',
            rx: 'calc(w/2)',
            ry: 'calc(h/2)',
            strokeWidth: 2,
            stroke: '#333333',
            fill: '#FFFFFF'
        },
        label: {
            textVerticalAnchor: 'middle',
            textAnchor: 'middle',
            x: 'calc(w/2)',
            y: 'calc(h/2)',
            fontSize: 14,
            fill: '#333333'
        }
    }
}, {
    markup: [
        {
            tagName: 'ellipse',
            selector: 'body'
        },
        {
            tagName: 'text',
            selector: 'label'
        }
    ]
});
const Path = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].define('standard.Path', {
    attrs: {
        root: {
            cursor: 'move'
        },
        body: {
            d: 'M 0 0 H calc(w) V calc(h) H 0 Z',
            strokeWidth: 2,
            stroke: '#333333',
            fill: '#FFFFFF'
        },
        label: {
            textVerticalAnchor: 'middle',
            textAnchor: 'middle',
            x: 'calc(w/2)',
            y: 'calc(h/2)',
            fontSize: 14,
            fill: '#333333'
        }
    }
}, {
    markup: [
        {
            tagName: 'path',
            selector: 'body'
        },
        {
            tagName: 'text',
            selector: 'label'
        }
    ]
});
const Polygon = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].define('standard.Polygon', {
    attrs: {
        root: {
            cursor: 'move'
        },
        body: {
            points: '0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)',
            strokeWidth: 2,
            stroke: '#333333',
            fill: '#FFFFFF'
        },
        label: {
            textVerticalAnchor: 'middle',
            textAnchor: 'middle',
            x: 'calc(w/2)',
            y: 'calc(h/2)',
            fontSize: 14,
            fill: '#333333'
        }
    }
}, {
    markup: [
        {
            tagName: 'polygon',
            selector: 'body'
        },
        {
            tagName: 'text',
            selector: 'label'
        }
    ]
});
const Polyline = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].define('standard.Polyline', {
    attrs: {
        root: {
            cursor: 'move'
        },
        body: {
            points: '0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)',
            strokeWidth: 2,
            stroke: '#333333',
            fill: '#FFFFFF'
        },
        label: {
            textVerticalAnchor: 'middle',
            textAnchor: 'middle',
            x: 'calc(w/2)',
            y: 'calc(h/2)',
            fontSize: 14,
            fill: '#333333'
        }
    }
}, {
    markup: [
        {
            tagName: 'polyline',
            selector: 'body'
        },
        {
            tagName: 'text',
            selector: 'label'
        }
    ]
});
const Image = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].define('standard.Image', {
    attrs: {
        root: {
            cursor: 'move'
        },
        image: {
            width: 'calc(w)',
            height: 'calc(h)'
        },
        label: {
            textVerticalAnchor: 'top',
            textAnchor: 'middle',
            x: 'calc(w/2)',
            y: 'calc(h+10)',
            fontSize: 14,
            fill: '#333333'
        }
    }
}, {
    markup: [
        {
            tagName: 'image',
            selector: 'image'
        },
        {
            tagName: 'text',
            selector: 'label'
        }
    ]
});
const BorderedImage = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].define('standard.BorderedImage', {
    attrs: {
        root: {
            cursor: 'move'
        },
        border: {
            width: 'calc(w)',
            height: 'calc(h)',
            stroke: '#333333',
            strokeWidth: 2
        },
        background: {
            width: 'calc(w-1)',
            height: 'calc(h-1)',
            x: 0.5,
            y: 0.5,
            fill: '#FFFFFF'
        },
        image: {
            // xlinkHref: '[URL]'
            width: 'calc(w-1)',
            height: 'calc(h-1)',
            x: 0.5,
            y: 0.5
        },
        label: {
            textVerticalAnchor: 'top',
            textAnchor: 'middle',
            x: 'calc(w/2)',
            y: 'calc(h+10)',
            fontSize: 14,
            fill: '#333333'
        }
    }
}, {
    markup: [
        {
            tagName: 'rect',
            selector: 'background',
            attributes: {
                'stroke': 'none'
            }
        },
        {
            tagName: 'image',
            selector: 'image'
        },
        {
            tagName: 'rect',
            selector: 'border',
            attributes: {
                'fill': 'none'
            }
        },
        {
            tagName: 'text',
            selector: 'label'
        }
    ]
});
const EmbeddedImage = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].define('standard.EmbeddedImage', {
    attrs: {
        root: {
            cursor: 'move'
        },
        body: {
            width: 'calc(w)',
            height: 'calc(h)',
            stroke: '#333333',
            fill: '#FFFFFF',
            strokeWidth: 2
        },
        image: {
            // xlinkHref: '[URL]'
            width: 'calc(0.3*w)',
            height: 'calc(h-20)',
            x: 10,
            y: 10,
            preserveAspectRatio: 'xMidYMin'
        },
        label: {
            textVerticalAnchor: 'top',
            textAnchor: 'left',
            x: 'calc(0.3*w+20)',
            y: 10,
            fontSize: 14,
            fill: '#333333'
        }
    }
}, {
    markup: [
        {
            tagName: 'rect',
            selector: 'body'
        },
        {
            tagName: 'image',
            selector: 'image'
        },
        {
            tagName: 'text',
            selector: 'label'
        }
    ]
});
const InscribedImage = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].define('standard.InscribedImage', {
    attrs: {
        root: {
            cursor: 'move'
        },
        border: {
            rx: 'calc(w/2)',
            ry: 'calc(h/2)',
            cx: 'calc(w/2)',
            cy: 'calc(h/2)',
            stroke: '#333333',
            strokeWidth: 2
        },
        background: {
            rx: 'calc(w/2)',
            ry: 'calc(h/2)',
            cx: 'calc(w/2)',
            cy: 'calc(h/2)',
            fill: '#FFFFFF'
        },
        image: {
            // The image corners touch the border when its size is Math.sqrt(2) / 2 = 0.707.. ~= 70%
            width: 'calc(0.68*w)',
            height: 'calc(0.68*h)',
            // The image offset is calculated as (100% - 68%) / 2
            x: 'calc(0.16*w)',
            y: 'calc(0.16*h)',
            preserveAspectRatio: 'xMidYMid'
        },
        label: {
            textVerticalAnchor: 'top',
            textAnchor: 'middle',
            x: 'calc(w/2)',
            y: 'calc(h+10)',
            fontSize: 14,
            fill: '#333333'
        }
    }
}, {
    markup: [
        {
            tagName: 'ellipse',
            selector: 'background'
        },
        {
            tagName: 'image',
            selector: 'image'
        },
        {
            tagName: 'ellipse',
            selector: 'border',
            attributes: {
                'fill': 'none'
            }
        },
        {
            tagName: 'text',
            selector: 'label'
        }
    ]
});
const HeaderedRectangle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].define('standard.HeaderedRectangle', {
    attrs: {
        root: {
            cursor: 'move'
        },
        body: {
            width: 'calc(w)',
            height: 'calc(h)',
            strokeWidth: 2,
            stroke: '#000000',
            fill: '#FFFFFF'
        },
        header: {
            width: 'calc(w)',
            height: 30,
            strokeWidth: 2,
            stroke: '#000000',
            fill: '#FFFFFF'
        },
        headerText: {
            textVerticalAnchor: 'middle',
            textAnchor: 'middle',
            x: 'calc(w/2)',
            y: 15,
            fontSize: 16,
            fill: '#333333'
        },
        bodyText: {
            textVerticalAnchor: 'middle',
            textAnchor: 'middle',
            x: 'calc(w/2)',
            y: 'calc(h/2+15)',
            fontSize: 14,
            fill: '#333333'
        }
    }
}, {
    markup: [
        {
            tagName: 'rect',
            selector: 'body'
        },
        {
            tagName: 'rect',
            selector: 'header'
        },
        {
            tagName: 'text',
            selector: 'headerText'
        },
        {
            tagName: 'text',
            selector: 'bodyText'
        }
    ]
});
var CYLINDER_TILT = 10;
const Cylinder = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].define('standard.Cylinder', {
    attrs: {
        root: {
            cursor: 'move'
        },
        body: {
            lateralArea: CYLINDER_TILT,
            fill: '#FFFFFF',
            stroke: '#333333',
            strokeWidth: 2
        },
        top: {
            cx: 'calc(w/2)',
            cy: CYLINDER_TILT,
            rx: 'calc(w/2)',
            ry: CYLINDER_TILT,
            fill: '#FFFFFF',
            stroke: '#333333',
            strokeWidth: 2
        },
        label: {
            textVerticalAnchor: 'middle',
            textAnchor: 'middle',
            x: 'calc(w/2)',
            y: 'calc(h+15)',
            fontSize: 14,
            fill: '#333333'
        }
    }
}, {
    markup: [
        {
            tagName: 'path',
            selector: 'body'
        },
        {
            tagName: 'ellipse',
            selector: 'top'
        },
        {
            tagName: 'text',
            selector: 'label'
        }
    ],
    topRy: function(t, opt) {
        // getter
        if (t === undefined) return this.attr('body/lateralArea');
        // setter
        var bodyAttrs = {
            lateralArea: t
        };
        var isPercentageSetter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isPercentage"])(t);
        var ty = isPercentageSetter ? `calc(${parseFloat(t) / 100}*h)` : t;
        var topAttrs = {
            cy: ty,
            ry: ty
        };
        return this.attr({
            body: bodyAttrs,
            top: topAttrs
        }, opt);
    }
}, {
    attributes: {
        'lateral-area': {
            set: function(t, refBBox) {
                var isPercentageSetter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isPercentage"])(t);
                if (isPercentageSetter) t = parseFloat(t) / 100;
                var x = refBBox.x;
                var y = refBBox.y;
                var w = refBBox.width;
                var h = refBBox.height;
                // curve control point variables
                var rx = w / 2;
                var ry = isPercentageSetter ? h * t : t;
                var kappa = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].KAPPA;
                var cx = kappa * rx;
                var cy = kappa * (isPercentageSetter ? h * t : t);
                // shape variables
                var xLeft = x;
                var xCenter = x + w / 2;
                var xRight = x + w;
                var ySideTop = y + ry;
                var yCurveTop = ySideTop - ry;
                var ySideBottom = y + h - ry;
                var yCurveBottom = y + h;
                // return calculated shape
                var data = [
                    'M',
                    xLeft,
                    ySideTop,
                    'L',
                    xLeft,
                    ySideBottom,
                    'C',
                    x,
                    ySideBottom + cy,
                    xCenter - cx,
                    yCurveBottom,
                    xCenter,
                    yCurveBottom,
                    'C',
                    xCenter + cx,
                    yCurveBottom,
                    xRight,
                    ySideBottom + cy,
                    xRight,
                    ySideBottom,
                    'L',
                    xRight,
                    ySideTop,
                    'C',
                    xRight,
                    ySideTop - cy,
                    xCenter + cx,
                    yCurveTop,
                    xCenter,
                    yCurveTop,
                    'C',
                    xCenter - cx,
                    yCurveTop,
                    xLeft,
                    ySideTop - cy,
                    xLeft,
                    ySideTop,
                    'Z'
                ];
                return {
                    d: data.join(' ')
                };
            },
            unset: 'd'
        }
    }
});
var foLabelMarkup = {
    tagName: 'foreignObject',
    selector: 'foreignObject',
    attributes: {
        'overflow': 'hidden'
    },
    children: [
        {
            tagName: 'div',
            namespaceURI: 'http://www.w3.org/1999/xhtml',
            selector: 'label',
            style: {
                width: '100%',
                height: '100%',
                position: 'static',
                backgroundColor: 'transparent',
                textAlign: 'center',
                margin: 0,
                padding: '0px 5px',
                boxSizing: 'border-box',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
            }
        }
    ]
};
var svgLabelMarkup = {
    tagName: 'text',
    selector: 'label',
    attributes: {
        'text-anchor': 'middle'
    }
};
var labelMarkup = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$env$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].test('svgforeignobject') ? foLabelMarkup : svgLabelMarkup;
const TextBlock = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].define('standard.TextBlock', {
    attrs: {
        root: {
            cursor: 'move'
        },
        body: {
            width: 'calc(w)',
            height: 'calc(h)',
            stroke: '#333333',
            fill: '#ffffff',
            strokeWidth: 2
        },
        foreignObject: {
            width: 'calc(w)',
            height: 'calc(h)'
        },
        label: {
            style: {
                fontSize: 14
            }
        }
    }
}, {
    markup: [
        {
            tagName: 'rect',
            selector: 'body'
        },
        labelMarkup
    ]
}, {
    attributes: {
        text: {
            set: function(text, refBBox, node, attrs) {
                if (node instanceof HTMLElement) {
                    node.textContent = text;
                } else {
                    // No foreign object
                    var style = attrs['style'] || {};
                    var wrapValue = {
                        text,
                        width: -5,
                        height: '100%'
                    };
                    var wrapAttrs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])({
                        'text-vertical-anchor': 'middle'
                    }, style);
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attributes"]['text-wrap'].set.call(this, wrapValue, refBBox, node, wrapAttrs);
                    return {
                        fill: style.color || null
                    };
                }
            },
            unset: function(node) {
                node.textContent = '';
                if (node instanceof SVGElement) {
                    return 'fill';
                }
            },
            position: function(text, refBBox, node) {
                // No foreign object
                if (node instanceof SVGElement) return refBBox.center();
            }
        }
    }
});
const Link = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Link$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Link"].define('standard.Link', {
    attrs: {
        line: {
            connection: true,
            stroke: '#333333',
            strokeWidth: 2,
            strokeLinejoin: 'round',
            targetMarker: {
                'type': 'path',
                'd': 'M 10 -5 0 0 10 5 z'
            }
        },
        wrapper: {
            connection: true,
            strokeWidth: 10,
            strokeLinejoin: 'round'
        }
    }
}, {
    markup: [
        {
            tagName: 'path',
            selector: 'wrapper',
            attributes: {
                'fill': 'none',
                'cursor': 'pointer',
                'stroke': 'transparent',
                'stroke-linecap': 'round'
            }
        },
        {
            tagName: 'path',
            selector: 'line',
            attributes: {
                'fill': 'none',
                'pointer-events': 'none'
            }
        }
    ]
});
const DoubleLink = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Link$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Link"].define('standard.DoubleLink', {
    attrs: {
        line: {
            connection: true,
            stroke: '#DDDDDD',
            strokeWidth: 4,
            strokeLinejoin: 'round',
            targetMarker: {
                type: 'path',
                stroke: '#000000',
                d: 'M 10 -3 10 -10 -2 0 10 10 10 3'
            }
        },
        outline: {
            connection: true,
            stroke: '#000000',
            strokeWidth: 6,
            strokeLinejoin: 'round'
        }
    }
}, {
    markup: [
        {
            tagName: 'path',
            selector: 'outline',
            attributes: {
                'fill': 'none',
                'cursor': 'pointer'
            }
        },
        {
            tagName: 'path',
            selector: 'line',
            attributes: {
                'fill': 'none',
                'pointer-events': 'none'
            }
        }
    ]
});
const ShadowLink = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Link$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Link"].define('standard.ShadowLink', {
    attrs: {
        line: {
            connection: true,
            stroke: '#FF0000',
            strokeWidth: 20,
            strokeLinejoin: 'round',
            targetMarker: {
                'type': 'path',
                'stroke': 'none',
                'd': 'M 0 -10 -10 0 0 10 z'
            },
            sourceMarker: {
                'type': 'path',
                'stroke': 'none',
                'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'
            }
        },
        shadow: {
            connection: true,
            transform: 'translate(3,6)',
            stroke: '#000000',
            strokeOpacity: 0.2,
            strokeWidth: 20,
            strokeLinejoin: 'round',
            targetMarker: {
                'type': 'path',
                'd': 'M 0 -10 -10 0 0 10 z',
                'stroke': 'none'
            },
            sourceMarker: {
                'type': 'path',
                'stroke': 'none',
                'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'
            }
        }
    }
}, {
    markup: [
        {
            tagName: 'path',
            selector: 'shadow',
            attributes: {
                'fill': 'none',
                'pointer-events': 'none'
            }
        },
        {
            tagName: 'path',
            selector: 'line',
            attributes: {
                'fill': 'none',
                'cursor': 'pointer'
            }
        }
    ]
});
}}),
"[project]/node_modules/@joint/core/src/shapes/index.mjs [app-client] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "standard": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$shapes$2f$standard$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$shapes$2f$standard$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/shapes/standard.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$shapes$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/shapes/index.mjs [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@joint/core/src/shapes/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "standard": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$shapes$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["standard"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$shapes$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/shapes/index.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$shapes$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/shapes/index.mjs [app-client] (ecmascript) <exports>");
}}),
"[project]/node_modules/@joint/core/src/shapes/index.mjs [app-client] (ecmascript) <export * as shapes>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "shapes": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$shapes$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$shapes$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/shapes/index.mjs [app-client] (ecmascript)");
}}),
}]);

//# sourceMappingURL=node_modules_%40joint_core_src_97fc8b._.js.map