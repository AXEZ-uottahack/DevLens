(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@maxgraph_core_lib_view_9b5e6b._.js", {

"[project]/node_modules/@maxgraph/core/lib/view/event/InternalMouseEvent.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/domUtils.js [app-client] (ecmascript)");
;
;
/**
 * Base class for all mouse events in mxGraph. A listener for this event should
 * implement the following methods:
 *
 * ```javascript
 * graph.addMouseListener(
 * {
 *   mouseDown: (sender, evt)=>
 *   {
 *     GlobalConfig.logger.debug('mouseDown');
 *   },
 *   mouseMove: (sender, evt)=>
 *   {
 *     GlobalConfig.logger.debug('mouseMove');
 *   },
 *   mouseUp: (sender, evt)=>
 *   {
 *     GlobalConfig.logger.debug('mouseUp');
 *   }
 * });
 * ```
 *
 * Constructor: mxMouseEvent
 *
 * Constructs a new event object for the given arguments.
 *
 * @param evt Native mouse event.
 * @param state Optional <CellState> under the mouse.
 */ class InternalMouseEvent {
    constructor(evt, state = null){
        /**
         * Holds the consumed state of this event.
         */ this.consumed = false;
        this.evt = evt;
        this.state = state;
        this.sourceState = state;
        // graphX and graphY are updated right after this constructor is executed,
        // so let them default to 0 and make them not nullable.
        this.graphX = 0;
        this.graphY = 0;
    }
    /**
     * Returns <evt>.
     */ getEvent() {
        return this.evt;
    }
    /**
     * Returns the target DOM element using {@link Event#getSource} for <evt>.
     */ getSource() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSource"])(this.evt);
    }
    /**
     * Returns true if the given {@link Shape} is the source of <evt>.
     */ isSource(shape) {
        return shape ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAncestorNode"])(shape.node, this.getSource()) : false;
    }
    /**
     * Returns <evt.clientX>.
     */ getX() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getClientX"])(this.getEvent());
    }
    /**
     * Returns <evt.clientY>.
     */ getY() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getClientY"])(this.getEvent());
    }
    /**
     * Returns <graphX>.
     */ getGraphX() {
        return this.graphX;
    }
    /**
     * Returns <graphY>.
     */ getGraphY() {
        return this.graphY;
    }
    /**
     * Returns <state>.
     */ getState() {
        return this.state;
    }
    /**
     * Returns the <Cell> in <state> is not null.
     */ getCell() {
        const state = this.getState();
        return state ? state.cell : null;
    }
    /**
     * Returns true if the event is a popup trigger.
     */ isPopupTrigger() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPopupTrigger"])(this.getEvent());
    }
    /**
     * Returns <consumed>.
     */ isConsumed() {
        return this.consumed;
    }
    /**
     * Sets <consumed> to true and invokes preventDefault on the native event
     * if such a method is defined. This is used mainly to avoid the cursor from
     * being changed to a text cursor in Webkit. You can use the preventDefault
     * flag to disable this functionality.
     *
     * @param preventDefault Specifies if the native event should be canceled. Default
     * is true.
     */ consume(preventDefault) {
        preventDefault = preventDefault ? preventDefault : window.TouchEvent && this.evt instanceof TouchEvent || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMouseEvent"])(this.evt);
        if (preventDefault && this.evt.preventDefault) {
            this.evt.preventDefault();
        }
        // Sets local consumed state
        this.consumed = true;
    }
}
const __TURBOPACK__default__export__ = InternalMouseEvent;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalMouseEvent.js [app-client] (ecmascript)");
;
;
;
// Checks if passive event listeners are supported
// see https://github.com/Modernizr/Modernizr/issues/1894
let supportsPassive = false;
try {
    document.addEventListener('test', ()=>{
        return;
    }, Object.defineProperty && Object.defineProperty({}, 'passive', {
        get: ()=>{
            supportsPassive = true;
        }
    }));
} catch (e) {
// ignore
}
/**
 * @class InternalEvent
 *
 * Cross-browser DOM event support. For internal event handling,
 * {@link mxEventSource} and the graph event dispatch loop in {@link graph} are used.
 *
 * ### Memory Leaks:
 *
 * Use this class for adding and removing listeners to/from DOM nodes. The
 * {@link removeAllListeners} function is provided to remove all listeners that
 * have been added using {@link addListener}. The function should be invoked when
 * the last reference is removed in the JavaScript code, typically when the
 * referenced DOM node is removed from the DOM.
 */ class InternalEvent {
    /**
     * Binds the function to the specified event on the given element. Use
     * {@link mxUtils.bind} in order to bind the "this" keyword inside the function
     * to a given execution scope.
     */ static addListener(element, eventName, funct) {
        element.addEventListener(eventName, funct, supportsPassive ? {
            passive: false
        } : false);
        if (!element.mxListenerList) {
            element.mxListenerList = [];
        }
        const entry = {
            name: eventName,
            f: funct
        };
        element.mxListenerList.push(entry);
    }
    /**
     * Removes the specified listener from the given element.
     */ static removeListener(element, eventName, funct) {
        element.removeEventListener(eventName, funct, false);
        if (element.mxListenerList) {
            const listenerCount = element.mxListenerList.length;
            for(let i = 0; i < listenerCount; i += 1){
                const entry = element.mxListenerList[i];
                if (entry.f === funct) {
                    element.mxListenerList.splice(i, 1);
                    break;
                }
            }
        }
    }
    /**
     * Removes all listeners from the given element.
     */ static removeAllListeners(element) {
        const list = element.mxListenerList;
        if (list) {
            while(list.length > 0){
                const entry = list[0];
                InternalEvent.removeListener(element, entry.name, entry.f);
            }
        }
    }
    /**
     * Adds the given listeners for touch, mouse and/or pointer events. If
     * <Client.IS_POINTER> is true then pointer events will be registered,
     * else the respective mouse events will be registered. If <Client.IS_POINTER>
     * is false and <Client.IS_TOUCH> is true then the respective touch events
     * will be registered as well as the mouse events.
     */ static addGestureListeners(node, startListener = null, moveListener = null, endListener = null) {
        if (startListener) {
            InternalEvent.addListener(node, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_POINTER ? 'pointerdown' : 'mousedown', startListener);
        }
        if (moveListener) {
            InternalEvent.addListener(node, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_POINTER ? 'pointermove' : 'mousemove', moveListener);
        }
        if (endListener) {
            InternalEvent.addListener(node, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_POINTER ? 'pointerup' : 'mouseup', endListener);
        }
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_POINTER && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_TOUCH) {
            if (startListener) {
                InternalEvent.addListener(node, 'touchstart', startListener);
            }
            if (moveListener) {
                InternalEvent.addListener(node, 'touchmove', moveListener);
            }
            if (endListener) {
                InternalEvent.addListener(node, 'touchend', endListener);
            }
        }
    }
    /**
     * Removes the given listeners from mousedown, mousemove, mouseup and the
     * respective touch events if <Client.IS_TOUCH> is true.
     */ static removeGestureListeners(node, startListener, moveListener, endListener) {
        if (startListener) {
            InternalEvent.removeListener(node, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_POINTER ? 'pointerdown' : 'mousedown', startListener);
        }
        if (moveListener) {
            InternalEvent.removeListener(node, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_POINTER ? 'pointermove' : 'mousemove', moveListener);
        }
        if (endListener) {
            InternalEvent.removeListener(node, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_POINTER ? 'pointerup' : 'mouseup', endListener);
        }
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_POINTER && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_TOUCH) {
            if (startListener) {
                InternalEvent.removeListener(node, 'touchstart', startListener);
            }
            if (moveListener) {
                InternalEvent.removeListener(node, 'touchmove', moveListener);
            }
            if (endListener) {
                InternalEvent.removeListener(node, 'touchend', endListener);
            }
        }
    }
    /**
     * Redirects the mouse events from the given DOM node to the graph dispatch
     * loop using the event and given state as event arguments. State can
     * either be an instance of <CellState> or a function that returns an
     * <CellState>. The down, move, up and dblClick arguments are optional
     * functions that take the trigger event as arguments and replace the
     * default behaviour.
     */ static redirectMouseEvents(node, graph, state = null, down = null, move = null, up = null, dblClick = null) {
        const getState = (evt)=>{
            return typeof state === 'function' ? state(evt) : state;
        };
        InternalEvent.addGestureListeners(node, (evt)=>{
            if (down) {
                down(evt);
            } else if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConsumed"])(evt)) {
                graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](evt, getState(evt)));
            }
        }, (evt)=>{
            if (move) {
                move(evt);
            } else if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConsumed"])(evt)) {
                graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](evt, getState(evt)));
            }
        }, (evt)=>{
            if (up) {
                up(evt);
            } else if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConsumed"])(evt)) {
                graph.fireMouseEvent(InternalEvent.MOUSE_UP, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](evt, getState(evt)));
            }
        });
        InternalEvent.addListener(node, 'dblclick', (evt)=>{
            if (dblClick) {
                dblClick(evt);
            } else if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConsumed"])(evt)) {
                const tmp = getState(evt);
                graph.dblClick(evt, tmp?.cell);
            }
        });
    }
    /**
     * Removes the known listeners from the given DOM node and its descendants.
     *
     * @param element DOM node to remove the listeners from.
     */ static release(element) {
        try {
            InternalEvent.removeAllListeners(element);
            // @ts-ignore
            const children = element.childNodes;
            if (children !== undefined) {
                const childCount = children.length;
                for(let i = 0; i < childCount; i += 1){
                    InternalEvent.release(children[i]);
                }
            }
        } catch (e) {
        // ignores errors as this is typically called in cleanup code
        }
    }
    /**
     * Installs the given function as a handler for mouse wheel events. The
     * function has two arguments: the mouse event and a boolean that specifies
     * if the wheel was moved up or down.
     *
     * This has been tested with IE 6 and 7, Firefox (all versions), Opera and
     * Safari. It does currently not work on Safari for Mac.
     *
     * ### Example
     *
     * @example
     * ```javascript
     * mxEvent.addMouseWheelListener(function (evt, up)
     * {
     *   GlobalConfig.logger.show();
     *   GlobalConfig.logger.debug('mouseWheel: up='+up);
     * });
     * ```
     *
     * @param funct Handler function that takes the event argument and a boolean up
     * argument for the mousewheel direction.
     * @param target Target for installing the listener in Google Chrome. See
     * https://www.chromestatus.com/features/6662647093133312.
     */ static addMouseWheelListener(funct, target) {
        if (funct != null) {
            const wheelHandler = (evt)=>{
                // To prevent window zoom on trackpad pinch
                if (evt.ctrlKey) {
                    evt.preventDefault();
                }
                // Handles the event using the given function
                if (Math.abs(evt.deltaX) > 0.5 || Math.abs(evt.deltaY) > 0.5) {
                    funct(evt, evt.deltaY == 0 ? -evt.deltaX > 0 : -evt.deltaY > 0);
                }
            };
            target = target != null ? target : window;
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_SF && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_TOUCH) {
                let scale = 1;
                InternalEvent.addListener(target, 'gesturestart', (evt)=>{
                    InternalEvent.consume(evt);
                    scale = 1;
                });
                InternalEvent.addListener(target, 'gesturechange', (evt)=>{
                    InternalEvent.consume(evt);
                    if (typeof evt.scale === 'number') {
                        const diff = scale - evt.scale;
                        if (Math.abs(diff) > 0.2) {
                            funct(evt, diff < 0, true);
                            scale = evt.scale;
                        }
                    }
                });
                InternalEvent.addListener(target, 'gestureend', (evt)=>{
                    InternalEvent.consume(evt);
                });
            } else {
                let evtCache = [];
                let dx0 = 0;
                let dy0 = 0;
                // Adds basic listeners for graph event dispatching
                InternalEvent.addGestureListeners(target, (evt)=>{
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMouseEvent"])(evt) && evt.pointerId != null) {
                        evtCache.push(evt);
                    }
                }, (evt)=>{
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMouseEvent"])(evt) && evtCache.length == 2) {
                        // Find this event in the cache and update its record with this event
                        for(let i = 0; i < evtCache.length; i += 1){
                            if (evt.pointerId == evtCache[i].pointerId) {
                                evtCache[i] = evt;
                                break;
                            }
                        }
                        // Calculate the distance between the two pointers
                        const dx = Math.abs(evtCache[0].clientX - evtCache[1].clientX);
                        const dy = Math.abs(evtCache[0].clientY - evtCache[1].clientY);
                        const tx = Math.abs(dx - dx0);
                        const ty = Math.abs(dy - dy0);
                        if (tx > InternalEvent.PINCH_THRESHOLD || ty > InternalEvent.PINCH_THRESHOLD) {
                            const cx = evtCache[0].clientX + (evtCache[1].clientX - evtCache[0].clientX) / 2;
                            const cy = evtCache[0].clientY + (evtCache[1].clientY - evtCache[0].clientY) / 2;
                            funct(evtCache[0], tx > ty ? dx > dx0 : dy > dy0, true, cx, cy);
                            // Cache the distance for the next move event
                            dx0 = dx;
                            dy0 = dy;
                        }
                    }
                }, (evt)=>{
                    evtCache = [];
                    dx0 = 0;
                    dy0 = 0;
                });
            }
            InternalEvent.addListener(target, 'wheel', wheelHandler);
        }
    }
    /**
     * Disables the context menu for the given element.
     */ static disableContextMenu(element) {
        InternalEvent.addListener(element, 'contextmenu', (evt)=>{
            if (evt.preventDefault) {
                evt.preventDefault();
            }
            return false;
        });
    }
    /**
     * Consumes the given event.
     *
     * @param evt Native event to be consumed.
     * @param {boolean} [preventDefault=true] Optional boolean to prevent the default for the event.
     * Default is true.
     * @param {boolean} [stopPropagation=true] Option boolean to stop event propagation. Default is
     * true.
     */ static consume(evt, preventDefault = true, stopPropagation = true) {
        if (preventDefault) {
            if (evt.preventDefault) {
                if (stopPropagation) {
                    evt.stopPropagation();
                }
                evt.preventDefault();
            } else if (stopPropagation) {
                evt.cancelBubble = true;
            }
        }
        // Opera
        // @ts-ignore This is a non-standard property.
        evt.isConsumed = true;
        // Other browsers
        if (!evt.preventDefault) {
            evt.returnValue = false;
        }
    }
}
//
// Special handles in mouse events
//
/**
 * Index for the label handle in an mxMouseEvent. This should be a negative
 * value that does not interfere with any possible handle indices.
 * @default -1
 */ InternalEvent.LABEL_HANDLE = -1;
/**
 * Index for the rotation handle in an mxMouseEvent. This should be a
 * negative value that does not interfere with any possible handle indices.
 * @default -2
 */ InternalEvent.ROTATION_HANDLE = -2;
/**
 * Start index for the custom handles in an mxMouseEvent. This should be a
 * negative value and is the start index which is decremented for each
 * custom handle.
 * @default -100
 */ InternalEvent.CUSTOM_HANDLE = -100;
/**
 * Start index for the virtual handles in an mxMouseEvent. This should be a
 * negative value and is the start index which is decremented for each
 * virtual handle.
 * This assumes that there are no more
 * than VIRTUAL_HANDLE - CUSTOM_HANDLE custom handles.
 *
 * @default -100000
 */ InternalEvent.VIRTUAL_HANDLE = -100000;
//
// Event names
//
/**
 * Specifies the event name for mouseDown.
 */ InternalEvent.MOUSE_DOWN = 'mouseDown';
/**
 * Specifies the event name for mouseMove.
 */ InternalEvent.MOUSE_MOVE = 'mouseMove';
/**
 * Specifies the event name for mouseUp.
 */ InternalEvent.MOUSE_UP = 'mouseUp';
/**
 * Specifies the event name for activate.
 */ InternalEvent.ACTIVATE = 'activate';
/**
 * Specifies the event name for resizeStart.
 */ InternalEvent.RESIZE_START = 'resizeStart';
/**
 * Specifies the event name for resize.
 */ InternalEvent.RESIZE = 'resize';
/**
 * Specifies the event name for resizeEnd.
 */ InternalEvent.RESIZE_END = 'resizeEnd';
/**
 * Specifies the event name for moveStart.
 */ InternalEvent.MOVE_START = 'moveStart';
/**
 * Specifies the event name for move.
 */ InternalEvent.MOVE = 'move';
/**
 * Specifies the event name for moveEnd.
 */ InternalEvent.MOVE_END = 'moveEnd';
/**
 * Specifies the event name for panStart.
 */ InternalEvent.PAN_START = 'panStart';
/**
 * Specifies the event name for pan.
 */ InternalEvent.PAN = 'pan';
/**
 * Specifies the event name for panEnd.
 */ InternalEvent.PAN_END = 'panEnd';
/**
 * Specifies the event name for minimize.
 */ InternalEvent.MINIMIZE = 'minimize';
/**
 * Specifies the event name for normalize.
 */ InternalEvent.NORMALIZE = 'normalize';
/**
 * Specifies the event name for maximize.
 */ InternalEvent.MAXIMIZE = 'maximize';
/**
 * Specifies the event name for hide.
 */ InternalEvent.HIDE = 'hide';
/**
 * Specifies the event name for show.
 */ InternalEvent.SHOW = 'show';
/**
 * Specifies the event name for close.
 */ InternalEvent.CLOSE = 'close';
/**
 * Specifies the event name for destroy.
 */ InternalEvent.DESTROY = 'destroy';
/**
 * Specifies the event name for refresh.
 */ InternalEvent.REFRESH = 'refresh';
/**
 * Specifies the event name for size.
 */ InternalEvent.SIZE = 'size';
/**
 * Specifies the event name for select.
 */ InternalEvent.SELECT = 'select';
/**
 * Specifies the event name for fired.
 */ InternalEvent.FIRED = 'fired';
/**
 * Specifies the event name for fireMouseEvent.
 */ InternalEvent.FIRE_MOUSE_EVENT = 'fireMouseEvent';
/**
 * Specifies the event name for gesture.
 */ InternalEvent.GESTURE = 'gesture';
/**
 * Specifies the event name for tapAndHold.
 */ InternalEvent.TAP_AND_HOLD = 'tapAndHold';
/**
 * Specifies the event name for get.
 */ InternalEvent.GET = 'get';
/**
 * Specifies the event name for receive.
 */ InternalEvent.RECEIVE = 'receive';
/**
 * Specifies the event name for connect.
 */ InternalEvent.CONNECT = 'connect';
/**
 * Specifies the event name for disconnect.
 */ InternalEvent.DISCONNECT = 'disconnect';
/**
 * Specifies the event name for suspend.
 */ InternalEvent.SUSPEND = 'suspend';
/**
 * Specifies the event name for suspend.
 */ InternalEvent.RESUME = 'resume';
/**
 * Specifies the event name for mark.
 */ InternalEvent.MARK = 'mark';
/**
 * Specifies the event name for root.
 */ InternalEvent.ROOT = 'root';
/**
 * Specifies the event name for post.
 */ InternalEvent.POST = 'post';
/**
 * Specifies the event name for open.
 */ InternalEvent.OPEN = 'open';
/**
 * Specifies the event name for open.
 */ InternalEvent.SAVE = 'save';
/**
 * Specifies the event name for beforeAddVertex.
 */ InternalEvent.BEFORE_ADD_VERTEX = 'beforeAddVertex';
/**
 * Specifies the event name for addVertex.
 */ InternalEvent.ADD_VERTEX = 'addVertex';
/**
 * Specifies the event name for afterAddVertex.
 */ InternalEvent.AFTER_ADD_VERTEX = 'afterAddVertex';
/**
 * Specifies the event name for done.
 */ InternalEvent.DONE = 'done';
/**
 * Specifies the event name for execute.
 */ InternalEvent.EXECUTE = 'execute';
/**
 * Specifies the event name for executed.
 */ InternalEvent.EXECUTED = 'executed';
/**
 * Specifies the event name for beginUpdate.
 */ InternalEvent.BEGIN_UPDATE = 'beginUpdate';
/**
 * Specifies the event name for startEdit.
 */ InternalEvent.START_EDIT = 'startEdit';
/**
 * Specifies the event name for endUpdate.
 */ InternalEvent.END_UPDATE = 'endUpdate';
/**
 * Specifies the event name for endEdit.
 */ InternalEvent.END_EDIT = 'endEdit';
/**
 * Specifies the event name for beforeUndo.
 */ InternalEvent.BEFORE_UNDO = 'beforeUndo';
/**
 * Specifies the event name for undo.
 */ InternalEvent.UNDO = 'undo';
/**
 * Specifies the event name for redo.
 */ InternalEvent.REDO = 'redo';
/**
 * Specifies the event name for change.
 */ InternalEvent.CHANGE = 'change';
/**
 * Specifies the event name for notify.
 */ InternalEvent.NOTIFY = 'notify';
/**
 * Specifies the event name for layoutCells.
 */ InternalEvent.LAYOUT_CELLS = 'layoutCells';
/**
 * Specifies the event name for click.
 */ InternalEvent.CLICK = 'click';
/**
 * Specifies the event name for scale.
 */ InternalEvent.SCALE = 'scale';
/**
 * Specifies the event name for translate.
 */ InternalEvent.TRANSLATE = 'translate';
/**
 * Specifies the event name for scaleAndTranslate.
 */ InternalEvent.SCALE_AND_TRANSLATE = 'scaleAndTranslate';
/**
 * Specifies the event name for up.
 */ InternalEvent.UP = 'up';
/**
 * Specifies the event name for down.
 */ InternalEvent.DOWN = 'down';
/**
 * Specifies the event name for add.
 */ InternalEvent.ADD = 'add';
/**
 * Specifies the event name for remove.
 */ InternalEvent.REMOVE = 'remove';
/**
 * Specifies the event name for clear.
 */ InternalEvent.CLEAR = 'clear';
/**
 * Specifies the event name for addCells.
 */ InternalEvent.ADD_CELLS = 'addCells';
/**
 * Specifies the event name for cellsAdded.
 */ InternalEvent.CELLS_ADDED = 'cellsAdded';
/**
 * Specifies the event name for moveCells.
 */ InternalEvent.MOVE_CELLS = 'moveCells';
/**
 * Specifies the event name for cellsMoved.
 */ InternalEvent.CELLS_MOVED = 'cellsMoved';
/**
 * Specifies the event name for resizeCells.
 */ InternalEvent.RESIZE_CELLS = 'resizeCells';
/**
 * Specifies the event name for cellsResized.
 */ InternalEvent.CELLS_RESIZED = 'cellsResized';
/**
 * Specifies the event name for toggleCells.
 */ InternalEvent.TOGGLE_CELLS = 'toggleCells';
/**
 * Specifies the event name for cellsToggled.
 */ InternalEvent.CELLS_TOGGLED = 'cellsToggled';
/**
 * Specifies the event name for orderCells.
 */ InternalEvent.ORDER_CELLS = 'orderCells';
/**
 * Specifies the event name for cellsOrdered.
 */ InternalEvent.CELLS_ORDERED = 'cellsOrdered';
/**
 * Specifies the event name for removeCells.
 */ InternalEvent.REMOVE_CELLS = 'removeCells';
/**
 * Specifies the event name for cellsRemoved.
 */ InternalEvent.CELLS_REMOVED = 'cellsRemoved';
/**
 * Specifies the event name for groupCells.
 */ InternalEvent.GROUP_CELLS = 'groupCells';
/**
 * Specifies the event name for ungroupCells.
 */ InternalEvent.UNGROUP_CELLS = 'ungroupCells';
/**
 * Specifies the event name for removeCellsFromParent.
 */ InternalEvent.REMOVE_CELLS_FROM_PARENT = 'removeCellsFromParent';
/**
 * Specifies the event name for foldCells.
 */ InternalEvent.FOLD_CELLS = 'foldCells';
/**
 * Specifies the event name for cellsFolded.
 */ InternalEvent.CELLS_FOLDED = 'cellsFolded';
/**
 * Specifies the event name for alignCells.
 */ InternalEvent.ALIGN_CELLS = 'alignCells';
/**
 * Specifies the event name for labelChanged.
 */ InternalEvent.LABEL_CHANGED = 'labelChanged';
/**
 * Specifies the event name for connectCell.
 */ InternalEvent.CONNECT_CELL = 'connectCell';
/**
 * Specifies the event name for cellConnected.
 */ InternalEvent.CELL_CONNECTED = 'cellConnected';
/**
 * Specifies the event name for splitEdge.
 */ InternalEvent.SPLIT_EDGE = 'splitEdge';
/**
 * Specifies the event name for flipEdge.
 */ InternalEvent.FLIP_EDGE = 'flipEdge';
/**
 * Specifies the event name for startEditing.
 */ InternalEvent.START_EDITING = 'startEditing';
/**
 * Specifies the event name for editingStarted.
 */ InternalEvent.EDITING_STARTED = 'editingStarted';
/**
 * Specifies the event name for editingStopped.
 */ InternalEvent.EDITING_STOPPED = 'editingStopped';
/**
 * Specifies the event name for addOverlay.
 */ InternalEvent.ADD_OVERLAY = 'addOverlay';
/**
 * Specifies the event name for removeOverlay.
 */ InternalEvent.REMOVE_OVERLAY = 'removeOverlay';
/**
 * Specifies the event name for updateCellSize.
 */ InternalEvent.UPDATE_CELL_SIZE = 'updateCellSize';
/**
 * Specifies the event name for escape.
 */ InternalEvent.ESCAPE = 'escape';
/**
 * Specifies the event name for doubleClick.
 */ InternalEvent.DOUBLE_CLICK = 'doubleClick';
/**
 * Specifies the event name for start.
 */ InternalEvent.START = 'start';
/**
 * Specifies the event name for reset.
 */ InternalEvent.RESET = 'reset';
/**
 * Threshold for pinch gestures to fire a mouse wheel event.
 * Default value is 10.
 */ InternalEvent.PINCH_THRESHOLD = 10;
const __TURBOPACK__default__export__ = InternalEvent;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript) <export default as InternalEvent>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "InternalEvent": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ /**
 * The mxEventObject is a wrapper for all properties of a single event.
 * Additionally, it also offers functions to consume the event and check if it
 * was consumed as follows:
 *
 * ```javascript
 * evt.consume();
 * INV: evt.isConsumed() == true
 * ```
 *
 * Constructor: mxEventObject
 *
 * Constructs a new event object with the specified name. An optional
 * sequence of key, value pairs can be appended to define properties.
 *
 * Example:
 *
 * ```javascript
 * new mxEventObject("eventName", key1, val1, .., keyN, valN)
 * ```
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
class EventObject {
    constructor(name = '', ...args){
        /**
         * Holds the consumed state. Default is false.
         */ this.consumed = false;
        this.name = name;
        this.properties = {};
        if (!!args[0] && args[0].constructor === Object) {
            // A literal object ({})
            for (const [key, value] of Object.entries(args[0])){
                this.properties[key] = value;
            }
        } else {
            // two-values [key, value, key, value, ...]
            for(let i = 0; i < args.length; i += 2){
                if (args[i + 1] !== null) {
                    this.properties[args[i]] = args[i + 1];
                }
            }
        }
    }
    /**
     * Returns <name>.
     */ getName() {
        return this.name;
    }
    /**
     * Returns <properties>.
     */ getProperties() {
        return this.properties;
    }
    /**
     * Returns the property for the given key.
     */ getProperty(key) {
        return this.properties[key];
    }
    /**
     * Returns true if the event has been consumed.
     */ isConsumed() {
        return this.consumed;
    }
    /**
     * Consumes the event.
     */ consume() {
        this.consumed = true;
    }
}
const __TURBOPACK__default__export__ = EventObject;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/event/EventSource.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
;
/**
 * Base class for objects that dispatch named events. To create a subclass that
 * inherits from mxEventSource, the following code is used.
 *
 * ```javascript
 * function MyClass() { };
 *
 * MyClass.prototype = new mxEventSource();
 * constructor = MyClass;
 * ```
 *
 * Known Subclasses:
 *
 * <Transactions>, {@link Graph}, {@link GraphView}, <Editor>, <CellOverlay>,
 * <MaxToolbar>, <MaxWindow>
 *
 * Constructor: mxEventSource
 *
 * Constructs a new event source.
 */ class EventSource {
    constructor(eventSource = null){
        /**
         * Holds the event names and associated listeners in an array. The array
         * contains the event name followed by the respective listener for each
         * registered listener.
         */ this.eventListeners = [];
        /**
         * Specifies if events can be fired. Default is true.
         */ this.eventsEnabled = true;
        /**
         * Optional source for events. Default is null.
         */ this.eventSource = null;
        this.eventSource = eventSource;
    }
    /**
     * Returns <eventsEnabled>.
     */ isEventsEnabled() {
        return this.eventsEnabled;
    }
    /**
     * Sets <eventsEnabled>.
     */ setEventsEnabled(value) {
        this.eventsEnabled = value;
    }
    /**
     * Returns <eventSource>.
     */ getEventSource() {
        return this.eventSource;
    }
    /**
     * Sets <eventSource>.
     */ setEventSource(value) {
        this.eventSource = value;
    }
    /**
     * Binds the specified function to the given event name. If no event name
     * is given, then the listener is registered for all events.
     *
     * The parameters of the listener are the sender and an {@link EventObject}.
     */ addListener(name, funct) {
        this.eventListeners.push({
            name,
            funct
        });
    }
    /**
     * Removes all occurrences of the given listener from <eventListeners>.
     */ removeListener(funct) {
        let i = 0;
        while(i < this.eventListeners.length){
            if (this.eventListeners[i].funct === funct) {
                this.eventListeners.splice(i, 1);
            } else {
                i += 1;
            }
        }
    }
    /**
     * Dispatches the given event to the listeners which are registered for
     * the event. The sender argument is optional. The current execution scope
     * ("this") is used for the listener invocation (see {@link Utils#bind}).
     *
     * Example:
     *
     * ```javascript
     * fireEvent(new mxEventObject("eventName", key1, val1, .., keyN, valN))
     * ```
     *
     * @param evt {@link EventObject} that represents the event.
     * @param sender Optional sender to be passed to the listener. Default value is
     * the return value of <getEventSource>.
     */ fireEvent(evt, sender = null) {
        if (this.isEventsEnabled()) {
            if (!evt) {
                evt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('');
            }
            if (!sender) {
                sender = this.getEventSource();
            }
            if (!sender) {
                sender = this;
            }
            for (const eventListener of this.eventListeners){
                if (eventListener.name === null || eventListener.name === evt.getName()) {
                    eventListener.funct.apply(this, [
                        sender,
                        evt
                    ]);
                }
            }
        }
    }
}
const __TURBOPACK__default__export__ = EventSource;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/canvas/AbstractCanvas2D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$UrlConverter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/UrlConverter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/config.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cloneUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/cloneUtils.js [app-client] (ecmascript)");
;
;
;
;
;
;
/**
 * Base class for all canvases.
 *
 * The following methods make up the public interface of the canvas 2D for all painting in mxGraph:
 *
 * - {@link save}, {@link restore}
 * - {@link scale}, {@link translate}, {@link rotate}
 * - {@link setAlpha}, {@link setFillAlpha}, {@link setStrokeAlpha}, {@link setFillColor}, {@link setGradient},
 *   {@link setStrokeColor}, {@link setStrokeWidth}, {@link setDashed}, {@link setDashPattern}, {@link setLineCap},
 *   {@link setLineJoin}, {@link setMiterLimit}
 * - {@link setFontColor}, {@link setFontBackgroundColor}, {@link setFontBorderColor}, {@link setFontSize},
 *   {@link setFontFamily}, {@link setFontStyle}
 * - {@link setShadow}, {@link setShadowColor}, {@link setShadowAlpha}, {@link setShadowOffset}
 * - {@link rect}, {@link roundrect}, {@link ellipse}, {@link image}, {@link text}
 * - {@link begin}, {@link moveTo}, {@link lineTo}, {@link quadTo}, {@link curveTo}
 * - {@link stroke}, {@link fill}, {@link fillAndStroke}
 *
 * {@link arcTo} is an additional method for drawing paths.
 * This is a synthetic method, meaning that it is turned into a sequence of curves by default.
 * Subclasses may add native support for arcs.
 *
 * All color values of {@link NONE} will be converted to null in the state.
 */ class AbstractCanvas2D {
    constructor(){
        /**
         * Holds the current state.
         */ this.state = this.createState();
        /**
         * Stack of states.
         */ this.states = [];
        /**
         * Holds the current path as an array.
         */ this.path = [];
        /**
         * Switch for rotation of HTML. Default is false.
         */ this.rotateHtml = true;
        /**
         * Holds the last x coordinate.
         */ this.lastX = 0;
        /**
         * Holds the last y coordinate.
         */ this.lastY = 0;
        /**
         * Contains the string used for moving in paths. Default is 'M'.
         */ this.moveOp = 'M';
        /**
         * Contains the string used for moving in paths. Default is 'L'.
         */ this.lineOp = 'L';
        /**
         * Contains the string used for quadratic paths. Default is 'Q'.
         */ this.quadOp = 'Q';
        /**
         * Contains the string used for bezier curves. Default is 'C'.
         */ this.curveOp = 'C';
        /**
         * Holds the operator for closing curves. Default is 'Z'.
         */ this.closeOp = 'Z';
        /**
         * Boolean value that specifies if events should be handled. Default is false.
         */ this.pointerEvents = false;
        // from Polyline (maybe from other shapes also)
        this.pointerEventsValue = null;
        /**
         * Adds the given operation to the path.
         */ this.addOp = (op, ...args)=>{
            this.path.push(op);
            if (args.length > 1) {
                const s = this.state;
                for(let i = 1; i < args.length; i += 2){
                    this.lastX = args[i - 1];
                    this.lastY = args[i];
                    this.path.push(this.format((this.lastX + s.dx) * s.scale));
                    this.path.push(this.format((this.lastY + s.dy) * s.scale));
                }
            }
        };
        this.converter = this.createUrlConverter();
        this.reset();
    }
    /**
     * Create a new <UrlConverter> and returns it.
     */ createUrlConverter() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$UrlConverter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    }
    /**
     * Resets the state of this canvas.
     */ reset() {
        this.state = this.createState();
        this.states = [];
    }
    /**
     * Creates the state of the this canvas.
     */ createState() {
        return {
            dx: 0,
            dy: 0,
            scale: 1,
            alpha: 1,
            fillAlpha: 1,
            strokeAlpha: 1,
            fillColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"],
            gradientFillAlpha: 1,
            gradientColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"],
            gradientAlpha: 1,
            gradientDirection: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST,
            strokeColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"],
            strokeWidth: 1,
            dashed: false,
            dashPattern: '3 3',
            fixDash: false,
            lineCap: 'flat',
            lineJoin: 'miter',
            miterLimit: 10,
            fontColor: '#000000',
            fontBackgroundColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"],
            fontBorderColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"],
            fontSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONTSIZE"],
            fontFamily: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONTFAMILY"],
            fontStyle: 0,
            shadow: false,
            shadowColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StyleDefaultsConfig"].shadowColor,
            shadowAlpha: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StyleDefaultsConfig"].shadowOpacity,
            shadowDx: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StyleDefaultsConfig"].shadowOffsetX,
            shadowDy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StyleDefaultsConfig"].shadowOffsetY,
            rotation: 0,
            rotationCx: 0,
            rotationCy: 0
        };
    }
    /**
     * Rounds all numbers to integers.
     */ format(value) {
        return Math.round(value);
    }
    /**
     * Rotates the given point and returns the result as an {@link Point}.
     */ rotatePoint(x, y, theta, cx, cy) {
        const rad = theta * (Math.PI / 180);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRotatedPoint"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y), Math.cos(rad), Math.sin(rad), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](cx, cy));
    }
    /**
     * Saves the current state.
     */ save() {
        this.states.push(this.state);
        this.state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cloneUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this.state);
    }
    /**
     * Restores the current state.
     */ restore() {
        const state = this.states.pop();
        if (state) this.state = state;
    }
    /**
     * Sets the current link. Hook for subclassers.
     */ setLink(link) {
    // nop
    }
    /**
     * Scales the current state.
     */ scale(value) {
        this.state.scale *= value;
        if (this.state.strokeWidth !== null) this.state.strokeWidth *= value;
    }
    /**
     * Translates the current state.
     */ translate(dx, dy) {
        this.state.dx += dx;
        this.state.dy += dy;
    }
    /**
     * Rotates the current state.
     */ rotate(theta, flipH, flipV, cx, cy) {
    // nop
    }
    /**
     * Sets the current alpha.
     */ setAlpha(value) {
        this.state.alpha = value;
    }
    /**
     * Sets the current solid fill alpha.
     */ setFillAlpha(value) {
        this.state.fillAlpha = value;
    }
    /**
     * Sets the current stroke alpha.
     */ setStrokeAlpha(value) {
        this.state.strokeAlpha = value;
    }
    /**
     * Sets the current fill color.
     */ setFillColor(value) {
        this.state.fillColor = value ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
        this.state.gradientColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
    }
    /**
     * Sets the current gradient.
     */ setGradient(color1, color2, x, y, w, h, direction, alpha1 = 1, alpha2 = 1) {
        const s = this.state;
        s.fillColor = color1;
        s.gradientFillAlpha = alpha1;
        s.gradientColor = color2;
        s.gradientAlpha = alpha2;
        s.gradientDirection = direction;
    }
    /**
     * Sets the current stroke color.
     */ setStrokeColor(value) {
        this.state.strokeColor = value ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
    }
    /**
     * Sets the current stroke width.
     */ setStrokeWidth(value) {
        this.state.strokeWidth = value;
    }
    /**
     * Enables or disables dashed lines.
     */ setDashed(value, fixDash = false) {
        this.state.dashed = value;
        this.state.fixDash = fixDash;
    }
    /**
     * Sets the current dash pattern.
     */ setDashPattern(value) {
        this.state.dashPattern = value;
    }
    /**
     * Sets the current line cap.
     */ setLineCap(value) {
        this.state.lineCap = value;
    }
    /**
     * Sets the current line join.
     */ setLineJoin(value) {
        this.state.lineJoin = value;
    }
    /**
     * Sets the current miter limit.
     */ setMiterLimit(value) {
        this.state.miterLimit = value;
    }
    /**
     * Sets the current font color.
     */ setFontColor(value) {
        this.state.fontColor = value ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
    }
    /**
     * Sets the current font background color.
     */ setFontBackgroundColor(value) {
        this.state.fontBackgroundColor = value ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
    }
    /**
     * Sets the current font border color.
     */ setFontBorderColor(value) {
        this.state.fontBorderColor = value ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
    }
    /**
     * Sets the current font size.
     */ setFontSize(value) {
        this.state.fontSize = value;
    }
    /**
     * Sets the current font family.
     */ setFontFamily(value) {
        this.state.fontFamily = value;
    }
    /**
     * Sets the current font style.
     */ setFontStyle(value) {
        this.state.fontStyle = value;
    }
    /**
     * Enables or disables and configures the current shadow.
     */ setShadow(enabled) {
        this.state.shadow = enabled;
    }
    /**
     * Sets the current shadow color.
     *
     * @param value Hexadecimal representation of the color or `none`.
     */ setShadowColor(value) {
        this.state.shadowColor = value ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
    }
    /**
     * Sets the current shadow alpha.
     *
     * @param value Number that represents the new alpha. Possible values are between 1 (opaque) and 0 (transparent).
     */ setShadowAlpha(value) {
        this.state.shadowAlpha = value;
    }
    /**
     * Sets the current shadow offset.
     *
     * @param dx Number that represents the horizontal offset of the shadow.
     * @param dy Number that represents the vertical offset of the shadow.
     */ setShadowOffset(dx, dy) {
        this.state.shadowDx = dx;
        this.state.shadowDy = dy;
    }
    /**
     * Starts a new path.
     */ begin() {
        this.lastX = 0;
        this.lastY = 0;
        this.path = [];
    }
    /**
     *  Moves the current path the given coordinates.
     */ moveTo(x, y) {
        this.addOp(this.moveOp, x, y);
    }
    /**
     * Draws a line to the given coordinates. Uses moveTo with the op argument.
     */ lineTo(x, y) {
        this.addOp(this.lineOp, x, y);
    }
    /**
     * Adds a quadratic curve to the current path.
     */ quadTo(x1, y1, x2, y2) {
        this.addOp(this.quadOp, x1, y1, x2, y2);
    }
    /**
     * Adds a bezier curve to the current path.
     */ curveTo(x1, y1, x2, y2, x3, y3) {
        this.addOp(this.curveOp, x1, y1, x2, y2, x3, y3);
    }
    /**
     * Adds the given arc to the current path. This is a synthetic operation that
     * is broken down into curves.
     * @param rx: The x distance between the current position
     *            and the center of the ellipse around which to arc
     * @param ry: The y distance between the current position
     *            and the center of the ellipse around which to arc
     * @param x: The x position of the end point of the arc
     * @param y: The y position of the end point of the arc
     */ arcTo(rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
        const curves = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arcToCurves"])(this.lastX, this.lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y);
        if (curves != null) {
            for(let i = 0; i < curves.length; i += 6){
                this.curveTo(curves[i], curves[i + 1], curves[i + 2], curves[i + 3], curves[i + 4], curves[i + 5]);
            }
        }
    }
    /**
     * Closes the current path.
     */ close(x1, y1, x2, y2, x3, y3) {
        this.addOp(this.closeOp);
    }
}
const __TURBOPACK__default__export__ = AbstractCanvas2D;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/canvas/SvgCanvas2D.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/domUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$xmlUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/xmlUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/StringUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$canvas$2f$AbstractCanvas2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/canvas/AbstractCanvas2D.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
// Activates workaround for gradient ID resolution if base tag is used.
const useAbsoluteIds = typeof DOMParser === 'function' && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_CHROMEAPP && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_EDGE && document.getElementsByTagName('base').length > 0;
/**
 * Extends {@link mxAbstractCanvas2D} to implement a canvas for SVG. This canvas writes all calls as SVG output to the
 * given SVG root node.
 *
 * ```javascript
 * var svgDoc = mxUtils.createXmlDocument();
 * var root = (svgDoc.createElementNS != null) ?
 * 		svgDoc.createElementNS(mxConstants.NS_SVG, 'svg') : svgDoc.createElement('svg');
 *
 * if (svgDoc.createElementNS == null)
 * {
 *   root.setAttribute('xmlns', mxConstants.NS_SVG);
 *   root.setAttribute('xmlns:xlink', mxConstants.NS_XLINK);
 * }
 * else
 * {
 *   root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', mxConstants.NS_XLINK);
 * }
 *
 * var bounds = graph.getGraphBounds();
 * root.setAttribute('width', (bounds.x + bounds.width + 4) + 'px');
 * root.setAttribute('height', (bounds.y + bounds.height + 4) + 'px');
 * root.setAttribute('version', '1.1');
 *
 * svgDoc.appendChild(root);
 *
 * var svgCanvas = new mxSvgCanvas2D(root);
 * ```
 *
 *
 * To disable anti-aliasing in the output, use the following code.
 * ```javascript
 * graph.view.canvas.ownerSVGElement.setAttribute('shape-rendering', 'crispEdges');
 * ```
 * Or set the respective attribute in the SVG element directly.
 */ class SvgCanvas2D extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$canvas$2f$AbstractCanvas2D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(root, styleEnabled){
        super();
        this.defs = null;
        this.styleEnabled = true;
        /**
         * Holds the current DOM node.
         */ this.node = null;
        /**
         * Specifies if plain text output should match the vertical HTML alignment.
         * @default true.
         */ this.matchHtmlAlignment = true;
        /**
         * Specifies if text output should be enabled.
         * @default true
         */ this.textEnabled = true;
        /**
         * Specifies if use of foreignObject for HTML markup is allowed.
         * @default true
         */ this.foEnabled = true;
        /**
         * Specifies the fallback text for unsupported foreignObjects in exported documents.
         * If this is set to `null` then no fallback text is added to the exported document.
         * @default [Object]
         */ this.foAltText = '[Object]';
        /**
         * Offset to be used for foreignObjects.
         * @default 0
         */ this.foOffset = 0;
        /**
         * Offset to be used for text elements.
         * @default 0
         */ this.textOffset = 0;
        /**
         * Offset to be used for image elements.
         * @default 0
         */ this.imageOffset = 0;
        /**
         * Adds transparent paths for strokes.
         * @default 0
         */ this.strokeTolerance = 0;
        /**
         * Minimum stroke width for output.
         * @default 1
         */ this.minStrokeWidth = 1;
        /**
         * Local counter for references in SVG export.
         * @default 0
         */ this.refCount = 0;
        /**
         * Correction factor for {@link mxConstants.LINE_HEIGHT} in HTML output.
         * @default 1
         */ this.lineHeightCorrection = 1;
        /**
         * Default value for active pointer events.
         * @default all
         */ this.pointerEventsValue = 'all';
        /**
         * Padding to be added for text that is not wrapped to account for differences in font metrics on different platforms in pixels.
         * @default 10.
         */ this.fontMetricsPadding = 10;
        /**
         * Specifies if offsetWidth and offsetHeight should be cached. This is used to speed up repaint of text in {@link updateText}.
         * @default true
         */ this.cacheOffsetSize = true;
        this.originalRoot = null;
        /**
         * Reference to the container for the SVG content.
         */ this.root = root;
        /**
         * Local cache of gradients for quick lookups.
         */ this.gradients = {};
        /**
         * Reference to the defs section of the SVG document. Only for export.
         */ this.defs = null;
        /**
         * Stores the value of styleEnabled passed to the constructor.
         */ this.styleEnabled = styleEnabled != null ? styleEnabled : false;
        let svg = null;
        // Adds optional defs section for export
        if (root.ownerDocument !== document) {
            let node = root;
            // Finds owner SVG element in XML DOM
            while(node && node.nodeName !== 'svg'){
                node = node.parentElement;
            }
            svg = node;
        }
        if (svg) {
            // Tries to get existing defs section
            const tmp = svg.getElementsByTagName('defs');
            if (tmp.length > 0) {
                this.defs = svg.getElementsByTagName('defs')[0];
            }
            // Adds defs section if none exists
            if (!this.defs) {
                this.defs = this.createElement('defs');
                if (svg.firstChild != null) {
                    svg.insertBefore(this.defs, svg.firstChild);
                } else {
                    svg.appendChild(this.defs);
                }
            }
            // Adds stylesheet
            if (this.styleEnabled) {
                this.defs.appendChild(this.createStyle());
            }
        }
    }
    /**
     * Rounds all numbers to 2 decimal points.
     */ format(value) {
        return parseFloat(value.toFixed(2));
    }
    /**
     * Returns the URL of the page without the hash part. This needs to use href to
     * include any search part with no params (ie question mark alone). This is a
     * workaround for the fact that window.location.search is empty if there is
     * no search string behind the question mark.
     */ getBaseUrl() {
        let { href } = window.location;
        const hash = href.lastIndexOf('#');
        if (hash > 0) {
            href = href.substring(0, hash);
        }
        return href;
    }
    /**
     * Returns any offsets for rendering pixels.
     */ reset() {
        super.reset();
        this.gradients = {};
    }
    end() {
        return;
    }
    /**
     * Creates the optional style section.
     */ createStyle() {
        const style = this.createElement('style');
        style.setAttribute('type', 'text/css');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["write"])(style, `svg{font-family:${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONTFAMILY"]};font-size:${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONTSIZE"]};fill:none;stroke-miterlimit:10}`);
        return style;
    }
    /**
     * Private helper function to create SVG elements
     */ createElement(tagName, namespace) {
        return this.root?.ownerDocument.createElementNS(namespace || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NS_SVG"], tagName);
    }
    /**
     * Returns the alternate text string for the given foreignObject.
     */ getAlternateText(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNotNullish"])(str) ? this.foAltText : null;
    }
    /**
     * Returns the alternate content for the given foreignObject.
     */ createAlternateContent(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation) {
        const text = this.getAlternateText(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation);
        const s = this.state;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNotNullish"])(text) && s.fontSize > 0) {
            const dy = valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].TOP ? 1 : valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].BOTTOM ? 0 : 0.3;
            const anchor = align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT ? 'end' : align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].LEFT ? 'start' : 'middle';
            const alt = this.createElement('text');
            alt.setAttribute('x', String(Math.round(x + s.dx)));
            alt.setAttribute('y', String(Math.round(y + s.dy + dy * s.fontSize)));
            alt.setAttribute('fill', s.fontColor || 'black');
            alt.setAttribute('font-family', s.fontFamily);
            alt.setAttribute('font-size', `${Math.round(s.fontSize)}px`);
            // Text-anchor start is default in SVG
            anchor !== 'start' && alt.setAttribute('text-anchor', anchor);
            const fontStyle = s.fontStyle;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].BOLD) && alt.setAttribute('font-weight', 'bold');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].ITALIC) && alt.setAttribute('font-style', 'italic');
            const txtDecor = [];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].UNDERLINE) && txtDecor.push('underline');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].STRIKETHROUGH) && txtDecor.push('line-through');
            txtDecor.length > 0 && alt.setAttribute('text-decoration', txtDecor.join(' '));
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["write"])(alt, text);
            return alt;
        }
        return null;
    }
    /**
     * Private helper function to create SVG elements
     */ createGradientId(start, end, alpha1, alpha2, direction) {
        // Removes illegal characters from gradient ID
        if (start.charAt(0) === '#') {
            start = start.substring(1);
        }
        if (end.charAt(0) === '#') {
            end = end.substring(1);
        }
        // Workaround for gradient IDs not working in Safari 5 / Chrome 6
        // if they contain uppercase characters
        start = `${start.toLowerCase()}-${alpha1}`;
        end = `${end.toLowerCase()}-${alpha2}`;
        // Wrong gradient directions possible?
        let dir = null;
        if (direction == null || direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) {
            dir = 's';
        } else if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST) {
            dir = 'e';
        } else {
            const tmp = start;
            start = end;
            end = tmp;
            if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH) {
                dir = 's';
            } else if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST) {
                dir = 'e';
            }
        }
        return `mx-gradient-${start}-${end}-${dir}`;
    }
    /**
     * Private helper function to create SVG elements
     */ getSvgGradient(start, end, alpha1, alpha2, direction) {
        const id = this.createGradientId(start, end, alpha1, alpha2, direction);
        let gradient = this.gradients[id];
        if (!gradient) {
            const svg = this.root.ownerSVGElement;
            let counter = 0;
            let tmpId = `${id}-${counter}`;
            if (svg) {
                gradient = svg.ownerDocument.getElementById(tmpId);
                while(gradient && gradient.ownerSVGElement !== svg){
                    tmpId = `${id}-${counter++}`;
                    gradient = svg.ownerDocument.getElementById(tmpId);
                }
            } else {
                // Uses shorter IDs for export
                tmpId = `id${++this.refCount}`;
            }
            if (!gradient) {
                gradient = this.createSvgGradient(start, end, alpha1, alpha2, direction);
                gradient.setAttribute('id', tmpId);
                if (this.defs) {
                    this.defs.appendChild(gradient);
                } else if (svg) {
                    svg.appendChild(gradient);
                }
            }
            this.gradients[id] = gradient;
        }
        return gradient.getAttribute('id');
    }
    /**
     * Creates the given SVG gradient.
     */ createSvgGradient(start, end, alpha1, alpha2, direction) {
        const gradient = this.createElement('linearGradient');
        gradient.setAttribute('x1', '0%');
        gradient.setAttribute('y1', '0%');
        gradient.setAttribute('x2', '0%');
        gradient.setAttribute('y2', '0%');
        if (direction == null || direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) {
            gradient.setAttribute('y2', '100%');
        } else if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST) {
            gradient.setAttribute('x2', '100%');
        } else if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH) {
            gradient.setAttribute('y1', '100%');
        } else if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST) {
            gradient.setAttribute('x1', '100%');
        }
        let op = alpha1 < 1 ? `;stop-opacity:${alpha1}` : '';
        let stop = this.createElement('stop');
        stop.setAttribute('offset', '0%');
        stop.setAttribute('style', `stop-color:${start}${op}`);
        gradient.appendChild(stop);
        op = alpha2 < 1 ? `;stop-opacity:${alpha2}` : '';
        stop = this.createElement('stop');
        stop.setAttribute('offset', '100%');
        stop.setAttribute('style', `stop-color:${end}${op}`);
        gradient.appendChild(stop);
        return gradient;
    }
    /**
     * Private helper function to create SVG elements
     */ addNode(filled, stroked) {
        const { node } = this;
        const s = this.state;
        if (node) {
            if (node.nodeName === 'path') {
                // Checks if the path is not empty
                if (this.path && this.path.length > 0) {
                    node.setAttribute('d', this.path.join(' '));
                } else {
                    return;
                }
            }
            if (filled && s.fillColor !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
                this.updateFill();
            } else if (!this.styleEnabled) {
                // Workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=814952
                if (node.nodeName === 'ellipse' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_FF) {
                    node.setAttribute('fill', 'transparent');
                } else {
                    node.setAttribute('fill', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]);
                }
                // Sets the actual filled state for stroke tolerance
                filled = false;
            }
            if (stroked && s.strokeColor !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
                this.updateStroke();
            } else if (!this.styleEnabled) {
                node.setAttribute('stroke', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]);
            }
            if (s.transform && s.transform.length > 0) {
                node.setAttribute('transform', s.transform);
            }
            if (s.shadow) {
                this.root.appendChild(this.createShadow(node));
            }
            // Adds stroke tolerance
            if (this.strokeTolerance > 0 && !filled) {
                this.root.appendChild(this.createTolerance(node));
            }
            // Adds pointer events
            if (this.pointerEvents) {
                node.setAttribute('pointer-events', this.pointerEventsValue);
            } else if (!this.pointerEvents && !this.originalRoot) {
                node.setAttribute('pointer-events', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]);
            }
            // Removes invisible nodes from output if they don't handle events
            if (node.nodeName !== 'rect' && node.nodeName !== 'path' && node.nodeName !== 'ellipse' || node.getAttribute('fill') !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"] && node.getAttribute('fill') !== 'transparent' || node.getAttribute('stroke') !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"] || node.getAttribute('pointer-events') !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
                // LATER: Update existing DOM for performance
                this.root.appendChild(node);
            }
            this.node = null;
        }
    }
    /**
     * Transfers the stroke attributes from <state> to <node>.
     */ updateFill() {
        const s = this.state;
        if (s.alpha < 1 || s.fillAlpha < 1) {
            this.node.setAttribute('fill-opacity', String(s.alpha * s.fillAlpha));
        }
        if (s.fillColor !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
            if (s.gradientColor !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
                const id = this.getSvgGradient(s.fillColor, s.gradientColor, s.gradientFillAlpha, s.gradientAlpha, s.gradientDirection);
                if (this.root?.ownerDocument === document && useAbsoluteIds) {
                    // Workaround for no fill with base tag in page (escape brackets)
                    const base = this.getBaseUrl().replace(/([()])/g, '\\$1');
                    this.node.setAttribute('fill', `url(${base}#${id})`);
                } else {
                    this.node.setAttribute('fill', `url(#${id})`);
                }
            } else {
                this.node.setAttribute('fill', s.fillColor.toLowerCase());
            }
        }
    }
    /**
     * Returns the current stroke width (>= 1), ie. max(1, this.format(this.state.strokeWidth * this.state.scale)).
     */ getCurrentStrokeWidth() {
        return Math.max(this.minStrokeWidth, Math.max(0.01, this.format(this.state.strokeWidth * this.state.scale)));
    }
    /**
     * Transfers the stroke attributes from {@link mxAbstractCanvas2D.state} to {@link node}.
     */ updateStroke() {
        const s = this.state;
        if (s.strokeColor && s.strokeColor !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
            this.node.setAttribute('stroke', s.strokeColor.toLowerCase());
        }
        if (s.alpha < 1 || s.strokeAlpha < 1) {
            this.node.setAttribute('stroke-opacity', String(s.alpha * s.strokeAlpha));
        }
        const sw = this.getCurrentStrokeWidth();
        if (sw !== 1) {
            this.node.setAttribute('stroke-width', String(sw));
        }
        if (this.node.nodeName === 'path') {
            this.updateStrokeAttributes();
        }
        if (s.dashed) {
            this.node.setAttribute('stroke-dasharray', this.createDashPattern((s.fixDash ? 1 : s.strokeWidth) * s.scale));
        }
    }
    /**
     * Transfers the stroke attributes from {@link mxAbstractCanvas2D.state} to {@link node}.
     */ updateStrokeAttributes() {
        const s = this.state;
        // Linejoin miter is default in SVG
        if (s.lineJoin && s.lineJoin !== 'miter') {
            this.node.setAttribute('stroke-linejoin', s.lineJoin);
        }
        if (s.lineCap) {
            // flat is called butt in SVG
            let value = s.lineCap;
            if (value === 'flat') {
                value = 'butt';
            }
            // Linecap butt is default in SVG
            if (value !== 'butt') {
                this.node.setAttribute('stroke-linecap', value);
            }
        }
        // Miterlimit 10 is default in our document
        if (s.miterLimit != null && (!this.styleEnabled || s.miterLimit !== 10)) {
            this.node.setAttribute('stroke-miterlimit', String(s.miterLimit));
        }
    }
    /**
     * Creates the SVG dash pattern for the given state.
     */ createDashPattern(scale) {
        const pat = [];
        if (typeof this.state.dashPattern === 'string') {
            const dash = this.state.dashPattern.split(' ');
            if (dash.length > 0) {
                for(let i = 0; i < dash.length; i += 1){
                    pat[i] = Number(dash[i]) * scale;
                }
            }
        }
        return pat.join(' ');
    }
    /**
     * Creates a hit detection tolerance shape for the given node.
     */ createTolerance(node) {
        const tol = node.cloneNode(true);
        const sw = parseFloat(tol.getAttribute('stroke-width') || '1') + this.strokeTolerance;
        tol.setAttribute('pointer-events', 'stroke');
        tol.setAttribute('visibility', 'hidden');
        tol.removeAttribute('stroke-dasharray');
        tol.setAttribute('stroke-width', String(sw));
        tol.setAttribute('fill', 'none');
        tol.setAttribute('stroke', 'white');
        return tol;
    }
    /**
     * Creates a shadow for the given node.
     */ createShadow(node) {
        const shadow = node.cloneNode(true);
        const s = this.state;
        // Firefox uses transparent for no fill in ellipses
        if (shadow.getAttribute('fill') !== 'none' && (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_FF || shadow.getAttribute('fill') !== 'transparent')) {
            shadow.setAttribute('fill', s.shadowColor);
        }
        if (shadow.getAttribute('stroke') !== 'none' && s.shadowColor && s.shadowColor !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
            shadow.setAttribute('stroke', s.shadowColor);
        }
        shadow.setAttribute('transform', `translate(${this.format(s.shadowDx * s.scale)},${this.format(s.shadowDy * s.scale)})${s.transform || ''}`);
        shadow.setAttribute('opacity', String(s.shadowAlpha));
        return shadow;
    }
    /**
     * Experimental implementation for hyperlinks.
     */ setLink(link) {
        if (!link) {
            this.root = this.originalRoot;
        } else {
            this.originalRoot = this.root;
            const node = this.createElement('a');
            // Workaround for implicit namespace handling in HTML5 export, IE adds NS1 namespace so use code below
            // in all IE versions except quirks mode. KNOWN: Adds xlink namespace to each image tag in output.
            if (node.setAttributeNS == null || this.root.ownerDocument !== document) {
                node.setAttribute('xlink:href', link);
            } else {
                node.setAttributeNS(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NS_XLINK"], 'xlink:href', link);
            }
            this.root.appendChild(node);
            this.root = node;
        }
    }
    /**
     * Sets the rotation of the canvas. Note that rotation cannot be concatenated.
     */ rotate(theta, flipH, flipV, cx, cy) {
        if (theta !== 0 || flipH || flipV) {
            const s = this.state;
            cx += s.dx;
            cy += s.dy;
            cx *= s.scale;
            cy *= s.scale;
            s.transform = s.transform || '';
            // This implementation uses custom scale/translate and built-in rotation
            // Rotation state is part of the AffineTransform in state.transform
            if (flipH && flipV) {
                theta += 180;
            } else if (flipH !== flipV) {
                const tx = flipH ? cx : 0;
                const sx = flipH ? -1 : 1;
                const ty = flipV ? cy : 0;
                const sy = flipV ? -1 : 1;
                s.transform += `translate(${this.format(tx)},${this.format(ty)})` + `scale(${this.format(sx)},${this.format(sy)})` + `translate(${this.format(-tx)},${this.format(-ty)})`;
            }
            if (flipH ? !flipV : flipV) {
                theta *= -1;
            }
            if (theta !== 0) {
                s.transform += `rotate(${this.format(theta)},${this.format(cx)},${this.format(cy)})`;
            }
            s.rotation += theta;
            s.rotationCx = cx;
            s.rotationCy = cy;
        }
    }
    /**
     * Extends superclass to create path.
     */ begin() {
        super.begin();
        this.node = this.createElement('path');
    }
    /**
     * Private helper function to create SVG elements
     */ rect(x, y, w, h) {
        const s = this.state;
        const n = this.createElement('rect');
        n.setAttribute('x', String(this.format((x + s.dx) * s.scale)));
        n.setAttribute('y', String(this.format((y + s.dy) * s.scale)));
        n.setAttribute('width', String(this.format(w * s.scale)));
        n.setAttribute('height', String(this.format(h * s.scale)));
        this.node = n;
    }
    /**
     * Private helper function to create SVG elements
     */ roundrect(x, y, w, h, dx, dy) {
        this.rect(x, y, w, h);
        if (dx > 0) {
            this.node.setAttribute('rx', String(this.format(dx * this.state.scale)));
        }
        if (dy > 0) {
            this.node.setAttribute('ry', String(this.format(dy * this.state.scale)));
        }
    }
    /**
     * Private helper function to create SVG elements
     */ ellipse(x, y, w, h) {
        const s = this.state;
        const n = this.createElement('ellipse');
        // No rounding for consistent output with 1.x
        n.setAttribute('cx', String(this.format((x + w / 2 + s.dx) * s.scale)));
        n.setAttribute('cy', String(this.format((y + h / 2 + s.dy) * s.scale)));
        n.setAttribute('rx', String(w / 2 * s.scale));
        n.setAttribute('ry', String(h / 2 * s.scale));
        this.node = n;
    }
    /**
     * Private helper function to create SVG elements
     */ image(x, y, w, h, src, aspect = true, flipH = false, flipV = false) {
        src = this.converter.convert(src);
        const s = this.state;
        x += s.dx;
        y += s.dy;
        const node = this.createElement('image');
        node.setAttribute('x', String(this.format(x * s.scale) + this.imageOffset));
        node.setAttribute('y', String(this.format(y * s.scale) + this.imageOffset));
        node.setAttribute('width', String(this.format(w * s.scale)));
        node.setAttribute('height', String(this.format(h * s.scale)));
        // Workaround for missing namespace support
        if (!node.setAttributeNS) {
            node.setAttribute('xlink:href', src);
        } else {
            node.setAttributeNS(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NS_XLINK"], 'xlink:href', src);
        }
        if (!aspect) {
            node.setAttribute('preserveAspectRatio', 'none');
        }
        if (s.alpha < 1 || s.fillAlpha < 1) {
            node.setAttribute('opacity', String(s.alpha * s.fillAlpha));
        }
        let tr = this.state.transform || '';
        if (flipH || flipV) {
            let sx = 1;
            let sy = 1;
            let dx = 0;
            let dy = 0;
            if (flipH) {
                sx = -1;
                dx = -w - 2 * x;
            }
            if (flipV) {
                sy = -1;
                dy = -h - 2 * y;
            }
            // Adds image transformation to existing transform
            tr += `scale(${sx},${sy})translate(${dx * s.scale},${dy * s.scale})`;
        }
        if (tr.length > 0) {
            node.setAttribute('transform', tr);
        }
        if (!this.pointerEvents) {
            node.setAttribute('pointer-events', 'none');
        }
        this.root.appendChild(node);
    }
    /**
     * Converts the given HTML string to XHTML.
     */ convertHtml(val) {
        const doc = new DOMParser().parseFromString(val, 'text/html');
        if (doc != null) {
            val = new XMLSerializer().serializeToString(doc.body);
            // Extracts body content from DOM
            if (val.substring(0, 5) === '<body') {
                val = val.substring(val.indexOf('>', 5) + 1);
            }
            if (val.substring(val.length - 7, val.length) === '</body>') {
                val = val.substring(0, val.length - 7);
            }
        }
        return val;
    }
    /**
     * Private helper function to create SVG elements
     * Note: signature changed in mxgraph 4.1.0
     */ createDiv(str) {
        let val = str;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(val)) {
            val = `<div><div>${this.convertHtml(val)}</div></div>`;
        }
        if (document.createElementNS) {
            const div = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(val)) {
                const n = val;
                const div2 = document.createElement('div');
                const div3 = div2.cloneNode(false);
                // Creates a copy for export
                if (this.root.ownerDocument !== document) {
                    div2.appendChild(n.cloneNode(true));
                } else {
                    div2.appendChild(n);
                }
                div3.appendChild(div2);
                div.appendChild(div3);
            } else {
                div.innerHTML = val;
            }
            return div;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(val)) {
            val = `<div><div>${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$xmlUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getXml"])(val)}</div></div>`;
        }
        val = `<div xmlns="http://www.w3.org/1999/xhtml">${val}</div>`;
        // NOTE: FF 3.6 crashes if content CSS contains "height:100%"
        return new DOMParser().parseFromString(val, 'text/xml').documentElement;
    }
    /**
     * Updates existing DOM nodes for text rendering. LATER: Merge common parts with text function below.
     */ updateText(x, y, w, h, align, valign, wrap, overflow, clip, rotation, node) {
        if (node && node.firstChild && node.firstChild.firstChild) {
            this.updateTextNodes(x, y, w, h, align, valign, wrap, overflow, clip, rotation, node.firstChild);
        }
    }
    /**
     * Creates a foreignObject for the given string and adds it to the given root.
     */ addForeignObject(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir, div, root) {
        const group = this.createElement('g');
        const fo = this.createElement('foreignObject');
        // Workarounds for print clipping and static position in Safari
        fo.setAttribute('style', 'overflow: visible; text-align: left;');
        fo.setAttribute('pointer-events', 'none');
        fo.appendChild(div);
        group.appendChild(fo);
        this.updateTextNodes(x, y, w, h, align, valign, wrap, overflow, clip, rotation, group);
        // Alternate content if foreignObject not supported
        if (this.root?.ownerDocument !== document) {
            const alt = this.createAlternateContent(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation);
            if (alt != null) {
                fo.setAttribute('requiredFeatures', 'http://www.w3.org/TR/SVG11/feature#Extensibility');
                const sw = this.createElement('switch');
                sw.appendChild(fo);
                sw.appendChild(alt);
                group.appendChild(sw);
            }
        }
        root.appendChild(group);
    }
    /**
     * Updates existing DOM nodes for text rendering.
     */ updateTextNodes(x, y, w, h, align, valign, wrap, overflow, clip, rotation, g) {
        const s = this.state.scale;
        SvgCanvas2D.createCss(w + 2, h, align, valign, wrap, overflow, clip, this.state.fontBackgroundColor != null ? this.state.fontBackgroundColor : null, this.state.fontBorderColor != null ? this.state.fontBorderColor : null, `display: flex; align-items: unsafe ${valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].TOP ? 'flex-start' : valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].BOTTOM ? 'flex-end' : 'center'}; ` + `justify-content: unsafe ${align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].LEFT ? 'flex-start' : align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT ? 'flex-end' : 'center'}; `, this.getTextCss(), s, (dx, dy, flex, item, block)=>{
            x += this.state.dx;
            y += this.state.dy;
            const fo = g.firstChild;
            const div = fo.firstChild;
            const box = div.firstChild;
            const text = box.firstChild;
            const r = (this.rotateHtml ? this.state.rotation : 0) + (rotation != null ? rotation : 0);
            let t = (this.foOffset !== 0 ? `translate(${this.foOffset} ${this.foOffset})` : '') + (s !== 1 ? `scale(${s})` : '');
            text.setAttribute('style', block);
            box.setAttribute('style', item);
            // Workaround for clipping in Webkit with scrolling and zoom
            fo.setAttribute('width', `${Math.ceil(1 / Math.min(1, s) * 100)}%`);
            fo.setAttribute('height', `${Math.ceil(1 / Math.min(1, s) * 100)}%`);
            const yp = Math.round(y + dy);
            // Allows for negative values which are causing problems with
            // transformed content where the top edge of the foreignObject
            // limits the text box being moved further up in the diagram.
            // KNOWN: Possible clipping problems with zoom and scrolling
            // but this is normally not used with scrollbars as the
            // coordinates are always positive with scrollbars.
            // Margin-top is ignored in Safari and no negative values allowed
            // for padding.
            if (yp < 0) {
                fo.setAttribute('y', String(yp));
            } else {
                fo.removeAttribute('y');
                flex += `padding-top: ${yp}px; `;
            }
            div.setAttribute('style', `${flex}margin-left: ${Math.round(x + dx)}px;`);
            t += r !== 0 ? `rotate(${r} ${x} ${y})` : '';
            // Output allows for reflow but Safari cannot use absolute position,
            // transforms or opacity. https://bugs.webkit.org/show_bug.cgi?id=23113
            if (t !== '') {
                g.setAttribute('transform', t);
            } else {
                g.removeAttribute('transform');
            }
            if (this.state.alpha !== 1) {
                g.setAttribute('opacity', String(this.state.alpha));
            } else {
                g.removeAttribute('opacity');
            }
        });
    }
    /**
     * Private helper function to create SVG elements
     */ getTextCss() {
        const s = this.state;
        const lh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ABSOLUTE_LINE_HEIGHT"] ? `${s.fontSize * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_HEIGHT"]}px` : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_HEIGHT"] * this.lineHeightCorrection;
        let css = `display: inline-block; font-size: ${s.fontSize}px; ` + `font-family: ${s.fontFamily}; color: ${s.fontColor}; line-height: ${lh}; pointer-events: ${this.pointerEvents ? this.pointerEventsValue : 'none'}; `;
        const fontStyle = s.fontStyle;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].BOLD) && (css += 'font-weight: bold; ');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].ITALIC) && (css += 'font-style: italic; ');
        const txtDecor = [];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].UNDERLINE) && txtDecor.push('underline');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].STRIKETHROUGH) && txtDecor.push('line-through');
        txtDecor.length > 0 && (css += `text-decoration: ${txtDecor.join(' ')}; `);
        return css;
    }
    /**
     * Paints the given text. Possible values for format are empty string for plain
     * text and html for HTML markup. Note that HTML markup is only supported if
     * foreignObject is supported and <foEnabled> is true. (This means IE9 and later
     * does currently not support HTML text as part of shapes.)
     */ text(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation = 0, dir) {
        if (this.textEnabled && str != null) {
            rotation = rotation != null ? rotation : 0;
            if (this.foEnabled && format === 'html') {
                const div = this.createDiv(str);
                // Ignores invalid XHTML labels
                if (div != null) {
                    if (dir != null) {
                        div.setAttribute('dir', dir);
                    }
                    this.addForeignObject(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir, div, this.root);
                }
            } else {
                this.plainText(x + this.state.dx, y + this.state.dy, w, h, str, align, valign, wrap, overflow, clip, rotation, dir);
            }
        }
    }
    /**
     * Creates a clip for the given coordinates.
     */ createClip(x, y, w, h) {
        x = Math.round(x);
        y = Math.round(y);
        w = Math.round(w);
        h = Math.round(h);
        const id = `mx-clip-${x}-${y}-${w}-${h}`;
        let counter = 0;
        let tmp = `${id}-${counter}`;
        // Resolves ID conflicts
        while(document.getElementById(tmp) != null){
            tmp = `${id}-${++counter}`;
        }
        const clip = this.createElement('clipPath');
        clip.setAttribute('id', tmp);
        const rect = this.createElement('rect');
        rect.setAttribute('x', String(x));
        rect.setAttribute('y', String(y));
        rect.setAttribute('width', String(w));
        rect.setAttribute('height', String(h));
        clip.appendChild(rect);
        return clip;
    }
    /**
     * Paints the given text. Possible values for format are empty string for
     * plain text and html for HTML markup.
     */ plainText(x, y, w, h, str, align, valign, wrap, overflow, clip, rotation = 0, dir) {
        const s = this.state;
        const size = s.fontSize;
        const node = this.createElement('g');
        let tr = s.transform || '';
        this.updateFont(node);
        // Ignores pointer events
        if (!this.pointerEvents && this.originalRoot == null) {
            node.setAttribute('pointer-events', 'none');
        }
        // Non-rotated text
        if (rotation !== 0) {
            tr += `rotate(${rotation},${this.format(x * s.scale)},${this.format(y * s.scale)})`;
        }
        if (dir != null) {
            node.setAttribute('direction', dir);
        }
        if (clip && w > 0 && h > 0) {
            let cx = x;
            let cy = y;
            if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER) {
                cx -= w / 2;
            } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT) {
                cx -= w;
            }
            if (overflow !== 'fill') {
                if (valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE) {
                    cy -= h / 2;
                } else if (valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].BOTTOM) {
                    cy -= h;
                }
            }
            // LATER: Remove spacing from clip rectangle
            const c = this.createClip(cx * s.scale - 2, cy * s.scale - 2, w * s.scale + 4, h * s.scale + 4);
            if (this.defs != null) {
                this.defs.appendChild(c);
            } else {
                // Makes sure clip is removed with referencing node
                this.root.appendChild(c);
            }
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_CHROMEAPP && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_EDGE && this.root.ownerDocument === document) {
                // Workaround for potential base tag
                const base = this.getBaseUrl().replace(/([()])/g, '\\$1');
                node.setAttribute('clip-path', `url(${base}#${c.getAttribute('id')})`);
            } else {
                node.setAttribute('clip-path', `url(#${c.getAttribute('id')})`);
            }
        }
        // Default is left
        const anchor = align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT ? 'end' : align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER ? 'middle' : 'start';
        // Text-anchor start is default in SVG
        if (anchor !== 'start') {
            node.setAttribute('text-anchor', anchor);
        }
        if (!this.styleEnabled || size !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONTSIZE"]) {
            node.setAttribute('font-size', `${size * s.scale}px`);
        }
        if (tr.length > 0) {
            node.setAttribute('transform', tr);
        }
        if (s.alpha < 1) {
            node.setAttribute('opacity', String(s.alpha));
        }
        const lines = str.split('\n');
        const lh = Math.round(size * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_HEIGHT"]);
        const textHeight = size + (lines.length - 1) * lh;
        let cy = y + size - 1;
        if (valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE) {
            if (overflow === 'fill') {
                cy -= h / 2;
            } else {
                const dy = (this.matchHtmlAlignment && clip && h > 0 ? Math.min(textHeight, h) : textHeight) / 2;
                cy -= dy;
            }
        } else if (valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].BOTTOM) {
            if (overflow === 'fill') {
                cy -= h;
            } else {
                const dy = this.matchHtmlAlignment && clip && h > 0 ? Math.min(textHeight, h) : textHeight;
                cy -= dy + 1;
            }
        }
        for(let i = 0; i < lines.length; i += 1){
            const line = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trim"])(lines[i]);
            // Workaround for bounding box of empty lines and spaces
            if (line) {
                const text = this.createElement('text');
                // LATER: Match horizontal HTML alignment
                text.setAttribute('x', String(this.format(x * s.scale) + this.textOffset));
                text.setAttribute('y', String(this.format(cy * s.scale) + this.textOffset));
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["write"])(text, line);
                node.appendChild(text);
            }
            cy += lh;
        }
        this.root.appendChild(node);
        this.addTextBackground(node, str, x, y, w, overflow === 'fill' ? h : textHeight, align, valign, overflow);
    }
    /**
     * Updates the text properties for the given node. (NOTE: For this to work in
     * IE, the given node must be a text or tspan element.)
     */ updateFont(node) {
        const s = this.state;
        if (s.fontColor && s.fontColor !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"]) {
            node.setAttribute('fill', s.fontColor);
        }
        if (!this.styleEnabled || s.fontFamily !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONTFAMILY"]) {
            node.setAttribute('font-family', s.fontFamily);
        }
        const fontStyle = s.fontStyle;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].BOLD) && node.setAttribute('font-weight', 'bold');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].ITALIC) && node.setAttribute('font-style', 'italic');
        const txtDecor = [];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].UNDERLINE) && txtDecor.push('underline');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].STRIKETHROUGH) && txtDecor.push('line-through');
        txtDecor.length > 0 && node.setAttribute('text-decoration', txtDecor.join(' '));
    }
    /**
     * Background color and border
     */ addTextBackground(node, str, x, y, w, h, align, valign, overflow) {
        const s = this.state;
        if (s.fontBackgroundColor != null || s.fontBorderColor != null) {
            let bbox = null;
            if (overflow === 'fill' || overflow === 'width') {
                if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER) {
                    x -= w / 2;
                } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT) {
                    x -= w;
                }
                if (valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE) {
                    y -= h / 2;
                } else if (valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].BOTTOM) {
                    y -= h;
                }
                bbox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]((x + 1) * s.scale, y * s.scale, (w - 2) * s.scale, (h + 2) * s.scale);
            // @ts-ignore check for getBBox
            } else if (node.getBBox != null && this.root.ownerDocument === document) {
                // Uses getBBox only if inside document for correct size
                try {
                    // @ts-ignore getBBox exists
                    bbox = node.getBBox();
                    bbox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](bbox.x, bbox.y + 1, bbox.width, bbox.height + 0);
                } catch (e) {
                // Ignores NS_ERROR_FAILURE in FF if container display is none.
                }
            }
            if (bbox == null || bbox.width === 0 || bbox.height === 0) {
                // Computes size if not in document or no getBBox available
                const div = document.createElement('div');
                // Wrapping and clipping can be ignored here
                div.style.lineHeight = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ABSOLUTE_LINE_HEIGHT"] ? `${s.fontSize * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_HEIGHT"]}px` : String(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LINE_HEIGHT"]);
                div.style.fontSize = `${s.fontSize}px`;
                div.style.fontFamily = s.fontFamily;
                div.style.whiteSpace = 'nowrap';
                div.style.position = 'absolute';
                div.style.visibility = 'hidden';
                div.style.display = 'inline-block';
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(s.fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].BOLD) && (div.style.fontWeight = 'bold');
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["matchBinaryMask"])(s.fontStyle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FONT"].ITALIC) && (div.style.fontStyle = 'italic');
                str = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["htmlEntities"])(str, false);
                div.innerHTML = str.replace(/\n/g, '<br/>');
                document.body.appendChild(div);
                const w = div.offsetWidth;
                const h = div.offsetHeight;
                document.body.removeChild(div);
                if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER) {
                    x -= w / 2;
                } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT) {
                    x -= w;
                }
                if (valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE) {
                    y -= h / 2;
                } else if (valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].BOTTOM) {
                    y -= h;
                }
                bbox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]((x + 1) * s.scale, (y + 2) * s.scale, w * s.scale, (h + 1) * s.scale);
            }
            if (bbox != null) {
                const n = this.createElement('rect');
                n.setAttribute('fill', s.fontBackgroundColor || 'none');
                n.setAttribute('stroke', s.fontBorderColor || 'none');
                n.setAttribute('x', String(Math.floor(bbox.x - 1)));
                n.setAttribute('y', String(Math.floor(bbox.y - 1)));
                n.setAttribute('width', String(Math.ceil(bbox.width + 2)));
                n.setAttribute('height', String(Math.ceil(bbox.height)));
                const sw = s.fontBorderColor ? Math.max(1, this.format(s.scale)) : 0;
                n.setAttribute('stroke-width', String(sw));
                // Workaround for crisp rendering - only required if not exporting
                if (this.root?.ownerDocument === document && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mod"])(sw, 2) === 1) {
                    n.setAttribute('transform', 'translate(0.5, 0.5)');
                }
                node.insertBefore(n, node.firstChild);
            }
        }
    }
    /**
     * Paints the outline of the current path.
     */ stroke() {
        this.addNode(false, true);
    }
    /**
     * Fills the current path.
     */ fill() {
        this.addNode(true, false);
    }
    /**
     * Fills and paints the outline of the current path.
     */ fillAndStroke() {
        this.addNode(true, true);
    }
}
/**
 * Updates existing DOM nodes for text rendering.
 */ SvgCanvas2D.createCss = (w, h, align, valign, wrap, overflow, clip, bg, border, flex, block, scale, callback)=>{
    let item = `box-sizing: border-box; font-size: 0; text-align: ${align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].LEFT ? 'left' : align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT ? 'right' : 'center'}; `;
    const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAlignmentAsPoint"])(align, valign);
    let ofl = 'overflow: hidden; ';
    let fw = 'width: 1px; ';
    let fh = 'height: 1px; ';
    let dx = pt.x * w;
    let dy = pt.y * h;
    if (clip) {
        fw = `width: ${Math.round(w)}px; `;
        item += `max-height: ${Math.round(h)}px; `;
        dy = 0;
    } else if (overflow === 'fill') {
        fw = `width: ${Math.round(w)}px; `;
        fh = `height: ${Math.round(h)}px; `;
        block += 'width: 100%; height: 100%; ';
        item += fw + fh;
    } else if (overflow === 'width') {
        fw = `width: ${Math.round(w)}px; `;
        block += 'width: 100%; ';
        item += fw;
        dy = 0;
        if (h > 0) {
            item += `max-height: ${Math.round(h)}px; `;
        }
    } else {
        ofl = '';
        dy = 0;
    }
    let bgc = '';
    if (bg) {
        bgc += `background-color: ${bg}; `;
    }
    if (border) {
        bgc += `border: 1px solid ${border}; `;
    }
    if (ofl == '' || clip) {
        block += bgc;
    } else {
        item += bgc;
    }
    if (wrap && w > 0) {
        block += `white-space: normal; word-wrap: ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WORD_WRAP"]}; `;
        fw = `width: ${Math.round(w)}px; `;
        if (ofl !== '' && overflow !== 'fill') {
            dy = 0;
        }
    } else {
        block += 'white-space: nowrap; ';
        if (ofl === '') {
            dx = 0;
        }
    }
    callback(dx, dy, flex + fw + fh, item + ofl, block, ofl);
};
const __TURBOPACK__default__export__ = SvgCanvas2D;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/image/ImageBox.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ /**
 * Encapsulates the URL, width and height of an image.
 *
 * Constructor: mxImage
 *
 * Constructs a new image.
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
class ImageBox {
    constructor(src, width, height){
        this.src = src;
        this.width = width;
        this.height = height;
    }
}
const __TURBOPACK__default__export__ = ImageBox;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/other/ConnectionConstraint.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ /**
 * Defines an object that contains the constraints about how to connect one side of an edge to its terminal.
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
class ConnectionConstraint {
    constructor(point, perimeter = true, name = null, dx = 0, dy = 0){
        /**
         * Boolean that specifies if the point should be projected onto the perimeter
         * of the terminal.
         */ this.perimeter = true;
        /**
         * Optional string that specifies the name of the constraint.
         */ this.name = null;
        /**
         * Optional float that specifies the horizontal offset of the constraint.
         */ this.dx = 0;
        /**
         * Optional float that specifies the vertical offset of the constraint.
         */ this.dy = 0;
        this.point = point;
        this.perimeter = perimeter;
        this.name = name;
        this.dx = dx;
        this.dy = dy;
    }
}
const __TURBOPACK__default__export__ = ConnectionConstraint;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/other/Guide.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$PolylineShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/PolylineShape.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
;
;
;
/**
 * Implements the alignment of selection cells to other cells in the graph.
 *
 * Constructor: mxGuide
 *
 * Constructs a new guide object.
 */ class Guide {
    constructor(graph, states){
        /**
         * Contains the {@link CellStates} that are used for alignment.
         */ this.states = [];
        /**
         * Specifies if horizontal guides are enabled. Default is true.
         */ this.horizontal = true;
        /**
         * Specifies if vertical guides are enabled. Default is true.
         */ this.vertical = true;
        /**
         * Holds the {@link Shape} for the horizontal guide.
         */ this.guideX = null;
        /**
         * Holds the {@link Shape} for the vertical guide.
         */ this.guideY = null;
        /**
         * Specifies if rounded coordinates should be used. Default is false.
         */ this.rounded = false;
        /**
         * Default tolerance in px if grid is disabled. Default is 2.
         */ this.tolerance = 2;
        this.graph = graph;
        this.setStates(states);
    }
    /**
     * Sets the {@link CellState}s that should be used for alignment.
     */ setStates(states) {
        this.states = states;
    }
    /**
     * Returns true if the guide should be enabled for the given native event. This
     * implementation always returns true.
     */ isEnabledForEvent(evt) {
        return true;
    }
    /**
     * Returns the tolerance for the guides. Default value is gridSize / 2.
     */ getGuideTolerance(gridEnabled = false) {
        return gridEnabled && this.graph.isGridEnabled() ? this.graph.getGridSize() / 2 : this.tolerance;
    }
    /**
     * Returns the mxShape to be used for painting the respective guide. This
     * implementation returns a new, dashed and crisp {@link PolylineShape} using
     * {@link GUIDE_COLOR} and {@link GUIDE_STROKEWIDTH} as the format.
     *
     * @param horizontal Boolean that specifies which guide should be created.
     */ createGuideShape(horizontal = false) {
        // TODO: Should vertical guides be supported here?? ============================
        const guide = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$PolylineShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]([], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GUIDE_COLOR"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GUIDE_STROKEWIDTH"]);
        guide.isDashed = true;
        return guide;
    }
    /**
     * Returns true if the given state should be ignored.
     * @param state
     */ isStateIgnored(state) {
        return false;
    }
    /**
     * Moves the <bounds> by the given {@link Point} and returnt the snapped point.
     */ move(bounds = null, delta, gridEnabled = false, clone = false) {
        if ((this.horizontal || this.vertical) && bounds) {
            const { scale } = this.graph.getView();
            const tt = this.getGuideTolerance(gridEnabled) * scale;
            const b = bounds.clone();
            b.x += delta.x;
            b.y += delta.y;
            let overrideX = false;
            let stateX = null;
            let valueX = null;
            let overrideY = false;
            let stateY = null;
            let valueY = null;
            let ttX = tt;
            let ttY = tt;
            const left = b.x;
            const right = b.x + b.width;
            const center = b.getCenterX();
            const top = b.y;
            const bottom = b.y + b.height;
            const middle = b.getCenterY();
            // Snaps the left, center and right to the given x-coordinate
            const snapX = (x, state, centerAlign)=>{
                let override = false;
                if (centerAlign && Math.abs(x - center) < ttX) {
                    delta.x = x - bounds.getCenterX();
                    ttX = Math.abs(x - center);
                    override = true;
                } else if (!centerAlign) {
                    if (Math.abs(x - left) < ttX) {
                        delta.x = x - bounds.x;
                        ttX = Math.abs(x - left);
                        override = true;
                    } else if (Math.abs(x - right) < ttX) {
                        delta.x = x - bounds.x - bounds.width;
                        ttX = Math.abs(x - right);
                        override = true;
                    }
                }
                if (override) {
                    stateX = state;
                    valueX = x;
                    if (!this.guideX) {
                        this.guideX = this.createGuideShape(true);
                        // Makes sure to use SVG shapes in order to implement
                        // event-transparency on the background area of the rectangle since
                        // HTML shapes do not let mouseevents through even when transparent
                        this.guideX.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIALECT"].SVG;
                        this.guideX.pointerEvents = false;
                        this.guideX.init(this.graph.getView().getOverlayPane());
                    }
                }
                overrideX = overrideX || override;
            };
            // Snaps the top, middle or bottom to the given y-coordinate
            const snapY = (y, state, centerAlign)=>{
                let override = false;
                if (centerAlign && Math.abs(y - middle) < ttY) {
                    delta.y = y - bounds.getCenterY();
                    ttY = Math.abs(y - middle);
                    override = true;
                } else if (!centerAlign) {
                    if (Math.abs(y - top) < ttY) {
                        delta.y = y - bounds.y;
                        ttY = Math.abs(y - top);
                        override = true;
                    } else if (Math.abs(y - bottom) < ttY) {
                        delta.y = y - bounds.y - bounds.height;
                        ttY = Math.abs(y - bottom);
                        override = true;
                    }
                }
                if (override) {
                    stateY = state;
                    valueY = y;
                    if (!this.guideY) {
                        this.guideY = this.createGuideShape(false);
                        // Makes sure to use SVG shapes in order to implement
                        // event-transparency on the background area of the rectangle since
                        // HTML shapes do not let mouseevents through even when transparent
                        this.guideY.dialect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIALECT"].SVG;
                        this.guideY.pointerEvents = false;
                        this.guideY.init(this.graph.getView().getOverlayPane());
                    }
                }
                overrideY = overrideY || override;
            };
            for(let i = 0; i < this.states.length; i += 1){
                const state = this.states[i];
                if (state && !this.isStateIgnored(state)) {
                    // Align x
                    if (this.horizontal) {
                        snapX(state.getCenterX(), state, true);
                        snapX(state.x, state, false);
                        snapX(state.x + state.width, state, false);
                        // Aligns left and right of shape to center of page
                        if (!state.cell) {
                            snapX(state.getCenterX(), state, false);
                        }
                    }
                    // Align y
                    if (this.vertical) {
                        snapY(state.getCenterY(), state, true);
                        snapY(state.y, state, false);
                        snapY(state.y + state.height, state, false);
                        // Aligns left and right of shape to center of page
                        if (!state.cell) {
                            snapY(state.getCenterY(), state, false);
                        }
                    }
                }
            }
            // Moves cells to the raster if not aligned
            this.graph.snapDelta(delta, bounds, !gridEnabled, overrideX, overrideY);
            delta = this.getDelta(bounds, stateX, delta.x, stateY, delta.y);
            // Redraws the guides
            const c = this.graph.container;
            if (!overrideX && this.guideX) {
                this.guideX.node.style.visibility = 'hidden';
            } else if (this.guideX) {
                let minY = null;
                let maxY = null;
                if (stateX) {
                    minY = Math.min(bounds.y + delta.y - this.graph.getPanDy(), stateX.y);
                    maxY = Math.max(bounds.y + bounds.height + delta.y - this.graph.getPanDy(), // @ts-ignore stateX! doesn't work for some reason...
                    stateX.y + stateX.height);
                }
                if (minY !== null && maxY !== null) {
                    this.guideX.points = [
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](valueX, minY),
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](valueX, maxY)
                    ];
                } else {
                    this.guideX.points = [
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](valueX, -this.graph.getPanDy()),
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](valueX, c.scrollHeight - 3 - this.graph.getPanDy())
                    ];
                }
                this.guideX.stroke = this.getGuideColor(stateX, true);
                this.guideX.node.style.visibility = 'visible';
                this.guideX.redraw();
            }
            if (!overrideY && this.guideY != null) {
                this.guideY.node.style.visibility = 'hidden';
            } else if (this.guideY != null) {
                let minX = null;
                let maxX = null;
                if (stateY != null && bounds != null) {
                    minX = Math.min(bounds.x + delta.x - this.graph.getPanDx(), stateY.x);
                    maxX = Math.max(bounds.x + bounds.width + delta.x - this.graph.getPanDx(), // @ts-ignore
                    stateY.x + stateY.width);
                }
                if (minX != null && maxX != null && valueY !== null) {
                    this.guideY.points = [
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](minX, valueY),
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](maxX, valueY)
                    ];
                } else if (valueY !== null) {
                    this.guideY.points = [
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](-this.graph.getPanDx(), valueY),
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](c.scrollWidth - 3 - this.graph.getPanDx(), valueY)
                    ];
                }
                this.guideY.stroke = this.getGuideColor(stateY, false);
                this.guideY.node.style.visibility = 'visible';
                this.guideY.redraw();
            }
        }
        return delta;
    }
    /**
     * Rounds to pixels for virtual states (eg. page guides)
     */ getDelta(bounds, stateX = null, dx, stateY = null, dy) {
        const s = this.graph.view.scale;
        if (this.rounded || stateX != null && stateX.cell == null) {
            dx = Math.round((bounds.x + dx) / s) * s - bounds.x;
        }
        if (this.rounded || stateY != null && stateY.cell == null) {
            dy = Math.round((bounds.y + dy) / s) * s - bounds.y;
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](dx, dy);
    }
    /**
     * Hides all current guides.
     */ getGuideColor(state, horizontal) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GUIDE_COLOR"];
    }
    /**
     * Hides all current guides.
     */ hide() {
        this.setVisible(false);
    }
    /**
     * Shows or hides the current guides.
     */ setVisible(visible) {
        if (this.guideX) {
            this.guideX.node.style.visibility = visible ? 'visible' : 'hidden';
        }
        if (this.guideY) {
            this.guideY.node.style.visibility = visible ? 'visible' : 'hidden';
        }
    }
    /**
     * Destroys all resources that this object uses.
     */ destroy() {
        if (this.guideX) {
            this.guideX.destroy();
            this.guideX = null;
        }
        if (this.guideY) {
            this.guideY.destroy();
            this.guideY = null;
        }
    }
}
const __TURBOPACK__default__export__ = Guide;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/other/PanningManager.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
;
;
;
/**
 * Implements a handler for panning.
 */ class PanningManager {
    constructor(graph){
        /**
         * Damper value for the panning. Default is 1/6.
         */ this.damper = 1 / 6;
        /**
         * Delay in milliseconds for the panning. Default is 10.
         */ this.delay = 10;
        /**
         * Specifies if mouse events outside of the component should be handled. Default is true.
         */ this.handleMouseOut = true;
        /**
         * Border to handle automatic panning inside the component. Default is 0 (disabled).
         */ this.border = 0;
        this.thread = null;
        this.active = false;
        this.tdx = 0;
        this.tdy = 0;
        this.t0x = 0;
        this.t0y = 0;
        this.dx = 0;
        this.dy = 0;
        this.scrollbars = false;
        this.scrollLeft = 0;
        this.scrollTop = 0;
        this.thread = null;
        this.active = false;
        this.tdx = 0;
        this.tdy = 0;
        this.t0x = 0;
        this.t0y = 0;
        this.dx = 0;
        this.dy = 0;
        this.scrollbars = false;
        this.scrollLeft = 0;
        this.scrollTop = 0;
        this.mouseListener = {
            mouseDown: (sender, me)=>{
                return;
            },
            mouseMove: (sender, me)=>{
                return;
            },
            mouseUp: (sender, me)=>{
                if (this.active) {
                    this.stop();
                }
            }
        };
        graph.addMouseListener(this.mouseListener);
        this.mouseUpListener = ()=>{
            if (this.active) {
                this.stop();
            }
        };
        // Stops scrolling on every mouseup anywhere in the document
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].addListener(document, 'mouseup', this.mouseUpListener);
        const createThread = ()=>{
            this.scrollbars = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasScrollbars"])(graph.container);
            this.scrollLeft = graph.container.scrollLeft;
            this.scrollTop = graph.container.scrollTop;
            return window.setInterval(()=>{
                this.tdx -= this.dx;
                this.tdy -= this.dy;
                if (this.scrollbars) {
                    const left = -graph.container.scrollLeft - Math.ceil(this.dx);
                    const top = -graph.container.scrollTop - Math.ceil(this.dy);
                    graph.panGraph(left, top);
                    graph.setPanDx(this.scrollLeft - graph.container.scrollLeft);
                    graph.setPanDy(this.scrollTop - graph.container.scrollTop);
                    graph.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PAN));
                // TODO: Implement graph.autoExtend
                } else {
                    graph.panGraph(this.getDx(), this.getDy());
                }
            }, this.delay);
        };
        this.isActive = ()=>{
            return this.active;
        };
        this.getDx = ()=>{
            return Math.round(this.tdx);
        };
        this.getDy = ()=>{
            return Math.round(this.tdy);
        };
        this.start = ()=>{
            this.t0x = graph.view.translate.x;
            this.t0y = graph.view.translate.y;
            this.active = true;
        };
        this.panTo = (x, y, w = 0, h = 0)=>{
            if (!this.active) {
                this.start();
            }
            this.scrollLeft = graph.container.scrollLeft;
            this.scrollTop = graph.container.scrollTop;
            const c = graph.container;
            this.dx = x + w - c.scrollLeft - c.clientWidth;
            if (this.dx < 0 && Math.abs(this.dx) < this.border) {
                this.dx = this.border + this.dx;
            } else if (this.handleMouseOut) {
                this.dx = Math.max(this.dx, 0);
            } else {
                this.dx = 0;
            }
            if (this.dx == 0) {
                this.dx = x - c.scrollLeft;
                if (this.dx > 0 && this.dx < this.border) {
                    this.dx -= this.border;
                } else if (this.handleMouseOut) {
                    this.dx = Math.min(0, this.dx);
                } else {
                    this.dx = 0;
                }
            }
            this.dy = y + h - c.scrollTop - c.clientHeight;
            if (this.dy < 0 && Math.abs(this.dy) < this.border) {
                this.dy = this.border + this.dy;
            } else if (this.handleMouseOut) {
                this.dy = Math.max(this.dy, 0);
            } else {
                this.dy = 0;
            }
            if (this.dy == 0) {
                this.dy = y - c.scrollTop;
                if (this.dy > 0 && this.dy < this.border) {
                    this.dy -= this.border;
                } else if (this.handleMouseOut) {
                    this.dy = Math.min(0, this.dy);
                } else {
                    this.dy = 0;
                }
            }
            if (this.dx != 0 || this.dy != 0) {
                this.dx *= this.damper;
                this.dy *= this.damper;
                if (this.thread == null) {
                    this.thread = createThread();
                }
            } else if (this.thread != null) {
                window.clearInterval(this.thread);
                this.thread = null;
            }
        };
        this.stop = ()=>{
            if (this.active) {
                this.active = false;
                if (this.thread != null) {
                    window.clearInterval(this.thread);
                    this.thread = null;
                }
                this.tdx = 0;
                this.tdy = 0;
                if (!this.scrollbars) {
                    const px = graph.getPanDx();
                    const py = graph.getPanDy();
                    if (px != 0 || py != 0) {
                        graph.panGraph(0, 0);
                        graph.view.setTranslate(this.t0x + px / graph.view.scale, this.t0y + py / graph.view.scale);
                    }
                } else {
                    graph.setPanDx(0);
                    graph.setPanDy(0);
                    graph.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PAN));
                }
            }
        };
        this.destroy = ()=>{
            graph.removeMouseListener(this.mouseListener);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].removeListener(document, 'mouseup', this.mouseUpListener);
        };
    }
}
const __TURBOPACK__default__export__ = PanningManager;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/RootChange.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ /**
 * Action to change the root in a model.
 *
 * Constructor: mxRootChange
 *
 * Constructs a change of the root in the
 * specified model.
 *
 * @class RootChange
 */ __turbopack_esm__({
    "RootChange": (()=>RootChange),
    "default": (()=>__TURBOPACK__default__export__)
});
class RootChange {
    constructor(model, root){
        this.model = model;
        this.root = root;
        this.previous = root;
    }
    /**
     * Carries out a change of the root using
     * <Transactions.rootChanged>.
     */ execute() {
        this.root = this.previous;
        this.previous = this.model.rootChanged(this.previous);
    }
}
const __TURBOPACK__default__export__ = RootChange;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/ChildChange.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ /**
 * Action to add or remove a child in a model.
 *
 * Constructor: mxChildChange
 *
 * Constructs a change of a child in the
 * specified model.
 *
 * @class ChildChange
 */ __turbopack_esm__({
    "ChildChange": (()=>ChildChange),
    "default": (()=>__TURBOPACK__default__export__)
});
class ChildChange {
    constructor(model, parent, child, index = 0){
        this.model = model;
        this.parent = parent;
        this.previous = parent;
        this.child = child;
        this.index = index;
        this.previousIndex = index;
    }
    /**
     * Changes the parent of {@link child}` using
     * <Transactions.parentForCellChanged> and
     * removes or restores the cell's
     * connections.
     */ execute() {
        let tmp = this.child.getParent();
        const tmp2 = tmp ? tmp.getIndex(this.child) : 0;
        if (!this.previous) {
            this.connect(this.child, false);
        }
        tmp = this.model.parentForCellChanged(this.child, this.previous, this.previousIndex);
        if (this.previous) {
            this.connect(this.child, true);
        }
        this.parent = this.previous;
        this.previous = tmp;
        this.index = this.previousIndex;
        this.previousIndex = tmp2;
    }
    /**
     * Disconnects the given cell recursively from its
     * terminals and stores the previous terminal in the
     * cell's terminals.
     *
     * @warning doc from mxGraph source code is incorrect
     */ connect(cell, isConnect = true) {
        const source = cell.getTerminal(true);
        const target = cell.getTerminal(false);
        if (source) {
            if (isConnect) {
                this.model.terminalForCellChanged(cell, source, true);
            } else {
                this.model.terminalForCellChanged(cell, null, true);
            }
        }
        if (target) {
            if (isConnect) {
                this.model.terminalForCellChanged(cell, target, false);
            } else {
                this.model.terminalForCellChanged(cell, null, false);
            }
        }
        cell.setTerminal(source, true);
        cell.setTerminal(target, false);
        const childCount = cell.getChildCount();
        for(let i = 0; i < childCount; i += 1){
            this.connect(cell.getChildAt(i), isConnect);
        }
    }
}
const __TURBOPACK__default__export__ = ChildChange;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/TerminalChange.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ /**
 * Action to change a terminal in a model.
 */ __turbopack_esm__({
    "TerminalChange": (()=>TerminalChange),
    "default": (()=>__TURBOPACK__default__export__)
});
class TerminalChange {
    constructor(model, cell, terminal, source){
        this.model = model;
        this.cell = cell;
        this.terminal = terminal;
        this.previous = terminal;
        this.source = source;
    }
    /**
     * Changes the terminal of {@link cell}` to {@link previous}` using
     * <Transactions.terminalForCellChanged>.
     */ execute() {
        this.terminal = this.previous;
        this.previous = this.model.terminalForCellChanged(this.cell, this.previous, this.source);
    }
}
const __TURBOPACK__default__export__ = TerminalChange;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/ValueChange.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ /**
 * Action to change a user object in a model.
 *
 * Constructs a change of a user object in the
 * specified model.
 *
 * @class ValueChange
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
class ValueChange {
    constructor(model, cell, value){
        this.model = model;
        this.cell = cell;
        this.value = value;
        this.previous = value;
    }
    /**
     * Changes the value of {@link cell}` to {@link previous}` using
     * <Transactions.valueForCellChanged>.
     */ execute() {
        this.value = this.previous;
        this.previous = this.model.valueForCellChanged(this.cell, this.previous);
    }
}
const __TURBOPACK__default__export__ = ValueChange;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/GeometryChange.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ /**
 * Action to change a cell's geometry in a model.
 *
 * Constructor: mxGeometryChange
 *
 * Constructs a change of a geometry in the
 * specified model.
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
class GeometryChange {
    constructor(model, cell, geometry){
        this.model = model;
        this.cell = cell;
        this.geometry = geometry;
        this.previous = geometry;
    }
    /**
     * Changes the geometry of {@link cell}` ro {@link previous}` using
     * <Transactions.geometryForCellChanged>.
     */ execute() {
        this.geometry = this.previous;
        this.previous = this.model.geometryForCellChanged(this.cell, this.previous);
    }
}
const __TURBOPACK__default__export__ = GeometryChange;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/StyleChange.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ /**
 * Action to change a cell's style in a model.
 *
 * @class StyleChange
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
class StyleChange {
    constructor(model, cell, style){
        this.model = model;
        this.cell = cell;
        this.style = style;
        this.previous = style;
    }
    /**
     * Changes the style of {@link cell}` to {@link previous}` using
     * <Transactions.styleForCellChanged>.
     */ execute() {
        this.style = this.previous;
        this.previous = this.model.styleForCellChanged(this.cell, this.previous);
    }
}
const __TURBOPACK__default__export__ = StyleChange;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/CollapseChange.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ /**
 * Action to change a cell's collapsed state in a model.
 *
 * Constructor: mxCollapseChange
 *
 * Constructs a change of a collapsed state in the
 * specified model.
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
class CollapseChange {
    constructor(model, cell, collapsed){
        this.model = model;
        this.cell = cell;
        this.collapsed = collapsed;
        this.previous = collapsed;
    }
    /**
     * Changes the collapsed state of {@link cell}` to {@link previous}` using
     * <Transactions.collapsedStateForCellChanged>.
     */ execute() {
        this.collapsed = this.previous;
        this.previous = this.model.collapsedStateForCellChanged(this.cell, this.previous);
    }
}
const __TURBOPACK__default__export__ = CollapseChange;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/VisibleChange.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ /**
 * Action to change a cell's visible state in a model.
 *
 * Constructor: mxVisibleChange
 *
 * Constructs a change of a visible state in the
 * specified model.
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
class VisibleChange {
    constructor(model, cell, visible){
        this.model = model;
        this.cell = cell;
        this.visible = visible;
        this.previous = visible;
    }
    /**
     * Changes the visible state of {@link cell}` to {@link previous}` using
     * <Transactions.visibleStateForCellChanged>.
     */ execute() {
        this.visible = this.previous;
        this.previous = this.model.visibleStateForCellChanged(this.cell, this.previous);
    }
}
const __TURBOPACK__default__export__ = VisibleChange;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/UndoableEdit.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
;
;
/**
 * Implements a composite undoable edit. Here is an example for a custom change
 * which gets executed via the model:
 *
 * ```javascript
 * function CustomChange(model, name)
 * {
 *   this.model = model;
 *   this.name = name;
 *   this.previous = name;
 * };
 *
 * execute = ()=>
 * {
 *   let tmp = this.model.name;
 *   this.model.name = this.previous;
 *   this.previous = tmp;
 * };
 *
 * let name = prompt('Enter name');
 * graph.model.execute(new CustomChange(graph.model, name));
 * ```
 *
 * Event: mxEvent.EXECUTED
 *
 * Fires between START_EDIT and END_EDIT after an atomic change was executed.
 * The <code>change</code> property contains the change that was executed.
 *
 * Event: mxEvent.START_EDIT
 *
 * Fires before a set of changes will be executed in <undo> or <redo>.
 * This event contains no properties.
 *
 * Event: mxEvent.END_EDIT
 *
 * Fires after a set of changeswas executed in <undo> or <redo>.
 * This event contains no properties.
 *
 * Constructor: mxUndoableEdit
 *
 * Constructs a new undoable edit for the given source.
 */ class UndoableEdit {
    constructor(source, significant = true){
        /**
         * Array that contains the changes that make up this edit. The changes are
         * expected to either have an undo and redo function, or an execute
         * function. Default is an empty array.
         */ this.changes = [];
        /**
         * Specifies if the undoable change is significant.
         * Default is true.
         */ this.significant = true;
        /**
         * Specifies if this edit has been undone. Default is false.
         */ this.undone = false;
        /**
         * Specifies if this edit has been redone. Default is false.
         */ this.redone = false;
        this.source = source;
        this.changes = [];
        this.significant = significant;
    }
    /**
     * Returns true if the this edit contains no changes.
     */ isEmpty() {
        return this.changes.length === 0;
    }
    /**
     * Returns <significant>.
     */ isSignificant() {
        return this.significant;
    }
    /**
     * Adds the specified change to this edit. The change is an object that is
     * expected to either have an undo and redo, or an execute function.
     */ add(change) {
        this.changes.push(change);
    }
    /**
     * Hook to notify any listeners of the changes after an <undo> or <redo>
     * has been carried out. This implementation is empty.
     */ notify() {
        return;
    }
    /**
     * Hook to free resources after the edit has been removed from the command
     * history. This implementation is empty.
     */ die() {
        return;
    }
    /**
     * Undoes all changes in this edit.
     */ undo() {
        if (!this.undone) {
            this.source.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].START_EDIT));
            const count = this.changes.length;
            for(let i = count - 1; i >= 0; i--){
                const change = this.changes[i];
                if (change.execute) {
                    change.execute();
                } else if (change.undo) {
                    change.undo();
                }
                // New global executed event
                this.source.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EXECUTED, {
                    change
                }));
            }
            this.undone = true;
            this.redone = false;
            this.source.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].END_EDIT));
        }
        this.notify();
    }
    /**
     * Redoes all changes in this edit.
     */ redo() {
        if (!this.redone) {
            this.source.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].START_EDIT));
            const count = this.changes.length;
            for(let i = 0; i < count; i += 1){
                const change = this.changes[i];
                if (change.execute != null) {
                    change.execute();
                } else if (change.redo != null) {
                    change.redo();
                }
                // New global executed event
                this.source.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EXECUTED, {
                    change
                }));
            }
            this.undone = false;
            this.redone = true;
            this.source.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].END_EDIT));
        }
        this.notify();
    }
}
const __TURBOPACK__default__export__ = UndoableEdit;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/CurrentRootChange.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
;
;
;
/**
 * Action to change the current root in a view.
 */ class CurrentRootChange {
    constructor(view, root){
        this.view = view;
        this.root = root;
        this.previous = root;
        this.isUp = root === null;
        if (!this.isUp) {
            let tmp = this.view.currentRoot;
            while(tmp){
                if (tmp === root) {
                    this.isUp = true;
                    break;
                }
                tmp = tmp.getParent();
            }
        }
    }
    /**
     * Changes the current root of the view.
     */ execute() {
        const tmp = this.view.currentRoot;
        this.view.currentRoot = this.previous;
        this.previous = tmp;
        const translate = this.view.graph.getTranslateForRoot(this.view.currentRoot);
        if (translate) {
            this.view.translate = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](-translate.x, -translate.y);
        }
        if (this.isUp) {
            this.view.clear(this.view.currentRoot, true, true);
            this.view.validate(null);
        } else {
            this.view.refresh();
        }
        const name = this.isUp ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UP : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DOWN;
        this.view.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](name, {
            root: this.view.currentRoot,
            previous: this.previous
        }));
        this.isUp = !this.isUp;
    }
}
const __TURBOPACK__default__export__ = CurrentRootChange;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/SelectionChange.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
;
;
/**
 * Action to change the current root in a view.
 */ class SelectionChange {
    constructor(graph, added = [], removed = []){
        this.graph = graph;
        this.added = added.slice();
        this.removed = removed.slice();
    }
    /**
     * Changes the current root of the view.
     */ execute() {
        const selectionModel = this.graph.getSelectionModel();
        for (const removed of this.removed){
            selectionModel.cellRemoved(removed);
        }
        for (const added of this.added){
            selectionModel.cellAdded(added);
        }
        [this.added, this.removed] = [
            this.removed,
            this.added
        ];
        selectionModel.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CHANGE, {
            added: this.added,
            removed: this.removed
        }));
    }
}
const __TURBOPACK__default__export__ = SelectionChange;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/GraphDataModel.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2018, JGraph Ltd
Copyright (c) 2006-2018, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "GraphDataModel": (()=>GraphDataModel),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/Cell.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cellArrayUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/cellArrayUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$RootChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/RootChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$ChildChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/ChildChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$TerminalChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/TerminalChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$ValueChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/ValueChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$GeometryChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/GeometryChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$StyleChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/StyleChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$CollapseChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/CollapseChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$VisibleChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/VisibleChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$UndoableEdit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/UndoableEdit.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellPath$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/CellPath.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventSource.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
class GraphDataModel extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(root = null){
        super();
        /**
         * Holds the root cell, which in turn contains the cells that represent the
         * layers of the diagram as child cells. That is, the actual elements of the
         * diagram are supposed to live in the third generation of cells and below.
         */ this.root = null;
        /**
         * Maps from Ids to cells.
         */ this.cells = {};
        /**
         * Specifies if edges should automatically be moved into the nearest common
         * ancestor of their terminals. Default is true.
         */ this.maintainEdgeParent = true;
        /**
         * Specifies if relative edge parents should be ignored for finding the nearest
         * common ancestors of an edge's terminals. Default is true.
         */ this.ignoreRelativeEdgeParent = true;
        /**
         * Specifies if the model should automatically create Ids for new cells.
         * Default is true.
         */ this.createIds = true;
        /**
         * Defines the prefix of new Ids. Default is an empty string.
         */ this.prefix = '';
        /**
         * Defines the postfix of new Ids. Default is an empty string.
         */ this.postfix = '';
        /**
         * Specifies the next Id to be created. Initial value is 0.
         */ // nextId: number | string;
        this.nextId = 0;
        /**
         * Holds the changes for the current transaction. If the transaction is
         * closed then a new object is created for this variable using
         * {@link createUndoableEdit}.
         */ this.currentEdit = null;
        /**
         * Counter for the depth of nested transactions. Each call to {@link beginUpdate}
         * will increment this number and each call to {@link endUpdate} will decrement
         * it. When the counter reaches 0, the transaction is closed and the
         * respective events are fired. Initial value is 0.
         */ this.updateLevel = 0;
        /**
         * True if the program flow is currently inside endUpdate.
         */ this.endingUpdate = false;
        this.currentEdit = this.createUndoableEdit();
        if (root != null) {
            this.setRoot(root);
        } else {
            this.clear();
        }
    }
    /**
     * Sets a new root using {@link createRoot}.
     */ clear() {
        this.setRoot(this.createRoot());
    }
    /**
     * Returns {@link createIds}.
     */ isCreateIds() {
        return this.createIds;
    }
    /**
     * Sets {@link createIds}.
     */ setCreateIds(value) {
        this.createIds = value;
    }
    /**
     * Creates a new root cell with a default layer (child 0).
     */ createRoot() {
        const cell = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        cell.insert(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]());
        return cell;
    }
    /**
     * Returns the {@link Cell} for the specified Id or null if no cell can be
     * found for the given Id.
     *
     * @param {string} id  A string representing the Id of the cell.
     */ getCell(id) {
        return this.cells ? this.cells[id] : null;
    }
    filterCells(cells, filter) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cellArrayUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filterCells"])(filter)(cells);
    }
    getRoot(cell = null) {
        return cell ? cell.getRoot() : this.root;
    }
    /**
     * Sets the {@link root} of the model using {@link RootChange} and adds the change to
     * the current transaction. This resets all datastructures in the model and
     * is the preferred way of clearing an existing model. Returns the new
     * root.
     *
     * Example:
     *
     * ```javascript
     * var root = new mxCell();
     * root.insert(new mxCell());
     * model.setRoot(root);
     * ```
     *
     * @param {Cell} root  that specifies the new root.
     */ setRoot(root) {
        this.execute(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$RootChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this, root));
        return root;
    }
    /**
     * Inner callback to change the root of the model and update the internal
     * datastructures, such as {@link cells} and {@link nextId}. Returns the previous root.
     *
     * @param {Cell} root  that specifies the new root.
     */ rootChanged(root) {
        const oldRoot = this.root;
        this.root = root;
        // Resets counters and datastructures
        this.nextId = 0;
        this.cells = null;
        this.cellAdded(root);
        return oldRoot;
    }
    /**
     * Returns true if the given cell is the root of the model and a non-null
     * value.
     *
     * @param {Cell} cell  that represents the possible root.
     */ isRoot(cell = null) {
        return cell != null && this.root === cell;
    }
    /**
     * Returns true if {@link isRoot} returns true for the parent of the given cell.
     *
     * @param cell  that represents the possible layer.
     */ isLayer(cell) {
        return cell ? this.isRoot(cell.getParent()) : false;
    }
    /**
     * Returns true if the model contains the given {@link Cell}.
     *
     * @param {Cell} cell  that specifies the cell.
     */ contains(cell) {
        return this.root.isAncestor(cell);
    }
    /**
     * Adds the specified child to the parent at the given index using
     * {@link ChildChange} and adds the change to the current transaction. If no
     * index is specified then the child is appended to the parent's array of
     * children. Returns the inserted child.
     *
     * @param {Cell} parent  that specifies the parent to contain the child.
     * @param {Cell} child  that specifies the child to be inserted.
     * @param index  Optional integer that specifies the index of the child.
     */ add(parent, child, index = null) {
        if (child !== parent && parent != null && child != null) {
            // Appends the child if no index was specified
            if (index == null) {
                index = parent.getChildCount();
            }
            const parentChanged = parent !== child.getParent();
            this.execute(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$ChildChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this, parent, child, index));
            // Maintains the edges parents by moving the edges
            // into the nearest common ancestor of its terminals
            if (this.maintainEdgeParent && parentChanged) {
                this.updateEdgeParents(child);
            }
        }
        return child;
    }
    /**
     * Inner callback to update {@link cells} when a cell has been added. This
     * implementation resolves collisions by creating new Ids. To change the
     * ID of a cell after it was inserted into the model, use the following
     * code:
     *
     * (code
     * delete model.cells[cell.getId()];
     * cell.setId(newId);
     * model.cells[cell.getId()] = cell;
     * ```
     *
     * If the change of the ID should be part of the command history, then the
     * cell should be removed from the model and a clone with the new ID should
     * be reinserted into the model instead.
     *
     * @param {Cell} cell  that specifies the cell that has been added.
     */ cellAdded(cell) {
        if (cell != null) {
            // Creates an Id for the cell if not Id exists
            if (cell.getId() == null && this.createIds) {
                cell.setId(this.createId(cell));
            }
            if (cell.getId() != null) {
                let collision = this.getCell(cell.getId());
                if (collision !== cell) {
                    // Creates new Id for the cell
                    // as long as there is a collision
                    while(collision != null){
                        cell.setId(this.createId(cell));
                        collision = this.getCell(cell.getId());
                    }
                    // Lazily creates the cells dictionary
                    if (this.cells == null) {
                        this.cells = {};
                    }
                    this.cells[cell.getId()] = cell;
                }
            }
            // Makes sure IDs of deleted cells are not reused
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumeric"])(String(cell.getId()))) {
                this.nextId = Math.max(this.nextId, parseInt(cell.getId()));
            }
            // Recursively processes child cells
            for (const child of cell.getChildren()){
                this.cellAdded(child);
            }
        }
    }
    /**
     * Hook method to create an Id for the specified cell. This implementation
     * concatenates {@link prefix}, id and {@link postfix} to create the Id and increments
     * {@link nextId}. The cell is ignored by this implementation, but can be used in
     * overridden methods to prefix the Ids with eg. the cell type.
     *
     * @param {Cell} cell  to create the Id for.
     */ createId(cell) {
        const id = this.nextId;
        this.nextId++;
        return this.prefix + id + this.postfix;
    }
    /**
     * Updates the parent for all edges that are connected to cell or one of
     * its descendants using {@link updateEdgeParent}.
     */ updateEdgeParents(cell, root = this.getRoot(cell)) {
        // Updates edges on children first
        const childCount = cell.getChildCount();
        for(let i = 0; i < childCount; i += 1){
            const child = cell.getChildAt(i);
            this.updateEdgeParents(child, root);
        }
        // Updates the parents of all connected edges
        const edgeCount = cell.getEdgeCount();
        const edges = [];
        for(let i = 0; i < edgeCount; i += 1){
            edges.push(cell.getEdgeAt(i));
        }
        for(let i = 0; i < edges.length; i += 1){
            const edge = edges[i];
            // Updates edge parent if edge and child have
            // a common root node (does not need to be the
            // model root node)
            if (root.isAncestor(edge)) {
                this.updateEdgeParent(edge, root);
            }
        }
    }
    /**
     * Inner callback to update the parent of the specified {@link Cell} to the
     * nearest-common-ancestor of its two terminals.
     *
     * @param {Cell} edge  that specifies the edge.
     * @param {Cell} root  that represents the current root of the model.
     */ updateEdgeParent(edge, root) {
        let source = edge.getTerminal(true);
        let target = edge.getTerminal(false);
        let cell = null;
        // Uses the first non-relative descendants of the source terminal
        while(source != null && !source.isEdge() && source.geometry != null && source.geometry.relative){
            source = source.getParent();
        }
        // Uses the first non-relative descendants of the target terminal
        while(target != null && this.ignoreRelativeEdgeParent && !target.isEdge() && target.geometry != null && target.geometry.relative){
            target = target.getParent();
        }
        if (root.isAncestor(source) && root.isAncestor(target)) {
            if (source === target) {
                cell = source ? source.getParent() : null;
            } else if (source) {
                cell = source.getNearestCommonAncestor(target);
            }
            if (cell != null && (cell.getParent() !== this.root || cell.isAncestor(edge)) && edge && edge.getParent() !== cell) {
                let geo = edge.getGeometry();
                if (geo != null) {
                    const origin1 = edge.getParent().getOrigin();
                    const origin2 = cell.getOrigin();
                    const dx = origin2.x - origin1.x;
                    const dy = origin2.y - origin1.y;
                    geo = geo.clone();
                    geo.translate(-dx, -dy);
                    this.setGeometry(edge, geo);
                }
                this.add(cell, edge, cell.getChildCount());
            }
        }
    }
    /**
     * Removes the specified cell from the model using {@link ChildChange} and adds
     * the change to the current transaction. This operation will remove the
     * cell and all of its children from the model. Returns the removed cell.
     *
     * @param {Cell} cell  that should be removed.
     */ remove(cell) {
        if (cell === this.root) {
            this.setRoot(null);
        } else if (cell.getParent() != null) {
            this.execute(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$ChildChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this, null, cell));
        }
        return cell;
    }
    /**
     * Inner callback to update {@link cells} when a cell has been removed.
     *
     * @param {Cell} cell  that specifies the cell that has been removed.
     */ cellRemoved(cell) {
        if (cell != null && this.cells != null) {
            // Recursively processes child cells
            const childCount = cell.getChildCount();
            for(let i = childCount - 1; i >= 0; i--){
                this.cellRemoved(cell.getChildAt(i));
            }
            // Removes the dictionary entry for the cell
            if (this.cells != null && cell.getId() != null) {
                // @ts-ignore
                delete this.cells[cell.getId()];
            }
        }
    }
    /**
     * Inner callback to update the parent of a cell using {@link Cell#insert}
     * on the parent and return the previous parent.
     *
     * @param {Cell} cell  to update the parent for.
     * @param {Cell} parent  that specifies the new parent of the cell.
     * @param index  Optional integer that defines the index of the child
     * in the parent's child array.
     */ parentForCellChanged(cell, parent, index) {
        const previous = cell.getParent();
        if (parent != null) {
            if (parent !== previous || previous.getIndex(cell) !== index) {
                parent.insert(cell, index);
            }
        } else if (previous != null) {
            const oldIndex = previous.getIndex(cell);
            previous.remove(oldIndex);
        }
        // Adds or removes the cell from the model
        const par = parent ? this.contains(parent) : null;
        const pre = this.contains(previous);
        if (par && !pre) {
            this.cellAdded(cell);
        } else if (pre && !par) {
            this.cellRemoved(cell);
        }
        return previous;
    }
    /**
     * Sets the source or target terminal of the given {@link Cell} using
     * {@link TerminalChange} and adds the change to the current transaction.
     * This implementation updates the parent of the edge using {@link updateEdgeParent}
     * if required.
     *
     * @param {Cell} edge  that specifies the edge.
     * @param {Cell} terminal  that specifies the new terminal.
     * @param isSource  Boolean indicating if the terminal is the new source or
     * target terminal of the edge.
     */ // setTerminal(edge: mxCell, terminal: mxCell, isSource: boolean): mxCell;
    setTerminal(edge, terminal, isSource) {
        const terminalChanged = terminal !== edge.getTerminal(isSource);
        this.execute(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$TerminalChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this, edge, terminal, isSource));
        if (this.maintainEdgeParent && terminalChanged) {
            this.updateEdgeParent(edge, this.getRoot());
        }
        return terminal;
    }
    /**
     * Sets the source and target {@link Cell} of the given {@link Cell} in a single
     * transaction using {@link setTerminal} for each end of the edge.
     *
     * @param {Cell} edge  that specifies the edge.
     * @param {Cell} source  that specifies the new source terminal.
     * @param {Cell} target  that specifies the new target terminal.
     */ // setTerminals(edge: mxCell, source: mxCell, target: mxCell): void;
    setTerminals(edge, source, target) {
        this.beginUpdate();
        try {
            this.setTerminal(edge, source, true);
            this.setTerminal(edge, target, false);
        } finally{
            this.endUpdate();
        }
    }
    /**
     * Inner helper function to update the terminal of the edge using
     * {@link Cell#insertEdge} and return the previous terminal.
     *
     * @param {Cell} edge  that specifies the edge to be updated.
     * @param {Cell} terminal  that specifies the new terminal.
     * @param isSource  Boolean indicating if the terminal is the new source or
     * target terminal of the edge.
     */ // terminalForCellChanged(edge: mxCell, terminal: mxCell, isSource: boolean): mxCell;
    terminalForCellChanged(edge, terminal, isSource = false) {
        const previous = edge.getTerminal(isSource);
        if (terminal != null) {
            terminal.insertEdge(edge, isSource);
        } else if (previous != null) {
            previous.removeEdge(edge, isSource);
        }
        return previous;
    }
    /**
     * Returns all edges between the given source and target pair. If directed
     * is true, then only edges from the source to the target are returned,
     * otherwise, all edges between the two cells are returned.
     *
     * @param {Cell} source  that defines the source terminal of the edge to be
     * returned.
     * @param {Cell} target  that defines the target terminal of the edge to be
     * returned.
     * @param directed  Optional boolean that specifies if the direction of the
     * edge should be taken into account. Default is false.
     */ getEdgesBetween(source, target, directed = false) {
        const tmp1 = source.getEdgeCount();
        const tmp2 = target.getEdgeCount();
        // Assumes the source has less connected edges
        let terminal = source;
        let edgeCount = tmp1;
        // Uses the smaller array of connected edges
        // for searching the edge
        if (tmp2 < tmp1) {
            edgeCount = tmp2;
            terminal = target;
        }
        const result = [];
        // Checks if the edge is connected to the correct
        // cell and returns the first match
        for(let i = 0; i < edgeCount; i += 1){
            const edge = terminal.getEdgeAt(i);
            const src = edge.getTerminal(true);
            const trg = edge.getTerminal(false);
            const directedMatch = src === source && trg === target;
            const oppositeMatch = trg === source && src === target;
            if (directedMatch || !directed && oppositeMatch) {
                result.push(edge);
            }
        }
        return result;
    }
    /**
     * Sets the user object of then given {@link Cell} using {@link ValueChange}
     * and adds the change to the current transaction.
     *
     * @param {Cell} cell  whose user object should be changed.
     * @param value  Object that defines the new user object.
     */ setValue(cell, value) {
        this.execute(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$ValueChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this, cell, value));
        return value;
    }
    /**
     * Inner callback to update the user object of the given {@link Cell}
     * using {@link Cell#valueChanged} and return the previous value,
     * that is, the return value of {@link Cell#valueChanged}.
     *
     * To change a specific attribute in an XML node, the following code can be
     * used.
     *
     * ```javascript
     * graph.getDataModel().valueForCellChanged(cell, value)
     * {
     *   var previous = cell.value.getAttribute('label');
     *   cell.value.setAttribute('label', value);
     *
     *   return previous;
     * };
     * ```
     */ valueForCellChanged(cell, value) {
        return cell.valueChanged(value);
    }
    /**
     * Sets the {@link Geometry} of the given {@link Cell}. The actual update
     * of the cell is carried out in {@link geometryForCellChanged}. The
     * {@link GeometryChange} action is used to encapsulate the change.
     *
     * @param {Cell} cell  whose geometry should be changed.
     * @param {Geometry} geometry  that defines the new geometry.
     */ setGeometry(cell, geometry) {
        if (geometry !== cell.getGeometry()) {
            this.execute(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$GeometryChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this, cell, geometry));
        }
        return geometry;
    }
    /**
     * Inner callback to update the {@link Geometry} of the given {@link Cell} using
     * {@link Cell#setGeometry} and return the previous {@link Geometry}.
     */ geometryForCellChanged(cell, geometry) {
        const previous = cell.getGeometry();
        cell.setGeometry(geometry);
        return previous;
    }
    /**
     * Sets the style of the given {@link Cell} using {@link StyleChange} and adds the change to the current transaction.
     *
     * **IMPORTANT**: Do not pass {@link Cell.getStyle} as value of the `style` parameter. Otherwise, no style change is performed, so the view won't be updated.
     * Always get a clone of the style of the cell with {@link Cell.getClonedStyle}, then update it and pass the updated style to this method.
     *
     * @param cell  whose style should be changed.
     * @param style the new cell style to set.
     */ setStyle(cell, style) {
        // To investigate in the future: it may be more convenient to do a deep comparison to prevent unnecessary changes
        // If the passed style is the same as the current style without being the same instance, we don't need to do anything
        // With the current implementation, a style change is executed when the styles are deep equal.
        if (style !== cell.getStyle()) {
            this.execute(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$StyleChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this, cell, style));
        }
    }
    /**
     * Inner callback to update the style of the given {@link Cell}  using {@link Cell#setStyle} and return the previous style.
     *
     * **IMPORTANT**: to fully work, this method should not receive `cell.getStyle` as value of the `style` parameter. See {@link setStyle} for more information.
     *
     * @param cell  whose style should be changed.
     * @param style the new cell style to set.
     */ styleForCellChanged(cell, style) {
        const previous = cell.getStyle();
        cell.setStyle(style);
        return previous;
    }
    /**
     * Sets the collapsed state of the given {@link Cell} using {@link CollapseChange}
     * and adds the change to the current transaction.
     *
     * @param {Cell} cell  whose collapsed state should be changed.
     * @param collapsed  Boolean that specifies the new collpased state.
     */ setCollapsed(cell, collapsed) {
        if (collapsed !== cell.isCollapsed()) {
            this.execute(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$CollapseChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this, cell, collapsed));
        }
        return collapsed;
    }
    /**
     * Inner callback to update the collapsed state of the
     * given {@link Cell} using {@link Cell#setCollapsed} and return
     * the previous collapsed state.
     *
     * @param {Cell} cell  that specifies the cell to be updated.
     * @param collapsed  Boolean that specifies the new collapsed state.
     */ collapsedStateForCellChanged(cell, collapsed) {
        const previous = cell.isCollapsed();
        cell.setCollapsed(collapsed);
        return previous;
    }
    /**
     * Sets the visible state of the given {@link Cell} using {@link VisibleChange} and
     * adds the change to the current transaction.
     *
     * @param {Cell} cell  whose visible state should be changed.
     * @param visible  Boolean that specifies the new visible state.
     */ setVisible(cell, visible) {
        if (visible !== cell.isVisible()) {
            this.execute(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$VisibleChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this, cell, visible));
        }
        return visible;
    }
    /**
     * Inner callback to update the visible state of the
     * given {@link Cell} using {@link Cell#setCollapsed} and return
     * the previous visible state.
     *
     * @param {Cell} cell  that specifies the cell to be updated.
     * @param visible  Boolean that specifies the new visible state.
     */ visibleStateForCellChanged(cell, visible) {
        const previous = cell.isVisible();
        cell.setVisible(visible);
        return previous;
    }
    /**
     * Executes the given edit and fires events if required. The edit object
     * requires an execute function which is invoked. The edit is added to the
     * {@link currentEdit} between {@link beginUpdate} and {@link endUpdate} calls, so that
     * events will be fired if this execute is an individual transaction, that
     * is, if no previous {@link beginUpdate} calls have been made without calling
     * {@link endUpdate}. This implementation fires an {@link execute} event before
     * executing the given change.
     *
     * @param change  Object that described the change.
     */ execute(change) {
        change.execute();
        this.beginUpdate();
        this.currentEdit.add(change);
        this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EXECUTE, {
            change
        }));
        // New global executed event
        this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EXECUTED, {
            change
        }));
        this.endUpdate();
    }
    /**
     * Updates the model in a transaction.
     * This is a shortcut to the usage of {@link beginUpdate} and the {@link endUpdate} methods.
     *
     * ```javascript
     * const model = graph.getDataModel();
     * const parent = graph.getDefaultParent();
     * const index = model.getChildCount(parent);
     * model.batchUpdate(() => {
     *   model.add(parent, v1, index);
     *   model.add(parent, v2, index+1);
     * });
     * ```
     *
     * @param fn the update to be performed in the transaction.
     */ batchUpdate(fn) {
        this.beginUpdate();
        try {
            fn();
        } finally{
            this.endUpdate();
        }
    }
    /**
     * Increments the {@link updateLevel} by one. The event notification
     * is queued until {@link updateLevel} reaches 0 by use of
     * {@link endUpdate}.
     *
     * All changes on {@link GraphDataModel} are transactional,
     * that is, they are executed in a single undoable change
     * on the model (without transaction isolation).
     * Therefore, if you want to combine any
     * number of changes into a single undoable change,
     * you should group any two or more API calls that
     * modify the graph model between {@link beginUpdate}
     * and {@link endUpdate} calls as shown here:
     *
     * ```javascript
     * const model = graph.getDataModel();
     * const parent = graph.getDefaultParent();
     * const index = model.getChildCount(parent);
     * model.beginUpdate();
     * try
     * {
     *   model.add(parent, v1, index);
     *   model.add(parent, v2, index+1);
     * }
     * finally
     * {
     *   model.endUpdate();
     * }
     * ```
     *
     * Of course there is a shortcut for appending a
     * sequence of cells into the default parent:
     *
     * ```javascript
     * graph.addCells([v1, v2]).
     * ```
     */ beginUpdate() {
        this.updateLevel += 1;
        this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].BEGIN_UPDATE));
        if (this.updateLevel === 1) {
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].START_EDIT));
        }
    }
    /**
     * Decrements the {@link updateLevel} by one and fires an {@link undo}
     * event if the {@link updateLevel} reaches 0. This function
     * indirectly fires a {@link change} event by invoking the notify
     * function on the {@link currentEdit} und then creates a new
     * {@link currentEdit} using {@link createUndoableEdit}.
     *
     * The {@link undo} event is fired only once per edit, whereas
     * the {@link change} event is fired whenever the notify
     * function is invoked, that is, on undo and redo of
     * the edit.
     */ endUpdate() {
        this.updateLevel -= 1;
        if (this.updateLevel === 0) {
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].END_EDIT));
        }
        if (!this.endingUpdate) {
            this.endingUpdate = this.updateLevel === 0;
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].END_UPDATE, {
                edit: this.currentEdit
            }));
            try {
                if (this.endingUpdate && !this.currentEdit.isEmpty()) {
                    this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].BEFORE_UNDO, {
                        edit: this.currentEdit
                    }));
                    const tmp = this.currentEdit;
                    this.currentEdit = this.createUndoableEdit();
                    tmp.notify();
                    this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNDO, {
                        edit: tmp
                    }));
                }
            } finally{
                this.endingUpdate = false;
            }
        }
    }
    /**
     * Creates a new {@link UndoableEdit} that implements the
     * notify function to fire a {@link change} and {@link notify} event
     * through the {@link UndoableEdit}'s source.
     *
     * @param significant  Optional boolean that specifies if the edit to be created is
     * significant. Default is true.
     */ createUndoableEdit(significant = true) {
        const edit = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$UndoableEdit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this, significant);
        edit.notify = ()=>{
            // LATER: Remove changes property (deprecated)
            edit.source.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CHANGE, {
                edit,
                changes: edit.changes
            }));
            edit.source.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].NOTIFY, {
                edit,
                changes: edit.changes
            }));
        };
        return edit;
    }
    /**
     * Merges the children of the given cell into the given target cell inside
     * this model. All cells are cloned unless there is a corresponding cell in
     * the model with the same id, in which case the source cell is ignored and
     * all edges are connected to the corresponding cell in this model. Edges
     * are considered to have no identity and are always cloned unless the
     * cloneAllEdges flag is set to false, in which case edges with the same
     * id in the target model are reconnected to reflect the terminals of the
     * source edges.
     */ mergeChildren(from, to, cloneAllEdges = true) {
        this.beginUpdate();
        try {
            const mapping = {};
            this.mergeChildrenImpl(from, to, cloneAllEdges, mapping);
            // Post-processes all edges in the mapping and
            // reconnects the terminals to the corresponding
            // cells in the target model
            for(const key in mapping){
                const cell = mapping[key];
                let terminal = cell.getTerminal(true);
                if (terminal != null) {
                    terminal = mapping[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellPath$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].create(terminal)];
                    this.setTerminal(cell, terminal, true);
                }
                terminal = cell.getTerminal(false);
                if (terminal != null) {
                    terminal = mapping[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellPath$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].create(terminal)];
                    this.setTerminal(cell, terminal, false);
                }
            }
        } finally{
            this.endUpdate();
        }
    }
    /**
     * Clones the children of the source cell into the given target cell in
     * this model and adds an entry to the mapping that maps from the source
     * cell to the target cell with the same id or the clone of the source cell
     * that was inserted into this model.
     */ mergeChildrenImpl(from, to, cloneAllEdges, mapping = {}) {
        this.beginUpdate();
        try {
            const childCount = from.getChildCount();
            for(let i = 0; i < childCount; i += 1){
                const cell = from.getChildAt(i);
                if (typeof cell.getId === 'function') {
                    const id = cell.getId();
                    let target = id != null && (!cell.isEdge() || !cloneAllEdges) ? this.getCell(id) : null;
                    // Clones and adds the child if no cell exists for the id
                    if (target == null) {
                        const clone = cell.clone();
                        clone.setId(id);
                        // Sets the terminals from the original cell to the clone
                        // because the lookup uses strings not cells in JS
                        clone.setTerminal(cell.getTerminal(true), true);
                        clone.setTerminal(cell.getTerminal(false), false);
                        // Do *NOT* use model.add as this will move the edge away
                        // from the parent in updateEdgeParent if maintainEdgeParent
                        // is enabled in the target model
                        target = to.insert(clone);
                        this.cellAdded(target);
                    }
                    // Stores the mapping for later reconnecting edges
                    mapping[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellPath$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].create(cell)] = target;
                    // Recurses
                    this.mergeChildrenImpl(cell, target, cloneAllEdges, mapping);
                }
            }
        } finally{
            this.endUpdate();
        }
    }
}
const __TURBOPACK__default__export__ = GraphDataModel;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/GraphView.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "GraphView": (()=>GraphView),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Dictionary.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$CurrentRootChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/CurrentRootChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$UndoableEdit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/UndoableEdit.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/config.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/RectangleShape.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/node/ImageShape.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalMouseEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cloneUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/cloneUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/StyleRegistry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/CellState.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventSource.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
class GraphView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(graph){
        super();
        // TODO: Document me!
        this.backgroundImage = null;
        this.backgroundPageShape = null;
        this.EMPTY_POINT = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        /**
         * Specifies the resource key for the status message after a long operation.
         * If the resource for this key does not exist then the value is used as
         * the status message. Default is 'done'.
         */ this.doneResource = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].language !== 'none' ? 'done' : '';
        /**
         * Specifies the resource key for the status message while the document is
         * being updated. If the resource for this key does not exist then the
         * value is used as the status message. Default is 'updatingDocument'.
         */ this.updatingDocumentResource = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].language !== 'none' ? 'updatingDocument' : '';
        /**
         * Specifies if string values in cell styles should be evaluated using
         * {@link eval}. This will only be used if the string values can't be mapped
         * to objects using {@link StyleRegistry}. Default is false. NOTE: Enabling this
         * switch carries a possible security risk.
         */ this.allowEval = false;
        /**
         * Specifies if a gesture should be captured when it goes outside of the
         * graph container. Default is true.
         */ this.captureDocumentGesture = true;
        /**
         * Specifies if shapes should be created, updated and destroyed using the
         * methods of {@link cellRenderer} in {@link graph}. Default is true.
         */ this.rendering = true;
        /**
         * {@link Cell} that acts as the root of the displayed cell hierarchy.
         */ this.currentRoot = null;
        this.graphBounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        this.scale = 1;
        /**
         * {@link Point} that specifies the current translation. Default is a new
         * empty {@link Point}.
         */ this.translate = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        this.states = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        /**
         * Specifies if the style should be updated in each validation step. If this
         * is false then the style is only updated if the state is created or if the
         * style of the cell was changed. Default is false.
         */ this.updateStyle = false;
        /**
         * During validation, this contains the last DOM node that was processed.
         */ this.lastNode = null;
        /**
         * During validation, this contains the last HTML DOM node that was processed.
         */ this.lastHtmlNode = null;
        /**
         * During validation, this contains the last edge's DOM node that was processed.
         */ this.lastForegroundNode = null;
        /**
         * During validation, this contains the last edge HTML DOM node that was processed.
         */ this.lastForegroundHtmlNode = null;
        this.endHandler = null;
        this.moveHandler = null;
        this.graph = graph;
    }
    /**
     * Returns {@link graphBounds}.
     */ getGraphBounds() {
        return this.graphBounds;
    }
    /**
     * Sets {@link graphBounds}.
     */ setGraphBounds(value) {
        this.graphBounds = value;
    }
    /**
     * Returns the {@link scale}.
     */ getScale() {
        return this.scale;
    }
    /**
     * Sets the scale and fires a {@link scale} event before calling {@link revalidate} followed
     * by {@link Graph.sizeDidChange}.
     *
     * @param value Decimal value that specifies the new scale (1 is 100%).
     */ setScale(value) {
        const previousScale = this.scale;
        if (previousScale !== value) {
            this.scale = value;
            if (this.isEventsEnabled()) {
                this.viewStateChanged();
            }
        }
        this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCALE, {
            scale: value,
            previousScale
        }));
    }
    /**
     * Returns the {@link translate}.
     */ getTranslate() {
        return this.translate;
    }
    isRendering() {
        return this.rendering;
    }
    setRendering(value) {
        this.rendering = value;
    }
    /**
     * Sets the translation and fires a {@link translate} event before calling
     * {@link revalidate} followed by {@link Graph.sizeDidChange}. The translation is the
     * negative of the origin.
     *
     * @param dx X-coordinate of the translation.
     * @param dy Y-coordinate of the translation.
     */ setTranslate(dx, dy) {
        const previousTranslate = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.translate.x, this.translate.y);
        if (this.translate.x !== dx || this.translate.y !== dy) {
            this.translate.x = dx;
            this.translate.y = dy;
            if (this.isEventsEnabled()) {
                this.viewStateChanged();
            }
        }
        this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TRANSLATE, {
            translate: this.translate,
            previousTranslate: previousTranslate
        }));
    }
    isAllowEval() {
        return this.allowEval;
    }
    setAllowEval(value) {
        this.allowEval = value;
    }
    /**
     * Returns {@link states}.
     */ getStates() {
        return this.states;
    }
    /**
     * Sets {@link states}.
     */ setStates(value) {
        this.states = value;
    }
    /**
     * Returns the DOM node that contains the background-, draw- and
     * overlay- and decoratorpanes.
     */ getCanvas() {
        return this.canvas;
    }
    /**
     * Returns the DOM node that represents the background layer.
     */ getBackgroundPane() {
        return this.backgroundPane;
    }
    /**
     * Returns the DOM node that represents the main drawing layer.
     */ getDrawPane() {
        return this.drawPane;
    }
    /**
     * Returns the DOM node that represents the layer above the drawing layer.
     */ getOverlayPane() {
        return this.overlayPane;
    }
    /**
     * Returns the DOM node that represents the topmost drawing layer.
     */ getDecoratorPane() {
        return this.decoratorPane;
    }
    /**
     * Returns the union of all {@link mxCellStates} for the given array of {@link Cell}.
     *
     * @param cells Array of {@link Cell} whose bounds should be returned.
     */ getBounds(cells) {
        let result = null;
        if (cells.length > 0) {
            for(let i = 0; i < cells.length; i += 1){
                if (cells[i].isVertex() || cells[i].isEdge()) {
                    const state = this.getState(cells[i]);
                    if (state) {
                        if (!result) {
                            result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromRectangle(state);
                        } else {
                            result.add(state);
                        }
                    }
                }
            }
        }
        return result;
    }
    /**
     * Sets and returns the current root and fires an {@link undo} event before
     * calling {@link graph.sizeDidChange}.
     *
     * @param root {@link mxCell} that specifies the root of the displayed cell hierarchy.
     */ setCurrentRoot(root) {
        if (this.currentRoot !== root) {
            const change = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$CurrentRootChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this, root);
            change.execute();
            const edit = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$UndoableEdit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this, true);
            edit.add(change);
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNDO, {
                edit
            }));
            this.graph.sizeDidChange();
            this.currentRoot = root;
        }
        return root;
    }
    /**
     * Sets the scale and translation and fires a {@link scale} and {@link translate} event
     * before calling {@link revalidate} followed by {@link graph.sizeDidChange}.
     *
     * @param scale Decimal value that specifies the new scale (1 is 100%).
     * @param dx X-coordinate of the translation.
     * @param dy Y-coordinate of the translation.
     */ scaleAndTranslate(scale, dx, dy) {
        const previousScale = this.scale;
        const previousTranslate = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.translate.x, this.translate.y);
        if (this.scale !== scale || this.translate.x !== dx || this.translate.y !== dy) {
            this.scale = scale;
            this.translate.x = dx;
            this.translate.y = dy;
            if (this.isEventsEnabled()) {
                this.viewStateChanged();
            }
        }
        this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SCALE_AND_TRANSLATE, {
            scale,
            previousScale,
            translate: this.translate,
            previousTranslate: previousTranslate
        }));
    }
    /**
     * Invoked after {@link scale} and/or {@link translate} has changed.
     */ viewStateChanged() {
        this.revalidate();
        this.graph.sizeDidChange();
    }
    /**
     * Clears the view if {@link currentRoot} is not null and revalidates.
     */ refresh() {
        if (this.currentRoot) {
            this.clear();
        }
        this.revalidate();
    }
    /**
     * Revalidates the complete view with all cell states.
     */ revalidate() {
        this.invalidate();
        this.validate();
    }
    /**
     * Removes the state of the given cell and all descendants if the given
     * cell is not the current root.
     *
     * @param cell Optional {@link Cell} for which the state should be removed. Default
     * is the root of the model.
     * @param force Boolean indicating if the current root should be ignored for
     * recursion.
     */ clear(cell, force = false, recurse = true) {
        if (!cell) {
            cell = this.graph.getDataModel().getRoot();
        }
        if (cell) {
            this.removeState(cell);
            if (recurse && (force || cell !== this.currentRoot)) {
                const childCount = cell.getChildCount();
                for(let i = 0; i < childCount; i += 1){
                    this.clear(cell.getChildAt(i), force);
                }
            } else {
                this.invalidate(cell);
            }
        }
    }
    /**
     * Invalidates the state of the given cell, all its descendants and
     * connected edges.
     *
     * @param cell Optional {@link Cell} to be invalidated. Default is the root of the
     * model.
     */ invalidate(cell = null, recurse = true, includeEdges = true) {
        const model = this.graph.getDataModel();
        cell = cell ?? model.getRoot();
        if (cell) {
            const state = this.getState(cell);
            if (state) {
                state.invalid = true;
            }
            // Avoids infinite loops for invalid graphs
            if (!cell.invalidating) {
                cell.invalidating = true;
                // Recursively invalidates all descendants
                if (recurse) {
                    const childCount = cell.getChildCount();
                    for(let i = 0; i < childCount; i += 1){
                        const child = cell.getChildAt(i);
                        this.invalidate(child, recurse, includeEdges);
                    }
                }
                // Propagates invalidation to all connected edges
                if (includeEdges) {
                    const edgeCount = cell.getEdgeCount();
                    for(let i = 0; i < edgeCount; i += 1){
                        this.invalidate(cell.getEdgeAt(i), recurse, includeEdges);
                    }
                }
                cell.invalidating = false;
            }
        }
    }
    /**
     * Calls {@link validateCell} and {@link validateCellState} and updates the {@link graphBounds}
     * using {@link getBoundingBox}. Finally the background is validated using
     * {@link validateBackground}.
     *
     * @param cell Optional {@link Cell} to be used as the root of the validation.
     * Default is {@link currentRoot} or the root of the model.
     */ validate(cell = null) {
        const t0 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GlobalConfig"].logger.enter('GraphView.validate');
        this.resetValidationState();
        const c = cell || (this.currentRoot ?? this.graph.getDataModel().getRoot());
        if (c) {
            const graphBounds = this.getBoundingBox(this.validateCellState(c ? this.validateCell(c) : null));
            this.setGraphBounds(graphBounds ?? this.getEmptyBounds());
            this.validateBackground();
            this.resetValidationState();
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$config$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GlobalConfig"].logger.leave('GraphView.validate', t0);
    }
    /**
     * Returns the bounds for an empty graph. This returns a rectangle at
     * {@link translate} with the size of 0 x 0.
     */ getEmptyBounds() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.translate.x * this.scale, this.translate.y * this.scale);
    }
    /**
     * Returns the bounding box of the shape and the label for the given
     * {@link CellState} and its children if recurse is true.
     *
     * @param state {@link CellState} whose bounding box should be returned.
     * @param recurse Optional boolean indicating if the children should be included.
     * Default is true.
     */ getBoundingBox(state = null, recurse = true) {
        let bbox = null;
        if (state) {
            if (state.shape && state.shape.boundingBox) {
                bbox = state.shape.boundingBox.clone();
            }
            // Adds label bounding box to graph bounds
            if (state.text && state.text.boundingBox) {
                if (bbox) {
                    bbox.add(state.text.boundingBox);
                } else {
                    bbox = state.text.boundingBox.clone();
                }
            }
            if (recurse) {
                const childCount = state.cell.getChildCount();
                for(let i = 0; i < childCount; i += 1){
                    const bounds = this.getBoundingBox(this.getState(state.cell.getChildAt(i)));
                    if (bounds) {
                        if (!bbox) {
                            bbox = bounds;
                        } else {
                            bbox.add(bounds);
                        }
                    }
                }
            }
        }
        return bbox;
    }
    /**
     * Creates and returns the shape used as the background page.
     *
     * @param bounds {@link mxRectangle} that represents the bounds of the shape.
     */ createBackgroundPageShape(bounds) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$RectangleShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](bounds, 'white', 'black');
    }
    /**
     * Calls {@link validateBackgroundImage} and {@link validateBackgroundPage}.
     */ validateBackground() {
        this.validateBackgroundImage();
        this.validateBackgroundPage();
    }
    /**
     * Validates the background image.
     */ validateBackgroundImage() {
        const bg = this.graph.getBackgroundImage();
        if (bg) {
            if (!this.backgroundImage || this.backgroundImage.imageSrc !== bg.src) {
                if (this.backgroundImage) {
                    this.backgroundImage.destroy();
                }
                const bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0, 1, 1);
                this.backgroundImage = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$node$2f$ImageShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](bounds, bg.src);
                this.backgroundImage.dialect = this.graph.dialect;
                this.backgroundImage.init(this.backgroundPane);
                this.backgroundImage.redraw();
            }
            this.redrawBackgroundImage(this.backgroundImage, bg);
        } else if (this.backgroundImage) {
            this.backgroundImage.destroy();
            this.backgroundImage = null;
        }
    }
    /**
     * Validates the background page.
     */ validateBackgroundPage() {
        const graph = this.graph;
        if (graph.pageVisible) {
            const bounds = this.getBackgroundPageBounds();
            if (this.backgroundPageShape == null) {
                this.backgroundPageShape = this.createBackgroundPageShape(bounds);
                this.backgroundPageShape.scale = this.scale;
                this.backgroundPageShape.isShadow = true;
                this.backgroundPageShape.dialect = this.graph.dialect;
                this.backgroundPageShape.init(this.backgroundPane);
                this.backgroundPageShape.redraw();
                if (this.backgroundPageShape.node) {
                    // Adds listener for double click handling on background
                    if (graph.isNativeDblClickEnabled()) {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].addListener(this.backgroundPageShape.node, 'dblclick', (evt)=>{
                            graph.dblClick(evt);
                        });
                    }
                    // Adds basic listeners for graph event dispatching outside of the
                    // container and finishing the handling of a single gesture
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].addGestureListeners(this.backgroundPageShape.node, (evt)=>{
                        graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](evt));
                    }, (evt)=>{
                        const tooltipHandler = graph.getPlugin('TooltipHandler');
                        // Hides the tooltip if mouse is outside container
                        if (tooltipHandler && tooltipHandler.isHideOnHover()) {
                            tooltipHandler.hide();
                        }
                        if (graph.isMouseDown && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConsumed"])(evt)) {
                            graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_MOVE, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](evt));
                        }
                    }, (evt)=>{
                        graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_UP, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](evt));
                    });
                }
            } else {
                this.backgroundPageShape.scale = this.scale;
                this.backgroundPageShape.bounds = bounds;
                this.backgroundPageShape.redraw();
            }
        } else if (this.backgroundPageShape) {
            this.backgroundPageShape.destroy();
            this.backgroundPageShape = null;
        }
    }
    /**
     * Returns the bounds for the background page.
     */ getBackgroundPageBounds() {
        const fmt = this.graph.pageFormat;
        const ps = this.scale * this.graph.pageScale;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.scale * this.translate.x, this.scale * this.translate.y, fmt.width * ps, fmt.height * ps);
    }
    /**
     * Updates the bounds and redraws the background image.
     *
     * Example:
     *
     * If the background image should not be scaled, this can be replaced with
     * the following.
     *
     * @example
     * ```javascript
     * redrawBackground(backgroundImage, bg)
     * {
     *   backgroundImage.bounds.x = this.translate.x;
     *   backgroundImage.bounds.y = this.translate.y;
     *   backgroundImage.bounds.width = bg.width;
     *   backgroundImage.bounds.height = bg.height;
     *
     *   backgroundImage.redraw();
     * };
     * ```
     *
     * @param backgroundImage {@link mxImageShape} that represents the background image.
     * @param bg {@link mxImage} that specifies the image and its dimensions.
     */ redrawBackgroundImage(backgroundImage, bg) {
        backgroundImage.scale = this.scale;
        if (backgroundImage.bounds) {
            const bounds = backgroundImage.bounds;
            bounds.x = this.scale * this.translate.x;
            bounds.y = this.scale * this.translate.y;
            bounds.width = this.scale * bg.width;
            bounds.height = this.scale * bg.height;
        }
        backgroundImage.redraw();
    }
    /**
     * Recursively creates the cell state for the given cell if visible is true and
     * the given cell is visible. If the cell is not visible but the state exists
     * then it is removed using {@link removeState}.
     *
     * @param cell {@link mxCell} whose {@link CellState} should be created.
     * @param visible Optional boolean indicating if the cell should be visible. Default
     * is true.
     */ validateCell(cell, visible = true) {
        visible = visible && cell.isVisible();
        const state = this.getState(cell, visible);
        if (state && !visible) {
            this.removeState(cell);
        } else {
            const childCount = cell.getChildCount();
            for(let i = 0; i < childCount; i += 1){
                this.validateCell(cell.getChildAt(i), visible && (!cell.isCollapsed() || cell === this.currentRoot));
            }
        }
        return cell;
    }
    /**
     * Validates and repaints the {@link CellState} for the given {@link Cell}.
     *
     * @param cell {@link mxCell} whose {@link CellState} should be validated.
     * @param recurse Optional boolean indicating if the children of the cell should be
     * validated. Default is true.
     */ validateCellState(cell, recurse = true) {
        let state = null;
        if (cell) {
            state = this.getState(cell);
            if (state) {
                if (state.invalid) {
                    state.invalid = false;
                    if (!state.style || state.invalidStyle) {
                        state.style = this.graph.getCellStyle(state.cell);
                        state.invalidStyle = false;
                    }
                    if (cell !== this.currentRoot) {
                        this.validateCellState(cell.getParent(), false);
                    }
                    state.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, true), false), true);
                    state.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, false), false), false);
                    this.updateCellState(state);
                    // Repaint happens immediately after the cell is validated
                    if (cell !== this.currentRoot && !state.invalid) {
                        this.graph.cellRenderer.redraw(state, false, this.isRendering());
                        // Handles changes to invertex paintbounds after update of rendering shape
                        state.updateCachedBounds();
                    }
                }
                if (recurse && !state.invalid) {
                    // Updates order in DOM if recursively traversing
                    if (state.shape) {
                        this.stateValidated(state);
                    }
                    const childCount = cell.getChildCount();
                    for(let i = 0; i < childCount; i += 1){
                        this.validateCellState(cell.getChildAt(i));
                    }
                }
            }
        }
        return state;
    }
    /**
     * Updates the given {@link CellState}.
     *
     * @param state {@link CellState} to be updated.
     */ updateCellState(state) {
        const absoluteOffset = state.absoluteOffset;
        const origin = state.origin;
        absoluteOffset.x = 0;
        absoluteOffset.y = 0;
        origin.x = 0;
        origin.y = 0;
        state.length = 0;
        if (state.cell !== this.currentRoot) {
            const parent = state.cell.getParent();
            const pState = parent ? this.getState(parent) : null;
            if (pState && pState.cell !== this.currentRoot) {
                origin.x += pState.origin.x;
                origin.y += pState.origin.y;
            }
            let offset = this.graph.getChildOffsetForCell(state.cell);
            if (offset) {
                origin.x += offset.x;
                origin.y += offset.y;
            }
            const geo = state.cell.getGeometry();
            if (geo) {
                if (!state.cell.isEdge()) {
                    offset = geo.offset ? geo.offset : this.EMPTY_POINT;
                    if (geo.relative && pState) {
                        if (pState.cell.isEdge()) {
                            const point = this.getPoint(pState, geo);
                            if (point) {
                                origin.x += point.x / this.scale - pState.origin.x - this.translate.x;
                                origin.y += point.y / this.scale - pState.origin.y - this.translate.y;
                            }
                        } else {
                            origin.x += geo.x * pState.unscaledWidth + offset.x;
                            origin.y += geo.y * pState.unscaledHeight + offset.y;
                        }
                    } else {
                        absoluteOffset.x = this.scale * offset.x;
                        absoluteOffset.y = this.scale * offset.y;
                        origin.x += geo.x;
                        origin.y += geo.y;
                    }
                }
                state.x = this.scale * (this.translate.x + origin.x);
                state.y = this.scale * (this.translate.y + origin.y);
                state.width = this.scale * geo.width;
                state.unscaledWidth = geo.width;
                state.height = this.scale * geo.height;
                state.unscaledHeight = geo.height;
                if (state.cell.isVertex()) {
                    this.updateVertexState(state, geo);
                }
                if (state.cell.isEdge()) {
                    this.updateEdgeState(state, geo);
                }
            }
        }
        state.updateCachedBounds();
    }
    /**
     * Validates the given cell state.
     */ updateVertexState(state, geo) {
        const parent = state.cell.getParent();
        const pState = parent ? this.getState(parent) : null;
        if (geo.relative && pState && !pState.cell.isEdge()) {
            const alpha = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toRadians"])(pState.style.rotation ?? 0);
            if (alpha !== 0) {
                const cos = Math.cos(alpha);
                const sin = Math.sin(alpha);
                const ct = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](state.getCenterX(), state.getCenterY());
                const cx = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](pState.getCenterX(), pState.getCenterY());
                const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRotatedPoint"])(ct, cos, sin, cx);
                state.x = pt.x - state.width / 2;
                state.y = pt.y - state.height / 2;
            }
        }
        this.updateVertexLabelOffset(state);
    }
    /**
     * Validates the given cell state.
     */ updateEdgeState(state, geo) {
        const source = state.getVisibleTerminalState(true);
        const target = state.getVisibleTerminalState(false);
        // This will remove edges with no terminals and no terminal points
        // as such edges are invalid and produce NPEs in the edge styles.
        // Also removes connected edges that have no visible terminals.
        if (state.cell.getTerminal(true) && !source || !source && !geo.getTerminalPoint(true) || state.cell.getTerminal(false) && !target || !target && !geo.getTerminalPoint(false)) {
            this.clear(state.cell, true);
        } else {
            this.updateFixedTerminalPoints(state, source, target);
            this.updatePoints(state, geo.points, source, target);
            this.updateFloatingTerminalPoints(state, source, target);
            const pts = state.absolutePoints;
            if (state.cell !== this.currentRoot && (pts == null || pts.length < 2 || pts[0] == null || pts[pts.length - 1] == null)) {
                // This will remove edges with invalid points from the list of states in the view.
                // Happens if the one of the terminals and the corresponding terminal point is null.
                this.clear(state.cell, true);
            } else {
                this.updateEdgeBounds(state);
                this.updateEdgeLabelOffset(state);
            }
        }
    }
    /**
     * Updates the absoluteOffset of the given vertex cell state. This takes
     * into account the label position styles.
     *
     * @param state {@link CellState} whose absolute offset should be updated.
     */ updateVertexLabelOffset(state) {
        const h = state.style.labelPosition ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER;
        if (h === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].LEFT) {
            let lw = state.style.labelWidth ?? null;
            if (lw != null) {
                lw *= this.scale;
            } else {
                lw = state.width;
            }
            // @ts-ignore
            state.absoluteOffset.x -= lw;
        } else if (h === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT) {
            // @ts-ignore
            state.absoluteOffset.x += state.width;
        } else if (h === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER) {
            const lw = state.style.labelWidth ?? null;
            if (lw != null) {
                // Aligns text block with given width inside the vertex width
                const align = state.style.align ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER;
                let dx = 0;
                if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER) {
                    dx = 0.5;
                } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT) {
                    dx = 1;
                }
                if (dx !== 0) {
                    // @ts-ignore
                    state.absoluteOffset.x -= (lw * this.scale - state.width) * dx;
                }
            }
        }
        const v = state.style.verticalLabelPosition ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE;
        if (v === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].TOP) {
            // @ts-ignore
            state.absoluteOffset.y -= state.height;
        } else if (v === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].BOTTOM) {
            // @ts-ignore
            state.absoluteOffset.y += state.height;
        }
    }
    /**
     * Resets the current validation state.
     */ resetValidationState() {
        this.lastNode = null;
        this.lastHtmlNode = null;
        this.lastForegroundNode = null;
        this.lastForegroundHtmlNode = null;
    }
    /**
     * Invoked when a state has been processed in {@link validatePoints}. This is used
     * to update the order of the DOM nodes of the shape.
     *
     * @param state {@link CellState} that represents the cell state.
     */ stateValidated(state) {
        const graph = this.graph;
        const fg = state.cell.isEdge() && graph.keepEdgesInForeground || state.cell.isVertex() && graph.keepEdgesInBackground;
        const htmlNode = fg ? this.lastForegroundHtmlNode || this.lastHtmlNode : this.lastHtmlNode;
        const node = fg ? this.lastForegroundNode || this.lastNode : this.lastNode;
        const result = graph.cellRenderer.insertStateAfter(state, node, htmlNode);
        if (fg) {
            this.lastForegroundHtmlNode = result[1];
            this.lastForegroundNode = result[0];
        } else {
            this.lastHtmlNode = result[1];
            this.lastNode = result[0];
        }
    }
    /**
     * Sets the initial absolute terminal points in the given state before the edge
     * style is computed.
     *
     * @param edge {@link CellState} whose initial terminal points should be updated.
     * @param source {@link CellState} which represents the source terminal.
     * @param target {@link CellState} which represents the target terminal.
     */ updateFixedTerminalPoints(edge, source, target) {
        this.updateFixedTerminalPoint(edge, source, true, this.graph.getConnectionConstraint(edge, source, true));
        this.updateFixedTerminalPoint(edge, target, false, this.graph.getConnectionConstraint(edge, target, false));
    }
    /**
     * Sets the fixed source or target terminal point on the given edge.
     *
     * @param edge <CellState> whose terminal point should be updated.
     * @param terminal <CellState> which represents the actual terminal.
     * @param source Boolean that specifies if the terminal is the source.
     * @param constraint {@link ConnectionConstraint} that specifies the connection.
     */ updateFixedTerminalPoint(edge, terminal, source, constraint) {
        edge.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(edge, terminal, source, constraint), source);
    }
    /**
     * Returns the fixed source or target terminal point for the given edge.
     *
     * @param edge <CellState> whose terminal point should be returned.
     * @param terminal <CellState> which represents the actual terminal.
     * @param source Boolean that specifies if the terminal is the source.
     * @param constraint {@link ConnectionConstraint} that specifies the connection.
     */ getFixedTerminalPoint(edge, terminal, source, constraint) {
        let pt = null;
        if (constraint && terminal) {
            pt = this.graph.getConnectionPoint(terminal, constraint, false); // FIXME Rounding introduced bugs when calculating label positions -> , this.graph.isOrthogonal(edge));
        }
        if (!pt && !terminal) {
            const s = this.scale;
            const tr = this.translate;
            const orig = edge.origin;
            const geo = edge.cell.getGeometry();
            pt = geo.getTerminalPoint(source);
            if (pt) {
                pt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](s * (tr.x + pt.x + orig.x), s * (tr.y + pt.y + orig.y));
            }
        }
        return pt;
    }
    /**
     * Updates the bounds of the given cell state to reflect the bounds of the stencil
     * if it has a fixed aspect and returns the previous bounds as an {@link Rectangle} if
     * the bounds have been modified or null otherwise.
     *
     * @param edge {@link CellState} whose bounds should be updated.
     */ updateBoundsFromStencil(state) {
        let previous = null;
        if (state && state.shape && state.shape.stencil && state.shape.stencil.aspect === 'fixed') {
            previous = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromRectangle(state);
            const asp = state.shape.stencil.computeAspect(null, state.x, state.y, state.width, state.height);
            state.setRect(asp.x, asp.y, state.shape.stencil.w0 * asp.width, state.shape.stencil.h0 * asp.height);
        }
        return previous;
    }
    /**
     * Updates the absolute points in the given state using the specified array
     * of {@link Point} as the relative points.
     *
     * @param edge {@link CellState} whose absolute points should be updated.
     * @param points Array of {@link Point} that constitute the relative points.
     * @param source {@link CellState} that represents the source terminal.
     * @param target {@link CellState} that represents the target terminal.
     */ updatePoints(edge, points, source, target) {
        const pts = [];
        pts.push(edge.absolutePoints[0]);
        const edgeStyle = this.getEdgeStyle(edge, points, source, target);
        if (edgeStyle && source) {
            // target can be null
            const src = this.getTerminalPort(edge, source, true);
            const trg = target ? this.getTerminalPort(edge, target, false) : null;
            // Uses the stencil bounds for routing and restores after routing
            const srcBounds = this.updateBoundsFromStencil(src);
            const trgBounds = this.updateBoundsFromStencil(trg);
            edgeStyle(edge, src, trg, points, pts);
            // Restores previous bounds
            if (src && srcBounds) {
                src.setRect(srcBounds.x, srcBounds.y, srcBounds.width, srcBounds.height);
            }
            if (trg && trgBounds) {
                trg.setRect(trgBounds.x, trgBounds.y, trgBounds.width, trgBounds.height);
            }
        } else if (points) {
            for(let i = 0; i < points.length; i += 1){
                if (points[i]) {
                    const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cloneUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(points[i]);
                    pts.push(this.transformControlPoint(edge, pt));
                }
            }
        }
        const tmp = edge.absolutePoints;
        pts.push(tmp[tmp.length - 1]);
        edge.absolutePoints = pts;
    }
    /**
     * Transforms the given control point to an absolute point.
     */ transformControlPoint(state, pt, ignoreScale = false) {
        if (state && pt) {
            const orig = state.origin;
            const scale = ignoreScale ? 1 : this.scale;
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](scale * (pt.x + this.translate.x + orig.x), scale * (pt.y + this.translate.y + orig.y));
        }
        return null;
    }
    /**
     * Returns true if the given edge should be routed with {@link graph.defaultLoopStyle}
     * or the {@link CellStateStyle.STYLE_LOOP} defined for the given edge.
     * This implementation returns `true` if the given edge is a loop and does not
     */ isLoopStyleEnabled(edge, points = [], source = null, target = null) {
        const sc = this.graph.getConnectionConstraint(edge, source, true);
        const tc = this.graph.getConnectionConstraint(edge, target, false);
        if ((points == null || points.length < 2) && !((edge.style.orthogonalLoop ?? false) || (sc == null || sc.point == null) && (tc == null || tc.point == null))) {
            return source != null && source === target;
        }
        return false;
    }
    /**
     * Returns the edge style function to be used to render the given edge state.
     */ getEdgeStyle(edge, points = [], source = null, target = null) {
        let edgeStyle = this.isLoopStyleEnabled(edge, points, source, target) ? edge.style.loopStyle ?? this.graph.defaultLoopStyle : !(edge.style.noEdgeStyle ?? false) ? edge.style.edgeStyle : null;
        // Converts string values to objects
        if (typeof edgeStyle === 'string') {
            let tmp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getValue(edgeStyle);
            if (!tmp && this.isAllowEval()) {
                tmp = eval(edgeStyle);
            }
            edgeStyle = tmp;
        }
        if (typeof edgeStyle === 'function') {
            return edgeStyle;
        }
        return null;
    }
    /**
     * Updates the terminal points in the given state after the edge style was
     * computed for the edge.
     *
     * @param state {@link CellState} whose terminal points should be updated.
     * @param source {@link CellState} that represents the source terminal.
     * @param target {@link CellState} that represents the target terminal.
     */ updateFloatingTerminalPoints(state, source, target) {
        const pts = state.absolutePoints;
        const p0 = pts[0];
        const pe = pts[pts.length - 1];
        if (!pe && target) {
            this.updateFloatingTerminalPoint(state, target, source, false);
        }
        if (!p0 && source) {
            this.updateFloatingTerminalPoint(state, source, target, true);
        }
    }
    /**
     * Updates the absolute terminal point in the given state for the given
     * start and end state, where start is the source if source is true.
     *
     * @param edge {@link CellState} whose terminal point should be updated.
     * @param start {@link CellState} for the terminal on "this" side of the edge.
     * @param end {@link CellState} for the terminal on the other side of the edge.
     * @param source Boolean indicating if start is the source terminal state.
     */ updateFloatingTerminalPoint(edge, start, end, source) {
        edge.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(edge, start, end, source), source);
    }
    /**
     * Returns the floating terminal point for the given edge, start and end
     * state, where start is the source if source is true.
     *
     * @param edge {@link CellState} whose terminal point should be returned.
     * @param start {@link CellState} for the terminal on "this" side of the edge.
     * @param end {@link CellState} for the terminal on the other side of the edge.
     * @param source Boolean indicating if start is the source terminal state.
     */ getFloatingTerminalPoint(edge, start, end, source) {
        start = this.getTerminalPort(edge, start, source);
        let next = this.getNextPoint(edge, end, source);
        const orth = this.graph.isOrthogonal(edge);
        const alpha = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toRadians"])(start.style.rotation ?? 0);
        const center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](start.getCenterX(), start.getCenterY());
        if (alpha !== 0) {
            const cos = Math.cos(-alpha);
            const sin = Math.sin(-alpha);
            next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRotatedPoint"])(next, cos, sin, center);
        }
        let border = edge.style.perimeterSpacing ?? 0;
        border += edge.style[source ? 'sourcePerimeterSpacing' : 'targetPerimeterSpacing'] ?? 0;
        let pt = this.getPerimeterPoint(start, next, alpha === 0 && orth, border);
        if (pt && alpha !== 0) {
            const cos = Math.cos(alpha);
            const sin = Math.sin(alpha);
            pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRotatedPoint"])(pt, cos, sin, center);
        }
        return pt;
    }
    /**
     * Returns an {@link CellState} that represents the source or target terminal or
     * port for the given edge.
     *
     * @param state {@link CellState} that represents the state of the edge.
     * @param terminal {@link CellState} that represents the terminal.
     * @param source Boolean indicating if the given terminal is the source terminal.
     */ getTerminalPort(state, terminal, source = false) {
        const key = source ? 'sourcePort' : 'targetPort';
        const id = state.style[key];
        if (id) {
            const cell = this.graph.getDataModel().getCell(id);
            if (cell) {
                const tmp = this.getState(cell, false);
                // Only uses ports where a cell state exists
                if (tmp) {
                    terminal = tmp;
                }
            }
        }
        return terminal;
    }
    /**
     * Returns an {@link Point} that defines the location of the intersection point between
     * the perimeter and the line between the center of the shape and the given point.
     *
     * @param terminal {@link CellState} for the source or target terminal.
     * @param next {@link Point} that lies outside the given terminal.
     * @param orthogonal Boolean that specifies if the orthogonal projection onto
     * the perimeter should be returned. If this is false then the intersection
     * of the perimeter and the line between the next and the center point is
     * returned.
     * @param border Optional border between the perimeter and the shape.
     */ getPerimeterPoint(terminal, next, orthogonal, border = 0) {
        let point = null;
        if (terminal != null) {
            const perimeter = this.getPerimeterFunction(terminal);
            if (perimeter != null && next != null) {
                const bounds = this.getPerimeterBounds(terminal, border);
                if (bounds.width > 0 || bounds.height > 0) {
                    point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](next.x, next.y);
                    let flipH = false;
                    let flipV = false;
                    if (terminal.cell.isVertex()) {
                        flipH = !!terminal.style.flipH;
                        flipV = !!terminal.style.flipV;
                        if (flipH) {
                            point.x = 2 * bounds.getCenterX() - point.x;
                        }
                        if (flipV) {
                            point.y = 2 * bounds.getCenterY() - point.y;
                        }
                    }
                    point = perimeter(bounds, terminal, point, orthogonal);
                    if (point != null) {
                        if (flipH) {
                            point.x = 2 * bounds.getCenterX() - point.x;
                        }
                        if (flipV) {
                            point.y = 2 * bounds.getCenterY() - point.y;
                        }
                    }
                }
            }
            if (point == null) {
                point = this.getPoint(terminal);
            }
        }
        return point;
    }
    /**
     * Returns the x-coordinate of the center point for automatic routing.
     */ getRoutingCenterX(state) {
        const f = state.style ? state.style.routingCenterX ?? 0 : 0;
        return state.getCenterX() + f * state.width;
    }
    /**
     * Returns the y-coordinate of the center point for automatic routing.
     */ getRoutingCenterY(state) {
        const f = state.style ? state.style.routingCenterY ?? 0 : 0;
        return state.getCenterY() + f * state.height;
    }
    /**
     * Returns the perimeter bounds for the given terminal, edge pair as an
     * {@link Rectangle}.
     *
     * If you have a model where each terminal has a relative child that should
     * act as the graphical endpoint for a connection from/to the terminal, then
     * this method can be replaced as follows:
     *
     * @example
     * ```javascript
     * var oldGetPerimeterBounds = getPerimeterBounds;
     * getPerimeterBounds(terminal, edge, isSource)
     * {
     *   var model = this.graph.getDataModel();
     *   var childCount = model.getChildCount(terminal.cell);
     *
     *   if (childCount > 0)
     *   {
     *     var child = model.getChildAt(terminal.cell, 0);
     *     var geo = model.getGeometry(child);
     *
     *     if (geo != null &&
     *         geo.relative)
     *     {
     *       var state = this.getState(child);
     *
     *       if (state != null)
     *       {
     *         terminal = state;
     *       }
     *     }
     *   }
     *
     *   return oldGetPerimeterBounds.apply(this, arguments);
     * };
     * ```
     *
     * @param terminal CellState that represents the terminal.
     * @param border Number that adds a border between the shape and the perimeter.
     */ getPerimeterBounds(terminal, border = 0) {
        border += terminal.style.perimeterSpacing ?? 0;
        return terminal.getPerimeterBounds(border * this.scale);
    }
    /**
     * Returns the perimeter function for the given state.
     */ getPerimeterFunction(state) {
        let perimeter = state.style.perimeter;
        // Converts string values to objects
        if (typeof perimeter === 'string') {
            let tmp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$StyleRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getValue(perimeter);
            if (tmp == null && this.isAllowEval()) {
                tmp = eval(perimeter);
            }
            perimeter = tmp;
        }
        if (typeof perimeter === 'function') {
            return perimeter;
        }
        return null;
    }
    /**
     * Returns the nearest point in the list of absolute points or the center
     * of the opposite terminal.
     *
     * @param edge {@link CellState} that represents the edge.
     * @param opposite {@link CellState} that represents the opposite terminal.
     * @param source Boolean indicating if the next point for the source or target
     * should be returned.
     */ getNextPoint(edge, opposite, source = false) {
        const pts = edge.absolutePoints;
        let point = null;
        if (pts.length >= 2) {
            const count = pts.length;
            point = pts[source ? Math.min(1, count - 1) : Math.max(0, count - 2)];
        }
        if (!point && opposite) {
            point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](opposite.getCenterX(), opposite.getCenterY());
        }
        return point; // shouldn't return null, but really?
    }
    /**
     * Returns the nearest ancestor terminal that is visible. The edge appears
     * to be connected to this terminal on the display. The result of this method
     * is cached in {@link CellState.getVisibleTerminalState}.
     *
     * @param edge {@link mxCell} whose visible terminal should be returned.
     * @param source Boolean that specifies if the source or target terminal
     * should be returned.
     */ getVisibleTerminal(edge, source) {
        const model = this.graph.getDataModel();
        let result = edge.getTerminal(source);
        let best = result;
        while(result && result !== this.currentRoot){
            if (best && !best.isVisible() || result.isCollapsed()) {
                best = result;
            }
            result = result.getParent();
        }
        // Checks if the result is valid for the current view state
        if (best && (!model.contains(best) || best.getParent() === model.getRoot() || best === this.currentRoot)) {
            best = null;
        }
        return best;
    }
    /**
     * Updates the given state using the bounding box of t
     * he absolute points.
     * Also updates {@link CellState.terminalDistance}, {@link CellState.length} and
     * {@link CellState.segments}.
     *
     * @param state {@link CellState} whose bounds should be updated.
     */ updateEdgeBounds(state) {
        const points = state.absolutePoints;
        const p0 = points[0];
        const pe = points[points.length - 1];
        if (p0 && pe && (p0.x !== pe.x || p0.y !== pe.y)) {
            const dx = pe.x - p0.x;
            const dy = pe.y - p0.y;
            state.terminalDistance = Math.sqrt(dx * dx + dy * dy);
        } else {
            state.terminalDistance = 0;
        }
        let length = 0;
        const segments = [];
        let pt = p0;
        if (pt) {
            let minX = pt.x;
            let minY = pt.y;
            let maxX = minX;
            let maxY = minY;
            for(let i = 1; i < points.length; i += 1){
                const tmp = points[i];
                if (tmp) {
                    const dx = pt.x - tmp.x;
                    const dy = pt.y - tmp.y;
                    const segment = Math.sqrt(dx * dx + dy * dy);
                    segments.push(segment);
                    length += segment;
                    pt = tmp;
                    minX = Math.min(pt.x, minX);
                    minY = Math.min(pt.y, minY);
                    maxX = Math.max(pt.x, maxX);
                    maxY = Math.max(pt.y, maxY);
                }
            }
            state.length = length;
            state.segments = segments;
            const markerSize = 1; // TODO: include marker size
            state.x = minX;
            state.y = minY;
            state.width = Math.max(markerSize, maxX - minX);
            state.height = Math.max(markerSize, maxY - minY);
        }
    }
    /**
     * Returns the absolute point on the edge for the given relative
     * {@link Geometry} as an {@link Point}. The edge is represented by the given
     * {@link CellState}.
     *
     * @param state {@link CellState} that represents the state of the parent edge.
     * @param geometry {@link mxGeometry} that represents the relative location.
     */ getPoint(state, geometry = null) {
        let x = state.getCenterX();
        let y = state.getCenterY();
        if (state.segments != null && (geometry == null || geometry.relative)) {
            const gx = geometry != null ? geometry.x / 2 : 0;
            const pointCount = state.absolutePoints.length;
            const dist = Math.round((gx + 0.5) * state.length);
            let segment = state.segments[0];
            let length = 0;
            let index = 1;
            while(dist >= Math.round(length + segment) && index < pointCount - 1){
                length += segment;
                segment = state.segments[index++];
            }
            const factor = segment === 0 ? 0 : (dist - length) / segment;
            const p0 = state.absolutePoints[index - 1];
            const pe = state.absolutePoints[index];
            if (p0 != null && pe != null) {
                let gy = 0;
                let offsetX = 0;
                let offsetY = 0;
                if (geometry != null) {
                    gy = geometry.y;
                    const { offset } = geometry;
                    if (offset != null) {
                        offsetX = offset.x;
                        offsetY = offset.y;
                    }
                }
                const dx = pe.x - p0.x;
                const dy = pe.y - p0.y;
                const nx = segment === 0 ? 0 : dy / segment;
                const ny = segment === 0 ? 0 : dx / segment;
                x = p0.x + dx * factor + (nx * gy + offsetX) * this.scale;
                y = p0.y + dy * factor - (ny * gy - offsetY) * this.scale;
            }
        } else if (geometry != null) {
            const { offset } = geometry;
            if (offset != null) {
                x += offset.x;
                y += offset.y;
            }
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y);
    }
    /**
     * Gets the relative point that describes the given, absolute label
     * position for the given edge state.
     *
     * @param state {@link CellState} that represents the state of the parent edge.
     * @param x Specifies the x-coordinate of the absolute label location.
     * @param y Specifies the y-coordinate of the absolute label location.
     */ getRelativePoint(edgeState, x, y) {
        const geometry = edgeState.cell.getGeometry();
        if (geometry) {
            const absolutePoints = edgeState.absolutePoints;
            const pointCount = absolutePoints.length;
            if (geometry.relative && pointCount > 1) {
                const totalLength = edgeState.length;
                const { segments } = edgeState;
                // Works out which line segment the point of the label is closest to
                let p0 = absolutePoints[0];
                let pe = absolutePoints[1];
                let minDist = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ptSegDistSq"])(p0.x, p0.y, pe.x, pe.y, x, y);
                let length = 0;
                let index = 0;
                let tmp = 0;
                for(let i = 2; i < pointCount; i += 1){
                    p0 = pe;
                    pe = absolutePoints[i];
                    const dist = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ptSegDistSq"])(p0.x, p0.y, pe.x, pe.y, x, y);
                    tmp += segments[i - 2];
                    if (dist <= minDist) {
                        minDist = dist;
                        index = i - 1;
                        length = tmp;
                    }
                }
                const seg = segments[index];
                p0 = absolutePoints[index];
                pe = absolutePoints[index + 1];
                const x2 = p0.x;
                const y2 = p0.y;
                const x1 = pe.x;
                const y1 = pe.y;
                let px = x;
                let py = y;
                const xSegment = x2 - x1;
                const ySegment = y2 - y1;
                px -= x1;
                py -= y1;
                let projlenSq = 0;
                px = xSegment - px;
                py = ySegment - py;
                const dotprod = px * xSegment + py * ySegment;
                if (dotprod <= 0.0) {
                    projlenSq = 0;
                } else {
                    projlenSq = dotprod * dotprod / (xSegment * xSegment + ySegment * ySegment);
                }
                let projlen = Math.sqrt(projlenSq);
                if (projlen > seg) {
                    projlen = seg;
                }
                let yDistance = Math.sqrt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ptSegDistSq"])(p0.x, p0.y, pe.x, pe.y, x, y));
                const direction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["relativeCcw"])(p0.x, p0.y, pe.x, pe.y, x, y);
                if (direction === -1) {
                    yDistance = -yDistance;
                }
                // Constructs the relative point for the label
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]((totalLength / 2 - length - projlen) / totalLength * -2, yDistance / this.scale);
            }
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    }
    /**
     * Updates {@link CellState.absoluteOffset} for the given state. The absolute
     * offset is normally used for the position of the edge label. Is is
     * calculated from the geometry as an absolute offset from the center
     * between the two endpoints if the geometry is absolute, or as the
     * relative distance between the center along the line and the absolute
     * orthogonal distance if the geometry is relative.
     *
     * @param state {@link CellState} whose absolute offset should be updated.
     */ updateEdgeLabelOffset(state) {
        const points = state.absolutePoints;
        const absoluteOffset = state.absoluteOffset;
        absoluteOffset.x = state.getCenterX();
        absoluteOffset.y = state.getCenterY();
        if (points.length > 0 && state.segments) {
            const geometry = state.cell.getGeometry();
            if (geometry) {
                if (geometry.relative) {
                    const offset = this.getPoint(state, geometry);
                    state.absoluteOffset = offset;
                } else {
                    const p0 = points[0];
                    const pe = points[points.length - 1];
                    if (p0 && pe) {
                        const dx = pe.x - p0.x;
                        const dy = pe.y - p0.y;
                        let x0 = 0;
                        let y0 = 0;
                        const off = geometry.offset;
                        if (off) {
                            x0 = off.x;
                            y0 = off.y;
                        }
                        const x = p0.x + dx / 2 + x0 * this.scale;
                        const y = p0.y + dy / 2 + y0 * this.scale;
                        absoluteOffset.x = x;
                        absoluteOffset.y = y;
                    }
                }
            }
        }
    }
    /**
     * Returns the {@link CellState} for the given cell. If create is true, then
     * the state is created if it does not yet exist.
     *
     * @param cell {@link mxCell} for which the {@link CellState} should be returned.
     * @param create Optional boolean indicating if a new state should be created
     * if it does not yet exist. Default is false.
     */ getState(cell, create = false) {
        let state = this.states.get(cell);
        if (create && (!state || this.updateStyle) && cell.isVisible()) {
            if (!state) {
                state = this.createState(cell);
                this.states.put(cell, state);
            } else {
                state.style = this.graph.getCellStyle(cell);
            }
        }
        return state;
    }
    /**
     * Returns the {@link mxCellStates} for the given array of {@link Cell}. The array
     * contains all states that are not null, that is, the returned array may
     * have less elements than the given array. If no argument is given, then
     * this returns {@link states}.
     */ getCellStates(cells = null) {
        if (!cells) {
            return this.states.getValues();
        }
        const result = [];
        for (const cell of cells){
            const state = this.getState(cell);
            if (state) {
                result.push(state);
            }
        }
        return result;
    }
    /**
     * Removes and returns the {@link CellState} for the given cell.
     *
     * @param cell {@link mxCell} for which the {@link CellState} should be removed.
     */ removeState(cell) {
        const state = this.states.remove(cell);
        if (state) {
            this.graph.cellRenderer.destroy(state);
            state.invalid = true;
            state.destroy();
        }
        return state;
    }
    /**
     * Creates and returns an {@link CellState} for the given cell and initializes
     * it using {@link cellRenderer.initialize}.
     *
     * @param cell {@link mxCell} for which a new {@link CellState} should be created.
     */ createState(cell) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this, cell, this.graph.getCellStyle(cell));
    }
    /**
     * Returns true if the event origin is one of the drawing panes or
     * containers of the view.
     */ isContainerEvent(evt) {
        const source = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSource"])(evt);
        return source && (source === this.graph.container || // @ts-ignore parentNode may exist
        source.parentNode === this.backgroundPane || source.parentNode && source.parentNode.parentNode === this.backgroundPane || source === this.canvas.parentNode || source === this.canvas || source === this.backgroundPane || source === this.drawPane || source === this.overlayPane || source === this.decoratorPane);
    }
    isScrollEvent(evt) {
        const graph = this.graph;
        const offset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getOffset"])(graph.container);
        const eventClientPosition = evt instanceof MouseEvent ? [
            evt.clientX,
            evt.clientY
        ] : [
            evt.touches[0].clientX,
            evt.touches[0].clientY
        ];
        const pt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](eventClientPosition[0] - offset.x, eventClientPosition[1] - offset.y);
        const container = graph.container;
        const outWidth = container.offsetWidth;
        const inWidth = container.clientWidth;
        if (outWidth > inWidth && pt.x > inWidth + 2 && pt.x <= outWidth) {
            return true;
        }
        const outHeight = container.offsetHeight;
        const inHeight = container.clientHeight;
        return outHeight > inHeight && pt.y > inHeight + 2 && pt.y <= outHeight;
    }
    /**
     * Initializes the graph event dispatch loop for the specified container
     * and invokes {@link create} to create the required DOM nodes for the display.
     */ init() {
        this.installListeners();
        this.createSvg();
    }
    /**
     * Installs the required listeners in the container.
     */ installListeners() {
        const graph = this.graph;
        const { container } = graph;
        // Support for touch device gestures (eg. pinch to zoom)
        // Double-tap handling is implemented in mxGraph.fireMouseEvent
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_TOUCH) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].addListener(container, 'gesturestart', (evt)=>{
                graph.fireGestureEvent(evt);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].consume(evt);
            });
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].addListener(container, 'gesturechange', (evt)=>{
                graph.fireGestureEvent(evt);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].consume(evt);
            });
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].addListener(container, 'gestureend', (evt)=>{
                graph.fireGestureEvent(evt);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].consume(evt);
            });
        }
        // Fires event only for one pointer per gesture
        let pointerId = null;
        // Adds basic listeners for graph event dispatching
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].addGestureListeners(container, (evt)=>{
            // Condition to avoid scrollbar events starting a rubberband selection
            if (this.isContainerEvent(evt) && (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_GC && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_SF || !this.isScrollEvent(evt))) {
                graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](evt));
                // @ts-ignore
                pointerId = evt.pointerId;
            }
        }, (evt)=>{
            if (this.isContainerEvent(evt) && // @ts-ignore
            (pointerId === null || evt.pointerId === pointerId)) {
                graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_MOVE, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](evt));
            }
        }, (evt)=>{
            if (this.isContainerEvent(evt)) {
                graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_UP, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](evt));
            }
            pointerId = null;
        });
        // Adds listener for double click handling on background, this does always
        // use native event handler, we assume that the DOM of the background
        // does not change during the double click
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].addListener(container, 'dblclick', (evt)=>{
            if (this.isContainerEvent(evt)) {
                graph.dblClick(evt);
            }
        });
        // Workaround for touch events which started on some DOM node
        // on top of the container, in which case the cells under the
        // mouse for the move and up events are not detected.
        const getState = (evt)=>{
            let state = null;
            // Workaround for touch events which started on some DOM node
            // on top of the container, in which case the cells under the
            // mouse for the move and up events are not detected.
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_TOUCH) {
                const x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getClientX"])(evt);
                const y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getClientY"])(evt);
                // Dispatches the drop event to the graph which
                // consumes and executes the source function
                const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertPoint"])(container, x, y);
                const cell = graph.getCellAt(pt.x, pt.y);
                if (cell) state = graph.view.getState(cell);
            }
            return state;
        };
        // Adds basic listeners for graph event dispatching outside of the
        // container and finishing the handling of a single gesture
        // Implemented via graph event dispatch loop to avoid duplicate events
        // in Firefox and Chrome
        graph.addMouseListener({
            mouseDown: (sender, me)=>{
                const popupMenuHandler = graph.getPlugin('PopupMenuHandler');
                popupMenuHandler?.hideMenu();
            },
            mouseMove: ()=>{
                return;
            },
            mouseUp: ()=>{
                return;
            }
        });
        this.moveHandler = (evt)=>{
            const tooltipHandler = graph.getPlugin('TooltipHandler');
            // Hides the tooltip if mouse is outside container
            if (tooltipHandler && tooltipHandler.isHideOnHover()) {
                tooltipHandler.hide();
            }
            if (this.captureDocumentGesture && graph.isMouseDown && graph.container != null && !this.isContainerEvent(evt) && graph.container.style.display !== 'none' && graph.container.style.visibility !== 'hidden' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConsumed"])(evt)) {
                graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_MOVE, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](evt, getState(evt)));
            }
        };
        this.endHandler = (evt)=>{
            if (this.captureDocumentGesture && graph.isMouseDown && graph.container != null && !this.isContainerEvent(evt) && graph.container.style.display !== 'none' && graph.container.style.visibility !== 'hidden') {
                graph.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_UP, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](evt));
            }
        };
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].addGestureListeners(document, null, this.moveHandler, this.endHandler);
    }
    /**
     * Creates and returns the DOM nodes for the SVG display.
     */ createSvg() {
        const { container } = this.graph;
        const canvas = this.canvas = document.createElementNS(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NS_SVG"], 'g');
        // For background image
        this.backgroundPane = document.createElementNS(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NS_SVG"], 'g');
        canvas.appendChild(this.backgroundPane);
        // Adds two layers (background is early feature)
        this.drawPane = document.createElementNS(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NS_SVG"], 'g');
        canvas.appendChild(this.drawPane);
        this.overlayPane = document.createElementNS(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NS_SVG"], 'g');
        canvas.appendChild(this.overlayPane);
        this.decoratorPane = document.createElementNS(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NS_SVG"], 'g');
        canvas.appendChild(this.decoratorPane);
        const root = document.createElementNS(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NS_SVG"], 'svg');
        root.style.left = '0px';
        root.style.top = '0px';
        root.style.width = '100%';
        root.style.height = '100%';
        // NOTE: In standards mode, the SVG must have block layout
        // in order for the container DIV to not show scrollbars.
        root.style.display = 'block';
        root.appendChild(this.canvas);
        if (container != null) {
            container.appendChild(root);
            this.updateContainerStyle(container);
        }
    }
    /**
     * Function: createHtml
     *
     * Creates the DOM nodes for the HTML display.
     */ createHtml() {
        const container = this.graph.container;
        if (container != null) {
            this.canvas = this.createHtmlPane('100%', '100%');
            this.canvas.style.overflow = 'hidden';
            // Uses minimal size for inner DIVs on Canvas. This is required
            // for correct event processing in IE. If we have an overlapping
            // DIV then the events on the cells are only fired for labels.
            this.backgroundPane = this.createHtmlPane('1px', '1px');
            this.drawPane = this.createHtmlPane('1px', '1px');
            this.overlayPane = this.createHtmlPane('1px', '1px');
            this.decoratorPane = this.createHtmlPane('1px', '1px');
            this.canvas.appendChild(this.backgroundPane);
            this.canvas.appendChild(this.drawPane);
            this.canvas.appendChild(this.overlayPane);
            this.canvas.appendChild(this.decoratorPane);
            container.appendChild(this.canvas);
            this.updateContainerStyle(container);
        }
    }
    /**
     * Function: updateHtmlCanvasSize
     *
     * Updates the size of the HTML canvas.
     */ updateHtmlCanvasSize(width, height) {
        if (this.graph.container != null) {
            const ow = this.graph.container.offsetWidth;
            const oh = this.graph.container.offsetHeight;
            if (ow < width) {
                this.canvas.style.width = width + 'px';
            } else {
                this.canvas.style.width = '100%';
            }
            if (oh < height) {
                this.canvas.style.height = height + 'px';
            } else {
                this.canvas.style.height = '100%';
            }
        }
    }
    /**
     * Function: createHtmlPane
     *
     * Creates and returns a drawing pane in HTML (DIV).
     */ createHtmlPane(width, height) {
        const pane = document.createElement('DIV');
        if (width != null && height != null) {
            pane.style.position = 'absolute';
            pane.style.left = '0px';
            pane.style.top = '0px';
            pane.style.width = width;
            pane.style.height = height;
        } else {
            pane.style.position = 'relative';
        }
        return pane;
    }
    /**
     * Updates the style of the container after installing the SVG DOM elements.
     */ updateContainerStyle(container) {
        // Workaround for offset of container
        const style = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCurrentStyle"])(container);
        if (style != null && style.position == 'static') {
            container.style.position = 'relative';
        }
        // Disables built-in pan and zoom in IE10 and later
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_POINTER) {
            container.style.touchAction = 'none';
        }
    }
    /**
     * Destroys the view and all its resources.
     */ destroy() {
        let root = null;
        if (this.canvas && this.canvas instanceof SVGElement) {
            root = this.canvas.ownerSVGElement;
        }
        if (!root) {
            root = this.canvas;
        }
        if (root && root.parentNode) {
            this.clear(this.currentRoot, true);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].removeGestureListeners(document, null, this.moveHandler, this.endHandler);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].release(this.graph.container);
            root.parentNode.removeChild(root);
            this.moveHandler = null;
            this.endHandler = null;
            // @ts-expect-error Can be null when destroyed.
            this.canvas = null;
            // @ts-expect-error Can be null when destroyed.
            this.backgroundPane = null;
            // @ts-expect-error Can be null when destroyed.
            this.drawPane = null;
            // @ts-expect-error Can be null when destroyed.
            this.overlayPane = null;
            // @ts-expect-error Can be null when destroyed.
            this.decoratorPane = null;
        }
    }
}
const __TURBOPACK__default__export__ = GraphView;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/GraphSelectionModel.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$SelectionChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/SelectionChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$UndoableEdit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/UndoableEdit.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventSource.js [app-client] (ecmascript)");
;
;
;
;
;
;
/**
 * Class: mxGraphSelectionModel
 *
 * Implements the selection model for a graph. Here is a listener that handles
 * all removed selection cells.
 *
 * (code)
 * graph.getSelectionModel().addListener(mxEvent.CHANGE, function(sender, evt)
 * {
 *   var cells = evt.getProperty('added');
 *
 *   for (var i = 0; i < cells.length; i++)
 *   {
 *     // Handle cells[i]...
 *   }
 * });
 * (end)
 *
 * Event: mxEvent.UNDO
 *
 * Fires after the selection was changed in <changeSelection>. The
 * <code>edit</code> property contains the {@link UndoableEdit} which contains the
 * {@link SelectionChange}.
 *
 * Event: mxEvent.CHANGE
 *
 * Fires after the selection changes by executing an {@link SelectionChange}. The
 * <code>added</code> and <code>removed</code> properties contain arrays of
 * cells that have been added to or removed from the selection, respectively.
 * The names are inverted due to historic reasons. This cannot be changed.
 *
 * Constructor: mxGraphSelectionModel
 *
 * Constructs a new graph selection model for the given {@link Graph}.
 *
 * Parameters:
 *
 * graph - Reference to the enclosing {@link Graph}.
 */ class GraphSelectionModel extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor(graph){
        super();
        /**
         * Specifies the resource key for the status message after a long operation.
         * If the resource for this key does not exist then the value is used as
         * the status message. Default is 'done'.
         */ this.doneResource = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].language !== 'none' ? 'done' : '';
        /**
         * Specifies the resource key for the status message while the selection is
         * being updated. If the resource for this key does not exist then the
         * value is used as the status message. Default is 'updatingSelection'.
         */ this.updatingSelectionResource = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].language !== 'none' ? 'updatingSelection' : '';
        /**
         * Specifies if only one selected item at a time is allowed.
         * Default is false.
         */ this.singleSelection = false;
        this.graph = graph;
        this.cells = [];
    }
    /**
     * Returns {@link singleSelection} as a boolean.
     */ isSingleSelection() {
        return this.singleSelection;
    }
    /**
     * Sets the {@link singleSelection} flag.
     *
     * @param {boolean} singleSelection Boolean that specifies the new value for
     * {@link singleSelection}.
     */ setSingleSelection(singleSelection) {
        this.singleSelection = singleSelection;
    }
    /**
     * Returns true if the given {@link Cell} is selected.
     */ isSelected(cell) {
        return this.cells.indexOf(cell) >= 0;
    }
    /**
     * Returns true if no cells are currently selected.
     */ isEmpty() {
        return this.cells.length === 0;
    }
    /**
     * Clears the selection and fires a {@link change} event if the selection was not
     * empty.
     */ clear() {
        this.changeSelection(null, this.cells);
    }
    /**
     * Selects the specified {@link Cell} using {@link setCells}.
     *
     * @param cell {@link mxCell} to be selected.
     */ setCell(cell) {
        this.setCells(cell ? [
            cell
        ] : []);
    }
    /**
     * Selects the given array of {@link Cell} and fires a {@link change} event.
     *
     * @param cells Array of {@link Cell} to be selected.
     */ setCells(cells) {
        if (this.singleSelection) {
            cells = [
                this.getFirstSelectableCell(cells)
            ];
        }
        const tmp = [];
        for(let i = 0; i < cells.length; i += 1){
            if (this.graph.isCellSelectable(cells[i])) {
                tmp.push(cells[i]);
            }
        }
        this.changeSelection(tmp, this.cells);
    }
    /**
     * Returns the first selectable cell in the given array of cells.
     */ getFirstSelectableCell(cells) {
        for(let i = 0; i < cells.length; i += 1){
            if (this.graph.isCellSelectable(cells[i])) {
                return cells[i];
            }
        }
        return null;
    }
    /**
     * Adds the given {@link Cell} to the selection and fires a {@link select} event.
     *
     * @param cell {@link mxCell} to add to the selection.
     */ addCell(cell) {
        this.addCells([
            cell
        ]);
    }
    /**
     * Adds the given array of {@link Cell} to the selection and fires a {@link select}
     * event.
     *
     * @param cells Array of {@link Cell} to add to the selection.
     */ addCells(cells) {
        let remove = null;
        if (this.singleSelection) {
            remove = this.cells;
            const selectableCell = this.getFirstSelectableCell(cells);
            cells = selectableCell ? [
                selectableCell
            ] : [];
        }
        const tmp = [];
        for(let i = 0; i < cells.length; i += 1){
            if (!this.isSelected(cells[i]) && this.graph.isCellSelectable(cells[i])) {
                tmp.push(cells[i]);
            }
        }
        this.changeSelection(tmp, remove);
    }
    /**
     * Removes the specified {@link Cell} from the selection and fires a {@link select}
     * event for the remaining cells.
     *
     * @param cell {@link mxCell} to remove from the selection.
     */ removeCell(cell) {
        this.removeCells([
            cell
        ]);
    }
    /**
     * Removes the specified {@link Cell} from the selection and fires a {@link select}
     * event for the remaining cells.
     *
     * @param cells {@link mxCell}s to remove from the selection.
     */ removeCells(cells) {
        const tmp = [];
        for(let i = 0; i < cells.length; i += 1){
            if (this.isSelected(cells[i])) {
                tmp.push(cells[i]);
            }
        }
        this.changeSelection(null, tmp);
    }
    /**
     * Adds/removes the specified arrays of {@link Cell} to/from the selection.
     *
     * @param added Array of {@link Cell} to add to the selection.
     * @param remove Array of {@link Cell} to remove from the selection.
     */ changeSelection(added = null, removed = null) {
        if (added && added.length > 0 && added[0] || removed && removed.length > 0 && removed[0]) {
            const change = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$SelectionChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.graph, added || [], removed || []);
            change.execute();
            const edit = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$UndoableEdit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.graph, false);
            edit.add(change);
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNDO, {
                edit
            }));
        }
    }
    /**
     * Inner callback to add the specified {@link Cell} to the selection. No event
     * is fired in this implementation.
     *
     * Paramters:
     *
     * @param cell {@link mxCell} to add to the selection.
     */ cellAdded(cell) {
        if (!this.isSelected(cell)) {
            this.cells.push(cell);
        }
    }
    /**
     * Inner callback to remove the specified {@link Cell} from the selection. No
     * event is fired in this implementation.
     *
     * @param cell {@link mxCell} to remove from the selection.
     */ cellRemoved(cell) {
        const index = this.cells.indexOf(cell);
        if (index >= 0) {
            this.cells.splice(index, 1);
        }
    }
}
const __TURBOPACK__default__export__ = GraphSelectionModel;
}}),
"[project]/node_modules/@maxgraph/core/lib/view/plugins/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2024-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "getDefaultPlugins": (()=>getDefaultPlugins)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$CellEditorHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/CellEditorHandler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$TooltipHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/TooltipHandler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$SelectionCellsHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/SelectionCellsHandler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$PopupMenuHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/PopupMenuHandler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$ConnectionHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/ConnectionHandler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$SelectionHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/SelectionHandler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$PanningHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/PanningHandler.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const getDefaultPlugins = ()=>[
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$CellEditorHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$TooltipHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$SelectionCellsHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$PopupMenuHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$ConnectionHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$SelectionHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$PanningHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
    ];
}}),
"[project]/node_modules/@maxgraph/core/lib/view/Graph.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors
Copyright (c) 2006-2015, JGraph Ltd
Copyright (c) 2006-2015, Gaudenz Alder

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "Graph": (()=>Graph)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/CellRenderer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$EdgeHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/EdgeHandler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$EdgeSegmentHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/EdgeSegmentHandler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$ElbowEdgeHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/ElbowEdgeHandler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$GraphDataModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/GraphDataModel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$GraphView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/GraphView.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$GraphSelectionModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/GraphSelectionModel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$Stylesheet$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/Stylesheet.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$VertexHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/handler/VertexHandler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$register$2d$shapes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/register-shapes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$register$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/register.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$MarkerShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/MarkerShape.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$plugins$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/plugins/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/style/EdgeStyle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$image$2f$ImageBox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/image/ImageBox.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$RootChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/RootChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$ChildChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/ChildChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$TerminalChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/TerminalChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$GeometryChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/GeometryChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$ValueChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/ValueChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$StyleChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/StyleChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/Cell.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/domUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventSource.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$_graph$2d$mixins$2d$apply$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/_graph-mixins-apply.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * Extends {@link EventSource} to implement a graph component for the browser. This is the main class of the package.
 *
 * To activate panning and connections use {@link setPanning} and {@link setConnectable}.
 * For rubberband selection you must create a new instance of {@link rubberband}.
 *
 * The following listeners are added to {@link mouseListeners} by default:
 *
 * - tooltipHandler: {@link TooltipHandler} that displays tooltips
 * - panningHandler: {@link PanningHandler} for panning and popup menus
 * - connectionHandler: {@link ConnectionHandler} for creating connections
 * - selectionHandler: {@link SelectionHandler} for moving and cloning cells
 *
 * These listeners will be called in the above order if they are enabled.
 */ class Graph extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    // ===================================================================================================================
    // Group: "Create Class Instance" factory functions.
    // These can be overridden in subclasses of Graph to allow the Graph to instantiate user-defined implementations with
    // custom behavior.
    // ===================================================================================================================
    /**
     * Creates a new {@link CellRenderer} to be used in this graph.
     */ createCellRenderer() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    }
    /**
     * Hooks to create a new {@link EdgeHandler} for the given {@link CellState}.
     *
     * @param state {@link CellState} to create the handler for.
     */ createEdgeHandlerInstance(state) {
        // Note this method not being called createEdgeHandler to keep compatibility
        // with older code which overrides/calls createEdgeHandler
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$EdgeHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](state);
    }
    /**
     * Hooks to create a new {@link EdgeSegmentHandler} for the given {@link CellState}.
     *
     * @param state {@link CellState} to create the handler for.
     */ createEdgeSegmentHandler(state) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$EdgeSegmentHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](state);
    }
    /**
     * Hooks to create a new {@link ElbowEdgeHandler} for the given {@link CellState}.
     *
     * @param state {@link CellState} to create the handler for.
     */ createElbowEdgeHandler(state) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$ElbowEdgeHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](state);
    }
    /**
     * Creates a new {@link GraphDataModel} to be used in this graph.
     */ createGraphDataModel() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$GraphDataModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    }
    /**
     * Creates a new {@link GraphView} to be used in this graph.
     */ createGraphView() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$GraphView$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this);
    }
    /**
     * Creates a new {@link GraphSelectionModel} to be used in this graph.
     */ createSelectionModel() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$GraphSelectionModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this);
    }
    /**
     * Creates a new {@link Stylesheet} to be used in this graph.
     */ createStylesheet() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$Stylesheet$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Stylesheet"]();
    }
    /**
     * Hooks to create a new {@link VertexHandler} for the given {@link CellState}.
     *
     * @param state {@link CellState} to create the handler for.
     */ createVertexHandler(state) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$handler$2f$VertexHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](state);
    }
    // ===================================================================================================================
    // Group: Main graph constructor and functions
    // ===================================================================================================================
    registerDefaults() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$register$2d$shapes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["registerDefaultShapes"])();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$register$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["registerDefaultStyleElements"])();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$MarkerShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["registerDefaultEdgeMarkers"])();
    }
    constructor(container, model, plugins = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$plugins$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDefaultPlugins"])(), stylesheet = null){
        super();
        this.destroyed = false;
        this.graphModelChangeListener = null;
        this.paintBackground = null;
        this.isConstrainedMoving = false;
        // ===================================================================================================================
        // Group: Variables (that maybe should be in the mixins, but need to be created for each new class instance)
        // ===================================================================================================================
        this.cells = [];
        this.imageBundles = [];
        /**
         * Holds the mouse event listeners. See {@link fireMouseEvent}.
         */ this.mouseListeners = [];
        /**
         * An array of {@link Multiplicity} describing the allowed connections in a graph.
         */ this.multiplicities = [];
        this.plugins = {};
        /**
         * RenderHint as it was passed to the constructor.
         */ this.renderHint = null;
        /**
         * Dialect to be used for drawing the graph. Possible values are all constants in {@link DIALECT}.
         */ this.dialect = 'svg';
        /**
         * Value returned by {@link getOverlap} if {@link isAllowOverlapParent} returns
         * `true` for the given cell. {@link getOverlap} is used in {@link constrainChild} if
         * {@link isConstrainChild} returns `true`. The value specifies the
         * portion of the child which is allowed to overlap the parent.
         */ this.defaultOverlap = 0.5;
        /**
         * Specifies the default parent to be used to insert new cells.
         * This is used in {@link getDefaultParent}.
         * @default null
         */ this.defaultParent = null;
        /**
         * Specifies the {@link Image} to be returned by {@link getBackgroundImage}.
         * @default null
         *
         * @example
         * ```javascript
         * var img = new mxImage('http://www.example.com/maps/examplemap.jpg', 1024, 768);
         * graph.setBackgroundImage(img);
         * graph.view.validate();
         * ```
         */ this.backgroundImage = null;
        /**
         * Specifies if the background page should be visible.
         * Not yet implemented.
         * @default false
         */ this.pageVisible = false;
        /**
         * Specifies if a dashed line should be drawn between multiple pages.
         * If you change this value while a graph is being displayed then you
         * should call {@link sizeDidChange} to force an update of the display.
         * @default false
         */ this.pageBreaksVisible = false;
        /**
         * Specifies the color for page breaks.
         * @default gray
         */ this.pageBreakColor = 'gray';
        /**
         * Specifies the page breaks should be dashed.
         * @default true
         */ this.pageBreakDashed = true;
        /**
         * Specifies the minimum distance in pixels for page breaks to be visible.
         * @default 20
         */ this.minPageBreakDist = 20;
        /**
         * Specifies if the graph size should be rounded to the next page number in
         * {@link sizeDidChange}. This is only used if the graph container has scrollbars.
         * @default false
         */ this.preferPageSize = false;
        /**
         * Specifies the page format for the background page.
         * This is used as the default in {@link PrintPreview} and for painting the background page
         * if {@link pageVisible} is `true` and the page breaks if {@link pageBreaksVisible} is `true`.
         * @default {@link mxConstants.PAGE_FORMAT_A4_PORTRAIT}
         */ this.pageFormat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PAGE_FORMAT_A4_PORTRAIT"]);
        /**
         * Specifies the scale of the background page.
         * Not yet implemented.
         * @default 1.5
         */ this.pageScale = 1.5;
        /**
         * Specifies the return value for {@link isEnabled}.
         * @default true
         */ this.enabled = true;
        /**
         * Specifies the return value for {@link canExportCell}.
         * @default true
         */ this.exportEnabled = true;
        /**
         * Specifies the return value for {@link canImportCell}.
         * @default true
         */ this.importEnabled = true;
        /**
         * Specifies if the graph should automatically scroll regardless of the
         * scrollbars. This will scroll the container using positive values for
         * scroll positions (ie usually only rightwards and downwards). To avoid
         * possible conflicts with panning, set {@link translateToScrollPosition} to `true`.
         */ this.ignoreScrollbars = false;
        /**
         * Specifies if the graph should automatically convert the current scroll
         * position to a translate in the graph view when a mouseUp event is received.
         * This can be used to avoid conflicts when using {@link autoScroll} and
         * {@link ignoreScrollbars} with no scrollbars in the container.
         */ this.translateToScrollPosition = false;
        /**
         * {@link Rectangle} that specifies the area in which all cells in the diagram
         * should be placed. Uses in {@link getMaximumGraphBounds}. Use a width or height of
         * `0` if you only want to give a upper, left corner.
         */ this.maximumGraphBounds = null;
        /**
         * {@link Rectangle} that specifies the minimum size of the graph. This is ignored
         * if the graph container has no scrollbars.
         * @default null
         */ this.minimumGraphSize = null;
        /**
         * {@link Rectangle} that specifies the minimum size of the {@link container} if
         * {@link resizeContainer} is `true`.
         */ this.minimumContainerSize = null;
        /**
         * {@link Rectangle} that specifies the maximum size of the container if
         * {@link resizeContainer} is `true`.
         */ this.maximumContainerSize = null;
        /**
         * Specifies if the container should be resized to the graph size when
         * the graph size has changed.
         * @default false
         */ this.resizeContainer = false;
        /**
         * Border to be added to the bottom and right side when the container is
         * being resized after the graph has been changed.
         * @default 0
         */ this.border = 0;
        /**
         * Specifies if edges should appear in the foreground regardless of their order
         * in the model. If {@link keepEdgesInForeground} and {@link keepEdgesInBackground} are
         * both `true` then the normal order is applied.
         * @default false
         */ this.keepEdgesInForeground = false;
        /**
         * Specifies if edges should appear in the background regardless of their order
         * in the model. If {@link keepEdgesInForeground} and {@link keepEdgesInBackground} are
         * both `true` then the normal order is applied.
         * @default false
         */ this.keepEdgesInBackground = false;
        /**
         * Specifies the return value for {@link isRecursiveResize}.
         * @default false (for backwards compatibility)
         */ this.recursiveResize = false;
        /**
         * Specifies if the scale and translate should be reset if the root changes in
         * the model.
         * @default true
         */ this.resetViewOnRootChange = true;
        /**
         * Specifies if loops (aka self-references) are allowed.
         * @default false
         */ this.allowLoops = false;
        /**
         * {@link EdgeStyle} to be used for loops. This is a fallback for loops if the
         * {@link CellStateStyle.loopStyle} is `undefined`.
         * @default {@link EdgeStyle.Loop}
         */ this.defaultLoopStyle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Loop;
        /**
         * Specifies if multiple edges in the same direction between the same pair of
         * vertices are allowed.
         * @default true
         */ this.multigraph = true;
        /**
         * Specifies the minimum scale to be applied in {@link fit}. Set this to `null` to allow any value.
         * @default 0.1
         */ this.minFitScale = 0.1;
        /**
         * Specifies the maximum scale to be applied in {@link fit}. Set this to `null` to allow any value.
         * @default 8
         */ this.maxFitScale = 8;
        /**
         * Specifies the {@link Image} for the image to be used to display a warning
         * overlay. See {@link setCellWarning}. Default value is Client.imageBasePath +
         * '/warning'.  The extension for the image depends on the platform. It is
         * '.png' on the Mac and '.gif' on all other platforms.
         */ this.warningImage = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$image$2f$ImageBox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].imageBasePath}/warning${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_MAC ? '.png' : '.gif'}`, 16, 16);
        /**
         * Specifies the resource key for the error message to be displayed in
         * non-multigraphs when two vertices are already connected. If the resource
         * for this key does not exist then the value is used as the error message.
         * @default 'alreadyConnected'
         */ this.alreadyConnectedResource = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].language != 'none' ? 'alreadyConnected' : '';
        /**
         * Specifies the resource key for the warning message to be displayed when
         * a collapsed cell contains validation errors. If the resource for this
         * key does not exist then the value is used as the warning message.
         * @default 'containsValidationErrors'
         */ this.containsValidationErrorsResource = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].language != 'none' ? 'containsValidationErrors' : '';
        this.getContainer = ()=>this.container;
        this.getPlugin = (id)=>this.plugins[id];
        this.getCellRenderer = ()=>this.cellRenderer;
        this.getDialect = ()=>this.dialect;
        this.isPageVisible = ()=>this.pageVisible;
        this.isPageBreaksVisible = ()=>this.pageBreaksVisible;
        this.getPageBreakColor = ()=>this.pageBreakColor;
        this.isPageBreakDashed = ()=>this.pageBreakDashed;
        this.getMinPageBreakDist = ()=>this.minPageBreakDist;
        this.isPreferPageSize = ()=>this.preferPageSize;
        this.getPageFormat = ()=>this.pageFormat;
        this.getPageScale = ()=>this.pageScale;
        this.isExportEnabled = ()=>this.exportEnabled;
        this.isImportEnabled = ()=>this.importEnabled;
        this.isIgnoreScrollbars = ()=>this.ignoreScrollbars;
        this.isTranslateToScrollPosition = ()=>this.translateToScrollPosition;
        this.getMinimumGraphSize = ()=>this.minimumGraphSize;
        this.setMinimumGraphSize = (size)=>this.minimumGraphSize = size;
        this.getMinimumContainerSize = ()=>this.minimumContainerSize;
        this.setMinimumContainerSize = (size)=>this.minimumContainerSize = size;
        this.getAlreadyConnectedResource = ()=>this.alreadyConnectedResource;
        this.getContainsValidationErrorsResource = ()=>this.containsValidationErrorsResource;
        this.registerDefaults();
        this.container = container ?? document.createElement('div');
        this.model = model ?? this.createGraphDataModel();
        this.cellRenderer = this.createCellRenderer();
        this.setStylesheet(stylesheet ?? this.createStylesheet());
        this.view = this.createGraphView();
        // Adds a graph model listener to update the view
        this.graphModelChangeListener = (sender, evt)=>{
            this.graphModelChanged(evt.getProperty('edit').changes);
        };
        this.getDataModel().addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CHANGE, this.graphModelChangeListener);
        // Initializes the container using the view
        this.view.init();
        // Updates the size of the container for the current graph
        this.sizeDidChange();
        // Set the selection model
        this.setSelectionModel(this.createSelectionModel());
        // Initializes plugins
        plugins.forEach((p)=>this.plugins[p.pluginId] = new p(this));
        this.view.revalidate();
    }
    getWarningImage() {
        return this.warningImage;
    }
    /**
     * Updates the model in a transaction.
     *
     * @param fn the update to be performed in the transaction.
     *
     * @see {@link GraphDataModel.batchUpdate}
     */ batchUpdate(fn) {
        this.getDataModel().batchUpdate(fn);
    }
    /**
     * Returns the {@link GraphDataModel} that contains the cells.
     */ getDataModel() {
        return this.model;
    }
    /**
     * Returns the {@link GraphView} that contains the {@link mxCellStates}.
     */ getView() {
        return this.view;
    }
    /**
     * Returns the {@link Stylesheet} that defines the style.
     */ getStylesheet() {
        return this.stylesheet;
    }
    /**
     * Sets the {@link Stylesheet} that defines the style.
     */ setStylesheet(stylesheet) {
        this.stylesheet = stylesheet;
    }
    /**
     * Called when the graph model changes. Invokes {@link processChange} on each
     * item of the given array to update the view accordingly.
     *
     * @param changes Array that contains the individual changes.
     */ graphModelChanged(changes) {
        for (const change of changes){
            this.processChange(change);
        }
        this.updateSelection();
        this.view.validate();
        this.sizeDidChange();
    }
    /**
     * Processes the given change and invalidates the respective cached data
     * in {@link GraphView}. This fires a {@link root} event if the root has changed in the
     * model.
     *
     * @param {(RootChange|ChildChange|TerminalChange|GeometryChange|ValueChange|StyleChange)} change - Object that represents the change on the model.
     */ processChange(change) {
        // Resets the view settings, removes all cells and clears
        // the selection if the root changes.
        if (change instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$RootChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
            this.clearSelection();
            this.setDefaultParent(null);
            if (change.previous) this.removeStateForCell(change.previous);
            if (this.resetViewOnRootChange) {
                this.view.scale = 1;
                this.view.translate.x = 0;
                this.view.translate.y = 0;
            }
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ROOT));
        } else if (change instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$ChildChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
            const newParent = change.child.getParent();
            this.view.invalidate(change.child, true, true);
            if (!newParent || !this.getDataModel().contains(newParent) || newParent.isCollapsed()) {
                this.view.invalidate(change.child, true, true);
                this.removeStateForCell(change.child);
                // Handles special case of current root of view being removed
                if (this.view.currentRoot == change.child) {
                    this.home();
                }
            }
            if (newParent != change.previous) {
                // Refreshes the collapse/expand icons on the parents
                if (newParent != null) {
                    this.view.invalidate(newParent, false, false);
                }
                if (change.previous != null) {
                    this.view.invalidate(change.previous, false, false);
                }
            }
        } else if (change instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$TerminalChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] || change instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$GeometryChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
            // Checks if the geometry has changed to avoid unnessecary revalidation
            if (change instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$TerminalChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] || change.previous == null && change.geometry != null || change.previous != null && !change.previous.equals(change.geometry)) {
                this.view.invalidate(change.cell);
            }
        } else if (change instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$ValueChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
            this.view.invalidate(change.cell, false, false);
        } else if (change instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$StyleChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
            this.view.invalidate(change.cell, true, true);
            const state = this.view.getState(change.cell);
            if (state != null) {
                state.invalidStyle = true;
            }
        } else if (change.cell != null && change.cell instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
            this.removeStateForCell(change.cell);
        }
    }
    /**
     * Scrolls the graph to the given point, extending the graph container if
     * specified.
     */ scrollPointToVisible(x, y, extend = false, border = 20) {
        const panningHandler = this.getPlugin('PanningHandler');
        if (!this.isTimerAutoScroll() && (this.ignoreScrollbars || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasScrollbars"])(this.container))) {
            const c = this.container;
            if (x >= c.scrollLeft && y >= c.scrollTop && x <= c.scrollLeft + c.clientWidth && y <= c.scrollTop + c.clientHeight) {
                let dx = c.scrollLeft + c.clientWidth - x;
                if (dx < border) {
                    const old = c.scrollLeft;
                    c.scrollLeft += border - dx;
                    // Automatically extends the canvas size to the bottom, right
                    // if the event is outside of the canvas and the edge of the
                    // canvas has been reached. Notes: Needs fix for IE.
                    if (extend && old === c.scrollLeft) {
                        // @ts-ignore
                        const root = this.view.getDrawPane().ownerSVGElement;
                        const width = c.scrollWidth + border - dx;
                        // Updates the clipping region. This is an expensive
                        // operation that should not be executed too often.
                        // @ts-ignore
                        root.style.width = `${width}px`;
                        c.scrollLeft += border - dx;
                    }
                } else {
                    dx = x - c.scrollLeft;
                    if (dx < border) {
                        c.scrollLeft -= border - dx;
                    }
                }
                let dy = c.scrollTop + c.clientHeight - y;
                if (dy < border) {
                    const old = c.scrollTop;
                    c.scrollTop += border - dy;
                    if (old == c.scrollTop && extend) {
                        // @ts-ignore
                        const root = this.view.getDrawPane().ownerSVGElement;
                        const height = c.scrollHeight + border - dy;
                        // Updates the clipping region. This is an expensive
                        // operation that should not be executed too often.
                        // @ts-ignore
                        root.style.height = `${height}px`;
                        c.scrollTop += border - dy;
                    }
                } else {
                    dy = y - c.scrollTop;
                    if (dy < border) {
                        c.scrollTop -= border - dy;
                    }
                }
            }
        } else if (this.isAllowAutoPanning() && panningHandler && !panningHandler.isActive()) {
            panningHandler.getPanningManager().panTo(x + this.getPanDx(), y + this.getPanDy());
        }
    }
    /**
     * Returns the size of the border and padding on all four sides of the
     * container. The left, top, right and bottom borders are stored in the x, y,
     * width and height of the returned {@link Rectangle}, respectively.
     */ getBorderSizes() {
        const css = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCurrentStyle"])(this.container);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseCssNumber"])(css.paddingLeft) + (css.borderLeftStyle != 'none' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseCssNumber"])(css.borderLeftWidth) : 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseCssNumber"])(css.paddingTop) + (css.borderTopStyle != 'none' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseCssNumber"])(css.borderTopWidth) : 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseCssNumber"])(css.paddingRight) + (css.borderRightStyle != 'none' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseCssNumber"])(css.borderRightWidth) : 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseCssNumber"])(css.paddingBottom) + (css.borderBottomStyle != 'none' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseCssNumber"])(css.borderBottomWidth) : 0));
    }
    /**
     * Returns the preferred size of the background page if {@link preferPageSize} is true.
     */ getPreferredPageSize(bounds, width, height) {
        const tr = this.view.translate;
        const fmt = this.pageFormat;
        const ps = this.pageScale;
        const page = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0, Math.ceil(fmt.width * ps), Math.ceil(fmt.height * ps));
        const hCount = this.pageBreaksVisible ? Math.ceil(width / page.width) : 1;
        const vCount = this.pageBreaksVisible ? Math.ceil(height / page.height) : 1;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0, hCount * page.width + 2 + tr.x, vCount * page.height + 2 + tr.y);
    }
    /**
     * Scales the graph such that the complete diagram fits into <container> and
     * returns the current scale in the view. To fit an initial graph prior to
     * rendering, set {@link GraphView#rendering} to false prior to changing the model
     * and execute the following after changing the model.
     *
     * ```javascript
     * graph.fit();
     * graph.view.rendering = true;
     * graph.refresh();
     * ```
     *
     * To fit and center the graph, the following code can be used.
     *
     * ```javascript
     * let margin = 2;
     * let max = 3;
     *
     * let bounds = graph.getGraphBounds();
     * let cw = graph.container.clientWidth - margin;
     * let ch = graph.container.clientHeight - margin;
     * let w = bounds.width / graph.view.scale;
     * let h = bounds.height / graph.view.scale;
     * let s = Math.min(max, Math.min(cw / w, ch / h));
     *
     * graph.view.scaleAndTranslate(s,
     *   (margin + cw - w * s) / (2 * s) - bounds.x / graph.view.scale,
     *   (margin + ch - h * s) / (2 * s) - bounds.y / graph.view.scale);
     * ```
     *
     * @param border Optional number that specifies the border. Default is <border>.
     * @param keepOrigin Optional boolean that specifies if the translate should be
     * changed. Default is false.
     * @param margin Optional margin in pixels. Default is 0.
     * @param enabled Optional boolean that specifies if the scale should be set or
     * just returned. Default is true.
     * @param ignoreWidth Optional boolean that specifies if the width should be
     * ignored. Default is false.
     * @param ignoreHeight Optional boolean that specifies if the height should be
     * ignored. Default is false.
     * @param maxHeight Optional maximum height.
     */ fit(border = this.getBorder(), keepOrigin = false, margin = 0, enabled = true, ignoreWidth = false, ignoreHeight = false, maxHeight = null) {
        if (this.container != null) {
            // Adds spacing and border from css
            const cssBorder = this.getBorderSizes();
            let w1 = this.container.offsetWidth - cssBorder.x - cssBorder.width - 1;
            let h1 = maxHeight != null ? maxHeight : this.container.offsetHeight - cssBorder.y - cssBorder.height - 1;
            let bounds = this.view.getGraphBounds();
            if (bounds.width > 0 && bounds.height > 0) {
                if (keepOrigin && bounds.x != null && bounds.y != null) {
                    bounds = bounds.clone();
                    bounds.width += bounds.x;
                    bounds.height += bounds.y;
                    bounds.x = 0;
                    bounds.y = 0;
                }
                // LATER: Use unscaled bounding boxes to fix rounding errors
                const s = this.view.scale;
                let w2 = bounds.width / s;
                let h2 = bounds.height / s;
                // Fits to the size of the background image if required
                if (this.backgroundImage != null) {
                    w2 = Math.max(w2, this.backgroundImage.width - bounds.x / s);
                    h2 = Math.max(h2, this.backgroundImage.height - bounds.y / s);
                }
                const b = (keepOrigin ? border : 2 * border) + margin + 1;
                w1 -= b;
                h1 -= b;
                let s2 = ignoreWidth ? h1 / h2 : ignoreHeight ? w1 / w2 : Math.min(w1 / w2, h1 / h2);
                if (this.minFitScale != null) {
                    s2 = Math.max(s2, this.minFitScale);
                }
                if (this.maxFitScale != null) {
                    s2 = Math.min(s2, this.maxFitScale);
                }
                if (enabled) {
                    if (!keepOrigin) {
                        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasScrollbars"])(this.container)) {
                            const x0 = bounds.x != null ? Math.floor(this.view.translate.x - bounds.x / s + border / s2 + margin / 2) : border;
                            const y0 = bounds.y != null ? Math.floor(this.view.translate.y - bounds.y / s + border / s2 + margin / 2) : border;
                            this.view.scaleAndTranslate(s2, x0, y0);
                        } else {
                            this.view.setScale(s2);
                            const b2 = this.getGraphBounds();
                            if (b2.x != null) {
                                this.container.scrollLeft = b2.x;
                            }
                            if (b2.y != null) {
                                this.container.scrollTop = b2.y;
                            }
                        }
                    } else if (this.view.scale != s2) {
                        this.view.setScale(s2);
                    }
                } else {
                    return s2;
                }
            }
        }
        return this.view.scale;
    }
    /**
     * Resizes the container for the given graph width and height.
     */ doResizeContainer(width, height) {
        if (this.maximumContainerSize != null) {
            width = Math.min(this.maximumContainerSize.width, width);
            height = Math.min(this.maximumContainerSize.height, height);
        }
        const container = this.container;
        container.style.width = `${Math.ceil(width)}px`;
        container.style.height = `${Math.ceil(height)}px`;
    }
    /*****************************************************************************
     * Group: UNCLASSIFIED
     *****************************************************************************/ /**
     * Creates a new handler for the given cell state. This implementation
     * returns a new {@link EdgeHandler} of the corresponding cell is an edge,
     * otherwise it returns an {@link VertexHandler}.
     *
     * @param state {@link CellState} whose handler should be created.
     */ createHandler(state) {
        let result = null;
        if (state.cell.isEdge()) {
            const source = state.getVisibleTerminalState(true);
            const target = state.getVisibleTerminalState(false);
            const geo = state.cell.getGeometry();
            const edgeStyle = this.getView().getEdgeStyle(state, geo ? geo.points || undefined : undefined, source, target);
            result = this.createEdgeHandler(state, edgeStyle);
        } else {
            result = this.createVertexHandler(state);
        }
        return result;
    }
    /**
     * Hooks to create a new {@link EdgeHandler} for the given {@link CellState}.
     *
     * @param state {@link CellState} to create the handler for.
     * @param edgeStyle the {@link EdgeStyleFunction} that let choose the actual edge handler.
     */ createEdgeHandler(state, edgeStyle) {
        let result = null;
        if (edgeStyle == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Loop || edgeStyle == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ElbowConnector || edgeStyle == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SideToSide || edgeStyle == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TopToBottom) {
            result = this.createElbowEdgeHandler(state);
        } else if (edgeStyle == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SegmentConnector || edgeStyle == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OrthConnector) {
            result = this.createEdgeSegmentHandler(state);
        } else {
            result = this.createEdgeHandlerInstance(state);
        }
        return result;
    }
    /*****************************************************************************
     * Group: Drilldown
     *****************************************************************************/ /**
     * Returns the current root of the displayed cell hierarchy. This is a
     * shortcut to {@link GraphView.currentRoot} in {@link GraphView}.
     */ getCurrentRoot() {
        return this.view.currentRoot;
    }
    /**
     * Returns the translation to be used if the given cell is the root cell as
     * an {@link Point}. This implementation returns null.
     *
     * To keep the children at their absolute position while stepping into groups,
     * this function can be overridden as follows.
     *
     * @example
     * ```javascript
     * var offset = new mxPoint(0, 0);
     *
     * while (cell != null)
     * {
     *   var geo = this.model.getGeometry(cell);
     *
     *   if (geo != null)
     *   {
     *     offset.x -= geo.x;
     *     offset.y -= geo.y;
     *   }
     *
     *   cell = this.model.getParent(cell);
     * }
     *
     * return offset;
     * ```
     *
     * @param cell {@link mxCell} that represents the root.
     */ getTranslateForRoot(cell) {
        return null;
    }
    /**
     * Returns the offset to be used for the cells inside the given cell. The
     * root and layer cells may be identified using {@link GraphDataModel.isRoot} and
     * {@link GraphDataModel.isLayer}. For all other current roots, the
     * {@link GraphView.currentRoot} field points to the respective cell, so that
     * the following holds: cell == this.view.currentRoot. This implementation
     * returns null.
     *
     * @param cell {@link mxCell} whose offset should be returned.
     */ getChildOffsetForCell(cell) {
        return null;
    }
    /**
     * Uses the root of the model as the root of the displayed cell hierarchy
     * and selects the previous root.
     */ home() {
        const current = this.getCurrentRoot();
        if (current != null) {
            this.view.setCurrentRoot(null);
            const state = this.view.getState(current);
            if (state != null) {
                this.setSelectionCell(current);
            }
        }
    }
    /**
     * Returns true if the given cell is a valid root for the cell display
     * hierarchy. This implementation returns true for all non-null values.
     *
     * @param cell {@link mxCell} which should be checked as a possible root.
     */ isValidRoot(cell) {
        return !!cell;
    }
    /*****************************************************************************
     * Group: Graph display
     *****************************************************************************/ /**
     * Returns the bounds of the visible graph. Shortcut to
     * {@link GraphView.getGraphBounds}. See also: {@link getBoundingBoxFromGeometry}.
     */ getGraphBounds() {
        return this.view.getGraphBounds();
    }
    /**
     * Returns the bounds inside which the diagram should be kept as an
     * {@link Rectangle}.
     */ getMaximumGraphBounds() {
        return this.maximumGraphBounds;
    }
    /**
     * Clears all cell states or the states for the hierarchy starting at the
     * given cell and validates the graph. This fires a refresh event as the
     * last step.
     *
     * @param cell Optional {@link Cell} for which the cell states should be cleared.
     */ refresh(cell = null) {
        if (cell) {
            this.view.clear(cell, false);
        } else {
            this.view.clear(undefined, true);
        }
        this.view.validate();
        this.sizeDidChange();
        this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].REFRESH));
    }
    /**
     * Centers the graph in the container.
     *
     * @param horizontal Optional boolean that specifies if the graph should be centered
     * horizontally. Default is `true`.
     * @param vertical Optional boolean that specifies if the graph should be centered
     * vertically. Default is `true`.
     * @param cx Optional float that specifies the horizontal center. Default is `0.5`.
     * @param cy Optional float that specifies the vertical center. Default is `0.5`.
     */ center(horizontal = true, vertical = true, cx = 0.5, cy = 0.5) {
        const container = this.container;
        const _hasScrollbars = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasScrollbars"])(this.container);
        const padding = 2 * this.getBorder();
        const cw = container.clientWidth - padding;
        const ch = container.clientHeight - padding;
        const bounds = this.getGraphBounds();
        const t = this.view.translate;
        const s = this.view.scale;
        let dx = horizontal ? cw - bounds.width : 0;
        let dy = vertical ? ch - bounds.height : 0;
        if (!_hasScrollbars) {
            this.view.setTranslate(horizontal ? Math.floor(t.x - bounds.x / s + dx * cx / s) : t.x, vertical ? Math.floor(t.y - bounds.y / s + dy * cy / s) : t.y);
        } else {
            bounds.x -= t.x;
            bounds.y -= t.y;
            const sw = container.scrollWidth;
            const sh = container.scrollHeight;
            if (sw > cw) {
                dx = 0;
            }
            if (sh > ch) {
                dy = 0;
            }
            this.view.setTranslate(Math.floor(dx / 2 - bounds.x), Math.floor(dy / 2 - bounds.y));
            container.scrollLeft = (sw - cw) / 2;
            container.scrollTop = (sh - ch) / 2;
        }
    }
    /**
     * Returns true if perimeter points should be computed such that the
     * resulting edge has only horizontal or vertical segments.
     *
     * @param edge {@link CellState} that represents the edge.
     */ isOrthogonal(edge) {
        /*
        'orthogonal' defines if the connection points on either end of the edge should
        be computed so that the edge is vertical or horizontal if possible
        and if the point is not at a fixed location. Default is false.
        This also returns true if the edgeStyle of the edge is an elbow or
        entity.
         */ const orthogonal = edge.style.orthogonal;
        if (orthogonal != null) {
            return orthogonal;
        }
        const tmp = this.view.getEdgeStyle(edge);
        return tmp === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SegmentConnector || tmp === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ElbowConnector || tmp === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SideToSide || tmp === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TopToBottom || tmp === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EntityRelation || tmp === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$style$2f$EdgeStyle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].OrthConnector;
    }
    /*****************************************************************************
     * Group: Graph appearance
     *****************************************************************************/ /**
     * Returns the {@link backgroundImage} as an {@link Image}.
     */ getBackgroundImage() {
        return this.backgroundImage;
    }
    /**
     * Sets the new {@link backgroundImage}.
     *
     * @param image New {@link Image} to be used for the background.
     */ setBackgroundImage(image) {
        this.backgroundImage = image;
    }
    /**
     * Returns the textual representation for the given cell.
     *
     * This implementation returns the node name or string-representation of the user object.
     *
     *
     * The following returns the label attribute from the cells user object if it is an XML node.
     *
     * @example
     * ```javascript
     * graph.convertValueToString = function(cell)
     * {
     * 	return cell.getAttribute('label');
     * }
     * ```
     *
     * See also: {@link cellLabelChanged}.
     *
     * @param cell {@link Cell} whose textual representation should be returned.
     */ convertValueToString(cell) {
        const value = cell.getValue();
        if (value != null) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(value)) {
                return value.nodeName;
            }
            if (typeof value.toString === 'function') {
                return value.toString();
            }
        }
        return '';
    }
    /**
     * Returns the string to be used as the link for the given cell.
     *
     * This implementation returns null.
     *
     * @param cell {@link Cell} whose link should be returned.
     */ getLinkForCell(cell) {
        return null;
    }
    /**
     * Returns the value of {@link border}.
     */ getBorder() {
        return this.border;
    }
    /**
     * Sets the value of {@link border}.
     *
     * @param value Positive integer that represents the border to be used.
     */ setBorder(value) {
        this.border = value;
    }
    /*****************************************************************************
     * Group: Graph behaviour
     *****************************************************************************/ /**
     * Returns {@link resizeContainer}.
     */ isResizeContainer() {
        return this.resizeContainer;
    }
    /**
     * Sets {@link resizeContainer}.
     *
     * @param value Boolean indicating if the container should be resized.
     */ setResizeContainer(value) {
        this.resizeContainer = value;
    }
    /**
     * Returns true if the graph is {@link enabled}.
     */ isEnabled() {
        return this.enabled;
    }
    /**
     * Specifies if the graph should allow any interactions. This
     * implementation updates {@link enabled}.
     *
     * @param value Boolean indicating if the graph should be enabled.
     */ setEnabled(value) {
        this.enabled = value;
    }
    /**
     * Returns {@link multigraph} as a boolean.
     */ isMultigraph() {
        return this.multigraph;
    }
    /**
     * Specifies if the graph should allow multiple connections between the
     * same pair of vertices.
     *
     * @param value Boolean indicating if the graph allows multiple connections
     * between the same pair of vertices.
     */ setMultigraph(value) {
        this.multigraph = value;
    }
    /**
     * Returns {@link allowLoops} as a boolean.
     */ isAllowLoops() {
        return this.allowLoops;
    }
    /**
     * Specifies if loops are allowed.
     *
     * @param value Boolean indicating if loops are allowed.
     */ setAllowLoops(value) {
        this.allowLoops = value;
    }
    /**
     * Returns {@link recursiveResize}.
     *
     * @param state {@link CellState} that is being resized.
     */ isRecursiveResize(state = null) {
        return this.recursiveResize;
    }
    /**
     * Sets {@link recursiveResize}.
     *
     * @param value New boolean value for {@link recursiveResize}.
     */ setRecursiveResize(value) {
        this.recursiveResize = value;
    }
    /**
     * Returns a decimal number representing the amount of the width and height
     * of the given cell that is allowed to overlap its parent. A value of 0
     * means all children must stay inside the parent, 1 means the child is
     * allowed to be placed outside of the parent such that it touches one of
     * the parents sides. If {@link isAllowOverlapParent} returns false for the given
     * cell, then this method returns 0.
     *
     * @param cell {@link mxCell} for which the overlap ratio should be returned.
     */ getOverlap(cell) {
        return this.isAllowOverlapParent(cell) ? this.defaultOverlap : 0;
    }
    /**
     * Returns true if the given cell is allowed to be placed outside of the
     * parents area.
     *
     * @param cell {@link mxCell} that represents the child to be checked.
     */ isAllowOverlapParent(cell) {
        return false;
    }
    /*****************************************************************************
     * Group: Cell retrieval
     *****************************************************************************/ /**
     * Returns {@link defaultParent} or {@link GraphView.currentRoot} or the first child
     * child of {@link GraphDataModel.root} if both are null. The value returned by
     * this function should be used as the parent for new cells (aka default
     * layer).
     */ getDefaultParent() {
        let parent = this.getCurrentRoot();
        if (!parent) {
            parent = this.defaultParent;
            if (!parent) {
                const root = this.getDataModel().getRoot();
                parent = root.getChildAt(0);
            }
        }
        return parent;
    }
    /**
     * Sets the {@link defaultParent} to the given cell. Set this to null to return
     * the first child of the root in getDefaultParent.
     */ setDefaultParent(cell) {
        this.defaultParent = cell;
    }
    /**
     * Destroys the graph and all its resources.
     */ destroy() {
        if (!this.destroyed) {
            this.destroyed = true;
            Object.values(this.plugins).forEach((p)=>p.onDestroy());
            this.view.destroy();
            if (this.model && this.graphModelChangeListener) {
                this.getDataModel().removeListener(this.graphModelChangeListener);
                this.graphModelChangeListener = null;
            }
        }
    }
}
// This introduces a side effect, but it is necessary to ensure the Graph is enriched with all properties and methods defined in mixins.
// It is only called when Graph is imported, so the Graph definition is always consistent.
// And this doesn't impact the tree-shaking.
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$_graph$2d$mixins$2d$apply$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyGraphMixins"])();
;
}}),
}]);

//# sourceMappingURL=node_modules_%40maxgraph_core_lib_view_9b5e6b._.js.map