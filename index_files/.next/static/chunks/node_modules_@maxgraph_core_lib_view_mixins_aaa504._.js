(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@maxgraph_core_lib_view_mixins_aaa504._.js", {

"[project]/node_modules/@maxgraph/core/lib/view/mixins/CellsMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "CellsMixin": (()=>CellsMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Dictionary.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cellArrayUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/cellArrayUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/StringUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
const CellsMixin = {
    cellsResizable: true,
    cellsBendable: true,
    cellsSelectable: true,
    cellsDisconnectable: true,
    autoSizeCells: false,
    autoSizeCellsOnAdd: false,
    cellsLocked: false,
    cellsCloneable: true,
    cellsDeletable: true,
    cellsMovable: true,
    extendParents: true,
    extendParentsOnAdd: true,
    extendParentsOnMove: false,
    getBoundingBox (cells) {
        let result = null;
        if (cells.length > 0) {
            for (const cell of cells){
                if (cell.isVertex() || cell.isEdge()) {
                    const bbox = this.getView().getBoundingBox(this.getView().getState(cell), true);
                    if (bbox) {
                        if (!result) {
                            result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromRectangle(bbox);
                        } else {
                            result.add(bbox);
                        }
                    }
                }
            }
        }
        return result;
    },
    removeStateForCell (cell) {
        for (const child of cell.getChildren()){
            this.removeStateForCell(child);
        }
        this.getView().invalidate(cell, false, true);
        this.getView().removeState(cell);
    },
    /*****************************************************************************
     * Group: Cell styles
     *****************************************************************************/ getCurrentCellStyle (cell, ignoreState = false) {
        const state = ignoreState ? null : this.getView().getState(cell);
        return state ? state.style : this.getCellStyle(cell);
    },
    getCellStyle (cell) {
        const cellStyle = cell.getStyle();
        const stylesheet = this.getStylesheet();
        // Gets the default style for the cell
        const defaultStyle = cell.isEdge() ? stylesheet.getDefaultEdgeStyle() : stylesheet.getDefaultVertexStyle();
        // Resolves the stylename using the above as the default
        const style = this.postProcessCellStyle(stylesheet.getCellStyle(cellStyle, defaultStyle ?? {}));
        return style;
    },
    postProcessCellStyle (style) {
        if (!style.image) {
            return style;
        }
        const key = style.image;
        let image = this.getImageFromBundles(key);
        if (image) {
            style.image = image;
        } else {
            image = key;
        }
        // Converts short data uris to normal data uris
        if (image && image.substring(0, 11) === 'data:image/') {
            if (image.substring(0, 20) === 'data:image/svg+xml,<') {
                // Required for FF and IE11
                image = image.substring(0, 19) + encodeURIComponent(image.substring(19));
            } else if (image.substring(0, 22) !== 'data:image/svg+xml,%3C') {
                const comma = image.indexOf(',');
                // Adds base64 encoding prefix if needed
                if (comma > 0 && image.substring(comma - 7, comma + 1) !== ';base64,') {
                    image = `${image.substring(0, comma)};base64,${image.substring(comma + 1)}`;
                }
            }
            style.image = image;
        }
        return style;
    },
    setCellStyle (style, cells) {
        cells = cells ?? this.getSelectionCells();
        this.batchUpdate(()=>{
            for (const cell of cells){
                this.getDataModel().setStyle(cell, style);
            }
        });
    },
    toggleCellStyle (key, defaultValue = false, cell) {
        cell = cell ?? this.getSelectionCell();
        return this.toggleCellStyles(key, defaultValue, [
            cell
        ]);
    },
    toggleCellStyles (key, defaultValue = false, cells) {
        let value = false;
        cells = cells ?? this.getSelectionCells();
        if (cells.length > 0) {
            const style = this.getCurrentCellStyle(cells[0]);
            value = style[key] ?? defaultValue ? false : true;
            this.setCellStyles(key, value, cells);
        }
        return value;
    },
    setCellStyles (key, value, cells) {
        cells = cells ?? this.getSelectionCells();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setCellStyles"])(this.getDataModel(), cells, key, value);
    },
    toggleCellStyleFlags (key, flag, cells) {
        cells = cells ?? this.getSelectionCells();
        this.setCellStyleFlags(key, flag, null, cells);
    },
    setCellStyleFlags (key, flag, value = null, cells) {
        cells = cells ?? this.getSelectionCells();
        if (cells.length > 0) {
            if (value === null) {
                const style = this.getCurrentCellStyle(cells[0]);
                const current = style[key] || 0;
                value = !((current & flag) === flag);
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setCellStyleFlags"])(this.getDataModel(), cells, key, flag, value);
        }
    },
    /*****************************************************************************
     * Group: Cell alignment and orientation
     *****************************************************************************/ alignCells (align, cells, param = null) {
        cells = cells ?? this.getSelectionCells();
        if (cells.length > 1) {
            // Finds the required coordinate for the alignment
            if (param === null) {
                for (const cell of cells){
                    const state = this.getView().getState(cell);
                    if (state && !cell.isEdge()) {
                        if (param === null) {
                            if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER) {
                                param = state.x + state.width / 2;
                                break;
                            } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT) {
                                param = state.x + state.width;
                            } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].TOP) {
                                param = state.y;
                            } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE) {
                                param = state.y + state.height / 2;
                                break;
                            } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].BOTTOM) {
                                param = state.y + state.height;
                            } else {
                                param = state.x;
                            }
                        } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT) {
                            param = Math.max(param, state.x + state.width);
                        } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].TOP) {
                            param = Math.min(param, state.y);
                        } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].BOTTOM) {
                            param = Math.max(param, state.y + state.height);
                        } else {
                            param = Math.min(param, state.x);
                        }
                    }
                }
            }
            // Aligns the cells to the coordinate
            if (param !== null) {
                const s = this.getView().scale;
                this.batchUpdate(()=>{
                    const p = param;
                    for (const cell of cells){
                        const state = this.getView().getState(cell);
                        if (state != null) {
                            let geo = cell.getGeometry();
                            if (geo != null && !cell.isEdge()) {
                                geo = geo.clone();
                                if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER) {
                                    geo.x += (p - state.x - state.width / 2) / s;
                                } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT) {
                                    geo.x += (p - state.x - state.width) / s;
                                } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].TOP) {
                                    geo.y += (p - state.y) / s;
                                } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE) {
                                    geo.y += (p - state.y - state.height / 2) / s;
                                } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].BOTTOM) {
                                    geo.y += (p - state.y - state.height) / s;
                                } else {
                                    geo.x += (p - state.x) / s;
                                }
                                this.resizeCell(cell, geo);
                            }
                        }
                    }
                    this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ALIGN_CELLS, {
                        align,
                        cells
                    }));
                });
            }
        }
        return cells;
    },
    /*****************************************************************************
     * Group: Cell cloning, insertion and removal
     *****************************************************************************/ cloneCell (cell, allowInvalidEdges = false, mapping = {}, keepPosition = false) {
        return this.cloneCells([
            cell
        ], allowInvalidEdges, mapping, keepPosition)[0];
    },
    cloneCells (cells, allowInvalidEdges = true, mapping = {}, keepPosition = false) {
        let clones;
        // Creates a dictionary for fast lookups
        const dict = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        const tmp = [];
        for (const cell of cells){
            dict.put(cell, true);
            tmp.push(cell);
        }
        if (tmp.length > 0) {
            const { scale } = this.getView();
            const trans = this.getView().translate;
            const out = [];
            clones = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cellArrayUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneCells"])(cells, true, mapping);
            for(let i = 0; i < cells.length; i += 1){
                const cell = cells[i];
                const clone = clones[i];
                if (!allowInvalidEdges && clone.isEdge() && this.getEdgeValidationError(clone, clone.getTerminal(true), clone.getTerminal(false)) !== null) {
                //clones[i] = null;
                } else {
                    out.push(clone);
                    const g = clone.getGeometry();
                    if (g) {
                        const state = this.getView().getState(cell);
                        const parent = cell.getParent();
                        const pstate = parent ? this.getView().getState(parent) : null;
                        if (state && pstate) {
                            const dx = keepPosition ? 0 : pstate.origin.x;
                            const dy = keepPosition ? 0 : pstate.origin.y;
                            if (clone.isEdge()) {
                                const pts = state.absolutePoints;
                                // Checks if the source is cloned or sets the terminal point
                                let src = cell.getTerminal(true);
                                while(src && !dict.get(src)){
                                    src = src.getParent();
                                }
                                if (!src && pts[0]) {
                                    g.setTerminalPoint(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](pts[0].x / scale - trans.x, pts[0].y / scale - trans.y), true);
                                }
                                // Checks if the target is cloned or sets the terminal point
                                let trg = cell.getTerminal(false);
                                while(trg && !dict.get(trg)){
                                    trg = trg.getParent();
                                }
                                const n = pts.length - 1;
                                const p = pts[n];
                                if (!trg && p) {
                                    g.setTerminalPoint(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](p.x / scale - trans.x, p.y / scale - trans.y), false);
                                }
                                // Translates the control points
                                const { points } = g;
                                if (points) {
                                    for (const point of points){
                                        point.x += dx;
                                        point.y += dy;
                                    }
                                }
                            } else {
                                g.translate(dx, dy);
                            }
                        }
                    }
                }
            }
            clones = out;
        } else {
            clones = [];
        }
        return clones;
    },
    addCell (cell, parent = null, index = null, source = null, target = null) {
        return this.addCells([
            cell
        ], parent, index, source, target)[0];
    },
    addCells (cells, parent = null, index = null, source = null, target = null, absolute = false) {
        const p = parent ?? this.getDefaultParent();
        const i = index ?? p.getChildCount();
        this.batchUpdate(()=>{
            this.cellsAdded(cells, p, i, source, target, absolute, true);
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ADD_CELLS, {
                cells,
                p,
                i,
                source,
                target
            }));
        });
        return cells;
    },
    cellsAdded (cells, parent, index, source = null, target = null, absolute = false, constrain = false, extend = true) {
        this.batchUpdate(()=>{
            const parentState = absolute ? this.getView().getState(parent) : null;
            const o1 = parentState ? parentState.origin : null;
            const zero = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0);
            cells.forEach((cell, i)=>{
                /* Can cells include null values?
                if (cell == null) {
                  index--;
                } else {
                */ const previous = cell.getParent();
                // Keeps the cell at its absolute location
                if (o1 && cell !== parent && parent !== previous) {
                    const oldState = previous ? this.getView().getState(previous) : null;
                    const o2 = oldState ? oldState.origin : zero;
                    let geo = cell.getGeometry();
                    if (geo) {
                        const dx = o2.x - o1.x;
                        const dy = o2.y - o1.y;
                        // FIXME: Cells should always be inserted first before any other edit
                        // to avoid forward references in sessions.
                        geo = geo.clone();
                        geo.translate(dx, dy);
                        if (!geo.relative && cell.isVertex() && !this.isAllowNegativeCoordinates()) {
                            geo.x = Math.max(0, geo.x);
                            geo.y = Math.max(0, geo.y);
                        }
                        this.getDataModel().setGeometry(cell, geo);
                    }
                }
                // Decrements all following indices
                // if cell is already in parent
                if (parent === previous && index + i > parent.getChildCount()) {
                    index--;
                }
                this.getDataModel().add(parent, cell, index + i);
                if (this.autoSizeCellsOnAdd) {
                    this.autoSizeCell(cell, true);
                }
                // Extends the parent or constrains the child
                if ((!extend || extend) && this.isExtendParentsOnAdd(cell) && this.isExtendParent(cell)) {
                    this.extendParent(cell);
                }
                // Additionally constrains the child after extending the parent
                if (!constrain || constrain) {
                    this.constrainChild(cell);
                }
                // Sets the source terminal
                if (source) {
                    this.cellConnected(cell, source, true);
                }
                // Sets the target terminal
                if (target) {
                    this.cellConnected(cell, target, false);
                }
            /*}*/ });
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CELLS_ADDED, {
                cells,
                parent,
                index,
                source,
                target,
                absolute
            }));
        });
    },
    autoSizeCell (cell, recurse = true) {
        if (recurse) {
            for (const child of cell.getChildren()){
                this.autoSizeCell(child);
            }
        }
        if (cell.isVertex() && this.isAutoSizeCell(cell)) {
            this.updateCellSize(cell);
        }
    },
    removeCells (cells = null, includeEdges = true) {
        if (!cells) {
            cells = this.getDeletableCells(this.getSelectionCells());
        }
        // Adds all edges to the cells
        if (includeEdges) {
            // FIXME: Remove duplicate cells in result or do not add if
            // in cells or descendant of cells
            cells = this.getDeletableCells(this.addAllEdges(cells));
        } else {
            cells = cells.slice();
            // Removes edges that are currently not
            // visible as those cannot be updated
            const edges = this.getDeletableCells(this.getAllEdges(cells));
            const dict = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
            for (const cell of cells){
                dict.put(cell, true);
            }
            for (const edge of edges){
                if (!this.getView().getState(edge) && !dict.get(edge)) {
                    dict.put(edge, true);
                    cells.push(edge);
                }
            }
        }
        this.batchUpdate(()=>{
            this.cellsRemoved(cells);
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].REMOVE_CELLS, {
                cells,
                includeEdges
            }));
        });
        return cells ?? [];
    },
    cellsRemoved (cells) {
        if (cells.length > 0) {
            const { scale } = this.getView();
            const tr = this.getView().translate;
            this.batchUpdate(()=>{
                // Creates hashtable for faster lookup
                const dict = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
                for (const cell of cells){
                    dict.put(cell, true);
                }
                for (const cell of cells){
                    // Disconnects edges which are not being removed
                    const edges = this.getAllEdges([
                        cell
                    ]);
                    const disconnectTerminal = (edge, source)=>{
                        let geo = edge.getGeometry();
                        if (geo) {
                            // Checks if terminal is being removed
                            const terminal = edge.getTerminal(source);
                            let connected = false;
                            let tmp = terminal;
                            while(tmp){
                                if (cell === tmp) {
                                    connected = true;
                                    break;
                                }
                                tmp = tmp.getParent();
                            }
                            if (connected) {
                                geo = geo.clone();
                                const state = this.getView().getState(edge);
                                if (state) {
                                    const pts = state.absolutePoints;
                                    const n = source ? 0 : pts.length - 1;
                                    const p = pts[n];
                                    geo.setTerminalPoint(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](p.x / scale - tr.x - state.origin.x, p.y / scale - tr.y - state.origin.y), source);
                                } else if (terminal) {
                                    // Fallback to center of terminal if routing
                                    // points are not available to add new point
                                    // KNOWN: Should recurse to find parent offset
                                    // of edge for nested groups but invisible edges
                                    // should be removed in removeCells step
                                    const tstate = this.getView().getState(terminal);
                                    if (tstate) {
                                        geo.setTerminalPoint(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](tstate.getCenterX() / scale - tr.x, tstate.getCenterY() / scale - tr.y), source);
                                    }
                                }
                                this.getDataModel().setGeometry(edge, geo);
                                this.getDataModel().setTerminal(edge, null, source);
                            }
                        }
                    };
                    for (const edge of edges){
                        if (!dict.get(edge)) {
                            dict.put(edge, true);
                            disconnectTerminal(edge, true);
                            disconnectTerminal(edge, false);
                        }
                    }
                    this.getDataModel().remove(cell);
                }
                this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CELLS_REMOVED, {
                    cells
                }));
            });
        }
    },
    /*****************************************************************************
     * Group: Cell visibility
     *****************************************************************************/ toggleCells (show = false, cells, includeEdges = true) {
        cells = cells ?? this.getSelectionCells();
        // Adds all connected edges recursively
        if (includeEdges) {
            cells = this.addAllEdges(cells);
        }
        this.batchUpdate(()=>{
            this.cellsToggled(cells, show);
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TOGGLE_CELLS, {
                show,
                cells,
                includeEdges
            }));
        });
        return cells;
    },
    cellsToggled (cells, show = false) {
        if (cells.length > 0) {
            this.batchUpdate(()=>{
                for (const cell of cells){
                    this.getDataModel().setVisible(cell, show);
                }
            });
        }
    },
    /*****************************************************************************
     * Group: Cell sizing
     *****************************************************************************/ updateCellSize (cell, ignoreChildren = false) {
        this.batchUpdate(()=>{
            this.cellSizeUpdated(cell, ignoreChildren);
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UPDATE_CELL_SIZE, {
                cell,
                ignoreChildren
            }));
        });
        return cell;
    },
    cellSizeUpdated (cell, ignoreChildren = false) {
        this.batchUpdate(()=>{
            const size = this.getPreferredSizeForCell(cell);
            let geo = cell.getGeometry();
            if (size && geo) {
                const collapsed = cell.isCollapsed();
                geo = geo.clone();
                if (this.isSwimlane(cell)) {
                    const style = this.getCellStyle(cell);
                    const cellStyle = cell.getStyle();
                    if (style.horizontal ?? true) {
                        cellStyle.startSize = size.height + 8;
                        if (collapsed) {
                            geo.height = size.height + 8;
                        }
                        geo.width = size.width;
                    } else {
                        cellStyle.startSize = size.width + 8;
                        if (collapsed) {
                            geo.width = size.width + 8;
                        }
                        geo.height = size.height;
                    }
                    this.getDataModel().setStyle(cell, cellStyle);
                } else {
                    const state = this.getView().createState(cell);
                    const align = state.style.align ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER;
                    if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].RIGHT) {
                        geo.x += geo.width - size.width;
                    } else if (align === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER) {
                        geo.x += Math.round((geo.width - size.width) / 2);
                    }
                    const valign = state.getVerticalAlign();
                    if (valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].BOTTOM) {
                        geo.y += geo.height - size.height;
                    } else if (valign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE) {
                        geo.y += Math.round((geo.height - size.height) / 2);
                    }
                    geo.width = size.width;
                    geo.height = size.height;
                }
                if (!ignoreChildren && !collapsed) {
                    const bounds = this.getView().getBounds(cell.getChildren());
                    if (bounds != null) {
                        const tr = this.getView().translate;
                        const { scale } = this.getView();
                        const width = (bounds.x + bounds.width) / scale - geo.x - tr.x;
                        const height = (bounds.y + bounds.height) / scale - geo.y - tr.y;
                        geo.width = Math.max(geo.width, width);
                        geo.height = Math.max(geo.height, height);
                    }
                }
                this.cellsResized([
                    cell
                ], [
                    geo
                ], false);
            }
        });
    },
    getPreferredSizeForCell (cell, textWidth = null) {
        let result = null;
        const state = this.getView().createState(cell);
        const { style } = state;
        if (!cell.isEdge()) {
            const fontSize = style.fontSize || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONTSIZE"];
            let dx = 0;
            let dy = 0;
            // Adds dimension of image if shape is a label
            if (state.getImageSrc() || style.image) {
                if (style.shape === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHAPE"].LABEL) {
                    if (style.verticalAlign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].MIDDLE) {
                        dx += style.imageWidth || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_IMAGESIZE"];
                    }
                    if (style.align !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ALIGN"].CENTER) {
                        dy += style.imageHeight || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_IMAGESIZE"];
                    }
                }
            }
            // Adds spacings
            dx += 2 * (style.spacing || 0);
            dx += style.spacingLeft || 0;
            dx += style.spacingRight || 0;
            dy += 2 * (style.spacing || 0);
            dy += style.spacingTop || 0;
            dy += style.spacingBottom || 0;
            // Add spacing for collapse/expand icon
            // LATER: Check alignment and use constants
            // for image spacing
            const image = this.getFoldingImage(state);
            if (image) {
                dx += image.width + 8;
            }
            // Adds space for label
            let value = this.getCellRenderer().getLabelValue(state);
            if (value && value.length > 0) {
                if (!this.isHtmlLabel(state.cell)) {
                    value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["htmlEntities"])(value, false);
                }
                value = value.replace(/\n/g, '<br>');
                const size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSizeForString"])(value, fontSize, style.fontFamily, textWidth, style.fontStyle);
                let width = size.width + dx;
                let height = size.height + dy;
                if (!(style.horizontal ?? true)) {
                    const tmp = height;
                    height = width;
                    width = tmp;
                }
                if (this.isGridEnabled()) {
                    width = this.snap(width + this.getGridSize() / 2);
                    height = this.snap(height + this.getGridSize() / 2);
                }
                result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0, width, height);
            } else {
                const gs2 = 4 * this.getGridSize();
                result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0, gs2, gs2);
            }
        }
        return result;
    },
    resizeCell (cell, bounds, recurse = false) {
        return this.resizeCells([
            cell
        ], [
            bounds
        ], recurse)[0];
    },
    resizeCells (cells, bounds, recurse) {
        recurse = recurse ?? this.isRecursiveResize();
        this.batchUpdate(()=>{
            const prev = this.cellsResized(cells, bounds, recurse);
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].RESIZE_CELLS, {
                cells,
                bounds,
                prev
            }));
        });
        return cells;
    },
    cellsResized (cells, bounds, recurse = false) {
        const prev = [];
        if (cells.length === bounds.length) {
            this.batchUpdate(()=>{
                cells.forEach((cell, i)=>{
                    prev.push(this.cellResized(cell, bounds[i], false, recurse));
                    if (this.isExtendParent(cell)) {
                        this.extendParent(cell);
                    }
                    this.constrainChild(cell);
                });
                if (this.isResetEdgesOnResize()) {
                    this.resetEdges(cells);
                }
                this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CELLS_RESIZED, {
                    cells,
                    bounds,
                    prev
                }));
            });
        }
        return prev;
    },
    cellResized (cell, bounds, ignoreRelative = false, recurse = false) {
        const prev = cell.getGeometry();
        if (prev && (prev.x !== bounds.x || prev.y !== bounds.y || prev.width !== bounds.width || prev.height !== bounds.height)) {
            const geo = prev.clone();
            if (!ignoreRelative && geo.relative) {
                const { offset } = geo;
                if (offset) {
                    offset.x += bounds.x - geo.x;
                    offset.y += bounds.y - geo.y;
                }
            } else {
                geo.x = bounds.x;
                geo.y = bounds.y;
            }
            geo.width = bounds.width;
            geo.height = bounds.height;
            if (!geo.relative && cell.isVertex() && !this.isAllowNegativeCoordinates()) {
                geo.x = Math.max(0, geo.x);
                geo.y = Math.max(0, geo.y);
            }
            this.batchUpdate(()=>{
                if (recurse) {
                    this.resizeChildCells(cell, geo);
                }
                this.getDataModel().setGeometry(cell, geo);
                this.constrainChildCells(cell);
            });
        }
        return prev;
    },
    resizeChildCells (cell, newGeo) {
        const geo = cell.getGeometry();
        if (geo) {
            const dx = geo.width !== 0 ? newGeo.width / geo.width : 1;
            const dy = geo.height !== 0 ? newGeo.height / geo.height : 1;
            for (const child of cell.getChildren()){
                this.scaleCell(child, dx, dy, true);
            }
        }
    },
    constrainChildCells (cell) {
        for (const child of cell.getChildren()){
            this.constrainChild(child);
        }
    },
    scaleCell (cell, dx, dy, recurse = false) {
        let geo = cell.getGeometry();
        if (geo) {
            const style = this.getCurrentCellStyle(cell);
            geo = geo.clone();
            // Stores values for restoring based on style
            const { x } = geo;
            const { y } = geo;
            const w = geo.width;
            const h = geo.height;
            geo.scale(dx, dy, style.aspect === 'fixed');
            if (style.resizeWidth) {
                geo.width = w * dx;
            } else if (!style.resizeWidth) {
                geo.width = w;
            }
            if (style.resizeHeight) {
                geo.height = h * dy;
            } else if (!style.resizeHeight) {
                geo.height = h;
            }
            if (!this.isCellMovable(cell)) {
                geo.x = x;
                geo.y = y;
            }
            if (!this.isCellResizable(cell)) {
                geo.width = w;
                geo.height = h;
            }
            if (cell.isVertex()) {
                this.cellResized(cell, geo, true, recurse);
            } else {
                this.getDataModel().setGeometry(cell, geo);
            }
        }
    },
    extendParent (cell) {
        const parent = cell.getParent();
        let p = parent ? parent.getGeometry() : null;
        if (parent && p && !parent.isCollapsed()) {
            const geo = cell.getGeometry();
            if (geo && !geo.relative && (p.width < geo.x + geo.width || p.height < geo.y + geo.height)) {
                p = p.clone();
                p.width = Math.max(p.width, geo.x + geo.width);
                p.height = Math.max(p.height, geo.y + geo.height);
                this.cellsResized([
                    parent
                ], [
                    p
                ], false);
            }
        }
    },
    // *************************************************************************************
    // Group: Cell moving
    // *************************************************************************************
    importCells (cells, dx, dy, target = null, evt = null, mapping = {}) {
        return this.moveCells(cells, dx, dy, true, target, evt, mapping);
    },
    moveCells (cells, dx = 0, dy = 0, clone = false, target = null, evt = null, mapping = {}) {
        if (dx !== 0 || dy !== 0 || clone || target) {
            // Removes descendants with ancestors in cells to avoid multiple moving
            cells = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$cellArrayUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTopmostCells"])(cells);
            const origCells = cells;
            this.batchUpdate(()=>{
                // Faster cell lookups to remove relative edge labels with selected
                // terminals to avoid explicit and implicit move at same time
                const dict = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
                for (const cell of cells){
                    dict.put(cell, true);
                }
                const isSelected = (cell)=>{
                    while(cell){
                        if (dict.get(cell)) {
                            return true;
                        }
                        cell = cell.getParent();
                    }
                    return false;
                };
                // Removes relative edge labels with selected terminals
                const checked = [];
                for (const cell of cells){
                    const geo = cell.getGeometry();
                    const parent = cell.getParent();
                    if (!geo || !geo.relative || parent && !parent.isEdge() || parent && !isSelected(parent.getTerminal(true)) && !isSelected(parent.getTerminal(false))) {
                        checked.push(cell);
                    }
                }
                cells = checked;
                if (clone) {
                    cells = this.cloneCells(cells, this.isCloneInvalidEdges(), mapping);
                    if (!target) {
                        target = this.getDefaultParent();
                    }
                }
                // FIXME: Cells should always be inserted first before any other edit
                // to avoid forward references in sessions.
                // Need to disable allowNegativeCoordinates if target not null to
                // allow for temporary negative numbers until cellsAdded is called.
                const previous = this.isAllowNegativeCoordinates();
                if (target) {
                    this.setAllowNegativeCoordinates(true);
                }
                this.cellsMoved(cells, dx, dy, !clone && this.isDisconnectOnMove() && this.isAllowDanglingEdges(), !target, this.isExtendParentsOnMove() && !target);
                this.setAllowNegativeCoordinates(previous);
                if (target) {
                    const index = target.getChildCount();
                    this.cellsAdded(cells, target, index, null, null, true);
                    // Restores parent edge on cloned edge labels
                    if (clone) {
                        cells.forEach((cell, i)=>{
                            const geo = cell.getGeometry();
                            const parent = origCells[i].getParent();
                            if (geo && geo.relative && parent && parent.isEdge() && this.getDataModel().contains(parent)) {
                                this.getDataModel().add(parent, cell);
                            }
                        });
                    }
                }
                // Dispatches a move event
                this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOVE_CELLS, {
                    cells,
                    dx,
                    dy,
                    clone,
                    target,
                    event: evt
                }));
            });
        }
        return cells;
    },
    cellsMoved (cells, dx, dy, disconnect = false, constrain = false, extend = false) {
        if (dx !== 0 || dy !== 0) {
            this.batchUpdate(()=>{
                if (disconnect) {
                    this.disconnectGraph(cells);
                }
                for (const cell of cells){
                    this.translateCell(cell, dx, dy);
                    if (extend && this.isExtendParent(cell)) {
                        this.extendParent(cell);
                    } else if (constrain) {
                        this.constrainChild(cell);
                    }
                }
                if (this.isResetEdgesOnMove()) {
                    this.resetEdges(cells);
                }
                this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CELLS_MOVED, {
                    cells,
                    dx,
                    dy,
                    disconnect
                }));
            });
        }
    },
    translateCell (cell, dx, dy) {
        let geometry = cell.getGeometry();
        if (geometry) {
            geometry = geometry.clone();
            geometry.translate(dx, dy);
            if (!geometry.relative && cell.isVertex() && !this.isAllowNegativeCoordinates()) {
                geometry.x = Math.max(0, geometry.x);
                geometry.y = Math.max(0, geometry.y);
            }
            if (geometry.relative && !cell.isEdge()) {
                const parent = cell.getParent();
                let angle = 0;
                if (parent.isVertex()) {
                    const style = this.getCurrentCellStyle(parent);
                    angle = style.rotation ?? 0;
                }
                if (angle !== 0) {
                    const rad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toRadians"])(-angle);
                    const cos = Math.cos(rad);
                    const sin = Math.sin(rad);
                    const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRotatedPoint"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](dx, dy), cos, sin, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0));
                    dx = pt.x;
                    dy = pt.y;
                }
                if (!geometry.offset) {
                    geometry.offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](dx, dy);
                } else {
                    geometry.offset.x = geometry.offset.x + dx;
                    geometry.offset.y = geometry.offset.y + dy;
                }
            }
            this.getDataModel().setGeometry(cell, geometry);
        }
    },
    getCellContainmentArea (cell) {
        if (!cell.isEdge()) {
            const parent = cell.getParent();
            if (parent && parent !== this.getDefaultParent()) {
                const g = parent.getGeometry();
                if (g) {
                    let x = 0;
                    let y = 0;
                    let w = g.width;
                    let h = g.height;
                    if (this.isSwimlane(parent)) {
                        const size = this.getStartSize(parent);
                        const style = this.getCurrentCellStyle(parent);
                        const dir = style.direction ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST;
                        const flipH = style.flipH ?? false;
                        const flipV = style.flipV ?? false;
                        if (dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH || dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH) {
                            const tmp = size.width;
                            size.width = size.height;
                            size.height = tmp;
                        }
                        if (dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST && !flipV || dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH && !flipH || dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST && flipV || dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH && flipH) {
                            x = size.width;
                            y = size.height;
                        }
                        w -= size.width;
                        h -= size.height;
                    }
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y, w, h);
                }
            }
        }
        return null;
    },
    constrainChild (cell, sizeFirst = true) {
        let geo = cell.getGeometry();
        if (geo && (this.isConstrainRelativeChildren() || !geo.relative)) {
            const parent = cell.getParent();
            let max = this.getMaximumGraphBounds();
            // Finds parent offset
            if (max && parent) {
                const off = this.getBoundingBoxFromGeometry([
                    parent
                ], false);
                if (off) {
                    max = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromRectangle(max);
                    max.x -= off.x;
                    max.y -= off.y;
                }
            }
            if (this.isConstrainChild(cell)) {
                let tmp = this.getCellContainmentArea(cell);
                if (tmp) {
                    const overlap = this.getOverlap(cell);
                    if (overlap > 0) {
                        tmp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromRectangle(tmp);
                        tmp.x -= tmp.width * overlap;
                        tmp.y -= tmp.height * overlap;
                        tmp.width += 2 * tmp.width * overlap;
                        tmp.height += 2 * tmp.height * overlap;
                    }
                    // Find the intersection between max and tmp
                    if (!max) {
                        max = tmp;
                    } else {
                        max = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromRectangle(max);
                        max.intersect(tmp);
                    }
                }
            }
            if (max) {
                const cells = [
                    cell
                ];
                if (!cell.isCollapsed()) {
                    const desc = cell.getDescendants();
                    for (const descItem of desc){
                        if (descItem.isVisible()) {
                            cells.push(descItem);
                        }
                    }
                }
                const bbox = this.getBoundingBoxFromGeometry(cells, false);
                if (bbox) {
                    geo = geo.clone();
                    // Cumulative horizontal movement
                    let dx = 0;
                    if (geo.width > max.width) {
                        dx = geo.width - max.width;
                        geo.width -= dx;
                    }
                    if (bbox.x + bbox.width > max.x + max.width) {
                        dx -= bbox.x + bbox.width - max.x - max.width - dx;
                    }
                    // Cumulative vertical movement
                    let dy = 0;
                    if (geo.height > max.height) {
                        dy = geo.height - max.height;
                        geo.height -= dy;
                    }
                    if (bbox.y + bbox.height > max.y + max.height) {
                        dy -= bbox.y + bbox.height - max.y - max.height - dy;
                    }
                    if (bbox.x < max.x) {
                        dx -= bbox.x - max.x;
                    }
                    if (bbox.y < max.y) {
                        dy -= bbox.y - max.y;
                    }
                    if (dx !== 0 || dy !== 0) {
                        if (geo.relative) {
                            // Relative geometries are moved via absolute offset
                            if (!geo.offset) {
                                geo.offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
                            }
                            geo.offset.x += dx;
                            geo.offset.y += dy;
                        } else {
                            geo.x += dx;
                            geo.y += dy;
                        }
                    }
                    this.getDataModel().setGeometry(cell, geo);
                }
            }
        }
    },
    /*****************************************************************************
     * Group: Cell retrieval
     *****************************************************************************/ getChildCells (parent, vertices = false, edges = false) {
        parent = parent ?? this.getDefaultParent();
        const cells = parent.getChildCells(vertices, edges);
        const result = [];
        // Filters out the non-visible child cells
        for (const cell of cells){
            if (cell.isVisible()) {
                result.push(cell);
            }
        }
        return result;
    },
    getCellAt (x, y, parent = null, vertices = true, edges = true, ignoreFn = null) {
        if (!parent) {
            parent = this.getCurrentRoot();
            if (!parent) {
                parent = this.getDataModel().getRoot();
            }
        }
        if (parent) {
            const childCount = parent.getChildCount();
            for(let i = childCount - 1; i >= 0; i--){
                const cell = parent.getChildAt(i);
                const result = this.getCellAt(x, y, cell, vertices, edges, ignoreFn);
                if (result) {
                    return result;
                }
                if (cell.isVisible() && (edges && cell.isEdge() || vertices && cell.isVertex())) {
                    const state = this.getView().getState(cell);
                    if (state && (!ignoreFn || !ignoreFn(state, x, y)) && this.intersects(state, x, y)) {
                        return cell;
                    }
                }
            }
        }
        return null;
    },
    getCells (x, y, width, height, parent = null, result = [], intersection = null, ignoreFn = null, includeDescendants = false) {
        if (width > 0 || height > 0 || intersection) {
            const model = this.getDataModel();
            const right = x + width;
            const bottom = y + height;
            if (!parent) {
                parent = this.getCurrentRoot();
                if (!parent) {
                    parent = model.getRoot();
                }
            }
            if (parent) {
                for (const cell of parent.getChildren()){
                    const state = this.getView().getState(cell);
                    if (state && cell.isVisible() && (!ignoreFn || !ignoreFn(state))) {
                        const deg = state.style.rotation ?? 0;
                        let box = state; // TODO: CHECK ME!!!! ==========================================================
                        if (deg !== 0) {
                            box = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBoundingBox"])(box, deg);
                        }
                        const hit = intersection && cell.isVertex() && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersects"])(intersection, box) || !intersection && (cell.isEdge() || cell.isVertex()) && box.x >= x && box.y + box.height <= bottom && box.y >= y && box.x + box.width <= right;
                        if (hit) {
                            result.push(cell);
                        }
                        if (!hit || includeDescendants) {
                            this.getCells(x, y, width, height, cell, result, intersection, ignoreFn, includeDescendants);
                        }
                    }
                }
            }
        }
        return result;
    },
    getCellsBeyond (x0, y0, parent = null, rightHalfpane = false, bottomHalfpane = false) {
        const result = [];
        if (rightHalfpane || bottomHalfpane) {
            if (!parent) {
                parent = this.getDefaultParent();
            }
            if (parent) {
                for (const child of parent.getChildren()){
                    const state = this.getView().getState(child);
                    if (child.isVisible() && state) {
                        if ((!rightHalfpane || state.x >= x0) && (!bottomHalfpane || state.y >= y0)) {
                            result.push(child);
                        }
                    }
                }
            }
        }
        return result;
    },
    intersects (state, x, y) {
        const pts = state.absolutePoints;
        if (pts.length > 0) {
            const t2 = this.getEventTolerance() * this.getEventTolerance();
            let pt = pts[0];
            for(let i = 1; i < pts.length; i += 1){
                const next = pts[i];
                if (pt && next) {
                    const dist = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ptSegDistSq"])(pt.x, pt.y, next.x, next.y, x, y);
                    if (dist <= t2) {
                        return true;
                    }
                }
                pt = next;
            }
        } else {
            const alpha = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toRadians"])(state.style.rotation ?? 0);
            if (alpha !== 0) {
                const cos = Math.cos(-alpha);
                const sin = Math.sin(-alpha);
                const cx = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](state.getCenterX(), state.getCenterY());
                const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRotatedPoint"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y), cos, sin, cx);
                x = pt.x;
                y = pt.y;
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(state, x, y)) {
                return true;
            }
        }
        return false;
    },
    isValidAncestor (cell, parent, recurse = false) {
        return recurse ? parent.isAncestor(cell) : cell.getParent() === parent;
    },
    /*****************************************************************************
     * Group: Graph behaviour
     *****************************************************************************/ isCellLocked (cell) {
        const geometry = cell.getGeometry();
        return this.isCellsLocked() || !!geometry && cell.isVertex() && geometry.relative;
    },
    isCellsLocked () {
        return this.cellsLocked;
    },
    setCellsLocked (value) {
        this.cellsLocked = value;
    },
    getCloneableCells (cells) {
        return this.getDataModel().filterCells(cells, (cell)=>{
            return this.isCellCloneable(cell);
        });
    },
    isCellCloneable (cell) {
        return this.isCellsCloneable() && (this.getCurrentCellStyle(cell).cloneable ?? true);
    },
    isCellsCloneable () {
        return this.cellsCloneable;
    },
    setCellsCloneable (value) {
        this.cellsCloneable = value;
    },
    getExportableCells (cells) {
        return this.getDataModel().filterCells(cells, (cell)=>{
            return this.canExportCell(cell);
        });
    },
    canExportCell (_cell = null) {
        return this.isExportEnabled();
    },
    getImportableCells (cells) {
        return this.getDataModel().filterCells(cells, (cell)=>{
            return this.canImportCell(cell);
        });
    },
    canImportCell (cell = null) {
        return this.isImportEnabled();
    },
    isCellSelectable (_cell) {
        return this.isCellsSelectable();
    },
    isCellsSelectable () {
        return this.cellsSelectable;
    },
    setCellsSelectable (value) {
        this.cellsSelectable = value;
    },
    getDeletableCells (cells) {
        return this.getDataModel().filterCells(cells, (cell)=>{
            return this.isCellDeletable(cell);
        });
    },
    isCellDeletable (cell) {
        return this.isCellsDeletable() && (this.getCurrentCellStyle(cell).deletable ?? true);
    },
    isCellsDeletable () {
        return this.cellsDeletable;
    },
    setCellsDeletable (value) {
        this.cellsDeletable = value;
    },
    isCellRotatable (cell) {
        return this.getCurrentCellStyle(cell).rotatable ?? true;
    },
    getMovableCells (cells) {
        return this.getDataModel().filterCells(cells, (cell)=>{
            return this.isCellMovable(cell);
        });
    },
    isCellMovable (cell) {
        return this.isCellsMovable() && !this.isCellLocked(cell) && (this.getCurrentCellStyle(cell).movable ?? true);
    },
    isCellsMovable () {
        return this.cellsMovable;
    },
    setCellsMovable (value) {
        this.cellsMovable = value;
    },
    isCellResizable (cell) {
        return this.isCellsResizable() && !this.isCellLocked(cell) && (this.getCurrentCellStyle(cell).resizable ?? true);
    },
    isCellsResizable () {
        return this.cellsResizable;
    },
    setCellsResizable (value) {
        this.cellsResizable = value;
    },
    isCellBendable (cell) {
        return this.isCellsBendable() && !this.isCellLocked(cell) && (this.getCurrentCellStyle(cell).bendable ?? true);
    },
    isCellsBendable () {
        return this.cellsBendable;
    },
    setCellsBendable (value) {
        this.cellsBendable = value;
    },
    isAutoSizeCell (cell) {
        return this.isAutoSizeCells() || (this.getCurrentCellStyle(cell).autoSize ?? false);
    },
    isAutoSizeCells () {
        return this.autoSizeCells;
    },
    setAutoSizeCells (value) {
        this.autoSizeCells = value;
    },
    isExtendParent (cell) {
        return !cell.isEdge() && this.isExtendParents();
    },
    isExtendParents () {
        return this.extendParents;
    },
    setExtendParents (value) {
        this.extendParents = value;
    },
    isExtendParentsOnAdd (cell) {
        return this.extendParentsOnAdd;
    },
    setExtendParentsOnAdd (value) {
        this.extendParentsOnAdd = value;
    },
    isExtendParentsOnMove () {
        return this.extendParentsOnMove;
    },
    setExtendParentsOnMove (value) {
        this.extendParentsOnMove = value;
    },
    /*****************************************************************************
     * Group: Graph appearance
     *****************************************************************************/ getCursorForCell (_cell) {
        return null;
    },
    /*****************************************************************************
     * Group: Graph display
     *****************************************************************************/ getCellBounds (cell, includeEdges = false, includeDescendants = false) {
        let cells = [
            cell
        ];
        // Includes all connected edges
        if (includeEdges) {
            cells = cells.concat(cell.getEdges());
        }
        let result = this.getView().getBounds(cells);
        // Recursively includes the bounds of the children
        if (includeDescendants) {
            for (const child of cell.getChildren()){
                const tmp = this.getCellBounds(child, includeEdges, true);
                if (result && tmp) {
                    result.add(tmp);
                } else {
                    result = tmp;
                }
            }
        }
        return result;
    },
    getBoundingBoxFromGeometry (cells, includeEdges = false) {
        let result = null;
        let tmp = null;
        for (const cell of cells){
            if (includeEdges || cell.isVertex()) {
                // Computes the bounding box for the points in the geometry
                const geo = cell.getGeometry();
                if (geo) {
                    let bbox = null;
                    if (cell.isEdge()) {
                        const addPoint = (pt)=>{
                            if (pt) {
                                if (!tmp) {
                                    tmp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](pt.x, pt.y, 0, 0);
                                } else {
                                    tmp.add(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](pt.x, pt.y, 0, 0));
                                }
                            }
                        };
                        if (!cell.getTerminal(true)) {
                            addPoint(geo.getTerminalPoint(true));
                        }
                        if (!cell.getTerminal(false)) {
                            addPoint(geo.getTerminalPoint(false));
                        }
                        const pts = geo.points;
                        if (pts && pts.length > 0) {
                            tmp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](pts[0].x, pts[0].y, 0, 0);
                            for(let j = 1; j < pts.length; j++){
                                addPoint(pts[j]);
                            }
                        }
                        bbox = tmp;
                    } else {
                        const parent = cell.getParent();
                        if (geo.relative && parent) {
                            if (parent.isVertex() && parent !== this.getView().currentRoot) {
                                tmp = this.getBoundingBoxFromGeometry([
                                    parent
                                ], false);
                                if (tmp) {
                                    bbox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](geo.x * tmp.width, geo.y * tmp.height, geo.width, geo.height);
                                    if (cells.indexOf(parent) >= 0) {
                                        bbox.x += tmp.x;
                                        bbox.y += tmp.y;
                                    }
                                }
                            }
                        } else {
                            bbox = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromRectangle(geo);
                            if (parent && parent.isVertex() && cells.indexOf(parent) >= 0) {
                                tmp = this.getBoundingBoxFromGeometry([
                                    parent
                                ], false);
                                if (tmp) {
                                    bbox.x += tmp.x;
                                    bbox.y += tmp.y;
                                }
                            }
                        }
                        if (bbox && geo.offset) {
                            bbox.x += geo.offset.x;
                            bbox.y += geo.offset.y;
                        }
                        const style = this.getCurrentCellStyle(cell);
                        if (bbox) {
                            const angle = style.rotation ?? 0;
                            if (angle !== 0) {
                                bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBoundingBox"])(bbox, angle);
                            }
                        }
                    }
                    if (bbox) {
                        if (!result) {
                            result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromRectangle(bbox);
                        } else {
                            result.add(bbox);
                        }
                    }
                }
            }
        }
        return result;
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/ConnectionsMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "ConnectionsMixin": (()=>ConnectionsMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$other$2f$ConnectionConstraint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/other/ConnectionConstraint.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Dictionary.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const ConnectionsMixin = {
    /*****************************************************************************
     * Group: Cell connecting and connection constraints
     *****************************************************************************/ constrainChildren: true,
    constrainRelativeChildren: false,
    disconnectOnMove: true,
    cellsDisconnectable: true,
    getOutlineConstraint (point, terminalState, me) {
        if (terminalState.shape) {
            const bounds = this.getView().getPerimeterBounds(terminalState);
            const direction = terminalState.style.direction;
            if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH || direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) {
                bounds.x += bounds.width / 2 - bounds.height / 2;
                bounds.y += bounds.height / 2 - bounds.width / 2;
                const tmp = bounds.width;
                bounds.width = bounds.height;
                bounds.height = tmp;
            }
            const alpha = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toRadians"])(terminalState.shape.getShapeRotation());
            if (alpha !== 0) {
                const cos = Math.cos(-alpha);
                const sin = Math.sin(-alpha);
                const ct = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](bounds.getCenterX(), bounds.getCenterY());
                point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRotatedPoint"])(point, cos, sin, ct);
            }
            let sx = 1;
            let sy = 1;
            let dx = 0;
            let dy = 0;
            // LATER: Add flipping support for image shapes
            if (terminalState.cell.isVertex()) {
                let flipH = terminalState.style.flipH;
                let flipV = terminalState.style.flipV;
                if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH || direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) {
                    const tmp = flipH;
                    flipH = flipV;
                    flipV = tmp;
                }
                if (flipH) {
                    sx = -1;
                    dx = -bounds.width;
                }
                if (flipV) {
                    sy = -1;
                    dy = -bounds.height;
                }
            }
            point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]((point.x - bounds.x) * sx - dx + bounds.x, (point.y - bounds.y) * sy - dy + bounds.y);
            const x = bounds.width === 0 ? 0 : Math.round((point.x - bounds.x) * 1000 / bounds.width) / 1000;
            const y = bounds.height === 0 ? 0 : Math.round((point.y - bounds.y) * 1000 / bounds.height) / 1000;
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$other$2f$ConnectionConstraint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y), false);
        }
        return null;
    },
    getAllConnectionConstraints (terminal, source) {
        return terminal?.shape?.stencil?.constraints ?? null;
    },
    getConnectionConstraint (edge, terminal, source = false) {
        let point = null;
        const x = edge.style[source ? 'exitX' : 'entryX'];
        if (x !== undefined) {
            const y = edge.style[source ? 'exitY' : 'entryY'];
            if (y !== undefined) {
                point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x, y);
            }
        }
        let perimeter = false;
        let dx = 0;
        let dy = 0;
        if (point) {
            perimeter = edge.style[source ? 'exitPerimeter' : 'entryPerimeter'] || false;
            // Add entry/exit offset
            dx = edge.style[source ? 'exitDx' : 'entryDx'];
            dy = edge.style[source ? 'exitDy' : 'entryDy'];
            dx = Number.isFinite(dx) ? dx : 0;
            dy = Number.isFinite(dy) ? dy : 0;
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$other$2f$ConnectionConstraint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](point, perimeter, null, dx, dy);
    },
    setConnectionConstraint (edge, terminal, source = false, constraint = null) {
        if (constraint) {
            this.batchUpdate(()=>{
                if (!constraint || !constraint.point) {
                    this.setCellStyles(source ? 'exitX' : 'entryX', null, [
                        edge
                    ]);
                    this.setCellStyles(source ? 'exitY' : 'entryY', null, [
                        edge
                    ]);
                    this.setCellStyles(source ? 'exitDx' : 'entryDx', null, [
                        edge
                    ]);
                    this.setCellStyles(source ? 'exitDy' : 'entryDy', null, [
                        edge
                    ]);
                    this.setCellStyles(source ? 'exitPerimeter' : 'entryPerimeter', null, [
                        edge
                    ]);
                } else if (constraint.point) {
                    this.setCellStyles(source ? 'exitX' : 'entryX', constraint.point.x, [
                        edge
                    ]);
                    this.setCellStyles(source ? 'exitY' : 'entryY', constraint.point.y, [
                        edge
                    ]);
                    this.setCellStyles(source ? 'exitDx' : 'entryDx', constraint.dx, [
                        edge
                    ]);
                    this.setCellStyles(source ? 'exitDy' : 'entryDy', constraint.dy, [
                        edge
                    ]);
                    // Only writes 0 since 1 is default
                    if (!constraint.perimeter) {
                        this.setCellStyles(source ? 'exitPerimeter' : 'entryPerimeter', '0', [
                            edge
                        ]);
                    } else {
                        this.setCellStyles(source ? 'exitPerimeter' : 'entryPerimeter', null, [
                            edge
                        ]);
                    }
                }
            });
        }
    },
    getConnectionPoint (vertex, constraint, round = true) {
        let point = null;
        if (constraint.point) {
            const bounds = this.getView().getPerimeterBounds(vertex);
            const cx = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](bounds.getCenterX(), bounds.getCenterY());
            const direction = vertex.style.direction;
            let r1 = 0;
            // Bounds need to be rotated by 90 degrees for further computation
            if (vertex.style.anchorPointDirection) {
                if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH) {
                    r1 += 270;
                } else if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST) {
                    r1 += 180;
                } else if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) {
                    r1 += 90;
                }
                // Bounds need to be rotated by 90 degrees for further computation
                if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH || direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) {
                    bounds.rotate90();
                }
            }
            const { scale } = this.getView();
            point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](bounds.x + constraint.point.x * bounds.width + constraint.dx * scale, bounds.y + constraint.point.y * bounds.height + constraint.dy * scale);
            // Rotation for direction before projection on perimeter
            let r2 = vertex.style.rotation || 0;
            if (constraint.perimeter) {
                if (r1 !== 0) {
                    // Only 90 degrees steps possible here so no trig needed
                    let cos = 0;
                    let sin = 0;
                    if (r1 === 90) {
                        sin = 1;
                    } else if (r1 === 180) {
                        cos = -1;
                    } else if (r1 === 270) {
                        sin = -1;
                    }
                    point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRotatedPoint"])(point, cos, sin, cx);
                }
                point = this.getView().getPerimeterPoint(vertex, point, false);
            } else {
                r2 += r1;
                if (vertex.cell.isVertex()) {
                    let flipH = vertex.style.flipH;
                    let flipV = vertex.style.flipV;
                    if (direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH || direction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) {
                        const temp = flipH;
                        flipH = flipV;
                        flipV = temp;
                    }
                    if (flipH) {
                        point.x = 2 * bounds.getCenterX() - point.x;
                    }
                    if (flipV) {
                        point.y = 2 * bounds.getCenterY() - point.y;
                    }
                }
            }
            // Generic rotation after projection on perimeter
            if (r2 !== 0 && point) {
                const rad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toRadians"])(r2);
                const cos = Math.cos(rad);
                const sin = Math.sin(rad);
                point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRotatedPoint"])(point, cos, sin, cx);
            }
        }
        if (round && point) {
            point.x = Math.round(point.x);
            point.y = Math.round(point.y);
        }
        return point;
    },
    connectCell (edge, terminal = null, source = false, constraint = null) {
        this.batchUpdate(()=>{
            const previous = edge.getTerminal(source);
            this.cellConnected(edge, terminal, source, constraint);
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CONNECT_CELL, 'edge', edge, 'terminal', terminal, 'source', source, 'previous', previous));
        });
        return edge;
    },
    cellConnected (edge, terminal, source = false, constraint = null) {
        this.batchUpdate(()=>{
            const previous = edge.getTerminal(source);
            // Updates the constraint
            this.setConnectionConstraint(edge, terminal, source, constraint);
            // Checks if the new terminal is a port, uses the ID of the port in the
            // style and the parent of the port as the actual terminal of the edge.
            if (this.isPortsEnabled()) {
                let id = null;
                if (terminal && this.isPort(terminal)) {
                    id = terminal.getId();
                    terminal = this.getTerminalForPort(terminal, source);
                }
                // Sets or resets all previous information for connecting to a child port
                const key = source ? 'sourcePort' : 'targetPort';
                this.setCellStyles(key, id, [
                    edge
                ]);
            }
            this.getDataModel().setTerminal(edge, terminal, source);
            if (this.isResetEdgesOnConnect()) {
                this.resetEdge(edge);
            }
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CELL_CONNECTED, 'edge', edge, 'terminal', terminal, 'source', source, 'previous', previous));
        });
    },
    disconnectGraph (cells) {
        this.batchUpdate(()=>{
            const { scale, translate: tr } = this.getView();
            // Fast lookup for finding cells in array
            const dict = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
            for(let i = 0; i < cells.length; i += 1){
                dict.put(cells[i], true);
            }
            for (const cell of cells){
                if (cell.isEdge()) {
                    let geo = cell.getGeometry();
                    if (geo) {
                        const state = this.getView().getState(cell);
                        const parent = cell.getParent();
                        const pstate = parent ? this.getView().getState(parent) : null;
                        if (state && pstate) {
                            geo = geo.clone();
                            const dx = -pstate.origin.x;
                            const dy = -pstate.origin.y;
                            const pts = state.absolutePoints;
                            let src = cell.getTerminal(true);
                            if (src && this.isCellDisconnectable(cell, src, true)) {
                                while(src && !dict.get(src)){
                                    src = src.getParent();
                                }
                                if (!src && pts[0]) {
                                    geo.setTerminalPoint(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](pts[0].x / scale - tr.x + dx, pts[0].y / scale - tr.y + dy), true);
                                    this.getDataModel().setTerminal(cell, null, true);
                                }
                            }
                            let trg = cell.getTerminal(false);
                            if (trg && this.isCellDisconnectable(cell, trg, false)) {
                                while(trg && !dict.get(trg)){
                                    trg = trg.getParent();
                                }
                                if (!trg) {
                                    const n = pts.length - 1;
                                    const p = pts[n];
                                    if (p) {
                                        geo.setTerminalPoint(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](p.x / scale - tr.x + dx, p.y / scale - tr.y + dy), false);
                                        this.getDataModel().setTerminal(cell, null, false);
                                    }
                                }
                            }
                            this.getDataModel().setGeometry(cell, geo);
                        }
                    }
                }
            }
        });
    },
    getConnections (cell, parent = null) {
        return this.getEdges(cell, parent, true, true, false);
    },
    isConstrainChild (cell) {
        return this.isConstrainChildren() && !!cell.getParent() && !cell.getParent().isEdge();
    },
    isConstrainChildren () {
        return this.constrainChildren;
    },
    setConstrainChildren (value) {
        this.constrainChildren = value;
    },
    isConstrainRelativeChildren () {
        return this.constrainRelativeChildren;
    },
    setConstrainRelativeChildren (value) {
        this.constrainRelativeChildren = value;
    },
    /*****************************************************************************
     * Group: Graph behaviour
     *****************************************************************************/ isDisconnectOnMove () {
        return this.disconnectOnMove;
    },
    setDisconnectOnMove (value) {
        this.disconnectOnMove = value;
    },
    isCellDisconnectable (cell, terminal = null, source = false) {
        return this.isCellsDisconnectable() && !this.isCellLocked(cell);
    },
    isCellsDisconnectable () {
        return this.cellsDisconnectable;
    },
    setCellsDisconnectable (value) {
        this.cellsDisconnectable = value;
    },
    isValidSource (cell) {
        return cell == null && this.isAllowDanglingEdges() || cell != null && (!cell.isEdge() || this.isConnectableEdges()) && cell.isConnectable();
    },
    isValidTarget (cell) {
        return this.isValidSource(cell);
    },
    isValidConnection (source, target) {
        return this.isValidSource(source) && this.isValidTarget(target);
    },
    setConnectable (connectable) {
        const connectionHandler = this.getPlugin('ConnectionHandler');
        connectionHandler?.setEnabled(connectable);
    },
    isConnectable () {
        const connectionHandler = this.getPlugin('ConnectionHandler');
        return connectionHandler?.isEnabled() ?? false;
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/DragDropMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ // @ts-expect-error The properties of PartialGraph are defined elsewhere.
__turbopack_esm__({
    "DragDropMixin": (()=>DragDropMixin)
});
const DragDropMixin = {
    dropEnabled: false,
    splitEnabled: true,
    autoScroll: true,
    isAutoScroll () {
        return this.autoScroll;
    },
    autoExtend: true,
    isAutoExtend () {
        return this.autoExtend;
    },
    /*****************************************************************************
     * Group: Graph behaviour
     *****************************************************************************/ isDropEnabled () {
        return this.dropEnabled;
    },
    setDropEnabled (value) {
        this.dropEnabled = value;
    },
    /*****************************************************************************
     * Group: Split behaviour
     *****************************************************************************/ isSplitEnabled () {
        return this.splitEnabled;
    },
    setSplitEnabled (value) {
        this.splitEnabled = value;
    },
    isSplitTarget (target, cells = [], evt) {
        if (target.isEdge() && cells.length === 1 && cells[0].isConnectable() && !this.getEdgeValidationError(target, target.getTerminal(true), cells[0])) {
            const src = target.getTerminal(true);
            const trg = target.getTerminal(false);
            return !cells[0].isAncestor(src) && !cells[0].isAncestor(trg);
        }
        return false;
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/EdgeMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "EdgeMixin": (()=>EdgeMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/Cell.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$arrayUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/arrayUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Dictionary.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const EdgeMixin = {
    resetEdgesOnResize: false,
    isResetEdgesOnResize () {
        return this.resetEdgesOnResize;
    },
    resetEdgesOnMove: false,
    isResetEdgesOnMove () {
        return this.resetEdgesOnMove;
    },
    resetEdgesOnConnect: true,
    isResetEdgesOnConnect () {
        return this.resetEdgesOnConnect;
    },
    connectableEdges: false,
    allowDanglingEdges: true,
    cloneInvalidEdges: false,
    alternateEdgeStyle: {},
    edgeLabelsMovable: true,
    // ***************************************************************************
    // Group: Graph Behaviour
    // ***************************************************************************
    isEdgeLabelsMovable () {
        return this.edgeLabelsMovable;
    },
    setEdgeLabelsMovable (value) {
        this.edgeLabelsMovable = value;
    },
    setAllowDanglingEdges (value) {
        this.allowDanglingEdges = value;
    },
    isAllowDanglingEdges () {
        return this.allowDanglingEdges;
    },
    setConnectableEdges (value) {
        this.connectableEdges = value;
    },
    isConnectableEdges () {
        return this.connectableEdges;
    },
    setCloneInvalidEdges (value) {
        this.cloneInvalidEdges = value;
    },
    isCloneInvalidEdges () {
        return this.cloneInvalidEdges;
    },
    // ***************************************************************************
    // Group: Cell alignment and orientation
    // ***************************************************************************
    flipEdge (edge) {
        if (this.alternateEdgeStyle) {
            this.batchUpdate(()=>{
                const style = edge.getStyle();
                if (Object.keys(style).length) {
                    this.getDataModel().setStyle(edge, this.alternateEdgeStyle);
                } else {
                    this.getDataModel().setStyle(edge, {});
                }
                // Removes all existing control points
                this.resetEdge(edge);
                this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FLIP_EDGE, {
                    edge
                }));
            });
        }
        return edge;
    },
    splitEdge (edge, cells, newEdge, dx = 0, dy = 0, x, y, parent = null) {
        parent = parent ?? edge.getParent();
        const source = edge.getTerminal(true);
        this.batchUpdate(()=>{
            if (!newEdge) {
                newEdge = this.cloneCell(edge);
                // Removes waypoints before/after new cell
                const state = this.getView().getState(edge);
                let geo = newEdge.getGeometry();
                if (geo && state) {
                    const t = this.getView().translate;
                    const s = this.getView().scale;
                    const idx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findNearestSegment"])(state, (dx + t.x) * s, (dy + t.y) * s);
                    geo.points = geo.points.slice(0, idx);
                    geo = edge.getGeometry();
                    if (geo) {
                        geo = geo.clone();
                        geo.points = geo.points.slice(idx);
                        this.getDataModel().setGeometry(edge, geo);
                    }
                }
            }
            this.cellsMoved(cells, dx, dy, false, false);
            this.cellsAdded(cells, parent, parent ? parent.getChildCount() : 0, null, null, true);
            this.cellsAdded([
                newEdge
            ], parent, parent ? parent.getChildCount() : 0, source, cells[0], false);
            this.cellConnected(edge, cells[0], true);
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SPLIT_EDGE, {
                edge,
                cells,
                newEdge,
                dx,
                dy
            }));
        });
        return newEdge;
    },
    insertEdge (...args) {
        let parent;
        let id;
        let value;
        let source;
        let target;
        let style;
        if (args.length === 1 && typeof args[0] === 'object') {
            const params = args[0];
            parent = params.parent;
            id = params.id;
            value = params.value;
            source = params.source;
            target = params.target;
            style = params.style;
        } else {
            // otherwise treat as individual arguments
            [parent, id, value, source, target, style] = args;
        }
        const edge = this.createEdge(parent, id, value, source, target, style);
        return this.addEdge(edge, parent, source, target);
    },
    createEdge (parent = null, id, value, source = null, target = null, style = {}) {
        // Creates the edge
        const edge = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](value, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](), style);
        edge.setId(id);
        edge.setEdge(true);
        edge.geometry.relative = true;
        return edge;
    },
    addEdge (edge, parent = null, source = null, target = null, index = null) {
        return this.addCell(edge, parent, index, source, target);
    },
    // ***************************************************************************
    // Group: Folding
    // ***************************************************************************
    addAllEdges (cells) {
        const allCells = cells.slice();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$arrayUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["removeDuplicates"])(allCells.concat(this.getAllEdges(cells)));
    },
    getAllEdges (cells) {
        let edges = [];
        if (cells) {
            for(let i = 0; i < cells.length; i += 1){
                const edgeCount = cells[i].getEdgeCount();
                for(let j = 0; j < edgeCount; j++){
                    edges.push(cells[i].getEdgeAt(j));
                }
                // Recurses
                const children = cells[i].getChildren();
                edges = edges.concat(this.getAllEdges(children));
            }
        }
        return edges;
    },
    getIncomingEdges (cell, parent = null) {
        return this.getEdges(cell, parent, true, false, false);
    },
    getOutgoingEdges (cell, parent = null) {
        return this.getEdges(cell, parent, false, true, false);
    },
    getEdges (cell, parent = null, incoming = true, outgoing = true, includeLoops = true, recurse = false) {
        let edges = [];
        const isCollapsed = cell.isCollapsed();
        const childCount = cell.getChildCount();
        for(let i = 0; i < childCount; i += 1){
            const child = cell.getChildAt(i);
            if (isCollapsed || !child.isVisible()) {
                edges = edges.concat(child.getEdges(incoming, outgoing));
            }
        }
        edges = edges.concat(cell.getEdges(incoming, outgoing));
        const result = [];
        for(let i = 0; i < edges.length; i += 1){
            const state = this.getView().getState(edges[i]);
            const source = state ? state.getVisibleTerminal(true) : this.getView().getVisibleTerminal(edges[i], true);
            const target = state ? state.getVisibleTerminal(false) : this.getView().getVisibleTerminal(edges[i], false);
            if (includeLoops && source === target || source !== target && (incoming && target === cell && (!parent || this.isValidAncestor(source, parent, recurse)) || outgoing && source === cell && (!parent || this.isValidAncestor(target, parent, recurse)))) {
                result.push(edges[i]);
            }
        }
        return result;
    },
    // ***************************************************************************
    // Group: Cell retrieval
    // ***************************************************************************
    getChildEdges (parent) {
        return this.getChildCells(parent, false, true);
    },
    getEdgesBetween (source, target, directed = false) {
        const edges = this.getEdges(source);
        const result = [];
        // Checks if the edge is connected to the correct
        // cell and returns the first match
        for(let i = 0; i < edges.length; i += 1){
            const state = this.getView().getState(edges[i]);
            const src = state ? state.getVisibleTerminal(true) : this.getView().getVisibleTerminal(edges[i], true);
            const trg = state ? state.getVisibleTerminal(false) : this.getView().getVisibleTerminal(edges[i], false);
            if (src === source && trg === target || !directed && src === target && trg === source) {
                result.push(edges[i]);
            }
        }
        return result;
    },
    // ***************************************************************************
    // Group: Cell moving
    // ***************************************************************************
    resetEdges (cells) {
        // Prepares faster cells lookup
        const dict = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        for(let i = 0; i < cells.length; i += 1){
            dict.put(cells[i], true);
        }
        this.batchUpdate(()=>{
            for(let i = 0; i < cells.length; i += 1){
                const edges = cells[i].getEdges();
                for(let j = 0; j < edges.length; j++){
                    const state = this.getView().getState(edges[j]);
                    const source = state ? state.getVisibleTerminal(true) : this.getView().getVisibleTerminal(edges[j], true);
                    const target = state ? state.getVisibleTerminal(false) : this.getView().getVisibleTerminal(edges[j], false);
                    // Checks if one of the terminals is not in the given array
                    if (!dict.get(source) || !dict.get(target)) {
                        this.resetEdge(edges[j]);
                    }
                }
                this.resetEdges(cells[i].getChildren());
            }
        });
    },
    resetEdge (edge) {
        let geo = edge.getGeometry();
        // Resets the control points
        if (geo && geo.points && geo.points.length > 0) {
            geo = geo.clone();
            geo.points = [];
            this.getDataModel().setGeometry(edge, geo);
        }
        return edge;
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/EditingMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "EditingMixin": (()=>EditingMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
;
;
;
const EditingMixin = {
    cellsEditable: true,
    /*****************************************************************************
     * Group: Cell in-place editing
     *****************************************************************************/ startEditing (evt) {
        this.startEditingAtCell(null, evt);
    },
    startEditingAtCell (cell = null, evt) {
        if (!evt || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiTouchEvent"])(evt)) {
            if (!cell) {
                cell = this.getSelectionCell();
                if (cell && !this.isCellEditable(cell)) {
                    cell = null;
                }
            } else {
                this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].START_EDITING, {
                    cell,
                    event: evt
                }));
                const cellEditorHandler = this.getPlugin('CellEditorHandler');
                cellEditorHandler?.startEditing(cell, evt);
                this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EDITING_STARTED, {
                    cell,
                    event: evt
                }));
            }
        }
    },
    getEditingValue (cell, evt) {
        return this.convertValueToString(cell);
    },
    stopEditing (cancel = false) {
        const cellEditorHandler = this.getPlugin('CellEditorHandler');
        cellEditorHandler?.stopEditing(cancel);
        this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].EDITING_STOPPED, {
            cancel
        }));
    },
    labelChanged (cell, value, evt) {
        this.batchUpdate(()=>{
            const old = cell.value;
            this.cellLabelChanged(cell, value, this.isAutoSizeCell(cell));
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].LABEL_CHANGED, {
                cell: cell,
                value: value,
                old: old,
                event: evt
            }));
        });
        return cell;
    },
    cellLabelChanged (cell, value, autoSize = false) {
        this.batchUpdate(()=>{
            this.getDataModel().setValue(cell, value);
            if (autoSize) {
                this.cellSizeUpdated(cell, false);
            }
        });
    },
    /*****************************************************************************
     * Group: Graph behaviour
     *****************************************************************************/ isEditing (cell = null) {
        const cellEditorHandler = this.getPlugin('CellEditorHandler');
        const editingCell = cellEditorHandler?.getEditingCell();
        return !cell ? !!editingCell : cell === editingCell;
    },
    isCellEditable (cell) {
        return this.isCellsEditable() && !this.isCellLocked(cell) && (this.getCurrentCellStyle(cell).editable ?? true);
    },
    isCellsEditable () {
        return this.cellsEditable;
    },
    setCellsEditable (value) {
        this.cellsEditable = value;
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/EventsMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "EventsMixin": (()=>EventsMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalMouseEvent.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const EventsMixin = {
    // TODO: Document me!
    lastTouchEvent: null,
    doubleClickCounter: 0,
    lastTouchCell: null,
    fireDoubleClick: null,
    tapAndHoldThread: null,
    lastMouseX: null,
    lastMouseY: null,
    isMouseTrigger: null,
    ignoreMouseEvents: null,
    mouseMoveRedirect: null,
    mouseUpRedirect: null,
    lastEvent: null,
    escapeEnabled: true,
    invokesStopCellEditing: true,
    enterStopsCellEditing: false,
    isMouseDown: false,
    nativeDblClickEnabled: true,
    doubleTapEnabled: true,
    doubleTapTimeout: 500,
    doubleTapTolerance: 25,
    lastTouchX: 0,
    lastTouchY: 0,
    lastTouchTime: 0,
    tapAndHoldEnabled: true,
    tapAndHoldDelay: 500,
    tapAndHoldInProgress: false,
    tapAndHoldValid: false,
    initialTouchX: 0,
    initialTouchY: 0,
    tolerance: 4,
    isNativeDblClickEnabled () {
        return this.nativeDblClickEnabled;
    },
    getEventTolerance () {
        return this.tolerance;
    },
    setEventTolerance (tolerance) {
        this.tolerance = tolerance;
    },
    escape (evt) {
        this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ESCAPE, {
            event: evt
        }));
    },
    click (me) {
        const evt = me.getEvent();
        let cell = me.getCell();
        const mxe = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CLICK, {
            event: evt,
            cell
        });
        if (me.isConsumed()) {
            mxe.consume();
        }
        this.fireEvent(mxe);
        if (this.isEnabled() && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConsumed"])(evt) && !mxe.isConsumed()) {
            if (cell) {
                if (this.isTransparentClickEvent(evt)) {
                    let active = false;
                    const tmp = this.getCellAt(me.graphX, me.graphY, null, false, false, (state)=>{
                        const selected = this.isCellSelected(state.cell);
                        active = active || selected;
                        return !active || selected || state.cell !== cell && state.cell.isAncestor(cell);
                    });
                    if (tmp) {
                        cell = tmp;
                    }
                }
            } else if (this.isSwimlaneSelectionEnabled()) {
                cell = this.getSwimlaneAt(me.getGraphX(), me.getGraphY());
                if (cell != null && (!this.isToggleEvent(evt) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAltDown"])(evt))) {
                    let temp = cell;
                    let swimlanes = [];
                    while(temp != null){
                        temp = temp.getParent();
                        const state = this.getView().getState(temp);
                        if (this.isSwimlane(temp) && state != null) {
                            swimlanes.push(temp);
                        }
                    }
                    // Selects ancestors for selected swimlanes
                    if (swimlanes.length > 0) {
                        swimlanes = swimlanes.reverse();
                        swimlanes.splice(0, 0, cell);
                        swimlanes.push(cell);
                        for(let i = 0; i < swimlanes.length - 1; i += 1){
                            if (this.isCellSelected(swimlanes[i])) {
                                cell = swimlanes[this.isToggleEvent(evt) ? i : i + 1];
                            }
                        }
                    }
                }
            }
            if (cell) {
                this.selectCellForEvent(cell, evt);
            } else if (!this.isToggleEvent(evt)) {
                this.clearSelection();
            }
        }
        return false;
    },
    dblClick (evt, cell = null) {
        const mxe = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].DOUBLE_CLICK, {
            event: evt,
            cell
        });
        this.fireEvent(mxe);
        // Handles the event if it has not been consumed
        if (this.isEnabled() && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConsumed"])(evt) && !mxe.isConsumed() && cell && this.isCellEditable(cell) && !this.isEditing(cell)) {
            this.startEditingAtCell(cell, evt);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].consume(evt);
        }
    },
    tapAndHold (me) {
        const evt = me.getEvent();
        const mxe = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].TAP_AND_HOLD, {
            event: evt,
            cell: me.getCell()
        });
        const panningHandler = this.getPlugin('PanningHandler');
        const connectionHandler = this.getPlugin('ConnectionHandler');
        // LATER: Check if event should be consumed if me is consumed
        this.fireEvent(mxe);
        if (mxe.isConsumed()) {
            // Resets the state of the panning handler
            panningHandler && (panningHandler.panningTrigger = false);
        }
        // Handles the event if it has not been consumed
        if (this.isEnabled() && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConsumed"])(evt) && !mxe.isConsumed() && connectionHandler && connectionHandler.isEnabled()) {
            const cell = connectionHandler.marker.getCell(me);
            if (cell) {
                const state = this.getView().getState(cell);
                if (state) {
                    connectionHandler.marker.currentColor = connectionHandler.marker.validColor;
                    connectionHandler.marker.markedState = state;
                    connectionHandler.marker.mark();
                    connectionHandler.first = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](me.getGraphX(), me.getGraphY());
                    connectionHandler.edgeState = connectionHandler.createEdgeState(me);
                    connectionHandler.previous = state;
                    connectionHandler.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].START, {
                        state: connectionHandler.previous
                    }));
                }
            }
        }
    },
    addMouseListener (listener) {
        this.mouseListeners.push(listener);
    },
    removeMouseListener (listener) {
        for(let i = 0; i < this.mouseListeners.length; i += 1){
            if (this.mouseListeners[i] === listener) {
                this.mouseListeners.splice(i, 1);
                break;
            }
        }
    },
    updateMouseEvent (me, evtName) {
        const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertPoint"])(this.getContainer(), me.getX(), me.getY());
        me.graphX = pt.x - this.getPanDx();
        me.graphY = pt.y - this.getPanDy();
        // Searches for rectangles using method if native hit detection is disabled on shape
        if (!me.getCell() && this.isMouseDown && evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_MOVE) {
            const cell = this.getCellAt(pt.x, pt.y, null, true, true, (state)=>{
                return !state.shape || state.shape.paintBackground !== this.paintBackground || state.style.pointerEvents || state.shape.fill !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NONE"];
            });
            me.state = cell ? this.getView().getState(cell) : null;
        }
        return me;
    },
    getStateForTouchEvent (evt) {
        const x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getClientX"])(evt);
        const y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getClientY"])(evt);
        // Dispatches the drop event to the graph which
        // consumes and executes the source function
        const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertPoint"])(this.getContainer(), x, y);
        const cell = this.getCellAt(pt.x, pt.y);
        return cell ? this.getView().getState(cell) : null;
    },
    isEventIgnored (evtName, me, sender) {
        const mouseEvent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMouseEvent"])(me.getEvent());
        let result = false;
        // Drops events that are fired more than once
        if (me.getEvent() === this.lastEvent) {
            result = true;
        } else {
            this.lastEvent = me.getEvent();
        }
        // Installs event listeners to capture the complete gesture from the event source
        // for non-MS touch events as a workaround for all events for the same geture being
        // fired from the event source even if that was removed from the DOM.
        const eventSource = this.getEventSource();
        if (eventSource && evtName !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_MOVE) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].removeGestureListeners(eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
            this.mouseMoveRedirect = null;
            this.mouseUpRedirect = null;
            this.setEventSource(null);
        } else if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_GC && eventSource && me.getSource() !== eventSource) {
            result = true;
        } else if (eventSource && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_TOUCH && evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN && !mouseEvent && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPenEvent"])(me.getEvent())) {
            this.setEventSource(me.getSource());
            this.mouseMoveRedirect = (evt)=>{
                this.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_MOVE, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](evt, this.getStateForTouchEvent(evt)));
            }, this.mouseUpRedirect = (evt)=>{
                this.fireMouseEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_UP, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalMouseEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](evt, this.getStateForTouchEvent(evt)));
            }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].addGestureListeners(eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
        }
        // Factored out the workarounds for FF to make it easier to override/remove
        // Note this method has side-effects!
        if (this.isSyntheticEventIgnored(evtName, me, sender)) {
            result = true;
        }
        // Never fires mouseUp/-Down for double clicks
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPopupTrigger"])(this.lastEvent) && evtName !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_MOVE && this.lastEvent.detail === 2) {
            return true;
        }
        // Filters out of sequence events or mixed event types during a gesture
        if (evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_UP && this.isMouseDown) {
            this.isMouseDown = false;
        } else if (evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN && !this.isMouseDown) {
            this.isMouseDown = true;
            this.isMouseTrigger = mouseEvent;
        } else if (!result && ((!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_FF || evtName !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_MOVE) && this.isMouseDown && this.isMouseTrigger !== mouseEvent || evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN && this.isMouseDown || evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_UP && !this.isMouseDown)) {
            result = true;
        }
        if (!result && evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN) {
            this.lastMouseX = me.getX();
            this.lastMouseY = me.getY();
        }
        return result;
    },
    isSyntheticEventIgnored (evtName, me, sender) {
        let result = false;
        const mouseEvent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMouseEvent"])(me.getEvent());
        // LATER: This does not cover all possible cases that can go wrong in FF
        if (this.ignoreMouseEvents && mouseEvent && evtName !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_MOVE) {
            this.ignoreMouseEvents = evtName !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_UP;
            result = true;
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_FF && !mouseEvent && evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_UP) {
            this.ignoreMouseEvents = true;
        }
        return result;
    },
    isEventSourceIgnored (evtName, me) {
        const source = me.getSource();
        if (!source) return true;
        // @ts-ignore nodeName could exist
        const name = source.nodeName ? source.nodeName.toLowerCase() : '';
        const candidate = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMouseEvent"])(me.getEvent()) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLeftMouseButton"])(me.getEvent());
        return evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN && candidate && (name === 'select' || name === 'option' || name === 'input' && // @ts-ignore type could exist
        source.type !== 'checkbox' && // @ts-ignore type could exist
        source.type !== 'radio' && // @ts-ignore type could exist
        source.type !== 'button' && // @ts-ignore type could exist
        source.type !== 'submit' && // @ts-ignore type could exist
        source.type !== 'file');
    },
    getEventState (state) {
        return state;
    },
    fireMouseEvent (evtName, me, sender) {
        sender = sender ?? this;
        if (this.isEventSourceIgnored(evtName, me)) {
            const tooltipHandler = this.getPlugin('TooltipHandler');
            if (tooltipHandler) {
                tooltipHandler.hide();
            }
            return;
        }
        // Updates the graph coordinates in the event
        me = this.updateMouseEvent(me, evtName);
        // Detects and processes double taps for touch-based devices which do not have native double click events
        // or where detection of double click is not always possible (quirks, IE10+). Note that this can only handle
        // double clicks on cells because the sequence of events in IE prevents detection on the background, it fires
        // two mouse ups, one of which without a cell but no mousedown for the second click which means we cannot
        // detect which mouseup(s) are part of the first click, ie we do not know when the first click ends.
        if (!this.nativeDblClickEnabled && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPopupTrigger"])(me.getEvent()) || this.doubleTapEnabled && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_TOUCH && ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTouchEvent"])(me.getEvent()) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPenEvent"])(me.getEvent()))) {
            const currentTime = new Date().getTime();
            if (evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN) {
                if (this.lastTouchEvent && this.lastTouchEvent !== me.getEvent() && currentTime - this.lastTouchTime < this.doubleTapTimeout && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance && this.doubleClickCounter < 2) {
                    this.doubleClickCounter += 1;
                    let doubleClickFired = false;
                    if (evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_UP) {
                        if (me.getCell() === this.lastTouchCell && this.lastTouchCell) {
                            this.lastTouchTime = 0;
                            const cell = this.lastTouchCell;
                            this.lastTouchCell = null;
                            this.dblClick(me.getEvent(), cell);
                            doubleClickFired = true;
                        }
                    } else {
                        this.fireDoubleClick = true;
                        this.lastTouchTime = 0;
                    }
                    if (doubleClickFired) {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].consume(me.getEvent());
                        return;
                    }
                } else if (!this.lastTouchEvent || this.lastTouchEvent !== me.getEvent()) {
                    this.lastTouchCell = me.getCell();
                    this.lastTouchX = me.getX();
                    this.lastTouchY = me.getY();
                    this.lastTouchTime = currentTime;
                    this.lastTouchEvent = me.getEvent();
                    this.doubleClickCounter = 0;
                }
            } else if ((this.isMouseDown || evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_UP) && this.fireDoubleClick) {
                this.fireDoubleClick = false;
                const cell = this.lastTouchCell;
                this.lastTouchCell = null;
                this.isMouseDown = false;
                // Workaround for Chrome/Safari not firing native double click events for double touch on background
                const valid = cell || ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTouchEvent"])(me.getEvent()) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPenEvent"])(me.getEvent())) && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_GC || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_SF);
                if (valid && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance) {
                    this.dblClick(me.getEvent(), cell);
                } else {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].consume(me.getEvent());
                }
                return;
            }
        }
        if (!this.isEventIgnored(evtName, me, sender)) {
            const state = me.getState();
            // Updates the event state via getEventState
            me.state = state ? this.getEventState(state) : null;
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FIRE_MOUSE_EVENT, {
                eventName: evtName,
                event: me
            }));
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_SF || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_GC || me.getEvent().target !== this.getContainer()) {
                const container = this.getContainer();
                if (evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_MOVE && this.isMouseDown && this.isAutoScroll() && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiTouchEvent"])(me.getEvent())) {
                    this.scrollPointToVisible(me.getGraphX(), me.getGraphY(), this.isAutoExtend());
                } else if (evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_UP && this.isIgnoreScrollbars() && this.isTranslateToScrollPosition() && (container.scrollLeft !== 0 || container.scrollTop !== 0)) {
                    const s = this.getView().scale;
                    const tr = this.getView().translate;
                    this.getView().setTranslate(tr.x - container.scrollLeft / s, tr.y - container.scrollTop / s);
                    container.scrollLeft = 0;
                    container.scrollTop = 0;
                }
                const mouseListeners = this.mouseListeners;
                // Does not change returnValue in Opera
                if (!me.getEvent().preventDefault) {
                    me.getEvent().returnValue = true;
                }
                for (const l of mouseListeners){
                    if (evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN) {
                        l.mouseDown(sender, me);
                    } else if (evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_MOVE) {
                        l.mouseMove(sender, me);
                    } else if (evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_UP) {
                        l.mouseUp(sender, me);
                    }
                }
                // Invokes the click handler
                if (evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_UP) {
                    this.click(me);
                }
            }
            // Detects tapAndHold events using a timer
            if (((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTouchEvent"])(me.getEvent()) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPenEvent"])(me.getEvent())) && evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN && this.tapAndHoldEnabled && !this.tapAndHoldInProgress) {
                this.tapAndHoldInProgress = true;
                this.initialTouchX = me.getGraphX();
                this.initialTouchY = me.getGraphY();
                const handler = ()=>{
                    if (this.tapAndHoldValid) {
                        this.tapAndHold(me);
                    }
                    this.tapAndHoldInProgress = false;
                    this.tapAndHoldValid = false;
                };
                if (this.tapAndHoldThread) {
                    window.clearTimeout(this.tapAndHoldThread);
                }
                this.tapAndHoldThread = window.setTimeout(handler, this.tapAndHoldDelay);
                this.tapAndHoldValid = true;
            } else if (evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_UP) {
                this.tapAndHoldInProgress = false;
                this.tapAndHoldValid = false;
            } else if (this.tapAndHoldValid) {
                this.tapAndHoldValid = Math.abs(this.initialTouchX - me.getGraphX()) < this.tolerance && Math.abs(this.initialTouchY - me.getGraphY()) < this.tolerance;
            }
            const cellEditorHandler = this.getPlugin('CellEditorHandler');
            // Stops editing for all events other than from cellEditorHandler
            if (evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN && this.isEditing() && !cellEditorHandler?.isEventSource(me.getEvent())) {
                this.stopEditing(!this.isInvokesStopCellEditing());
            }
            this.consumeMouseEvent(evtName, me, sender);
        }
    },
    consumeMouseEvent (evtName, me, sender) {
        sender = sender ?? this;
        // Workaround for duplicate click in Windows 8 with Chrome/FF/Opera with touch
        if (evtName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].MOUSE_DOWN && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTouchEvent"])(me.getEvent())) {
            me.consume(false);
        }
    },
    fireGestureEvent (evt, cell = null) {
        // Resets double tap event handling when gestures take place
        this.lastTouchTime = 0;
        this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].GESTURE, {
            event: evt,
            cell
        }));
    },
    sizeDidChange () {
        const bounds = this.getGraphBounds();
        const border = this.getBorder();
        let width = Math.max(0, bounds.x) + bounds.width + 2 * border;
        let height = Math.max(0, bounds.y) + bounds.height + 2 * border;
        const minimumContainerSize = this.getMinimumContainerSize();
        if (minimumContainerSize) {
            width = Math.max(width, minimumContainerSize.width);
            height = Math.max(height, minimumContainerSize.height);
        }
        if (this.isResizeContainer()) {
            this.doResizeContainer(width, height);
        }
        if (this.isPreferPageSize() || this.isPageVisible()) {
            const size = this.getPreferredPageSize(bounds, Math.max(1, width), Math.max(1, height));
            width = size.width * this.getView().scale;
            height = size.height * this.getView().scale;
        }
        const minimumGraphSize = this.getMinimumGraphSize();
        if (minimumGraphSize) {
            width = Math.max(width, minimumGraphSize.width * this.getView().scale);
            height = Math.max(height, minimumGraphSize.height * this.getView().scale);
        }
        width = Math.ceil(width);
        height = Math.ceil(height);
        // @ts-ignore
        const root = this.getView().getDrawPane().ownerSVGElement;
        if (root) {
            root.style.minWidth = `${Math.max(1, width)}px`;
            root.style.minHeight = `${Math.max(1, height)}px`;
            root.style.width = '100%';
            root.style.height = '100%';
        }
        this.updatePageBreaks(this.isPageBreaksVisible(), width, height);
        this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].SIZE, {
            bounds
        }));
    },
    isCloneEvent (evt) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isControlDown"])(evt);
    },
    isTransparentClickEvent (evt) {
        return false;
    },
    isToggleEvent (evt) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].IS_MAC ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMetaDown"])(evt) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isControlDown"])(evt);
    },
    isGridEnabledEvent (evt) {
        return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAltDown"])(evt);
    },
    isConstrainedEvent (evt) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isShiftDown"])(evt);
    },
    isIgnoreTerminalEvent (_evt) {
        return false;
    },
    getPointForEvent (evt, addOffset = true) {
        const p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertPoint"])(this.getContainer(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getClientX"])(evt), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getClientY"])(evt));
        const s = this.getView().scale;
        const tr = this.getView().translate;
        const off = addOffset ? this.getGridSize() / 2 : 0;
        p.x = this.snap(p.x / s - tr.x - off);
        p.y = this.snap(p.y / s - tr.y - off);
        return p;
    },
    isEscapeEnabled () {
        return this.escapeEnabled;
    },
    setEscapeEnabled (value) {
        this.escapeEnabled = value;
    },
    isInvokesStopCellEditing () {
        return this.invokesStopCellEditing;
    },
    setInvokesStopCellEditing (value) {
        this.invokesStopCellEditing = value;
    },
    isEnterStopsCellEditing () {
        return this.enterStopsCellEditing;
    },
    setEnterStopsCellEditing (value) {
        this.enterStopsCellEditing = value;
    },
    getCursorForMouseEvent (me) {
        const cell = me.getCell();
        return cell ? this.getCursorForCell(cell) : null;
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/FoldingMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "FoldingMixin": (()=>FoldingMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$image$2f$ImageBox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/image/ImageBox.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/Client.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const FoldingMixin = {
    options: {
        foldingEnabled: true,
        collapsedImage: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$image$2f$ImageBox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].imageBasePath}/collapsed.gif`, 9, 9),
        expandedImage: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$image$2f$ImageBox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].imageBasePath}/expanded.gif`, 9, 9),
        collapseToPreferredSize: true
    },
    collapseExpandResource: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$Client$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].language != 'none' ? 'collapse-expand' : '',
    getCollapseExpandResource () {
        return this.collapseExpandResource;
    },
    isFoldingEnabled () {
        return this.options.foldingEnabled;
    },
    getFoldableCells (cells, collapse = false) {
        return this.getDataModel().filterCells(cells, (cell)=>{
            return this.isCellFoldable(cell, collapse);
        });
    },
    isCellFoldable (cell, collapse) {
        const style = this.getCurrentCellStyle(cell);
        return cell.getChildCount() > 0 && (style.foldable ?? true);
    },
    getFoldingImage (state) {
        if (state != null && this.isFoldingEnabled() && !state.cell.isEdge()) {
            const tmp = state.cell.isCollapsed();
            if (this.isCellFoldable(state.cell, !tmp)) {
                return tmp ? this.options.collapsedImage : this.options.expandedImage;
            }
        }
        return null;
    },
    foldCells (collapse = false, recurse = false, cells = null, checkFoldable = false, _evt = null) {
        if (cells == null) {
            cells = this.getFoldableCells(this.getSelectionCells(), collapse);
        }
        this.stopEditing(false);
        this.batchUpdate(()=>{
            this.cellsFolded(cells, collapse, recurse, checkFoldable);
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].FOLD_CELLS, 'collapse', collapse, 'recurse', recurse, 'cells', cells));
        });
        return cells;
    },
    cellsFolded (cells = null, collapse = false, recurse = false, checkFoldable = false) {
        if (cells != null && cells.length > 0) {
            this.batchUpdate(()=>{
                for(let i = 0; i < cells.length; i += 1){
                    if ((!checkFoldable || this.isCellFoldable(cells[i], collapse)) && collapse !== cells[i].isCollapsed()) {
                        this.getDataModel().setCollapsed(cells[i], collapse);
                        this.swapBounds(cells[i], collapse);
                        if (this.isExtendParent(cells[i])) {
                            this.extendParent(cells[i]);
                        }
                        if (recurse) {
                            const children = cells[i].getChildren();
                            this.cellsFolded(children, collapse, recurse);
                        }
                        this.constrainChild(cells[i]);
                    }
                }
                this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CELLS_FOLDED, {
                    cells,
                    collapse,
                    recurse
                }));
            });
        }
    },
    swapBounds (cell, willCollapse = false) {
        let geo = cell.getGeometry();
        if (geo != null) {
            geo = geo.clone();
            this.updateAlternateBounds(cell, geo, willCollapse);
            geo.swap();
            this.getDataModel().setGeometry(cell, geo);
        }
    },
    updateAlternateBounds (cell = null, geo = null, willCollapse = false) {
        if (cell != null && geo != null) {
            const style = this.getCurrentCellStyle(cell);
            if (geo.alternateBounds == null) {
                let bounds = geo;
                if (this.options.collapseToPreferredSize) {
                    const tmp = this.getPreferredSizeForCell(cell);
                    if (tmp != null) {
                        bounds = tmp;
                        const startSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getValue"])(style, 'startSize');
                        if (startSize > 0) {
                            bounds.height = Math.max(bounds.height, startSize);
                        }
                    }
                }
                geo.alternateBounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0, bounds.width, bounds.height);
            }
            if (geo.alternateBounds != null) {
                geo.alternateBounds.x = geo.x;
                geo.alternateBounds.y = geo.y;
                const alpha = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toRadians"])(style.rotation || 0);
                if (alpha !== 0) {
                    const dx = geo.alternateBounds.getCenterX() - geo.getCenterX();
                    const dy = geo.alternateBounds.getCenterY() - geo.getCenterY();
                    const cos = Math.cos(alpha);
                    const sin = Math.sin(alpha);
                    const dx2 = cos * dx - sin * dy;
                    const dy2 = sin * dx + cos * dy;
                    geo.alternateBounds.x += dx2 - dx;
                    geo.alternateBounds.y += dy2 - dy;
                }
            }
        }
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/GroupingMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "GroupingMixin": (()=>GroupingMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/Cell.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
;
;
;
;
;
;
const GroupingMixin = {
    groupCells (group, border = 0, cells) {
        if (!cells) cells = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sortCells"])(this.getSelectionCells(), true);
        if (!cells) cells = this.getCellsForGroup(cells);
        if (group == null) {
            group = this.createGroupCell(cells);
        }
        const bounds = this.getBoundsForGroup(group, cells, border);
        if (cells.length > 1 && bounds != null) {
            // Uses parent of group or previous parent of first child
            let parent = group.getParent();
            if (parent == null) {
                parent = cells[0].getParent();
            }
            this.batchUpdate(()=>{
                // Checks if the group has a geometry and
                // creates one if one does not exist
                if (group.getGeometry() == null) {
                    this.getDataModel().setGeometry(group, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]());
                }
                // Adds the group into the parent
                let index = parent.getChildCount();
                this.cellsAdded([
                    group
                ], parent, index, null, null, false, false, false);
                // Adds the children into the group and moves
                index = group.getChildCount();
                this.cellsAdded(cells, group, index, null, null, false, false, false);
                this.cellsMoved(cells, -bounds.x, -bounds.y, false, false, false);
                // Resizes the group
                this.cellsResized([
                    group
                ], [
                    bounds
                ], false);
                this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].GROUP_CELLS, {
                    group,
                    border,
                    cells
                }));
            });
        }
        return group;
    },
    getCellsForGroup (cells) {
        const result = [];
        if (cells != null && cells.length > 0) {
            const parent = cells[0].getParent();
            result.push(cells[0]);
            // Filters selection cells with the same parent
            for(let i = 1; i < cells.length; i += 1){
                if (cells[i].getParent() === parent) {
                    result.push(cells[i]);
                }
            }
        }
        return result;
    },
    getBoundsForGroup (group, children, border) {
        const result = this.getBoundingBoxFromGeometry(children, true);
        if (result != null) {
            if (this.isSwimlane(group)) {
                const size = this.getStartSize(group);
                result.x -= size.width;
                result.y -= size.height;
                result.width += size.width;
                result.height += size.height;
            }
            // Adds the border
            if (border != null) {
                result.x -= border;
                result.y -= border;
                result.width += 2 * border;
                result.height += 2 * border;
            }
        }
        return result;
    },
    createGroupCell (cells) {
        const group = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]('');
        group.setVertex(true);
        group.setConnectable(false);
        return group;
    },
    ungroupCells (cells) {
        let result = [];
        if (cells == null) {
            cells = this.getCellsForUngroup();
        }
        if (cells != null && cells.length > 0) {
            this.batchUpdate(()=>{
                const _cells = cells;
                for(let i = 0; i < _cells.length; i += 1){
                    let children = _cells[i].getChildren();
                    if (children != null && children.length > 0) {
                        children = children.slice();
                        const parent = _cells[i].getParent();
                        const index = parent.getChildCount();
                        this.cellsAdded(children, parent, index, null, null, true);
                        result = result.concat(children);
                        // Fix relative child cells
                        for (const child of children){
                            const state = this.getView().getState(child);
                            let geo = child.getGeometry();
                            if (state != null && geo != null && geo.relative) {
                                geo = geo.clone();
                                geo.x = state.origin.x;
                                geo.y = state.origin.y;
                                geo.relative = false;
                                this.getDataModel().setGeometry(child, geo);
                            }
                        }
                    }
                }
                this.removeCellsAfterUngroup(_cells);
                this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].UNGROUP_CELLS, {
                    cells
                }));
            });
        }
        return result;
    },
    getCellsForUngroup () {
        const cells = this.getSelectionCells();
        // Finds the cells with children
        const tmp = [];
        for(let i = 0; i < cells.length; i += 1){
            if (cells[i].isVertex() && cells[i].getChildCount() > 0) {
                tmp.push(cells[i]);
            }
        }
        return tmp;
    },
    removeCellsAfterUngroup (cells) {
        this.cellsRemoved(this.addAllEdges(cells));
    },
    removeCellsFromParent (cells) {
        if (cells == null) {
            cells = this.getSelectionCells();
        }
        this.batchUpdate(()=>{
            const parent = this.getDefaultParent();
            const index = parent.getChildCount();
            this.cellsAdded(cells, parent, index, null, null, true);
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].REMOVE_CELLS_FROM_PARENT, {
                cells
            }));
        });
        return cells;
    },
    updateGroupBounds (cells, border = 0, moveGroup = false, topBorder = 0, rightBorder = 0, bottomBorder = 0, leftBorder = 0) {
        if (cells == null) {
            cells = this.getSelectionCells();
        }
        border = border != null ? border : 0;
        moveGroup = moveGroup != null ? moveGroup : false;
        topBorder = topBorder != null ? topBorder : 0;
        rightBorder = rightBorder != null ? rightBorder : 0;
        bottomBorder = bottomBorder != null ? bottomBorder : 0;
        leftBorder = leftBorder != null ? leftBorder : 0;
        this.batchUpdate(()=>{
            for(let i = cells.length - 1; i >= 0; i--){
                let geo = cells[i].getGeometry();
                if (geo == null) {
                    continue;
                }
                const children = this.getChildCells(cells[i]);
                if (children != null && children.length > 0) {
                    const bounds = this.getBoundingBoxFromGeometry(children, true);
                    if (bounds != null && bounds.width > 0 && bounds.height > 0) {
                        // Adds the size of the title area for swimlanes
                        const size = this.isSwimlane(cells[i]) ? this.getActualStartSize(cells[i], true) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
                        geo = geo.clone();
                        if (moveGroup) {
                            geo.x = Math.round(geo.x + bounds.x - border - size.x - leftBorder);
                            geo.y = Math.round(geo.y + bounds.y - border - size.y - topBorder);
                        }
                        geo.width = Math.round(bounds.width + 2 * border + size.x + leftBorder + rightBorder + size.width);
                        geo.height = Math.round(bounds.height + 2 * border + size.y + topBorder + bottomBorder + size.height);
                        this.getDataModel().setGeometry(cells[i], geo);
                        this.moveCells(children, border + size.x - bounds.x + leftBorder, border + size.y - bounds.y + topBorder);
                    }
                }
            }
        });
        return cells;
    },
    /*****************************************************************************
     * Group: Drilldown
     *****************************************************************************/ enterGroup (cell) {
        cell = cell || this.getSelectionCell();
        if (cell != null && this.isValidRoot(cell)) {
            this.getView().setCurrentRoot(cell);
            this.clearSelection();
        }
    },
    exitGroup () {
        const root = this.getDataModel().getRoot();
        const current = this.getCurrentRoot();
        if (current != null) {
            let next = current.getParent();
            // Finds the next valid root in the hierarchy
            while(next !== root && !this.isValidRoot(next) && next.getParent() !== root){
                next = next.getParent();
            }
            // Clears the current root if the new root is
            // the model's root or one of the layers.
            if (next === root || next.getParent() === root) {
                this.getView().setCurrentRoot(null);
            } else {
                this.getView().setCurrentRoot(next);
            }
            const state = this.getView().getState(current);
            // Selects the previous root in the graph
            if (state != null) {
                this.setSelectionCell(current);
            }
        }
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/ImageMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ // @ts-expect-error The properties of PartialGraph are defined elsewhere.
__turbopack_esm__({
    "ImageMixin": (()=>ImageMixin)
});
const ImageMixin = {
    addImageBundle (bundle) {
        this.imageBundles.push(bundle);
    },
    removeImageBundle (bundle) {
        const tmp = [];
        for(let i = 0; i < this.imageBundles.length; i += 1){
            if (this.imageBundles[i] !== bundle) {
                tmp.push(this.imageBundles[i]);
            }
        }
        this.imageBundles = tmp;
    },
    getImageFromBundles (key) {
        if (key) {
            for(let i = 0; i < this.imageBundles.length; i += 1){
                const image = this.imageBundles[i].getImage(key);
                if (image) {
                    return image;
                }
            }
        }
        return null;
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/LabelMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ // @ts-expect-error The properties of PartialGraph are defined elsewhere.
__turbopack_esm__({
    "LabelMixin": (()=>LabelMixin)
});
const LabelMixin = {
    getLabel (cell) {
        let result = '';
        if (this.isLabelsVisible() && cell != null) {
            const style = this.getCurrentCellStyle(cell);
            if (!(style.noLabel ?? false)) {
                result = this.convertValueToString(cell);
            }
        }
        return result;
    },
    isHtmlLabel (_cell) {
        return this.isHtmlLabels();
    },
    labelsVisible: true,
    isLabelsVisible () {
        return this.labelsVisible;
    },
    htmlLabels: false,
    isHtmlLabels () {
        return this.htmlLabels;
    },
    setHtmlLabels (value) {
        this.htmlLabels = value;
    },
    isWrapping (cell) {
        return this.getCurrentCellStyle(cell).whiteSpace === 'wrap';
    },
    isLabelClipped (cell) {
        return this.getCurrentCellStyle(cell).overflow === 'hidden';
    },
    isLabelMovable (cell) {
        return !this.isCellLocked(cell) && (cell.isEdge() && this.isEdgeLabelsMovable() || cell.isVertex() && this.isVertexLabelsMovable());
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/OrderMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "OrderMixin": (()=>OrderMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
;
;
;
const OrderMixin = {
    orderCells (back = false, cells) {
        if (!cells) cells = this.getSelectionCells();
        if (!cells) {
            cells = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sortCells"])(this.getSelectionCells(), true);
        }
        this.batchUpdate(()=>{
            this.cellsOrdered(cells, back);
            const event = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ORDER_CELLS, 'back', back, 'cells', cells);
            this.fireEvent(event);
        });
        return cells;
    },
    cellsOrdered (cells, back = false) {
        this.batchUpdate(()=>{
            for(let i = 0; i < cells.length; i += 1){
                const parent = cells[i].getParent();
                if (back) {
                    this.getDataModel().add(parent, cells[i], i);
                } else {
                    this.getDataModel().add(parent, cells[i], parent ? parent.getChildCount() - 1 : 0);
                }
            }
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CELLS_ORDERED, {
                back,
                cells
            }));
        });
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/PageBreaksMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "PageBreaksMixin": (()=>PageBreaksMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$PolylineShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/edge/PolylineShape.js [app-client] (ecmascript)");
;
;
;
const PageBreaksMixin = {
    horizontalPageBreaks: null,
    verticalPageBreaks: null,
    updatePageBreaks (visible, _width, _height) {
        const { scale, translate: tr } = this.getView();
        const fmt = this.getPageFormat();
        const ps = scale * this.getPageScale();
        const bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0, 0, fmt.width * ps, fmt.height * ps);
        const gb = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].fromRectangle(this.getGraphBounds());
        gb.width = Math.max(1, gb.width);
        gb.height = Math.max(1, gb.height);
        bounds.x = Math.floor((gb.x - tr.x * scale) / bounds.width) * bounds.width + tr.x * scale;
        bounds.y = Math.floor((gb.y - tr.y * scale) / bounds.height) * bounds.height + tr.y * scale;
        gb.width = Math.ceil((gb.width + (gb.x - bounds.x)) / bounds.width) * bounds.width;
        gb.height = Math.ceil((gb.height + (gb.y - bounds.y)) / bounds.height) * bounds.height;
        // Does not show page breaks if the scale is too small
        visible = visible && Math.min(bounds.width, bounds.height) > this.getMinPageBreakDist();
        const horizontalCount = visible ? Math.ceil(gb.height / bounds.height) + 1 : 0;
        const verticalCount = visible ? Math.ceil(gb.width / bounds.width) + 1 : 0;
        const right = (verticalCount - 1) * bounds.width;
        const bottom = (horizontalCount - 1) * bounds.height;
        if (this.horizontalPageBreaks == null && horizontalCount > 0) {
            this.horizontalPageBreaks = [];
        }
        if (this.verticalPageBreaks == null && verticalCount > 0) {
            this.verticalPageBreaks = [];
        }
        const drawPageBreaks = (breaks)=>{
            if (breaks != null) {
                const count = breaks === this.horizontalPageBreaks ? horizontalCount : verticalCount;
                for(let i = 0; i <= count; i += 1){
                    const pts = breaks === this.horizontalPageBreaks ? [
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](Math.round(bounds.x), Math.round(bounds.y + i * bounds.height)),
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](Math.round(bounds.x + right), Math.round(bounds.y + i * bounds.height))
                    ] : [
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](Math.round(bounds.x + i * bounds.width), Math.round(bounds.y)),
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](Math.round(bounds.x + i * bounds.width), Math.round(bounds.y + bottom))
                    ];
                    if (breaks[i] != null) {
                        breaks[i].points = pts;
                        breaks[i].redraw();
                    } else {
                        const pageBreak = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$edge$2f$PolylineShape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](pts, this.getPageBreakColor());
                        pageBreak.dialect = this.getDialect();
                        pageBreak.pointerEvents = false;
                        pageBreak.isDashed = this.isPageBreakDashed();
                        pageBreak.init(this.getView().backgroundPane);
                        pageBreak.redraw();
                        breaks[i] = pageBreak;
                    }
                }
                for(let i = count; i < breaks.length; i += 1){
                    breaks[i].destroy();
                }
                breaks.splice(count, breaks.length - count);
            }
        };
        drawPageBreaks(this.horizontalPageBreaks);
        drawPageBreaks(this.verticalPageBreaks);
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/OverlaysMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "OverlaysMixin": (()=>OverlaysMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellOverlay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/CellOverlay.js [app-client] (ecmascript)");
;
;
;
const OverlaysMixin = {
    addCellOverlay (cell, overlay) {
        cell.overlays.push(overlay);
        // Immediately update the cell display if the state exists
        const state = this.getView().getState(cell);
        if (state) {
            this.getCellRenderer().redraw(state);
        }
        this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ADD_OVERLAY, {
            cell,
            overlay
        }));
        return overlay;
    },
    getCellOverlays (cell) {
        return cell.overlays;
    },
    removeCellOverlay (cell, overlay = null) {
        if (!overlay) {
            this.removeCellOverlays(cell);
        } else {
            const index = cell.overlays.indexOf(overlay);
            if (index >= 0) {
                cell.overlays.splice(index, 1);
                // Immediately updates the cell display if the state exists
                const state = this.getView().getState(cell);
                if (state) {
                    this.getCellRenderer().redraw(state);
                }
                this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].REMOVE_OVERLAY, {
                    cell,
                    overlay
                }));
            } else {
                overlay = null;
            }
        }
        return overlay;
    },
    removeCellOverlays (cell) {
        const { overlays } = cell;
        cell.overlays = [];
        // Immediately updates the cell display if the state exists
        const state = this.getView().getState(cell);
        if (state) {
            this.getCellRenderer().redraw(state);
        }
        for(let i = 0; i < overlays.length; i += 1){
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].REMOVE_OVERLAY, 'cell', cell, 'overlay', overlays[i]));
        }
        return overlays;
    },
    clearCellOverlays (cell = null) {
        cell = cell ?? this.getDataModel().getRoot();
        if (!cell) return;
        this.removeCellOverlays(cell);
        // Recursively removes all overlays from the children
        const childCount = cell.getChildCount();
        for(let i = 0; i < childCount; i += 1){
            const child = cell.getChildAt(i);
            this.clearCellOverlays(child); // recurse
        }
    },
    setCellWarning (cell, warning = null, img, isSelect = false) {
        img = img ?? this.getWarningImage();
        if (warning && warning.length > 0) {
            // Creates the overlay with the image and warning
            const overlay = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$CellOverlay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](img, `<font color=red>${warning}</font>`);
            // Adds a handler for single mouseclicks to select the cell
            if (isSelect) {
                overlay.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].CLICK, (sender, evt)=>{
                    if (this.isEnabled()) {
                        this.setSelectionCell(cell);
                    }
                });
            }
            // Sets and returns the overlay in the graph
            return this.addCellOverlay(cell, overlay);
        }
        this.removeCellOverlays(cell);
        return null;
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/PanningMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "PanningMixin": (()=>PanningMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/EventObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/event/InternalEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Point.js [app-client] (ecmascript)");
;
;
;
;
;
const PanningMixin = {
    shiftPreview1: null,
    shiftPreview2: null,
    useScrollbarsForPanning: true,
    isUseScrollbarsForPanning () {
        return this.useScrollbarsForPanning;
    },
    timerAutoScroll: false,
    isTimerAutoScroll () {
        return this.timerAutoScroll;
    },
    allowAutoPanning: false,
    isAllowAutoPanning () {
        return this.allowAutoPanning;
    },
    panDx: 0,
    getPanDx () {
        return this.panDx;
    },
    setPanDx (dx) {
        this.panDx = dx;
    },
    panDy: 0,
    getPanDy () {
        return this.panDy;
    },
    setPanDy (dy) {
        this.panDy = dy;
    },
    panGraph (dx, dy) {
        const container = this.getContainer();
        if (this.useScrollbarsForPanning && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasScrollbars"])(container)) {
            container.scrollLeft = -dx;
            container.scrollTop = -dy;
        } else {
            const canvas = this.getView().getCanvas();
            // Puts everything inside the container in a DIV so that it
            // can be moved without changing the state of the container
            if (dx === 0 && dy === 0) {
                canvas.removeAttribute('transform');
                if (this.shiftPreview1) {
                    let child = this.shiftPreview1.firstChild;
                    while(child){
                        const next = child.nextSibling;
                        container.appendChild(child);
                        child = next;
                    }
                    if (this.shiftPreview1.parentNode) {
                        this.shiftPreview1.parentNode.removeChild(this.shiftPreview1);
                    }
                    this.shiftPreview1 = null;
                    container.appendChild(canvas.parentNode);
                    const shiftPreview2 = this.shiftPreview2;
                    child = shiftPreview2.firstChild;
                    while(child){
                        const next = child.nextSibling;
                        container.appendChild(child);
                        child = next;
                    }
                    if (shiftPreview2.parentNode) {
                        shiftPreview2.parentNode.removeChild(shiftPreview2);
                    }
                    this.shiftPreview2 = null;
                }
            } else {
                canvas.setAttribute('transform', `translate(${dx},${dy})`);
                if (!this.shiftPreview1) {
                    // Needs two divs for stuff before and after the SVG element
                    this.shiftPreview1 = document.createElement('div');
                    this.shiftPreview1.style.position = 'absolute';
                    this.shiftPreview1.style.overflow = 'visible';
                    this.shiftPreview2 = document.createElement('div');
                    this.shiftPreview2.style.position = 'absolute';
                    this.shiftPreview2.style.overflow = 'visible';
                    let current = this.shiftPreview1;
                    let child = container.firstChild;
                    while(child){
                        const next = child.nextSibling;
                        // SVG element is moved via transform attribute
                        // @ts-ignore
                        if (child !== canvas.parentNode) {
                            current.appendChild(child);
                        } else {
                            current = this.shiftPreview2;
                        }
                        child = next;
                    }
                    // Inserts elements only if not empty
                    if (this.shiftPreview1.firstChild) {
                        container.insertBefore(this.shiftPreview1, canvas.parentNode);
                    }
                    if (this.shiftPreview2.firstChild) {
                        container.appendChild(this.shiftPreview2);
                    }
                }
                this.shiftPreview1.style.left = `${dx}px`;
                this.shiftPreview1.style.top = `${dy}px`;
                if (this.shiftPreview2) {
                    this.shiftPreview2.style.left = `${dx}px`;
                    this.shiftPreview2.style.top = `${dy}px`;
                }
            }
            this.panDx = dx;
            this.panDy = dy;
            this.fireEvent(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$EventObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$event$2f$InternalEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].PAN));
        }
    },
    scrollCellToVisible (cell, center = false) {
        const x = -this.getView().translate.x;
        const y = -this.getView().translate.y;
        const state = this.getView().getState(cell);
        if (state) {
            const bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](x + state.x, y + state.y, state.width, state.height);
            if (center && this.getContainer()) {
                const w = this.getContainer().clientWidth;
                const h = this.getContainer().clientHeight;
                bounds.x = bounds.getCenterX() - w / 2;
                bounds.width = w;
                bounds.y = bounds.getCenterY() - h / 2;
                bounds.height = h;
            }
            const tr = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.getView().translate.x, this.getView().translate.y);
            if (this.scrollRectToVisible(bounds)) {
                // Triggers an update via the view's event source
                const tr2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.getView().translate.x, this.getView().translate.y);
                this.getView().translate.x = tr.x;
                this.getView().translate.y = tr.y;
                this.getView().setTranslate(tr2.x, tr2.y);
            }
        }
    },
    scrollRectToVisible (rect) {
        let isChanged = false;
        const container = this.getContainer();
        const w = container.offsetWidth;
        const h = container.offsetHeight;
        const widthLimit = Math.min(w, rect.width);
        const heightLimit = Math.min(h, rect.height);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasScrollbars"])(container)) {
            rect.x += this.getView().translate.x;
            rect.y += this.getView().translate.y;
            let dx = container.scrollLeft - rect.x;
            const ddx = Math.max(dx - container.scrollLeft, 0);
            if (dx > 0) {
                container.scrollLeft -= dx + 2;
            } else {
                dx = rect.x + widthLimit - container.scrollLeft - container.clientWidth;
                if (dx > 0) {
                    container.scrollLeft += dx + 2;
                }
            }
            let dy = container.scrollTop - rect.y;
            const ddy = Math.max(0, dy - container.scrollTop);
            if (dy > 0) {
                container.scrollTop -= dy + 2;
            } else {
                dy = rect.y + heightLimit - container.scrollTop - container.clientHeight;
                if (dy > 0) {
                    container.scrollTop += dy + 2;
                }
            }
            if (!this.useScrollbarsForPanning && (ddx != 0 || ddy != 0)) {
                this.getView().setTranslate(ddx, ddy);
            }
        } else {
            const x = -this.getView().translate.x;
            const y = -this.getView().translate.y;
            const s = this.getView().scale;
            if (rect.x + widthLimit > x + w) {
                this.getView().translate.x -= (rect.x + widthLimit - w - x) / s;
                isChanged = true;
            }
            if (rect.y + heightLimit > y + h) {
                this.getView().translate.y -= (rect.y + heightLimit - h - y) / s;
                isChanged = true;
            }
            if (rect.x < x) {
                this.getView().translate.x += (x - rect.x) / s;
                isChanged = true;
            }
            if (rect.y < y) {
                this.getView().translate.y += (y - rect.y) / s;
                isChanged = true;
            }
            if (isChanged) {
                this.getView().refresh();
                const selectionCellsHandler = this.getPlugin('SelectionCellsHandler');
                // Repaints selection marker (ticket 18)
                if (selectionCellsHandler) {
                    selectionCellsHandler.refresh();
                }
            }
        }
        return isChanged;
    },
    setPanning (enabled) {
        const panningHandler = this.getPlugin('PanningHandler');
        panningHandler && (panningHandler.panningEnabled = enabled);
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/PortsMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "PortsMixin": (()=>PortsMixin)
});
const PortsMixin = {
    portsEnabled: true,
    isPort (cell) {
        return false;
    },
    getTerminalForPort (cell, _source = false) {
        return cell.getParent();
    },
    isPortsEnabled () {
        return this.portsEnabled;
    },
    setPortsEnabled (value) {
        this.portsEnabled = value;
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/SelectionMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "SelectionMixin": (()=>SelectionMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Dictionary.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$RootChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/RootChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$ChildChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/undoable_changes/ChildChange.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/Cell.js [app-client] (ecmascript)");
;
;
;
;
const SelectionMixin = {
    selectionModel: null,
    getSelectionModel () {
        return this.selectionModel;
    },
    setSelectionModel (selectionModel) {
        this.selectionModel = selectionModel;
    },
    /*****************************************************************************
     * Selection
     *****************************************************************************/ isCellSelected (cell) {
        return this.selectionModel.isSelected(cell);
    },
    isSelectionEmpty () {
        return this.selectionModel.isEmpty();
    },
    clearSelection () {
        this.selectionModel.clear();
    },
    getSelectionCount () {
        return this.selectionModel.cells.length;
    },
    getSelectionCell () {
        return this.selectionModel.cells[0];
    },
    getSelectionCells () {
        return this.selectionModel.cells.slice();
    },
    setSelectionCell (cell) {
        this.selectionModel.setCell(cell);
    },
    setSelectionCells (cells) {
        this.selectionModel.setCells(cells);
    },
    addSelectionCell (cell) {
        this.selectionModel.addCell(cell);
    },
    addSelectionCells (cells) {
        this.selectionModel.addCells(cells);
    },
    removeSelectionCell (cell) {
        this.selectionModel.removeCell(cell);
    },
    removeSelectionCells (cells) {
        this.selectionModel.removeCells(cells);
    },
    selectRegion (rect, evt) {
        const cells = this.getCells(rect.x, rect.y, rect.width, rect.height);
        this.selectCellsForEvent(cells, evt);
        return cells;
    },
    selectNextCell () {
        this.selectCell(true);
    },
    selectPreviousCell () {
        this.selectCell();
    },
    selectParentCell () {
        this.selectCell(false, true);
    },
    selectChildCell () {
        this.selectCell(false, false, true);
    },
    selectCell (isNext = false, isParent = false, isChild = false) {
        const cell = this.selectionModel.cells.length > 0 ? this.selectionModel.cells[0] : null;
        if (this.selectionModel.cells.length > 1) {
            this.selectionModel.clear();
        }
        const parent = cell ? cell.getParent() : this.getDefaultParent();
        const childCount = parent.getChildCount();
        if (!cell && childCount > 0) {
            const child = parent.getChildAt(0);
            this.setSelectionCell(child);
        } else if (parent && (!cell || isParent) && this.getView().getState(parent) && parent.getGeometry()) {
            if (this.getCurrentRoot() !== parent) {
                this.setSelectionCell(parent);
            }
        } else if (cell && isChild) {
            const tmp = cell.getChildCount();
            if (tmp > 0) {
                const child = cell.getChildAt(0);
                this.setSelectionCell(child);
            }
        } else if (childCount > 0) {
            let i = parent.getIndex(cell);
            if (isNext) {
                i++;
                const child = parent.getChildAt(i % childCount);
                this.setSelectionCell(child);
            } else {
                i--;
                const index = i < 0 ? childCount - 1 : i;
                const child = parent.getChildAt(index);
                this.setSelectionCell(child);
            }
        }
    },
    selectAll (parent, descendants = false) {
        parent = parent ?? this.getDefaultParent();
        const cells = descendants ? parent.filterDescendants((cell)=>{
            return cell !== parent && !!this.getView().getState(cell);
        }) : parent.getChildren();
        this.setSelectionCells(cells);
    },
    selectVertices (parent, selectGroups = false) {
        this.selectCells(true, false, parent, selectGroups);
    },
    selectEdges (parent) {
        this.selectCells(false, true, parent);
    },
    selectCells (vertices = false, edges = false, parent, selectGroups = false) {
        parent = parent ?? this.getDefaultParent();
        const filter = (cell)=>{
            const p = cell.getParent();
            return !!this.getView().getState(cell) && ((selectGroups || cell.getChildCount() === 0) && cell.isVertex() && vertices && p && !p.isEdge() || cell.isEdge() && edges);
        };
        const cells = parent.filterDescendants(filter);
        this.setSelectionCells(cells);
    },
    selectCellForEvent (cell, evt) {
        const isSelected = this.isCellSelected(cell);
        if (this.isToggleEvent(evt)) {
            if (isSelected) {
                this.removeSelectionCell(cell);
            } else {
                this.addSelectionCell(cell);
            }
        } else if (!isSelected || this.getSelectionCount() !== 1) {
            this.setSelectionCell(cell);
        }
    },
    selectCellsForEvent (cells, evt) {
        if (this.isToggleEvent(evt)) {
            this.addSelectionCells(cells);
        } else {
            this.setSelectionCells(cells);
        }
    },
    isSiblingSelected (cell) {
        const parent = cell.getParent();
        const childCount = parent.getChildCount();
        for(let i = 0; i < childCount; i += 1){
            const child = parent.getChildAt(i);
            if (cell !== child && this.isCellSelected(child)) {
                return true;
            }
        }
        return false;
    },
    /*****************************************************************************
     * Selection state
     *****************************************************************************/ getSelectionCellsForChanges (changes, ignoreFn = null) {
        const dict = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        const cells = [];
        const addCell = (cell)=>{
            if (!dict.get(cell) && this.getDataModel().contains(cell)) {
                if (cell.isEdge() || cell.isVertex()) {
                    dict.put(cell, true);
                    cells.push(cell);
                } else {
                    const childCount = cell.getChildCount();
                    for(let i = 0; i < childCount; i += 1){
                        addCell(cell.getChildAt(i));
                    }
                }
            }
        };
        for(let i = 0; i < changes.length; i += 1){
            const change = changes[i];
            if (change.constructor !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$RootChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] && (!ignoreFn || !ignoreFn(change))) {
                let cell = null;
                if (change instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$undoable_changes$2f$ChildChange$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
                    cell = change.child;
                } else if (change.cell && change.cell instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
                    cell = change.cell;
                }
                if (cell) {
                    addCell(cell);
                }
            }
        }
        return cells;
    },
    updateSelection () {
        const cells = this.getSelectionCells();
        const removed = [];
        for (const cell of cells){
            if (!this.getDataModel().contains(cell) || !cell.isVisible()) {
                removed.push(cell);
            } else {
                let par = cell.getParent();
                while(par && par !== this.getView().currentRoot){
                    if (par.isCollapsed() || !par.isVisible()) {
                        removed.push(cell);
                        break;
                    }
                    par = par.getParent();
                }
            }
        }
        this.removeSelectionCells(removed);
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/SnapMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ // @ts-expect-error The properties of PartialGraph are defined elsewhere.
__turbopack_esm__({
    "SnapMixin": (()=>SnapMixin)
});
const SnapMixin = {
    snapTolerance: 0,
    getSnapTolerance () {
        return this.snapTolerance;
    },
    gridSize: 10,
    gridEnabled: true,
    snap (value) {
        if (this.gridEnabled) {
            value = Math.round(value / this.gridSize) * this.gridSize;
        }
        return value;
    },
    snapDelta (delta, bounds, ignoreGrid = false, ignoreHorizontal = false, ignoreVertical = false) {
        const t = this.getView().translate;
        const s = this.getView().scale;
        if (!ignoreGrid && this.gridEnabled) {
            const tol = this.gridSize * s * 0.5;
            if (!ignoreHorizontal) {
                const tx = bounds.x - (this.snap(bounds.x / s - t.x) + t.x) * s;
                if (Math.abs(delta.x - tx) < tol) {
                    delta.x = 0;
                } else {
                    delta.x = this.snap(delta.x / s) * s - tx;
                }
            }
            if (!ignoreVertical) {
                const ty = bounds.y - (this.snap(bounds.y / s - t.y) + t.y) * s;
                if (Math.abs(delta.y - ty) < tol) {
                    delta.y = 0;
                } else {
                    delta.y = this.snap(delta.y / s) * s - ty;
                }
            }
        } else {
            const tol = 0.5 * s;
            if (!ignoreHorizontal) {
                const tx = bounds.x - (Math.round(bounds.x / s - t.x) + t.x) * s;
                if (Math.abs(delta.x - tx) < tol) {
                    delta.x = 0;
                } else {
                    delta.x = Math.round(delta.x / s) * s - tx;
                }
            }
            if (!ignoreVertical) {
                const ty = bounds.y - (Math.round(bounds.y / s - t.y) + t.y) * s;
                if (Math.abs(delta.y - ty) < tol) {
                    delta.y = 0;
                } else {
                    delta.y = Math.round(delta.y / s) * s - ty;
                }
            }
        }
        return delta;
    },
    isGridEnabled () {
        return this.gridEnabled;
    },
    setGridEnabled (value) {
        this.gridEnabled = value;
    },
    getGridSize () {
        return this.gridSize;
    },
    setGridSize (value) {
        this.gridSize = value;
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/SwimlaneMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "SwimlaneMixin": (()=>SwimlaneMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/mathUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/EventUtils.js [app-client] (ecmascript)");
;
;
;
;
;
const SwimlaneMixin = {
    swimlaneSelectionEnabled: true,
    swimlaneNesting: true,
    swimlaneIndicatorColorAttribute: 'fillColor',
    getSwimlane (cell = null) {
        while(cell && !this.isSwimlane(cell)){
            cell = cell.getParent();
        }
        return cell;
    },
    getSwimlaneAt (x, y, parent) {
        if (!parent) {
            parent = this.getCurrentRoot();
            if (!parent) {
                parent = this.getDataModel().getRoot();
            }
        }
        if (parent) {
            const childCount = parent.getChildCount();
            for(let i = 0; i < childCount; i += 1){
                const child = parent.getChildAt(i);
                if (child) {
                    const result = this.getSwimlaneAt(x, y, child);
                    if (result != null) {
                        return result;
                    }
                    if (child.isVisible() && this.isSwimlane(child)) {
                        const state = this.getView().getState(child);
                        if (state && this.intersects(state, x, y)) {
                            return child;
                        }
                    }
                }
            }
        }
        return null;
    },
    hitsSwimlaneContent (swimlane, x, y) {
        const state = this.getView().getState(swimlane);
        const size = this.getStartSize(swimlane);
        if (state) {
            const scale = this.getView().getScale();
            x -= state.x;
            y -= state.y;
            if (size.width > 0 && x > 0 && x > size.width * scale) {
                return true;
            }
            if (size.height > 0 && y > 0 && y > size.height * scale) {
                return true;
            }
        }
        return false;
    },
    getStartSize (swimlane, ignoreState = false) {
        const result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        const style = this.getCurrentCellStyle(swimlane, ignoreState);
        const size = style.startSize ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_STARTSIZE"];
        if (style.horizontal ?? true) {
            result.height = size;
        } else {
            result.width = size;
        }
        return result;
    },
    getSwimlaneDirection (style) {
        const dir = style.direction ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST;
        const flipH = style.flipH;
        const flipV = style.flipV;
        const h = style.horizontal ?? true;
        let n = h ? 0 : 3;
        if (dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH) {
            n--;
        } else if (dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST) {
            n += 2;
        } else if (dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) {
            n += 1;
        }
        const _mod = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mod"])(n, 2);
        if (flipH && _mod === 1) {
            n += 2;
        }
        if (flipV && _mod === 0) {
            n += 2;
        }
        return [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].EAST,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST
        ][(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$mathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mod"])(n, 4)];
    },
    getActualStartSize (swimlane, ignoreState = false) {
        const result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        if (this.isSwimlane(swimlane, ignoreState)) {
            const style = this.getCurrentCellStyle(swimlane, ignoreState);
            const size = style.startSize ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_STARTSIZE"];
            const dir = this.getSwimlaneDirection(style);
            if (dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].NORTH) {
                result.y = size;
            } else if (dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].WEST) {
                result.x = size;
            } else if (dir === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIRECTION"].SOUTH) {
                result.height = size;
            } else {
                result.width = size;
            }
        }
        return result;
    },
    isSwimlane (cell, ignoreState = false) {
        if (cell && cell.getParent() !== this.getDataModel().getRoot() && !cell.isEdge()) {
            return this.getCurrentCellStyle(cell, ignoreState).shape === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHAPE"].SWIMLANE;
        }
        return false;
    },
    isValidDropTarget (cell, cells, evt) {
        return cell && (this.isSplitEnabled() && this.isSplitTarget(cell, cells, evt) || !cell.isEdge() && (this.isSwimlane(cell) || cell.getChildCount() > 0 && !cell.isCollapsed()));
    },
    getDropTarget (cells, evt, cell = null, clone = false) {
        if (!this.isSwimlaneNesting()) {
            for(let i = 0; i < cells.length; i += 1){
                if (this.isSwimlane(cells[i])) {
                    return null;
                }
            }
        }
        const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertPoint"])(this.getContainer(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getClientX"])(evt), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$EventUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getClientY"])(evt));
        pt.x -= this.getPanDx();
        pt.y -= this.getPanDy();
        const swimlane = this.getSwimlaneAt(pt.x, pt.y);
        if (!cell) {
            cell = swimlane;
        } else if (swimlane) {
            // Checks if the cell is an ancestor of the swimlane
            // under the mouse and uses the swimlane in that case
            let tmp = swimlane.getParent();
            while(tmp && this.isSwimlane(tmp) && tmp !== cell){
                tmp = tmp.getParent();
            }
            if (tmp === cell) {
                cell = swimlane;
            }
        }
        while(cell && !this.isValidDropTarget(cell, cells, evt) && !this.getDataModel().isLayer(cell)){
            cell = cell.getParent();
        }
        // Checks if parent is dropped into child if not cloning
        let parentCell = cell;
        if (!clone) {
            while(parentCell && cells.indexOf(parentCell) < 0){
                parentCell = parentCell.getParent();
            }
        }
        return !this.getDataModel().isLayer(cell) && !parentCell ? cell : null;
    },
    isSwimlaneNesting () {
        return this.swimlaneNesting;
    },
    setSwimlaneNesting (value) {
        this.swimlaneNesting = value;
    },
    isSwimlaneSelectionEnabled () {
        return this.swimlaneSelectionEnabled;
    },
    setSwimlaneSelectionEnabled (value) {
        this.swimlaneSelectionEnabled = value;
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/TerminalMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "TerminalMixin": (()=>TerminalMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Dictionary.js [app-client] (ecmascript)");
;
const TerminalMixin = {
    isTerminalPointMovable (cell, source) {
        return true;
    },
    getOpposites (edges, terminal = null, includeSources = true, includeTargets = true) {
        const terminals = [];
        // Fast lookup to avoid duplicates in terminals array
        const dict = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Dictionary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        for(let i = 0; i < edges.length; i += 1){
            const state = this.getView().getState(edges[i]);
            const source = state ? state.getVisibleTerminal(true) : this.getView().getVisibleTerminal(edges[i], true);
            const target = state ? state.getVisibleTerminal(false) : this.getView().getVisibleTerminal(edges[i], false);
            // Checks if the terminal is the source of the edge and if the
            // target should be stored in the result
            if (source === terminal && target && target !== terminal && includeTargets) {
                if (!dict.get(target)) {
                    dict.put(target, true);
                    terminals.push(target);
                }
            } else if (target === terminal && source && source !== terminal && includeSources) {
                if (!dict.get(source)) {
                    dict.put(source, true);
                    terminals.push(source);
                }
            }
        }
        return terminals;
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/TooltipMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "TooltipMixin": (()=>TooltipMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/StringUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Translations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Translations.js [app-client] (ecmascript)");
;
;
const TooltipMixin = {
    getTooltip (state, node, x, y) {
        let tip = null;
        // Checks if the mouse is over the folding icon
        if (state.control && (node === state.control.node || node.parentNode === state.control.node)) {
            tip = this.getCollapseExpandResource();
            tip = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$StringUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["htmlEntities"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Translations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].get(tip) || tip, true).replace(/\\n/g, '<br>');
        }
        if (!tip && state.overlays) {
            state.overlays.visit((id, shape)=>{
                // LATER: Exit loop if tip is not null
                if (!tip && (node === shape.node || node.parentNode === shape.node)) {
                    tip = shape.overlay ? shape.overlay.toString() ?? null : null;
                }
            });
        }
        if (!tip) {
            const selectionCellsHandler = this.getPlugin('SelectionCellsHandler');
            const handler = selectionCellsHandler?.getHandler(state.cell);
            if (handler && 'getTooltipForNode' in handler && typeof handler.getTooltipForNode === 'function') {
                tip = handler.getTooltipForNode(node);
            }
        }
        if (!tip) {
            tip = this.getTooltipForCell(state.cell);
        }
        return tip;
    },
    getTooltipForCell (cell) {
        let tip = null;
        if (cell && 'getTooltip' in cell) {
            // @ts-ignore getTooltip() must exists.
            tip = cell.getTooltip();
        } else {
            tip = this.convertValueToString(cell);
        }
        return tip;
    },
    setTooltips (enabled) {
        const tooltipHandler = this.getPlugin('TooltipHandler');
        tooltipHandler?.setEnabled(enabled);
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/ValidationMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "ValidationMixin": (()=>ValidationMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Translations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Translations.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/domUtils.js [app-client] (ecmascript)");
;
;
const ValidationMixin = {
    validationAlert (message) {
        alert(message);
    },
    isEdgeValid (edge, source, target) {
        return !this.getEdgeValidationError(edge, source, target);
    },
    getEdgeValidationError (edge = null, source = null, target = null) {
        if (edge && !this.isAllowDanglingEdges() && (!source || !target)) {
            return '';
        }
        if (edge && !edge.getTerminal(true) && !edge.getTerminal(false)) {
            return null;
        }
        // Checks if we're dealing with a loop
        if (!this.isAllowLoops() && source === target && source) {
            return '';
        }
        // Checks if the connection is generally allowed
        if (!this.isValidConnection(source, target)) {
            return '';
        }
        if (source && target) {
            let error = '';
            // Checks if the cells are already connected
            // and adds an error message if required
            if (!this.isMultigraph()) {
                const tmp = this.getDataModel().getEdgesBetween(source, target, true);
                // Checks if the source and target are not connected by another edge
                if (tmp.length > 1 || tmp.length === 1 && tmp[0] !== edge) {
                    error += `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Translations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].get(this.getAlreadyConnectedResource()) || this.getAlreadyConnectedResource()}\n`;
                }
            }
            // Gets the number of outgoing edges from the source
            // and the number of incoming edges from the target
            // without counting the edge being currently changed.
            const sourceOut = source.getDirectedEdgeCount(true, edge);
            const targetIn = target.getDirectedEdgeCount(false, edge);
            // Checks the change against each multiplicity rule
            for (const multiplicity of this.multiplicities){
                const err = multiplicity.check(this, edge, source, target, sourceOut, targetIn);
                if (err != null) {
                    error += err;
                }
            }
            // Validates the source and target terminals independently
            const err = this.validateEdge(edge, source, target);
            if (err != null) {
                error += err;
            }
            return error.length > 0 ? error : null;
        }
        return this.isAllowDanglingEdges() ? null : '';
    },
    validateEdge (edge = null, source = null, target = null) {
        return null;
    },
    validateGraph (cell = null, context) {
        cell = cell ?? this.getDataModel().getRoot();
        if (!cell) {
            return 'The root does not exist!';
        }
        context = context ?? {};
        let isValid = true;
        const childCount = cell.getChildCount();
        for(let i = 0; i < childCount; i += 1){
            const tmp = cell.getChildAt(i);
            let ctx = context;
            if (this.isValidRoot(tmp)) {
                ctx = {};
            }
            const warn = this.validateGraph(tmp, ctx);
            if (warn) {
                this.setCellWarning(tmp, warn.replace(/\n/g, '<br>'));
            } else {
                this.setCellWarning(tmp, null);
            }
            isValid = isValid && warn == null;
        }
        let warning = '';
        // Adds error for invalid children if collapsed (children invisible)
        if (cell && cell.isCollapsed() && !isValid) {
            warning += `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Translations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].get(this.getContainsValidationErrorsResource()) || this.getContainsValidationErrorsResource()}\n`;
        }
        // Checks edges and cells using the defined multiplicities
        if (cell && cell.isEdge()) {
            warning += this.getEdgeValidationError(cell, cell.getTerminal(true), cell.getTerminal(false)) || '';
        } else {
            warning += this.getCellValidationError(cell) || '';
        }
        // Checks custom validation rules
        const err = this.validateCell(cell, context);
        if (err != null) {
            warning += err;
        }
        // Updates the display with the warning icons
        // before any potential alerts are displayed.
        // LATER: Move this into addCellOverlay. Redraw
        // should check if overlay was added or removed.
        if (cell.getParent() == null) {
            this.getView().validate();
        }
        return warning.length > 0 || !isValid ? warning : null;
    },
    getCellValidationError (cell) {
        const outCount = cell.getDirectedEdgeCount(true);
        const inCount = cell.getDirectedEdgeCount(false);
        const value = cell.getValue();
        let error = '';
        for(let i = 0; i < this.multiplicities.length; i += 1){
            const rule = this.multiplicities[i];
            if (rule.source && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(value, rule.type, rule.attr, rule.value) && (outCount > rule.max || outCount < rule.min)) {
                error += `${rule.countError}\n`;
            } else if (!rule.source && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$domUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(value, rule.type, rule.attr, rule.value) && (inCount > rule.max || inCount < rule.min)) {
                error += `${rule.countError}\n`;
            }
        }
        return error.length > 0 ? error : null;
    },
    validateCell (cell, context) {
        return null;
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/VertexMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "VertexMixin": (()=>VertexMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/cell/Cell.js [app-client] (ecmascript)");
;
;
const VertexMixin = {
    vertexLabelsMovable: false,
    allowNegativeCoordinates: true,
    isAllowNegativeCoordinates () {
        return this.allowNegativeCoordinates;
    },
    setAllowNegativeCoordinates (value) {
        this.allowNegativeCoordinates = value;
    },
    insertVertex (...args) {
        let parent;
        let id;
        let value;
        let x;
        let y;
        let width;
        let height;
        let style;
        let relative;
        let geometryClass;
        if (args.length === 1 && typeof args[0] === 'object') {
            const params = args[0];
            parent = params.parent;
            id = params.id;
            value = params.value;
            x = 'x' in params ? params.x : params.position?.[0];
            y = 'y' in params ? params.y : params.position?.[1];
            width = 'width' in params ? params.width : params.size?.[0];
            height = 'height' in params ? params.height : params.size?.[1];
            style = params.style;
            relative = params.relative;
            geometryClass = params.geometryClass;
        } else {
            // Otherwise treat as arguments
            [parent, id, value, x, y, width, height, style, relative, geometryClass] = args;
        }
        const vertex = this.createVertex(parent, id, value, x, y, width, height, style, relative, geometryClass);
        return this.addCell(vertex, parent);
    },
    createVertex (_parent, id, value, x, y, width, height, style, relative = false, geometryClass = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
        // Creates the geometry for the vertex
        const geometry = new geometryClass(x, y, width, height);
        geometry.relative = relative;
        // Creates the vertex
        const vertex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$cell$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](value, geometry, style);
        vertex.setId(id);
        vertex.setVertex(true);
        vertex.setConnectable(true);
        return vertex;
    },
    getChildVertices (parent) {
        return this.getChildCells(parent, true, false);
    },
    isVertexLabelsMovable () {
        return this.vertexLabelsMovable;
    },
    setVertexLabelsMovable (value) {
        this.vertexLabelsMovable = value;
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/ZoomMixin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2021-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "ZoomMixin": (()=>ZoomMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/styleUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js [app-client] (ecmascript)");
;
;
const ZoomMixin = {
    zoomFactor: 1.2,
    keepSelectionVisibleOnZoom: false,
    centerZoom: true,
    zoomIn () {
        this.zoom(this.zoomFactor);
    },
    zoomOut () {
        this.zoom(1 / this.zoomFactor);
    },
    zoomActual () {
        if (this.getView().scale === 1) {
            this.getView().setTranslate(0, 0);
        } else {
            this.getView().translate.x = 0;
            this.getView().translate.y = 0;
            this.getView().setScale(1);
        }
    },
    zoomTo (scale, center = false) {
        this.zoom(scale / this.getView().scale, center);
    },
    zoom (factor, center) {
        center = center ?? this.centerZoom;
        const scale = Math.round(this.getView().scale * factor * 100) / 100;
        const state = this.getView().getState(this.getSelectionCell());
        const container = this.getContainer();
        factor = scale / this.getView().scale;
        if (this.keepSelectionVisibleOnZoom && state != null) {
            const rect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$geometry$2f$Rectangle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](state.x * factor, state.y * factor, state.width * factor, state.height * factor);
            // Refreshes the display only once if a scroll is carried out
            this.getView().scale = scale;
            if (!this.scrollRectToVisible(rect)) {
                this.getView().revalidate();
                // Forces an event to be fired but does not revalidate again
                this.getView().setScale(scale);
            }
        } else {
            const _hasScrollbars = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasScrollbars"])(this.getContainer());
            if (center && !_hasScrollbars) {
                let dx = container.offsetWidth;
                let dy = container.offsetHeight;
                if (factor > 1) {
                    const f = (factor - 1) / (scale * 2);
                    dx *= -f;
                    dy *= -f;
                } else {
                    const f = (1 / factor - 1) / (this.getView().scale * 2);
                    dx *= f;
                    dy *= f;
                }
                this.getView().scaleAndTranslate(scale, this.getView().translate.x + dx, this.getView().translate.y + dy);
            } else {
                // Allows for changes of translate and scrollbars during setscale
                const tx = this.getView().translate.x;
                const ty = this.getView().translate.y;
                const sl = container.scrollLeft;
                const st = container.scrollTop;
                this.getView().setScale(scale);
                if (_hasScrollbars) {
                    let dx = 0;
                    let dy = 0;
                    if (center) {
                        dx = container.offsetWidth * (factor - 1) / 2;
                        dy = container.offsetHeight * (factor - 1) / 2;
                    }
                    container.scrollLeft = (this.getView().translate.x - tx) * this.getView().scale + Math.round(sl * factor + dx);
                    container.scrollTop = (this.getView().translate.y - ty) * this.getView().scale + Math.round(st * factor + dy);
                }
            }
        }
    },
    zoomToRect (rect) {
        const container = this.getContainer();
        const scaleX = container.clientWidth / rect.width;
        const scaleY = container.clientHeight / rect.height;
        const aspectFactor = scaleX / scaleY;
        // Remove any overlap of the rect outside the client area
        rect.x = Math.max(0, rect.x);
        rect.y = Math.max(0, rect.y);
        let rectRight = Math.min(container.scrollWidth, rect.x + rect.width);
        let rectBottom = Math.min(container.scrollHeight, rect.y + rect.height);
        rect.width = rectRight - rect.x;
        rect.height = rectBottom - rect.y;
        // The selection area has to be increased to the same aspect
        // ratio as the container, centred around the centre point of the
        // original rect passed in.
        if (aspectFactor < 1.0) {
            // Height needs increasing
            const newHeight = rect.height / aspectFactor;
            const deltaHeightBuffer = (newHeight - rect.height) / 2.0;
            rect.height = newHeight;
            // Assign up to half the buffer to the upper part of the rect, not crossing 0
            // put the rest on the bottom
            const upperBuffer = Math.min(rect.y, deltaHeightBuffer);
            rect.y -= upperBuffer;
            // Check if the bottom has extended too far
            rectBottom = Math.min(container.scrollHeight, rect.y + rect.height);
            rect.height = rectBottom - rect.y;
        } else {
            // Width needs increasing
            const newWidth = rect.width * aspectFactor;
            const deltaWidthBuffer = (newWidth - rect.width) / 2.0;
            rect.width = newWidth;
            // Assign up to half the buffer to the upper part of the rect, not crossing 0
            // put the rest on the bottom
            const leftBuffer = Math.min(rect.x, deltaWidthBuffer);
            rect.x -= leftBuffer;
            // Check if the right hand side has extended too far
            rectRight = Math.min(container.scrollWidth, rect.x + rect.width);
            rect.width = rectRight - rect.x;
        }
        const scale = container.clientWidth / rect.width;
        const newScale = this.getView().scale * scale;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$styleUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasScrollbars"])(this.getContainer())) {
            this.getView().scaleAndTranslate(newScale, this.getView().translate.x - rect.x / this.getView().scale, this.getView().translate.y - rect.y / this.getView().scale);
        } else {
            this.getView().setScale(newScale);
            container.scrollLeft = Math.round(rect.x * scale);
            container.scrollTop = Math.round(rect.y * scale);
        }
    }
};
}}),
"[project]/node_modules/@maxgraph/core/lib/view/mixins/_graph-mixins-apply.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
Copyright 2024-present The maxGraph project Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/ __turbopack_esm__({
    "applyGraphMixins": (()=>applyGraphMixins)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/util/Utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$Graph$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/Graph.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$CellsMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/CellsMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$ConnectionsMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/ConnectionsMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$DragDropMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/DragDropMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$EdgeMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/EdgeMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$EditingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/EditingMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$EventsMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/EventsMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$FoldingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/FoldingMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$GroupingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/GroupingMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$ImageMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/ImageMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$LabelMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/LabelMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$OrderMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/OrderMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$PageBreaksMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/PageBreaksMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$OverlaysMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/OverlaysMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$PanningMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/PanningMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$PortsMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/PortsMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$SelectionMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/SelectionMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$SnapMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/SnapMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$SwimlaneMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/SwimlaneMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$TerminalMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/TerminalMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$TooltipMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/TooltipMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$ValidationMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/ValidationMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$VertexMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/VertexMixin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$ZoomMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@maxgraph/core/lib/view/mixins/ZoomMixin.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const applyGraphMixins = ()=>{
    const mixIntoGraph = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$util$2f$Utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mixInto"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$Graph$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Graph"]);
    // Apply the mixins in alphabetic order to ease maintenance.
    // The order should have no influence of the resulting Graph prototype.
    for (const mixin of [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$CellsMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellsMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$ConnectionsMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConnectionsMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$DragDropMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DragDropMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$EdgeMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EdgeMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$EditingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EditingMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$EventsMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventsMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$FoldingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FoldingMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$GroupingMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GroupingMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$ImageMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ImageMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$LabelMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LabelMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$OrderMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OrderMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$PageBreaksMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PageBreaksMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$OverlaysMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OverlaysMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$PanningMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PanningMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$PortsMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PortsMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$SelectionMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SelectionMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$SnapMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SnapMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$SwimlaneMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SwimlaneMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$TerminalMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TerminalMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$TooltipMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TooltipMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$ValidationMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ValidationMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$VertexMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexMixin"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$maxgraph$2f$core$2f$lib$2f$view$2f$mixins$2f$ZoomMixin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZoomMixin"]
    ]){
        mixIntoGraph(mixin);
    }
};
}}),
}]);

//# sourceMappingURL=node_modules_%40maxgraph_core_lib_view_mixins_aaa504._.js.map