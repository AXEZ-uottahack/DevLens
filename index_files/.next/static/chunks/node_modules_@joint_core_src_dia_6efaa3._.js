(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@joint_core_src_dia_6efaa3._.js", {

"[project]/node_modules/@joint/core/src/dia/index.mjs [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
;
;
;
;
;
;
;
;
;
;
;
;
}}),
"[project]/node_modules/@joint/core/src/dia/index.mjs [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/index.mjs [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@joint/core/src/dia/attributes/props.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/utilHelpers.mjs [app-client] (ecmascript)");
;
const validPropertiesList = [
    'checked',
    'selected',
    'disabled',
    'readOnly',
    'contentEditable',
    'value',
    'indeterminate'
];
const validProperties = validPropertiesList.reduce((acc, key)=>{
    acc[key] = true;
    return acc;
}, {});
const props = {
    qualify: function(properties) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(properties);
    },
    set: function(properties, _, node) {
        Object.keys(properties).forEach(function(key) {
            if (validProperties[key] && key in node) {
                const value = properties[key];
                if (node.tagName === 'SELECT' && Array.isArray(value)) {
                    Array.from(node.options).forEach(function(option, index) {
                        option.selected = value.includes(option.value);
                    });
                } else {
                    node[key] = value;
                }
            }
        });
    }
};
const __TURBOPACK__default__export__ = props;
}}),
"[project]/node_modules/@joint/core/src/dia/attributes/legacy.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/util.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/point.mjs [app-client] (ecmascript)");
;
;
function positionWrapper(axis, dimension, origin) {
    return function(value, refBBox) {
        var valuePercentage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isPercentage"])(value);
        value = parseFloat(value);
        if (valuePercentage) {
            value /= 100;
        }
        var delta;
        if (isFinite(value)) {
            var refOrigin = refBBox[origin]();
            if (valuePercentage || value > 0 && value < 1) {
                delta = refOrigin[axis] + refBBox[dimension] * value;
            } else {
                delta = refOrigin[axis] + value;
            }
        }
        var point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"])();
        point[axis] = delta || 0;
        return point;
    };
}
function setWrapper(attrName, dimension) {
    return function(value, refBBox) {
        var isValuePercentage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isPercentage"])(value);
        value = parseFloat(value);
        if (isValuePercentage) {
            value /= 100;
        }
        var attrs = {};
        if (isFinite(value)) {
            var attrValue = isValuePercentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);
            attrs[attrName] = attrValue;
        }
        return attrs;
    };
}
const legacyAttributesNS = {
    // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width
    // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box
    // otherwise, `refX` is the left coordinate of the bounding box
    'ref-x': {
        position: positionWrapper('x', 'width', 'origin')
    },
    'ref-y': {
        position: positionWrapper('y', 'height', 'origin')
    },
    // `ref-dx` and `ref-dy` define the offset of the sub-element relative to the right and/or bottom
    // coordinate of the reference element.
    'ref-dx': {
        position: positionWrapper('x', 'width', 'corner')
    },
    'ref-dy': {
        position: positionWrapper('y', 'height', 'corner')
    },
    // 'ref-width'/'ref-height' defines the width/height of the sub-element relatively to
    // the reference element size
    // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width
    // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20
    'ref-width': {
        set: setWrapper('width', 'width')
    },
    'ref-height': {
        set: setWrapper('height', 'height')
    },
    'ref-rx': {
        set: setWrapper('rx', 'width')
    },
    'ref-ry': {
        set: setWrapper('ry', 'height')
    },
    'ref-cx': {
        set: setWrapper('cx', 'width')
    },
    'ref-cy': {
        set: setWrapper('cy', 'height')
    },
    'ref-r-inscribed': {
        set: function(attrName) {
            var widthFn = setWrapper(attrName, 'width');
            var heightFn = setWrapper(attrName, 'height');
            return function(value, refBBox) {
                var fn = refBBox.height > refBBox.width ? widthFn : heightFn;
                return fn(value, refBBox);
            };
        }('r')
    },
    'ref-r-circumscribed': {
        set: function(value, refBBox) {
            var isValuePercentage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isPercentage"])(value);
            value = parseFloat(value);
            if (isValuePercentage) {
                value /= 100;
            }
            var diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);
            var rValue;
            if (isFinite(value)) {
                if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;
                else rValue = Math.max(value + diagonalLength, 0);
            }
            return {
                r: rValue
            };
        }
    }
};
// NOTE: refX & refY are SVG attributes that define the reference point of the marker.
// That's why we need to define both variants: `refX` and `ref-x` (and `refY` and `ref-y`).
legacyAttributesNS['refX'] = legacyAttributesNS['ref-x'];
legacyAttributesNS['refY'] = legacyAttributesNS['ref-y'];
// This allows to combine both absolute and relative positioning
// refX: 50%, refX2: 20
legacyAttributesNS['ref-x2'] = legacyAttributesNS['ref-x'];
legacyAttributesNS['ref-y2'] = legacyAttributesNS['ref-y'];
legacyAttributesNS['ref-width2'] = legacyAttributesNS['ref-width'];
legacyAttributesNS['ref-height2'] = legacyAttributesNS['ref-height'];
// Aliases
legacyAttributesNS['ref-r'] = legacyAttributesNS['ref-r-inscribed'];
const __TURBOPACK__default__export__ = legacyAttributesNS;
}}),
"[project]/node_modules/@joint/core/src/dia/attributes/text.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/utilHelpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/mvc/Dom/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/V/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/util.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$calc$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/calc.mjs [app-client] (ecmascript)");
;
;
;
;
function isTextInUse(_value, _node, attrs) {
    return attrs.text !== undefined;
}
const FONT_ATTRIBUTES = [
    'font-weight',
    'font-family',
    'font-size',
    'letter-spacing',
    'text-transform'
];
const textAttributesNS = {
    'line-height': {
        qualify: isTextInUse
    },
    'text-vertical-anchor': {
        qualify: isTextInUse
    },
    'text-path': {
        qualify: isTextInUse
    },
    'annotations': {
        qualify: isTextInUse
    },
    'eol': {
        qualify: isTextInUse
    },
    'display-empty': {
        qualify: isTextInUse
    },
    'text': {
        qualify: function(_text, _node, attrs) {
            const textWrap = attrs['text-wrap'];
            return !textWrap || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(textWrap);
        },
        unset: function(node) {
            node.textContent = '';
        },
        set: function(text, refBBox, node, attrs) {
            const cacheName = 'joint-text';
            const cache = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].data.get(node, cacheName);
            const lineHeight = attrs['line-height'];
            const textVerticalAnchor = attrs['text-vertical-anchor'];
            const displayEmpty = attrs['display-empty'];
            const fontSize = attrs['font-size'];
            const annotations = attrs.annotations;
            const eol = attrs.eol;
            const x = attrs.x;
            let textPath = attrs['text-path'];
            // Update the text only if there was a change in the string
            // or any of its attributes.
            const textHash = JSON.stringify([
                text,
                lineHeight,
                annotations,
                textVerticalAnchor,
                eol,
                displayEmpty,
                textPath,
                x,
                fontSize
            ]);
            if (cache === undefined || cache !== textHash) {
                // Chrome bug:
                // <tspan> positions defined as `em` are not updated
                // when container `font-size` change.
                if (fontSize) node.setAttribute('font-size', fontSize);
                // Text Along Path Selector
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(textPath)) {
                    const pathSelector = textPath.selector;
                    if (typeof pathSelector === 'string') {
                        const pathNode = this.findNode(pathSelector);
                        if (pathNode instanceof SVGPathElement) {
                            textPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])({
                                'xlink:href': '#' + pathNode.id
                            }, textPath);
                        }
                    }
                }
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(node).text('' + text, {
                    lineHeight,
                    annotations,
                    textPath,
                    x,
                    textVerticalAnchor,
                    eol,
                    displayEmpty
                });
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].data.set(node, cacheName, textHash);
            }
        }
    },
    'text-wrap': {
        qualify: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"],
        set: function(value, refBBox, node, attrs) {
            var size = {};
            // option `width`
            var width = value.width || 0;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isPercentage"])(width)) {
                size.width = refBBox.width * parseFloat(width) / 100;
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$calc$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isCalcExpression"])(width)) {
                size.width = Number((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$calc$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["evalCalcExpression"])(width, refBBox));
            } else {
                if (value.width === null) {
                    // breakText() requires width to be specified.
                    size.width = Infinity;
                } else if (width <= 0) {
                    size.width = refBBox.width + width;
                } else {
                    size.width = width;
                }
            }
            // option `height`
            var height = value.height || 0;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isPercentage"])(height)) {
                size.height = refBBox.height * parseFloat(height) / 100;
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$calc$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isCalcExpression"])(height)) {
                size.height = Number((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$calc$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["evalCalcExpression"])(height, refBBox));
            } else {
                if (value.height === null) {
                // if height is not specified breakText() does not
                // restrict the height of the text.
                } else if (height <= 0) {
                    size.height = refBBox.height + height;
                } else {
                    size.height = height;
                }
            }
            // option `text`
            var wrappedText;
            var text = value.text;
            if (text === undefined) text = attrs.text;
            if (text !== undefined) {
                const breakTextFn = value.breakText || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["breakText"];
                const computedStyles = getComputedStyle(node);
                const wrapFontAttributes = {};
                // The font size attributes must be set on the node
                // to get the correct text wrapping.
                // TODO: set the native SVG attributes before special attributes
                for(let i = 0; i < FONT_ATTRIBUTES.length; i++){
                    const name = FONT_ATTRIBUTES[i];
                    if (name in attrs) {
                        node.setAttribute(name, attrs[name]);
                    }
                    // Note: computedStyles is a live object
                    // i.e. the properties are evaluated when accessed.
                    wrapFontAttributes[name] = computedStyles[name];
                }
                // The `line-height` attribute in SVG is JoinJS specific.
                // TODO: change the `lineHeight` to breakText option.
                wrapFontAttributes.lineHeight = attrs['line-height'];
                wrappedText = breakTextFn('' + text, size, wrapFontAttributes, {
                    // Provide an existing SVG Document here
                    // instead of creating a temporary one over again.
                    svgDocument: this.paper.svg,
                    ellipsis: value.ellipsis,
                    hyphen: value.hyphen,
                    separator: value.separator,
                    maxLineCount: value.maxLineCount,
                    preserveSpaces: value.preserveSpaces
                });
            } else {
                wrappedText = '';
            }
            textAttributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);
        },
        // We expose the font attributes list to allow
        // the user to take other custom font attributes into account
        // when wrapping the text.
        FONT_ATTRIBUTES
    },
    'title': {
        qualify: function(title, node) {
            // HTMLElement title is specified via an attribute (i.e. not an element)
            return node instanceof SVGElement;
        },
        unset: function(node) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].data.remove(node, 'joint-title');
            const titleNode = node.firstElementChild;
            if (titleNode) {
                titleNode.remove();
            }
        },
        set: function(title, refBBox, node) {
            var cacheName = 'joint-title';
            var cache = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].data.get(node, cacheName);
            if (cache === undefined || cache !== title) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].data.set(node, cacheName, title);
                if (node.tagName === 'title') {
                    // The target node is a <title> element.
                    node.textContent = title;
                    return;
                }
                // Generally <title> element should be the first child element of its parent.
                var firstChild = node.firstElementChild;
                if (firstChild && firstChild.tagName === 'title') {
                    // Update an existing title
                    firstChild.textContent = title;
                } else {
                    // Create a new title
                    var titleNode = document.createElementNS(node.namespaceURI, 'title');
                    titleNode.textContent = title;
                    node.insertBefore(titleNode, firstChild);
                }
            }
        }
    }
};
const __TURBOPACK__default__export__ = textAttributesNS;
}}),
"[project]/node_modules/@joint/core/src/dia/attributes/connection.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/point.mjs [app-client] (ecmascript)");
;
function atConnectionWrapper(method, opt) {
    var zeroVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](1, 0);
    return function(value) {
        var p, angle;
        var tangent = this[method](value);
        if (tangent) {
            angle = opt.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;
            p = tangent.start;
        } else {
            p = this.path.start;
            angle = 0;
        }
        if (angle === 0) return {
            transform: 'translate(' + p.x + ',' + p.y + ')'
        };
        return {
            transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')'
        };
    };
}
function isLinkView() {
    return this.model.isLink();
}
const connectionAttributesNS = {
    'connection': {
        qualify: isLinkView,
        unset: 'd',
        set: function({ stubs = 0 }) {
            let d;
            if (isFinite(stubs) && stubs !== 0) {
                let offset;
                if (stubs < 0) {
                    offset = (this.getConnectionLength() + stubs) / 2;
                } else {
                    offset = stubs;
                }
                const path = this.getConnection();
                const segmentSubdivisions = this.getConnectionSubdivisions();
                const sourceParts = path.divideAtLength(offset, {
                    segmentSubdivisions
                });
                const targetParts = path.divideAtLength(-offset, {
                    segmentSubdivisions
                });
                if (sourceParts && targetParts) {
                    d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;
                }
            }
            return {
                d: d || this.getSerializedConnection()
            };
        }
    },
    'at-connection-length-keep-gradient': {
        qualify: isLinkView,
        unset: 'transform',
        set: atConnectionWrapper('getTangentAtLength', {
            rotate: true
        })
    },
    'at-connection-length-ignore-gradient': {
        qualify: isLinkView,
        unset: 'transform',
        set: atConnectionWrapper('getTangentAtLength', {
            rotate: false
        })
    },
    'at-connection-ratio-keep-gradient': {
        qualify: isLinkView,
        unset: 'transform',
        set: atConnectionWrapper('getTangentAtRatio', {
            rotate: true
        })
    },
    'at-connection-ratio-ignore-gradient': {
        qualify: isLinkView,
        unset: 'transform',
        set: atConnectionWrapper('getTangentAtRatio', {
            rotate: false
        })
    }
};
connectionAttributesNS['at-connection-length'] = connectionAttributesNS['at-connection-length-keep-gradient'];
connectionAttributesNS['at-connection-ratio'] = connectionAttributesNS['at-connection-ratio-keep-gradient'];
const __TURBOPACK__default__export__ = connectionAttributesNS;
}}),
"[project]/node_modules/@joint/core/src/dia/attributes/shape.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/mvc/Dom/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$path$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/path.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/V/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$polyline$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/polyline.mjs [app-client] (ecmascript)");
;
;
;
function shapeWrapper(shapeConstructor, opt) {
    var cacheName = 'joint-shape';
    var resetOffset = opt && opt.resetOffset;
    return function(value, refBBox, node) {
        var cache = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].data.get(node, cacheName);
        if (!cache || cache.value !== value) {
            // only recalculate if value has changed
            var cachedShape = shapeConstructor(value);
            cache = {
                value: value,
                shape: cachedShape,
                shapeBBox: cachedShape.bbox()
            };
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].data.set(node, cacheName, cache);
        }
        var shape = cache.shape.clone();
        var shapeBBox = cache.shapeBBox.clone();
        var shapeOrigin = shapeBBox.origin();
        var refOrigin = refBBox.origin();
        shapeBBox.x = refOrigin.x;
        shapeBBox.y = refOrigin.y;
        var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);
        // `maxRectScaleToFit` can give Infinity if width or height is 0
        var sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;
        var sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;
        shape.scale(sx, sy, shapeOrigin);
        if (resetOffset) {
            shape.translate(-shapeOrigin.x, -shapeOrigin.y);
        }
        return shape;
    };
}
// `d` attribute for SVGPaths
function dWrapper(opt) {
    function pathConstructor(value) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$path$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalizePathData(value));
    }
    var shape = shapeWrapper(pathConstructor, opt);
    return function(value, refBBox, node) {
        var path = shape(value, refBBox, node);
        return {
            d: path.serialize()
        };
    };
}
// `points` attribute for SVGPolylines and SVGPolygons
function pointsWrapper(opt) {
    var shape = shapeWrapper(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$polyline$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Polyline"], opt);
    return function(value, refBBox, node) {
        var polyline = shape(value, refBBox, node);
        return {
            points: polyline.serialize()
        };
    };
}
const shapeAttributesNS = {
    'ref-d-reset-offset': {
        unset: 'd',
        set: dWrapper({
            resetOffset: true
        })
    },
    'ref-d-keep-offset': {
        unset: 'd',
        set: dWrapper({
            resetOffset: false
        })
    },
    'ref-points-reset-offset': {
        unset: 'points',
        set: pointsWrapper({
            resetOffset: true
        })
    },
    'ref-points-keep-offset': {
        unset: 'points',
        set: pointsWrapper({
            resetOffset: false
        })
    }
};
// Aliases
shapeAttributesNS['ref-d'] = shapeAttributesNS['ref-d-reset-offset'];
shapeAttributesNS['ref-points'] = shapeAttributesNS['ref-points-reset-offset'];
const __TURBOPACK__default__export__ = shapeAttributesNS;
}}),
"[project]/node_modules/@joint/core/src/dia/attributes/defs.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/utilHelpers.mjs [app-client] (ecmascript)");
;
function contextMarker(context) {
    var marker = {};
    // Stroke
    // The context 'fill' is disregarded here. The usual case is to use the marker with a connection
    // (for which 'fill' attribute is set to 'none').
    var stroke = context.stroke;
    if (typeof stroke === 'string') {
        marker['stroke'] = stroke;
        marker['fill'] = stroke;
    }
    // Opacity
    // Again the context 'fill-opacity' is ignored.
    var strokeOpacity = context['stroke-opacity'];
    if (strokeOpacity === undefined) strokeOpacity = context.opacity;
    if (strokeOpacity !== undefined) {
        marker['stroke-opacity'] = strokeOpacity;
        marker['fill-opacity'] = strokeOpacity;
    }
    return marker;
}
function setPaintURL(def) {
    const { paper } = this;
    const url = def.type === 'pattern' ? paper.definePattern(def) : paper.defineGradient(def);
    return `url(#${url})`;
}
const defsAttributesNS = {
    'source-marker': {
        qualify: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"],
        unset: 'marker-start',
        set: function(marker, refBBox, node, attrs) {
            marker = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(contextMarker(attrs), marker);
            return {
                'marker-start': 'url(#' + this.paper.defineMarker(marker) + ')'
            };
        }
    },
    'target-marker': {
        qualify: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"],
        unset: 'marker-end',
        set: function(marker, refBBox, node, attrs) {
            marker = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(contextMarker(attrs), {
                'transform': 'rotate(180)'
            }, marker);
            return {
                'marker-end': 'url(#' + this.paper.defineMarker(marker) + ')'
            };
        }
    },
    'vertex-marker': {
        qualify: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"],
        unset: 'marker-mid',
        set: function(marker, refBBox, node, attrs) {
            marker = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(contextMarker(attrs), marker);
            return {
                'marker-mid': 'url(#' + this.paper.defineMarker(marker) + ')'
            };
        }
    },
    'fill': {
        qualify: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"],
        set: setPaintURL
    },
    'stroke': {
        qualify: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"],
        set: setPaintURL
    },
    'filter': {
        qualify: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"],
        set: function(filter) {
            return 'url(#' + this.paper.defineFilter(filter) + ')';
        }
    }
};
const __TURBOPACK__default__export__ = defsAttributesNS;
}}),
"[project]/node_modules/@joint/core/src/dia/attributes/offset.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// Offset attributes require the cell view to be rendered before they can be applied
// (they must be appended to the DOM).
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/util.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/point.mjs [app-client] (ecmascript)");
;
;
function offsetWrapper(axis, dimension, corner) {
    return function(value, nodeBBox) {
        var delta;
        if (value === 'middle') {
            delta = nodeBBox[dimension] / 2;
        } else if (value === corner) {
            delta = nodeBBox[dimension];
        } else if (isFinite(value)) {
            // TODO: or not to do a breaking change?
            delta = value > -1 && value < 1 ? -nodeBBox[dimension] * value : -value;
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isPercentage"])(value)) {
            delta = nodeBBox[dimension] * parseFloat(value) / 100;
        } else {
            delta = 0;
        }
        var point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]();
        point[axis] = -(nodeBBox[axis] + delta);
        return point;
    };
}
const offsetAttributesNS = {
    // `x-alignment` when set to `middle` causes centering of the sub-element around its new x coordinate.
    // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.
    'x-alignment': {
        offset: offsetWrapper('x', 'width', 'right')
    },
    // `y-alignment` when set to `middle` causes centering of the sub-element around its new y coordinate.
    // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.
    'y-alignment': {
        offset: offsetWrapper('y', 'height', 'bottom')
    },
    'reset-offset': {
        offset: function(val, nodeBBox) {
            return val ? {
                x: -nodeBBox.x,
                y: -nodeBBox.y
            } : {
                x: 0,
                y: 0
            };
        }
    }
};
const __TURBOPACK__default__export__ = offsetAttributesNS;
}}),
"[project]/node_modules/@joint/core/src/dia/attributes/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "attributes": (()=>attributes)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/utilHelpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/mvc/Dom/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$props$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/attributes/props.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$legacy$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/attributes/legacy.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$text$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/attributes/text.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$connection$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/attributes/connection.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$shape$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/attributes/shape.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$defs$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/attributes/defs.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$offset$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/attributes/offset.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/V/index.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
function setIfChangedWrapper(attribute) {
    return function setIfChanged(value, _, node) {
        const vel = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(node);
        if (vel.attr(attribute) === value) return;
        vel.attr(attribute, value);
    };
}
const attributesNS = {
    'ref': {
    },
    'href': {
        set: setIfChangedWrapper('href')
    },
    'xlink:href': {
        set: setIfChangedWrapper('xlink:href')
    },
    // `port` attribute contains the `id` of the port that the underlying magnet represents.
    'port': {
        set: function(port) {
            return port === null || port.id === undefined ? port : port.id;
        }
    },
    // `style` attribute is special in the sense that it sets the CSS style of the sub-element.
    'style': {
        qualify: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"],
        set: function(styles, refBBox, node) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(node).css(styles);
        }
    },
    'html': {
        unset: function(node) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(node).empty();
        },
        set: function(html, refBBox, node) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(node).html(html + '');
        }
    },
    // Properties setter (set various properties on the node)
    props: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$props$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
};
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(attributesNS, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$legacy$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(attributesNS, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$text$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(attributesNS, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$connection$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(attributesNS, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$shape$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(attributesNS, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$defs$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(attributesNS, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$offset$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
const attributes = attributesNS;
}}),
"[project]/node_modules/@joint/core/src/dia/Cell.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Cell": (()=>Cell)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Model$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/mvc/Model.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/utilHelpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/util.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$cloneCells$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/cloneCells.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/attributes/index.mjs [app-client] (ecmascript)");
;
;
;
;
;
// Cell base model.
// --------------------------
const attributesMerger = function(a, b) {
    if (Array.isArray(a)) {
        return b;
    }
};
function removeEmptyAttributes(obj) {
    // Remove toplevel empty attributes
    for(const key in obj){
        const objValue = obj[key];
        const isRealObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(objValue) && !Array.isArray(objValue);
        if (!isRealObject) continue;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmpty"])(objValue)) {
            delete obj[key];
        }
    }
}
const Cell = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Model$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Model"].extend({
    // This is the same as mvc.Model with the only difference that is uses util.merge
    // instead of just _.extend. The reason is that we want to mixin attributes set in upper classes.
    constructor: function(attributes, options) {
        var defaults;
        var attrs = attributes || {};
        if (typeof this.preinitialize === 'function') {
            // Check to support an older version
            this.preinitialize.apply(this, arguments);
        }
        this.cid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uniqueId"])('c');
        this.attributes = {};
        if (options && options.collection) this.collection = options.collection;
        if (options && options.parse) attrs = this.parse(attrs, options) || {};
        if (defaults = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["result"])(this, 'defaults')) {
            //<custom code>
            // Replaced the call to _.defaults with util.merge.
            const customizer = options && options.mergeArrays === true ? false : attributesMerger;
            attrs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])({}, defaults, attrs, customizer);
        //</custom code>
        }
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
    },
    translate: function(dx, dy, opt) {
        throw new Error('Must define a translate() method.');
    },
    toJSON: function(opt) {
        const { ignoreDefaults, ignoreEmptyAttributes = false } = opt || {};
        const defaults = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["result"])(this.constructor.prototype, 'defaults');
        if (ignoreDefaults === false) {
            // Return all attributes without omitting the defaults
            const finalAttributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneDeep"])(this.attributes);
            if (!ignoreEmptyAttributes) return finalAttributes;
            removeEmptyAttributes(finalAttributes);
            return finalAttributes;
        }
        let defaultAttributes = {};
        let attributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneDeep"])(this.attributes);
        if (ignoreDefaults === true) {
            // Compare all attributes with the defaults
            defaultAttributes = defaults;
        } else {
            // Compare only the specified attributes with the defaults, use `attrs` as a default if not specified
            const differentiateKeys = Array.isArray(ignoreDefaults) ? ignoreDefaults : [
                'attrs'
            ];
            differentiateKeys.forEach((key)=>{
                defaultAttributes[key] = defaults[key] || {};
            });
        }
        // Omit `id` and `type` attribute from the defaults since it should be always present
        const finalAttributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["objectDifference"])(attributes, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["omit"])(defaultAttributes, 'id', 'type'), {
            maxDepth: 4
        });
        if (ignoreEmptyAttributes) {
            removeEmptyAttributes(finalAttributes);
        }
        return finalAttributes;
    },
    initialize: function(options) {
        const idAttribute = this.getIdAttribute();
        if (!options || options[idAttribute] === undefined) {
            this.set(idAttribute, this.generateId(), {
                silent: true
            });
        }
        this._transitionIds = {};
        this._scheduledTransitionIds = {};
        // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.
        this.processPorts();
        this.on('change:attrs', this.processPorts, this);
    },
    getIdAttribute: function() {
        return this.idAttribute || 'id';
    },
    generateId: function() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["uuid"])();
    },
    /**
     * @deprecated
     */ processPorts: function() {
        // Whenever `attrs` changes, we extract ports from the `attrs` object and store it
        // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`
        // set to that port, we remove those links as well (to follow the same behaviour as
        // with a removed element).
        var previousPorts = this.ports;
        // Collect ports from the `attrs` object.
        var ports = {};
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forIn"])(this.get('attrs'), function(attrs, selector) {
            if (attrs && attrs.port) {
                // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).
                if (attrs.port.id !== undefined) {
                    ports[attrs.port.id] = attrs.port;
                } else {
                    ports[attrs.port] = {
                        id: attrs.port
                    };
                }
            }
        });
        // Collect ports that have been removed (compared to the previous ports) - if any.
        // Use hash table for quick lookup.
        var removedPorts = {};
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forIn"])(previousPorts, function(port, id) {
            if (!ports[id]) removedPorts[id] = true;
        });
        // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.
        if (this.graph && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmpty"])(removedPorts)) {
            var inboundLinks = this.graph.getConnectedLinks(this, {
                inbound: true
            });
            inboundLinks.forEach(function(link) {
                if (removedPorts[link.get('target').port]) link.remove();
            });
            var outboundLinks = this.graph.getConnectedLinks(this, {
                outbound: true
            });
            outboundLinks.forEach(function(link) {
                if (removedPorts[link.get('source').port]) link.remove();
            });
        }
        // Update the `ports` object.
        this.ports = ports;
    },
    remove: function(opt = {}) {
        // Store the graph in a variable because `this.graph` won't be accessible
        // after `this.trigger('remove', ...)` down below.
        const { graph, collection } = this;
        if (!graph) {
            // The collection is a common mvc collection (not the graph collection).
            if (collection) collection.remove(this, opt);
            return this;
        }
        graph.startBatch('remove');
        // First, unembed this cell from its parent cell if there is one.
        const parentCell = this.getParentCell();
        if (parentCell) {
            parentCell.unembed(this, opt);
        }
        // Remove also all the cells, which were embedded into this cell
        const embeddedCells = this.getEmbeddedCells();
        for(let i = 0, n = embeddedCells.length; i < n; i++){
            const embed = embeddedCells[i];
            if (embed) {
                embed.remove(opt);
            }
        }
        this.trigger('remove', this, graph.attributes.cells, opt);
        graph.stopBatch('remove');
        return this;
    },
    toFront: function(opt) {
        var graph = this.graph;
        if (graph) {
            opt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaults"])(opt || {}, {
                foregroundEmbeds: true
            });
            let cells;
            if (opt.deep) {
                cells = this.getEmbeddedCells({
                    deep: true,
                    breadthFirst: opt.breadthFirst !== false,
                    sortSiblings: opt.foregroundEmbeds
                });
                cells.unshift(this);
            } else {
                cells = [
                    this
                ];
            }
            const sortedCells = opt.foregroundEmbeds ? cells : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sortBy"])(cells, (cell)=>cell.z());
            const maxZ = graph.maxZIndex();
            let z = maxZ - cells.length + 1;
            const collection = graph.get('cells');
            let shouldUpdate = collection.toArray().indexOf(sortedCells[0]) !== collection.length - cells.length;
            if (!shouldUpdate) {
                shouldUpdate = sortedCells.some(function(cell, index) {
                    return cell.z() !== z + index;
                });
            }
            if (shouldUpdate) {
                this.startBatch('to-front');
                z = z + cells.length;
                sortedCells.forEach(function(cell, index) {
                    cell.set('z', z + index, opt);
                });
                this.stopBatch('to-front');
            }
        }
        return this;
    },
    toBack: function(opt) {
        var graph = this.graph;
        if (graph) {
            opt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaults"])(opt || {}, {
                foregroundEmbeds: true
            });
            let cells;
            if (opt.deep) {
                cells = this.getEmbeddedCells({
                    deep: true,
                    breadthFirst: opt.breadthFirst !== false,
                    sortSiblings: opt.foregroundEmbeds
                });
                cells.unshift(this);
            } else {
                cells = [
                    this
                ];
            }
            const sortedCells = opt.foregroundEmbeds ? cells : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sortBy"])(cells, (cell)=>cell.z());
            let z = graph.minZIndex();
            var collection = graph.get('cells');
            let shouldUpdate = collection.toArray().indexOf(sortedCells[0]) !== 0;
            if (!shouldUpdate) {
                shouldUpdate = sortedCells.some(function(cell, index) {
                    return cell.z() !== z + index;
                });
            }
            if (shouldUpdate) {
                this.startBatch('to-back');
                z -= cells.length;
                sortedCells.forEach(function(cell, index) {
                    cell.set('z', z + index, opt);
                });
                this.stopBatch('to-back');
            }
        }
        return this;
    },
    parent: function(parent, opt) {
        // getter
        if (parent === undefined) return this.get('parent');
        // setter
        return this.set('parent', parent, opt);
    },
    embed: function(cell, opt = {}) {
        const cells = Array.isArray(cell) ? cell : [
            cell
        ];
        if (!this.canEmbed(cells)) {
            throw new Error('Recursive embedding not allowed.');
        }
        if (opt.reparent) {
            const parents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uniq"])(cells.map((c)=>c.getParentCell()));
            // Unembed cells from their current parents.
            parents.forEach((parent)=>{
                // Cell doesn't have to be embedded.
                if (!parent) return;
                // Pass all the `cells` since the `dia.Cell._unembedCells` method can handle cases
                // where not all elements of `cells` are embedded in the same parent.
                parent._unembedCells(cells, opt);
            });
        } else if (cells.some((c)=>c.isEmbedded() && this.id !== c.parent())) {
            throw new Error('Embedding of already embedded cells is not allowed.');
        }
        this._embedCells(cells, opt);
        return this;
    },
    unembed: function(cell, opt) {
        const cells = Array.isArray(cell) ? cell : [
            cell
        ];
        this._unembedCells(cells, opt);
        return this;
    },
    canEmbed: function(cell) {
        const cells = Array.isArray(cell) ? cell : [
            cell
        ];
        return cells.every((c)=>this !== c && !this.isEmbeddedIn(c));
    },
    _embedCells: function(cells, opt) {
        const batchName = 'embed';
        this.startBatch(batchName);
        const embeds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])([], this.get('embeds'));
        cells.forEach((cell)=>{
            // We keep all element ids after link ids.
            embeds[cell.isLink() ? 'unshift' : 'push'](cell.id);
            cell.parent(this.id, opt);
        });
        this.set('embeds', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uniq"])(embeds), opt);
        this.stopBatch(batchName);
    },
    _unembedCells: function(cells, opt) {
        const batchName = 'unembed';
        this.startBatch(batchName);
        cells.forEach((cell)=>cell.unset('parent', opt));
        this.set('embeds', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["without"])(this.get('embeds'), ...cells.map((cell)=>cell.id)), opt);
        this.stopBatch(batchName);
    },
    getParentCell: function() {
        // unlike link.source/target, cell.parent stores id directly as a string
        var parentId = this.parent();
        var graph = this.graph;
        return parentId && graph && graph.getCell(parentId) || null;
    },
    // Return an array of ancestor cells.
    // The array is ordered from the parent of the cell
    // to the most distant ancestor.
    getAncestors: function() {
        var ancestors = [];
        if (!this.graph) {
            return ancestors;
        }
        var parentCell = this.getParentCell();
        while(parentCell){
            ancestors.push(parentCell);
            parentCell = parentCell.getParentCell();
        }
        return ancestors;
    },
    getEmbeddedCells: function(opt) {
        opt = opt || {};
        // Cell models can only be retrieved when this element is part of a collection.
        // There is no way this element knows about other cells otherwise.
        // This also means that calling e.g. `translate()` on an element with embeds before
        // adding it to a graph does not translate its embeds.
        if (!this.graph) {
            return [];
        }
        if (opt.deep) {
            if (opt.breadthFirst) {
                return this._getEmbeddedCellsBfs(opt.sortSiblings);
            } else {
                return this._getEmbeddedCellsDfs(opt.sortSiblings);
            }
        }
        const embeddedIds = this.get('embeds');
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmpty"])(embeddedIds)) {
            return [];
        }
        let cells = embeddedIds.map(this.graph.getCell, this.graph);
        if (opt.sortSiblings) {
            cells = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sortBy"])(cells, (cell)=>cell.z());
        }
        return cells;
    },
    _getEmbeddedCellsBfs: function(sortSiblings) {
        const cells = [];
        const queue = [];
        queue.push(this);
        while(queue.length > 0){
            const current = queue.shift();
            cells.push(current);
            const embeddedCells = current.getEmbeddedCells({
                sortSiblings: sortSiblings
            });
            queue.push(...embeddedCells);
        }
        cells.shift();
        return cells;
    },
    _getEmbeddedCellsDfs: function(sortSiblings) {
        const cells = [];
        const stack = [];
        stack.push(this);
        while(stack.length > 0){
            const current = stack.pop();
            cells.push(current);
            const embeddedCells = current.getEmbeddedCells({
                sortSiblings: sortSiblings
            });
            // When using the stack, cells that are embedded last are processed first.
            // To maintain the original order, we need to push the cells in reverse order
            for(let i = embeddedCells.length - 1; i >= 0; --i){
                stack.push(embeddedCells[i]);
            }
        }
        cells.shift();
        return cells;
    },
    isEmbeddedIn: function(cell, opt) {
        var cellId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(cell) ? cell : cell.id;
        var parentId = this.parent();
        opt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])({
            deep: true
        }, opt);
        // See getEmbeddedCells().
        if (this.graph && opt.deep) {
            while(parentId){
                if (parentId === cellId) {
                    return true;
                }
                parentId = this.graph.getCell(parentId).parent();
            }
            return false;
        } else {
            // When this cell is not part of a collection check
            // at least whether it's a direct child of given cell.
            return parentId === cellId;
        }
    },
    // Whether or not the cell is embedded in any other cell.
    isEmbedded: function() {
        return !!this.parent();
    },
    // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).
    // Shallow cloning simply clones the cell and returns a new cell with different ID.
    // Deep cloning clones the cell and all its embedded cells recursively.
    clone: function(opt) {
        opt = opt || {};
        if (!opt.deep) {
            // Shallow cloning.
            var clone = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Model$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Model"].prototype.clone.apply(this, arguments);
            // We don't want the clone to have the same ID as the original.
            clone.set(this.getIdAttribute(), this.generateId());
            // A shallow cloned element does not carry over the original embeds.
            clone.unset('embeds');
            // And can not be embedded in any cell
            // as the clone is not part of the graph.
            clone.unset('parent');
            return clone;
        } else {
            // Deep cloning.
            // For a deep clone, simply call `graph.cloneCells()` with the cell and all its embedded cells.
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$cloneCells$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneCells"])([
                this
            ].concat(this.getEmbeddedCells({
                deep: true
            }))));
        }
    },
    // A convenient way to set nested properties.
    // This method merges the properties you'd like to set with the ones
    // stored in the cell and makes sure change events are properly triggered.
    // You can either set a nested property with one object
    // or use a property path.
    // The most simple use case is:
    // `cell.prop('name/first', 'John')` or
    // `cell.prop({ name: { first: 'John' } })`.
    // Nested arrays are supported too:
    // `cell.prop('series/0/data/0/degree', 50)` or
    // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.
    prop: function(props, value, opt) {
        var delim = '/';
        var _isString = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(props);
        if (_isString || Array.isArray(props)) {
            // Get/set an attribute by a special path syntax that delimits
            // nested objects by the colon character.
            if (arguments.length > 1) {
                var path;
                var pathArray;
                if (_isString) {
                    path = props;
                    pathArray = path.split('/');
                } else {
                    path = props.join(delim);
                    pathArray = props.slice();
                }
                var property = pathArray[0];
                var pathArrayLength = pathArray.length;
                const options = opt || {};
                options.propertyPath = path;
                options.propertyValue = value;
                options.propertyPathArray = pathArray;
                if (!('rewrite' in options)) {
                    options.rewrite = false;
                }
                var update = {};
                // Initialize the nested object. Sub-objects are either arrays or objects.
                // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.
                // Note that this imposes a limitation on object keys one can use with Inspector.
                // Pure integer keys will cause issues and are therefore not allowed.
                var initializer = update;
                var prevProperty = property;
                for(var i = 1; i < pathArrayLength; i++){
                    var pathItem = pathArray[i];
                    var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);
                    initializer = initializer[prevProperty] = isArrayIndex ? [] : {};
                    prevProperty = pathItem;
                }
                // Fill update with the `value` on `path`.
                update = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["setByPath"])(update, pathArray, value, '/');
                var baseAttributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])({}, this.attributes);
                // if rewrite mode enabled, we replace value referenced by path with
                // the new one (we don't merge).
                options.rewrite && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["unsetByPath"])(baseAttributes, path, '/');
                // Merge update with the model attributes.
                var attributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])(baseAttributes, update);
                // Finally, set the property to the updated attributes.
                return this.set(property, attributes[property], options);
            } else {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getByPath"])(this.attributes, props, delim);
            }
        }
        const options = value || {};
        // Note: '' is not the path to the root. It's a path with an empty string i.e. { '': {}}.
        options.propertyPath = null;
        options.propertyValue = props;
        options.propertyPathArray = [];
        if (!('rewrite' in options)) {
            options.rewrite = false;
        }
        // Create a new object containing only the changed attributes.
        const changedAttributes = {};
        for(const key in props){
            // Merging the values of changed attributes with the current ones.
            const { changedValue } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])({}, {
                changedValue: this.attributes[key]
            }, {
                changedValue: props[key]
            });
            changedAttributes[key] = changedValue;
        }
        return this.set(changedAttributes, options);
    },
    // A convenient way to unset nested properties
    removeProp: function(path, opt) {
        opt = opt || {};
        var pathArray = Array.isArray(path) ? path : path.split('/');
        // Once a property is removed from the `attrs` attribute
        // the cellView will recognize a `dirty` flag and re-render itself
        // in order to remove the attribute from SVG element.
        var property = pathArray[0];
        if (property === 'attrs') opt.dirty = true;
        if (pathArray.length === 1) {
            // A top level property
            return this.unset(path, opt);
        }
        // A nested property
        var nestedPath = pathArray.slice(1);
        var propertyValue = this.get(property);
        if (propertyValue === undefined || propertyValue === null) return this;
        propertyValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneDeep"])(propertyValue);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["unsetByPath"])(propertyValue, nestedPath, '/');
        return this.set(property, propertyValue, opt);
    },
    // A convenient way to set nested attributes.
    attr: function(attrs, value, opt) {
        var args = Array.from(arguments);
        if (args.length === 0) {
            return this.get('attrs');
        }
        if (Array.isArray(attrs)) {
            args[0] = [
                'attrs'
            ].concat(attrs);
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(attrs)) {
            // Get/set an attribute by a special path syntax that delimits
            // nested objects by the colon character.
            args[0] = 'attrs/' + attrs;
        } else {
            args[0] = {
                'attrs': attrs
            };
        }
        return this.prop.apply(this, args);
    },
    // A convenient way to unset nested attributes
    removeAttr: function(path, opt) {
        if (Array.isArray(path)) {
            return this.removeProp([
                'attrs'
            ].concat(path));
        }
        return this.removeProp('attrs/' + path, opt);
    },
    transition: function(path, value, opt, delim) {
        delim = delim || '/';
        var defaults = {
            duration: 100,
            delay: 10,
            timingFunction: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["timing"].linear,
            valueFunction: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["interpolate"].number
        };
        opt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(defaults, opt);
        var firstFrameTime = 0;
        var interpolatingFunction;
        var setter = (function(runtime) {
            var id, progress, propertyValue;
            firstFrameTime = firstFrameTime || runtime;
            runtime -= firstFrameTime;
            progress = runtime / opt.duration;
            if (progress < 1) {
                this._transitionIds[path] = id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nextFrame"])(setter);
            } else {
                progress = 1;
                delete this._transitionIds[path];
            }
            propertyValue = interpolatingFunction(opt.timingFunction(progress));
            opt.transitionId = id;
            this.prop(path, propertyValue, opt);
            if (!id) this.trigger('transition:end', this, path);
        }).bind(this);
        const { _scheduledTransitionIds } = this;
        let initialId;
        var initiator = (callback)=>{
            if (_scheduledTransitionIds[path]) {
                _scheduledTransitionIds[path] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["without"])(_scheduledTransitionIds[path], initialId);
                if (_scheduledTransitionIds[path].length === 0) {
                    delete _scheduledTransitionIds[path];
                }
            }
            this.stopPendingTransitions(path, delim);
            interpolatingFunction = opt.valueFunction((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getByPath"])(this.attributes, path, delim), value);
            this._transitionIds[path] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nextFrame"])(callback);
            this.trigger('transition:start', this, path);
        };
        initialId = setTimeout(initiator, opt.delay, setter);
        _scheduledTransitionIds[path] || (_scheduledTransitionIds[path] = []);
        _scheduledTransitionIds[path].push(initialId);
        return initialId;
    },
    getTransitions: function() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])(Object.keys(this._transitionIds), Object.keys(this._scheduledTransitionIds));
    },
    stopScheduledTransitions: function(path, delim = '/') {
        const { _scheduledTransitionIds = {} } = this;
        let transitions = Object.keys(_scheduledTransitionIds);
        if (path) {
            const pathArray = path.split(delim);
            transitions = transitions.filter((key)=>{
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEqual"])(pathArray, key.split(delim).slice(0, pathArray.length));
            });
        }
        transitions.forEach((key)=>{
            const transitionIds = _scheduledTransitionIds[key];
            // stop the initiator
            transitionIds.forEach((transitionId)=>clearTimeout(transitionId));
            delete _scheduledTransitionIds[key];
        // Note: we could trigger transition:cancel` event here
        });
        return this;
    },
    stopPendingTransitions (path, delim = '/') {
        const { _transitionIds = {} } = this;
        let transitions = Object.keys(_transitionIds);
        if (path) {
            const pathArray = path.split(delim);
            transitions = transitions.filter((key)=>{
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEqual"])(pathArray, key.split(delim).slice(0, pathArray.length));
            });
        }
        transitions.forEach((key)=>{
            const transitionId = _transitionIds[key];
            // stop the setter
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["cancelFrame"])(transitionId);
            delete _transitionIds[key];
            this.trigger('transition:end', this, key);
        });
    },
    stopTransitions: function(path, delim = '/') {
        this.stopScheduledTransitions(path, delim);
        this.stopPendingTransitions(path, delim);
        return this;
    },
    // A shorcut making it easy to create constructs like the following:
    // `var el = (new joint.shapes.standard.Rectangle()).addTo(graph)`.
    addTo: function(graph, opt) {
        graph.addCell(this, opt);
        return this;
    },
    // A shortcut for an equivalent call: `paper.findViewByModel(cell)`
    // making it easy to create constructs like the following:
    // `cell.findView(paper).highlight()`
    findView: function(paper) {
        return paper.findViewByModel(this);
    },
    isElement: function() {
        return false;
    },
    isLink: function() {
        return false;
    },
    startBatch: function(name, opt) {
        if (this.graph) {
            this.graph.startBatch(name, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])({}, opt, {
                cell: this
            }));
        }
        return this;
    },
    stopBatch: function(name, opt) {
        if (this.graph) {
            this.graph.stopBatch(name, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])({}, opt, {
                cell: this
            }));
        }
        return this;
    },
    getChangeFlag: function(attributes) {
        var flag = 0;
        if (!attributes) return flag;
        for(var key in attributes){
            if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) continue;
            flag |= attributes[key];
        }
        return flag;
    },
    angle: function() {
        // To be overridden.
        return 0;
    },
    position: function() {
        // To be overridden.
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(0, 0);
    },
    z: function() {
        return this.get('z') || 0;
    },
    getPointFromConnectedLink: function() {
        // To be overridden
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point();
    },
    getBBox: function() {
        // To be overridden
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect(0, 0, 0, 0);
    },
    getPointRotatedAroundCenter (angle, x, y) {
        const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(x, y);
        if (angle) point.rotate(this.getBBox().center(), angle);
        return point;
    },
    getAbsolutePointFromRelative (x, y) {
        // Rotate the position to take the model angle into account
        return this.getPointRotatedAroundCenter(-this.angle(), // Transform the relative position to absolute
        this.position().offset(x, y));
    },
    getRelativePointFromAbsolute (x, y) {
        return this// Rotate the coordinates to mitigate the element's rotation.
        .getPointRotatedAroundCenter(this.angle(), x, y)// Transform the absolute position into relative
        .difference(this.position());
    }
}, {
    getAttributeDefinition: function(attrName) {
        var defNS = this.attributes;
        var globalDefNS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attributes"];
        return defNS && defNS[attrName] || globalDefNS[attrName];
    },
    define: function(type, defaults, protoProps, staticProps) {
        protoProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])({
            defaults: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultsDeep"])({
                type: type
            }, defaults, this.prototype.defaults)
        }, protoProps);
        var Cell = this.extend(protoProps, staticProps);
        // es5 backward compatibility
        /* eslint-disable no-undef */ if (typeof joint !== 'undefined' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["has"])(joint, 'shapes')) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["setByPath"])(joint.shapes, type, Cell, '.');
        }
        /* eslint-enable no-undef */ return Cell;
    }
});
}}),
"[project]/node_modules/@joint/core/src/dia/Graph.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Graph": (()=>Graph)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Collection$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/mvc/Collection.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Model$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/mvc/Model.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$cloneCells$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/cloneCells.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$wrappers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/wrappers.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
const GraphCells = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Collection$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"].extend({
    initialize: function(models, opt) {
        // Set the optional namespace where all model classes are defined.
        if (opt.cellNamespace) {
            this.cellNamespace = opt.cellNamespace;
        } else {
            /* eslint-disable no-undef */ this.cellNamespace = typeof joint !== 'undefined' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.has(joint, 'shapes') ? joint.shapes : null;
        /* eslint-enable no-undef */ }
        this.graph = opt.graph;
    },
    model: function(attrs, opt) {
        const collection = opt.collection;
        const namespace = collection.cellNamespace;
        const { type } = attrs;
        // Find the model class based on the `type` attribute in the cell namespace
        const ModelClass = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.getByPath(namespace, type, '.');
        if (!ModelClass) {
            throw new Error(`dia.Graph: Could not find cell constructor for type: '${type}'. Make sure to add the constructor to 'cellNamespace'.`);
        }
        return new ModelClass(attrs, opt);
    },
    _addReference: function(model, options) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Collection$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"].prototype._addReference.apply(this, arguments);
        // If not in `dry` mode and the model does not have a graph reference yet,
        // set the reference.
        if (!options.dry && !model.graph) {
            model.graph = this.graph;
        }
    },
    _removeReference: function(model, options) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Collection$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Collection"].prototype._removeReference.apply(this, arguments);
        // If not in `dry` mode and the model has a reference to this exact graph,
        // remove the reference.
        if (!options.dry && model.graph === this.graph) {
            model.graph = null;
        }
    },
    // `comparator` makes it easy to sort cells based on their `z` index.
    comparator: function(model) {
        return model.get('z') || 0;
    }
});
const Graph = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Model$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Model"].extend({
    initialize: function(attrs, opt) {
        opt = opt || {};
        // Passing `cellModel` function in the options object to graph allows for
        // setting models based on attribute objects. This is especially handy
        // when processing JSON graphs that are in a different than JointJS format.
        var cells = new GraphCells([], {
            model: opt.cellModel,
            cellNamespace: opt.cellNamespace,
            graph: this
        });
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Model$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Model"].prototype.set.call(this, 'cells', cells);
        // Make all the events fired in the `cells` collection available.
        // to the outside world.
        cells.on('all', this.trigger, this);
        // JointJS automatically doesn't trigger re-sort if models attributes are changed later when
        // they're already in the collection. Therefore, we're triggering sort manually here.
        this.on('change:z', this._sortOnChangeZ, this);
        // `joint.dia.Graph` keeps an internal data structure (an adjacency list)
        // for fast graph queries. All changes that affect the structure of the graph
        // must be reflected in the `al` object. This object provides fast answers to
        // questions such as "what are the neighbours of this node" or "what
        // are the sibling links of this link".
        // Outgoing edges per node. Note that we use a hash-table for the list
        // of outgoing edges for a faster lookup.
        // [nodeId] -> Object [edgeId] -> true
        this._out = {};
        // Ingoing edges per node.
        // [nodeId] -> Object [edgeId] -> true
        this._in = {};
        // `_nodes` is useful for quick lookup of all the elements in the graph, without
        // having to go through the whole cells array.
        // [node ID] -> true
        this._nodes = {};
        // `_edges` is useful for quick lookup of all the links in the graph, without
        // having to go through the whole cells array.
        // [edgeId] -> true
        this._edges = {};
        this._batches = {};
        cells.on('add', this._restructureOnAdd, this);
        cells.on('remove', this._restructureOnRemove, this);
        cells.on('reset', this._restructureOnReset, this);
        cells.on('change:source', this._restructureOnChangeSource, this);
        cells.on('change:target', this._restructureOnChangeTarget, this);
        cells.on('remove', this._removeCell, this);
    },
    _sortOnChangeZ: function() {
        this.get('cells').sort();
    },
    _restructureOnAdd: function(cell) {
        if (cell.isLink()) {
            this._edges[cell.id] = true;
            var { source, target } = cell.attributes;
            if (source.id) {
                (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;
            }
            if (target.id) {
                (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;
            }
        } else {
            this._nodes[cell.id] = true;
        }
    },
    _restructureOnRemove: function(cell) {
        if (cell.isLink()) {
            delete this._edges[cell.id];
            var { source, target } = cell.attributes;
            if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {
                delete this._out[source.id][cell.id];
            }
            if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {
                delete this._in[target.id][cell.id];
            }
        } else {
            delete this._nodes[cell.id];
        }
    },
    _restructureOnReset: function(cells) {
        // Normalize into an array of cells. The original `cells` is GraphCells mvc collection.
        cells = cells.models;
        this._out = {};
        this._in = {};
        this._nodes = {};
        this._edges = {};
        cells.forEach(this._restructureOnAdd, this);
    },
    _restructureOnChangeSource: function(link) {
        var prevSource = link.previous('source');
        if (prevSource.id && this._out[prevSource.id]) {
            delete this._out[prevSource.id][link.id];
        }
        var source = link.attributes.source;
        if (source.id) {
            (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;
        }
    },
    _restructureOnChangeTarget: function(link) {
        var prevTarget = link.previous('target');
        if (prevTarget.id && this._in[prevTarget.id]) {
            delete this._in[prevTarget.id][link.id];
        }
        var target = link.get('target');
        if (target.id) {
            (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;
        }
    },
    // Return all outbound edges for the node. Return value is an object
    // of the form: [edgeId] -> true
    getOutboundEdges: function(node) {
        return this._out && this._out[node] || {};
    },
    // Return all inbound edges for the node. Return value is an object
    // of the form: [edgeId] -> true
    getInboundEdges: function(node) {
        return this._in && this._in[node] || {};
    },
    toJSON: function(opt = {}) {
        // JointJS does not recursively call `toJSON()` on attributes that are themselves models/collections.
        // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.
        var json = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Model$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Model"].prototype.toJSON.apply(this, arguments);
        json.cells = this.get('cells').toJSON(opt.cellAttributes);
        return json;
    },
    fromJSON: function(json, opt) {
        if (!json.cells) {
            throw new Error('Graph JSON must contain cells array.');
        }
        return this.set(json, opt);
    },
    set: function(key, val, opt) {
        var attrs;
        // Handle both `key`, value and {key: value} style arguments.
        if (typeof key === 'object') {
            attrs = key;
            opt = val;
        } else {
            (attrs = {})[key] = val;
        }
        // Make sure that `cells` attribute is handled separately via resetCells().
        if (attrs.hasOwnProperty('cells')) {
            this.resetCells(attrs.cells, opt);
            attrs = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.omit(attrs, 'cells');
        }
        // The rest of the attributes are applied via original set method.
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Model$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Model"].prototype.set.call(this, attrs, opt);
    },
    clear: function(opt) {
        opt = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign({}, opt, {
            clear: true
        });
        var collection = this.get('cells');
        if (collection.length === 0) return this;
        this.startBatch('clear', opt);
        // The elements come after the links.
        var cells = collection.sortBy(function(cell) {
            return cell.isLink() ? 1 : 2;
        });
        do {
            // Remove all the cells one by one.
            // Note that all the links are removed first, so it's
            // safe to remove the elements without removing the connected
            // links first.
            cells.shift().remove(opt);
        }while (cells.length > 0)
        this.stopBatch('clear');
        return this;
    },
    _prepareCell: function(cell) {
        let attrs;
        if (cell instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Model$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Model"]) {
            attrs = cell.attributes;
        } else {
            attrs = cell;
        }
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isString(attrs.type)) {
            throw new TypeError('dia.Graph: cell type must be a string.');
        }
        return cell;
    },
    minZIndex: function() {
        var firstCell = this.get('cells').first();
        return firstCell ? firstCell.get('z') || 0 : 0;
    },
    maxZIndex: function() {
        var lastCell = this.get('cells').last();
        return lastCell ? lastCell.get('z') || 0 : 0;
    },
    addCell: function(cell, opt) {
        if (Array.isArray(cell)) {
            return this.addCells(cell, opt);
        }
        if (cell instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Model$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Model"]) {
            if (!cell.has('z')) {
                cell.set('z', this.maxZIndex() + 1);
            }
        } else if (cell.z === undefined) {
            cell.z = this.maxZIndex() + 1;
        }
        this.get('cells').add(this._prepareCell(cell, opt), opt || {});
        return this;
    },
    addCells: function(cells, opt) {
        if (cells.length === 0) return this;
        cells = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.flattenDeep(cells);
        opt.maxPosition = opt.position = cells.length - 1;
        this.startBatch('add', opt);
        cells.forEach(function(cell) {
            this.addCell(cell, opt);
            opt.position--;
        }, this);
        this.stopBatch('add', opt);
        return this;
    },
    // When adding a lot of cells, it is much more efficient to
    // reset the entire cells collection in one go.
    // Useful for bulk operations and optimizations.
    resetCells: function(cells, opt) {
        var preparedCells = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(cells).map(function(cell) {
            return this._prepareCell(cell, opt);
        }, this);
        this.get('cells').reset(preparedCells, opt);
        return this;
    },
    removeCells: function(cells, opt) {
        if (cells.length) {
            this.startBatch('remove');
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.invoke(cells, 'remove', opt);
            this.stopBatch('remove');
        }
        return this;
    },
    _removeCell: function(cell, collection, options) {
        options = options || {};
        if (!options.clear) {
            // Applications might provide a `disconnectLinks` option set to `true` in order to
            // disconnect links when a cell is removed rather then removing them. The default
            // is to remove all the associated links.
            if (options.disconnectLinks) {
                this.disconnectLinks(cell, options);
            } else {
                this.removeLinks(cell, options);
            }
        }
        // Silently remove the cell from the cells collection. Silently, because
        // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is
        // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events
        // would be triggered on the graph model.
        this.get('cells').remove(cell, {
            silent: true
        });
    },
    transferCellEmbeds: function(sourceCell, targetCell, opt = {}) {
        const batchName = 'transfer-embeds';
        this.startBatch(batchName);
        // Embed children of the source cell in the target cell.
        const children = sourceCell.getEmbeddedCells();
        targetCell.embed(children, {
            ...opt,
            reparent: true
        });
        this.stopBatch(batchName);
    },
    transferCellConnectedLinks: function(sourceCell, targetCell, opt = {}) {
        const batchName = 'transfer-connected-links';
        this.startBatch(batchName);
        // Reconnect all the links connected to the old cell to the new cell.
        const connectedLinks = this.getConnectedLinks(sourceCell, opt);
        connectedLinks.forEach((link)=>{
            if (link.getSourceCell() === sourceCell) {
                link.prop([
                    'source',
                    'id'
                ], targetCell.id, opt);
            }
            if (link.getTargetCell() === sourceCell) {
                link.prop([
                    'target',
                    'id'
                ], targetCell.id, opt);
            }
        });
        this.stopBatch(batchName);
    },
    // Get a cell by `id`.
    getCell: function(id) {
        return this.get('cells').get(id);
    },
    getCells: function() {
        return this.get('cells').toArray();
    },
    getElements: function() {
        return this.get('cells').toArray().filter((cell)=>cell.isElement());
    },
    getLinks: function() {
        return this.get('cells').toArray().filter((cell)=>cell.isLink());
    },
    getFirstCell: function() {
        return this.get('cells').first();
    },
    getLastCell: function() {
        return this.get('cells').last();
    },
    // Get all inbound and outbound links connected to the cell `model`.
    getConnectedLinks: function(model, opt) {
        opt = opt || {};
        var indirect = opt.indirect;
        var inbound = opt.inbound;
        var outbound = opt.outbound;
        if (inbound === undefined && outbound === undefined) {
            inbound = outbound = true;
        }
        // the final array of connected link models
        var links = [];
        // a hash table of connected edges of the form: [edgeId] -> true
        // used for quick lookups to check if we already added a link
        var edges = {};
        if (outbound) {
            addOutbounds(this, model);
        }
        if (inbound) {
            addInbounds(this, model);
        }
        function addOutbounds(graph, model) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.forIn(graph.getOutboundEdges(model.id), (function(_, edge) {
                // skip links that were already added
                // (those must be self-loop links)
                // (because they are inbound and outbound edges of the same two elements)
                if (edges[edge]) return;
                var link = graph.getCell(edge);
                links.push(link);
                edges[edge] = true;
                if (indirect) {
                    if (inbound) addInbounds(graph, link);
                    if (outbound) addOutbounds(graph, link);
                }
            }).bind(graph));
            if (indirect && model.isLink()) {
                var outCell = model.getTargetCell();
                if (outCell && outCell.isLink()) {
                    if (!edges[outCell.id]) {
                        links.push(outCell);
                        addOutbounds(graph, outCell);
                    }
                }
            }
        }
        function addInbounds(graph, model) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.forIn(graph.getInboundEdges(model.id), (function(_, edge) {
                // skip links that were already added
                // (those must be self-loop links)
                // (because they are inbound and outbound edges of the same two elements)
                if (edges[edge]) return;
                var link = graph.getCell(edge);
                links.push(link);
                edges[edge] = true;
                if (indirect) {
                    if (inbound) addInbounds(graph, link);
                    if (outbound) addOutbounds(graph, link);
                }
            }).bind(graph));
            if (indirect && model.isLink()) {
                var inCell = model.getSourceCell();
                if (inCell && inCell.isLink()) {
                    if (!edges[inCell.id]) {
                        links.push(inCell);
                        addInbounds(graph, inCell);
                    }
                }
            }
        }
        // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells
        if (opt.deep) {
            var embeddedCells = model.getEmbeddedCells({
                deep: true
            });
            // in the first round, we collect all the embedded elements
            var embeddedElements = {};
            embeddedCells.forEach(function(cell) {
                if (cell.isElement()) {
                    embeddedElements[cell.id] = true;
                }
            });
            embeddedCells.forEach(function(cell) {
                if (cell.isLink()) return;
                if (outbound) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.forIn(this.getOutboundEdges(cell.id), (function(exists, edge) {
                        if (!edges[edge]) {
                            var edgeCell = this.getCell(edge);
                            var { source, target } = edgeCell.attributes;
                            var sourceId = source.id;
                            var targetId = target.id;
                            // if `includeEnclosed` option is falsy, skip enclosed links
                            if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {
                                return;
                            }
                            links.push(this.getCell(edge));
                            edges[edge] = true;
                        }
                    }).bind(this));
                }
                if (inbound) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.forIn(this.getInboundEdges(cell.id), (function(exists, edge) {
                        if (!edges[edge]) {
                            var edgeCell = this.getCell(edge);
                            var { source, target } = edgeCell.attributes;
                            var sourceId = source.id;
                            var targetId = target.id;
                            // if `includeEnclosed` option is falsy, skip enclosed links
                            if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {
                                return;
                            }
                            links.push(this.getCell(edge));
                            edges[edge] = true;
                        }
                    }).bind(this));
                }
            }, this);
        }
        return links;
    },
    getNeighbors: function(model, opt) {
        opt || (opt = {});
        var inbound = opt.inbound;
        var outbound = opt.outbound;
        if (inbound === undefined && outbound === undefined) {
            inbound = outbound = true;
        }
        var neighbors = this.getConnectedLinks(model, opt).reduce((function(res, link) {
            var { source, target } = link.attributes;
            var loop = link.hasLoop(opt);
            // Discard if it is a point, or if the neighbor was already added.
            if (inbound && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.has(source, 'id') && !res[source.id]) {
                var sourceElement = this.getCell(source.id);
                if (sourceElement.isElement()) {
                    if (loop || sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model))) {
                        res[source.id] = sourceElement;
                    }
                }
            }
            // Discard if it is a point, or if the neighbor was already added.
            if (outbound && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.has(target, 'id') && !res[target.id]) {
                var targetElement = this.getCell(target.id);
                if (targetElement.isElement()) {
                    if (loop || targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model))) {
                        res[target.id] = targetElement;
                    }
                }
            }
            return res;
        }).bind(this), {});
        if (model.isLink()) {
            if (inbound) {
                var sourceCell = model.getSourceCell();
                if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {
                    neighbors[sourceCell.id] = sourceCell;
                }
            }
            if (outbound) {
                var targetCell = model.getTargetCell();
                if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {
                    neighbors[targetCell.id] = targetCell;
                }
            }
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(neighbors);
    },
    getCommonAncestor: function() {
        var cellsAncestors = Array.from(arguments).map(function(cell) {
            var ancestors = [];
            var parentId = cell.get('parent');
            while(parentId){
                ancestors.push(parentId);
                parentId = this.getCell(parentId).get('parent');
            }
            return ancestors;
        }, this);
        cellsAncestors = cellsAncestors.sort(function(a, b) {
            return a.length - b.length;
        });
        var commonAncestor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(cellsAncestors.shift()).find(function(ancestor) {
            return cellsAncestors.every(function(cellAncestors) {
                return cellAncestors.includes(ancestor);
            });
        });
        return this.getCell(commonAncestor);
    },
    // Find the whole branch starting at `element`.
    // If `opt.deep` is `true`, take into account embedded elements too.
    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.
    getSuccessors: function(element, opt) {
        opt = opt || {};
        var res = [];
        // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.
        this.search(element, function(el) {
            if (el !== element) {
                res.push(el);
            }
        }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign({}, opt, {
            outbound: true
        }));
        return res;
    },
    cloneCells: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$cloneCells$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneCells"],
    // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).
    // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.
    // Return a map of the form: [original cell ID] -> [clone].
    cloneSubgraph: function(cells, opt) {
        var subgraph = this.getSubgraph(cells, opt);
        return this.cloneCells(subgraph);
    },
    // Return `cells` and all the connected links that connect cells in the `cells` array.
    // If `opt.deep` is `true`, return all the cells including all their embedded cells
    // and all the links that connect any of the returned cells.
    // For example, for a single shallow element, the result is that very same element.
    // For two elements connected with a link: `A --- L ---> B`, the result for
    // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.
    getSubgraph: function(cells, opt) {
        opt = opt || {};
        var subgraph = [];
        // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.
        var cellMap = {};
        var elements = [];
        var links = [];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(cells).forEach(function(cell) {
            if (!cellMap[cell.id]) {
                subgraph.push(cell);
                cellMap[cell.id] = cell;
                if (cell.isLink()) {
                    links.push(cell);
                } else {
                    elements.push(cell);
                }
            }
            if (opt.deep) {
                var embeds = cell.getEmbeddedCells({
                    deep: true
                });
                embeds.forEach(function(embed) {
                    if (!cellMap[embed.id]) {
                        subgraph.push(embed);
                        cellMap[embed.id] = embed;
                        if (embed.isLink()) {
                            links.push(embed);
                        } else {
                            elements.push(embed);
                        }
                    }
                });
            }
        });
        links.forEach(function(link) {
            // For links, return their source & target (if they are elements - not points).
            var { source, target } = link.attributes;
            if (source.id && !cellMap[source.id]) {
                var sourceElement = this.getCell(source.id);
                subgraph.push(sourceElement);
                cellMap[sourceElement.id] = sourceElement;
                elements.push(sourceElement);
            }
            if (target.id && !cellMap[target.id]) {
                var targetElement = this.getCell(target.id);
                subgraph.push(this.getCell(target.id));
                cellMap[targetElement.id] = targetElement;
                elements.push(targetElement);
            }
        }, this);
        elements.forEach(function(element) {
            // For elements, include their connected links if their source/target is in the subgraph;
            var links = this.getConnectedLinks(element, opt);
            links.forEach(function(link) {
                var { source, target } = link.attributes;
                if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {
                    subgraph.push(link);
                    cellMap[link.id] = link;
                }
            });
        }, this);
        return subgraph;
    },
    // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.
    // If `opt.deep` is `true`, take into account embedded elements too.
    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.
    getPredecessors: function(element, opt) {
        opt = opt || {};
        var res = [];
        // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.
        this.search(element, function(el) {
            if (el !== element) {
                res.push(el);
            }
        }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign({}, opt, {
            inbound: true
        }));
        return res;
    },
    // Perform search on the graph.
    // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.
    // By setting `opt.inbound` to `true`, you can reverse the direction of the search.
    // If `opt.deep` is `true`, take into account embedded elements too.
    // `iteratee` is a function of the form `function(element) {}`.
    // If `iteratee` explicitly returns `false`, the searching stops.
    search: function(element, iteratee, opt) {
        opt = opt || {};
        if (opt.breadthFirst) {
            this.bfs(element, iteratee, opt);
        } else {
            this.dfs(element, iteratee, opt);
        }
    },
    // Breadth-first search.
    // If `opt.deep` is `true`, take into account embedded elements too.
    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).
    // `iteratee` is a function of the form `function(element, distance) {}`.
    // where `element` is the currently visited element and `distance` is the distance of that element
    // from the root `element` passed the `bfs()`, i.e. the element we started the search from.
    // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels
    // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.
    // If `iteratee` explicitly returns `false`, the searching stops.
    bfs: function(element, iteratee, opt = {}) {
        const visited = {};
        const distance = {};
        const queue = [];
        queue.push(element);
        distance[element.id] = 0;
        while(queue.length > 0){
            var next = queue.shift();
            if (visited[next.id]) continue;
            visited[next.id] = true;
            if (iteratee.call(this, next, distance[next.id]) === false) continue;
            const neighbors = this.getNeighbors(next, opt);
            for(let i = 0, n = neighbors.length; i < n; i++){
                const neighbor = neighbors[i];
                distance[neighbor.id] = distance[next.id] + 1;
                queue.push(neighbor);
            }
        }
    },
    // Depth-first search.
    // If `opt.deep` is `true`, take into account embedded elements too.
    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).
    // `iteratee` is a function of the form `function(element, distance) {}`.
    // If `iteratee` explicitly returns `false`, the search stops.
    dfs: function(element, iteratee, opt = {}) {
        const visited = {};
        const distance = {};
        const queue = [];
        queue.push(element);
        distance[element.id] = 0;
        while(queue.length > 0){
            const next = queue.pop();
            if (visited[next.id]) continue;
            visited[next.id] = true;
            if (iteratee.call(this, next, distance[next.id]) === false) continue;
            const neighbors = this.getNeighbors(next, opt);
            const lastIndex = queue.length;
            for(let i = 0, n = neighbors.length; i < n; i++){
                const neighbor = neighbors[i];
                distance[neighbor.id] = distance[next.id] + 1;
                queue.splice(lastIndex, 0, neighbor);
            }
        }
    },
    // Get all the roots of the graph. Time complexity: O(|V|).
    getSources: function() {
        var sources = [];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.forIn(this._nodes, (function(exists, node) {
            if (!this._in[node] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isEmpty(this._in[node])) {
                sources.push(this.getCell(node));
            }
        }).bind(this));
        return sources;
    },
    // Get all the leafs of the graph. Time complexity: O(|V|).
    getSinks: function() {
        var sinks = [];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.forIn(this._nodes, (function(exists, node) {
            if (!this._out[node] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isEmpty(this._out[node])) {
                sinks.push(this.getCell(node));
            }
        }).bind(this));
        return sinks;
    },
    // Return `true` if `element` is a root. Time complexity: O(1).
    isSource: function(element) {
        return !this._in[element.id] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isEmpty(this._in[element.id]);
    },
    // Return `true` if `element` is a leaf. Time complexity: O(1).
    isSink: function(element) {
        return !this._out[element.id] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isEmpty(this._out[element.id]);
    },
    // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.
    isSuccessor: function(elementA, elementB) {
        var isSuccessor = false;
        this.search(elementA, function(element) {
            if (element === elementB && element !== elementA) {
                isSuccessor = true;
                return false;
            }
        }, {
            outbound: true
        });
        return isSuccessor;
    },
    // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.
    isPredecessor: function(elementA, elementB) {
        var isPredecessor = false;
        this.search(elementA, function(element) {
            if (element === elementB && element !== elementA) {
                isPredecessor = true;
                return false;
            }
        }, {
            inbound: true
        });
        return isPredecessor;
    },
    // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.
    // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`
    // for more details.
    // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.
    // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.
    isNeighbor: function(elementA, elementB, opt) {
        opt = opt || {};
        var inbound = opt.inbound;
        var outbound = opt.outbound;
        if (inbound === undefined && outbound === undefined) {
            inbound = outbound = true;
        }
        var isNeighbor = false;
        this.getConnectedLinks(elementA, opt).forEach(function(link) {
            var { source, target } = link.attributes;
            // Discard if it is a point.
            if (inbound && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.has(source, 'id') && source.id === elementB.id) {
                isNeighbor = true;
                return false;
            }
            // Discard if it is a point, or if the neighbor was already added.
            if (outbound && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.has(target, 'id') && target.id === elementB.id) {
                isNeighbor = true;
                return false;
            }
        });
        return isNeighbor;
    },
    // Disconnect links connected to the cell `model`.
    disconnectLinks: function(model, opt) {
        this.getConnectedLinks(model).forEach(function(link) {
            link.set(link.attributes.source.id === model.id ? 'source' : 'target', {
                x: 0,
                y: 0
            }, opt);
        });
    },
    // Remove links connected to the cell `model` completely.
    removeLinks: function(model, opt) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.invoke(this.getConnectedLinks(model), 'remove', opt);
    },
    // Find all cells at given point
    findElementsAtPoint: function(point, opt) {
        return this._filterAtPoint(this.getElements(), point, opt);
    },
    findLinksAtPoint: function(point, opt) {
        return this._filterAtPoint(this.getLinks(), point, opt);
    },
    findCellsAtPoint: function(point, opt) {
        return this._filterAtPoint(this.getCells(), point, opt);
    },
    _filterAtPoint: function(cells, point, opt = {}) {
        return cells.filter((el)=>el.getBBox({
                rotate: true
            }).containsPoint(point, opt));
    },
    // Find all cells in given area
    findElementsInArea: function(area, opt = {}) {
        return this._filterInArea(this.getElements(), area, opt);
    },
    findLinksInArea: function(area, opt = {}) {
        return this._filterInArea(this.getLinks(), area, opt);
    },
    findCellsInArea: function(area, opt = {}) {
        return this._filterInArea(this.getCells(), area, opt);
    },
    _filterInArea: function(cells, area, opt = {}) {
        const r = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect(area);
        const { strict = false } = opt;
        const method = strict ? 'containsRect' : 'intersect';
        return cells.filter((el)=>r[method](el.getBBox({
                rotate: true
            })));
    },
    // Find all cells under the given element.
    findElementsUnderElement: function(element, opt) {
        return this._filterCellsUnderElement(this.getElements(), element, opt);
    },
    findLinksUnderElement: function(element, opt) {
        return this._filterCellsUnderElement(this.getLinks(), element, opt);
    },
    findCellsUnderElement: function(element, opt) {
        return this._filterCellsUnderElement(this.getCells(), element, opt);
    },
    _isValidElementUnderElement: function(el1, el2) {
        return el1.id !== el2.id && !el1.isEmbeddedIn(el2);
    },
    _isValidLinkUnderElement: function(link, el) {
        return link.source().id !== el.id && link.target().id !== el.id && !link.isEmbeddedIn(el);
    },
    _validateCellsUnderElement: function(cells, element) {
        return cells.filter((cell)=>{
            return cell.isLink() ? this._isValidLinkUnderElement(cell, element) : this._isValidElementUnderElement(cell, element);
        });
    },
    _getFindUnderElementGeometry: function(element, searchBy = 'bbox') {
        const bbox = element.getBBox({
            rotate: true
        });
        return searchBy !== 'bbox' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.getRectPoint(bbox, searchBy) : bbox;
    },
    _filterCellsUnderElement: function(cells, element, opt = {}) {
        const geometry = this._getFindUnderElementGeometry(element, opt.searchBy);
        const filteredCells = geometry.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.types.Point ? this._filterAtPoint(cells, geometry) : this._filterInArea(cells, geometry, opt);
        return this._validateCellsUnderElement(filteredCells, element);
    },
    // @deprecated use `findElementsInArea` instead
    findModelsInArea: function(area, opt) {
        return this.findElementsInArea(area, opt);
    },
    // @deprecated use `findElementsAtPoint` instead
    findModelsFromPoint: function(point) {
        return this.findElementsAtPoint(point);
    },
    // @deprecated use `findModelsUnderElement` instead
    findModelsUnderElement: function(element, opt) {
        return this.findElementsUnderElement(element, opt);
    },
    // Return bounding box of all elements.
    getBBox: function() {
        return this.getCellsBBox(this.getCells());
    },
    // Return the bounding box of all cells in array provided.
    getCellsBBox: function(cells, opt = {}) {
        const { rotate = true } = opt;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(cells).reduce(function(memo, cell) {
            const rect = cell.getBBox({
                rotate
            });
            if (!rect) return memo;
            if (memo) {
                return memo.union(rect);
            }
            return rect;
        }, null);
    },
    translate: function(dx, dy, opt) {
        // Don't translate cells that are embedded in any other cell.
        var cells = this.getCells().filter(function(cell) {
            return !cell.isEmbedded();
        });
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.invoke(cells, 'translate', dx, dy, opt);
        return this;
    },
    resize: function(width, height, opt) {
        return this.resizeCells(width, height, this.getCells(), opt);
    },
    resizeCells: function(width, height, cells, opt) {
        // `getBBox` method returns `null` if no elements provided.
        // i.e. cells can be an array of links
        var bbox = this.getCellsBBox(cells);
        if (bbox) {
            var sx = Math.max(width / bbox.width, 0);
            var sy = Math.max(height / bbox.height, 0);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.invoke(cells, 'scale', sx, sy, bbox.origin(), opt);
        }
        return this;
    },
    startBatch: function(name, data) {
        data = data || {};
        this._batches[name] = (this._batches[name] || 0) + 1;
        return this.trigger('batch:start', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign({}, data, {
            batchName: name
        }));
    },
    stopBatch: function(name, data) {
        data = data || {};
        this._batches[name] = (this._batches[name] || 0) - 1;
        return this.trigger('batch:stop', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign({}, data, {
            batchName: name
        }));
    },
    hasActiveBatch: function(name) {
        const batches = this._batches;
        let names;
        if (arguments.length === 0) {
            names = Object.keys(batches);
        } else if (Array.isArray(name)) {
            names = name;
        } else {
            names = [
                name
            ];
        }
        return names.some((batch)=>batches[batch] > 0);
    }
}, {
    validations: {
        multiLinks: function(graph, link) {
            // Do not allow multiple links to have the same source and target.
            var { source, target } = link.attributes;
            if (source.id && target.id) {
                var sourceModel = link.getSourceCell();
                if (sourceModel) {
                    var connectedLinks = graph.getConnectedLinks(sourceModel, {
                        outbound: true
                    });
                    var sameLinks = connectedLinks.filter(function(_link) {
                        var { source: _source, target: _target } = _link.attributes;
                        return _source && _source.id === source.id && (!_source.port || _source.port === source.port) && _target && _target.id === target.id && (!_target.port || _target.port === target.port);
                    });
                    if (sameLinks.length > 1) {
                        return false;
                    }
                }
            }
            return true;
        },
        linkPinning: function(_graph, link) {
            var { source, target } = link.attributes;
            return source.id && target.id;
        }
    }
});
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$wrappers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["wrapWith"])(Graph.prototype, [
    'resetCells',
    'addCells',
    'removeCells'
], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$wrappers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["wrappers"].cells);
}}),
"[project]/node_modules/@joint/core/src/dia/PaperLayer.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LayersNames": (()=>LayersNames),
    "PaperLayer": (()=>PaperLayer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$View$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/mvc/View.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/util.mjs [app-client] (ecmascript) <locals>");
;
;
const LayersNames = {
    GRID: 'grid',
    CELLS: 'cells',
    BACK: 'back',
    FRONT: 'front',
    TOOLS: 'tools',
    LABELS: 'labels'
};
const PaperLayer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$View$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"].extend({
    tagName: 'g',
    svgElement: true,
    pivotNodes: null,
    defaultTheme: null,
    options: {
        name: ''
    },
    className: function() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addClassNamePrefix"])(`${this.options.name}-layer`);
    },
    init: function() {
        this.pivotNodes = {};
    },
    insertSortedNode: function(node, z) {
        this.el.insertBefore(node, this.insertPivot(z));
    },
    insertNode: function(node) {
        const { el } = this;
        if (node.parentNode !== el) {
            el.appendChild(node);
        }
    },
    insertPivot: function(z) {
        const { el, pivotNodes } = this;
        z = +z;
        z || (z = 0);
        let pivotNode = pivotNodes[z];
        if (pivotNode) return pivotNode;
        pivotNode = pivotNodes[z] = document.createComment('z-index:' + (z + 1));
        let neighborZ = -Infinity;
        for(let currentZ in pivotNodes){
            currentZ = +currentZ;
            if (currentZ < z && currentZ > neighborZ) {
                neighborZ = currentZ;
                if (neighborZ === z - 1) continue;
            }
        }
        if (neighborZ !== -Infinity) {
            const neighborPivot = pivotNodes[neighborZ];
            // Insert After
            el.insertBefore(pivotNode, neighborPivot.nextSibling);
        } else {
            // First Child
            el.insertBefore(pivotNode, el.firstChild);
        }
        return pivotNode;
    },
    removePivots: function() {
        const { el, pivotNodes } = this;
        for(let z in pivotNodes)el.removeChild(pivotNodes[z]);
        this.pivotNodes = {};
    }
});
}}),
"[project]/node_modules/@joint/core/src/dia/attributes/eval.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "evalAttribute": (()=>evalAttribute),
    "evalAttributes": (()=>evalAttributes)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$calc$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/calc.mjs [app-client] (ecmascript)");
;
const calcAttributesList = [
    'transform',
    'x',
    'y',
    'cx',
    'cy',
    'dx',
    'dy',
    'x1',
    'y1',
    'x2',
    'y2',
    'points',
    'd',
    'r',
    'rx',
    'ry',
    'width',
    'height',
    'stroke-width',
    'font-size'
];
const positiveValueList = [
    'r',
    'rx',
    'ry',
    'width',
    'height',
    'stroke-width',
    'font-size'
];
const calcAttributes = calcAttributesList.reduce((acc, attrName)=>{
    acc[attrName] = true;
    return acc;
}, {});
const positiveValueAttributes = positiveValueList.reduce((acc, attrName)=>{
    acc[attrName] = true;
    return acc;
}, {});
function evalAttributes(attrs, refBBox) {
    const evalAttrs = {};
    for(let attrName in attrs){
        if (!attrs.hasOwnProperty(attrName)) continue;
        evalAttrs[attrName] = evalAttribute(attrName, attrs[attrName], refBBox);
    }
    return evalAttrs;
}
function evalAttribute(attrName, attrValue, refBBox) {
    if (attrName in calcAttributes && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$calc$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isCalcExpression"])(attrValue)) {
        let evalAttrValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$calc$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["evalCalcExpression"])(attrValue, refBBox);
        if (attrName in positiveValueAttributes) {
            evalAttrValue = Math.max(0, evalAttrValue);
        }
        return evalAttrValue;
    }
    return attrValue;
}
}}),
"[project]/node_modules/@joint/core/src/dia/HighlighterView.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "HighlighterView": (()=>HighlighterView)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/mvc/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/utilHelpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/V/index.mjs [app-client] (ecmascript)");
;
;
;
function toArray(obj) {
    if (!obj) return [];
    if (Array.isArray(obj)) return obj;
    return [
        obj
    ];
}
const HighlighterView = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.View.extend({
    tagName: 'g',
    svgElement: true,
    className: 'highlight',
    HIGHLIGHT_FLAG: 1,
    UPDATE_PRIORITY: 3,
    DETACHABLE: false,
    UPDATABLE: true,
    MOUNTABLE: true,
    cellView: null,
    nodeSelector: null,
    node: null,
    updateRequested: false,
    postponedUpdate: false,
    transformGroup: null,
    detachedTransformGroup: null,
    requestUpdate (cellView, nodeSelector) {
        const { paper } = cellView;
        this.cellView = cellView;
        this.nodeSelector = nodeSelector;
        if (paper) {
            this.updateRequested = true;
            paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);
        }
    },
    confirmUpdate () {
        // The cellView is now rendered/updated since it has a higher update priority.
        this.updateRequested = false;
        const { cellView, nodeSelector } = this;
        if (cellView.isMounted()) {
            this.update(cellView, nodeSelector);
            this.mount();
            this.transform();
        } else {
            this.postponedUpdate = true;
        }
        return 0;
    },
    findNode (cellView, nodeSelector = null) {
        let el;
        if (typeof nodeSelector === 'string') {
            el = cellView.findNode(nodeSelector);
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(nodeSelector)) {
            const isLink = cellView.model.isLink();
            const { label = null, port, selector } = nodeSelector;
            if (isLink && label !== null) {
                // Link Label Selector
                el = cellView.findLabelNode(label, selector);
            } else if (!isLink && port) {
                // Element Port Selector
                el = cellView.findPortNode(port, selector);
            } else {
                // Cell Selector
                el = cellView.findNode(selector);
            }
        } else if (nodeSelector) {
            el = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].toNode(nodeSelector);
            if (!(el instanceof SVGElement)) el = null;
        }
        return el ? el : null;
    },
    getNodeMatrix (cellView, node) {
        const { options } = this;
        const { layer } = options;
        const { rotatableNode } = cellView;
        const nodeMatrix = cellView.getNodeMatrix(node);
        if (rotatableNode) {
            if (layer) {
                if (rotatableNode.contains(node)) {
                    return nodeMatrix;
                }
                // The node is outside of the rotatable group.
                // Compensate the rotation set by transformGroup.
                return cellView.getRootRotateMatrix().inverse().multiply(nodeMatrix);
            } else {
                return cellView.getNodeRotateMatrix(node).multiply(nodeMatrix);
            }
        }
        return nodeMatrix;
    },
    mount () {
        const { MOUNTABLE, cellView, el, options, transformGroup, detachedTransformGroup, postponedUpdate, nodeSelector } = this;
        if (!MOUNTABLE || transformGroup) return;
        if (postponedUpdate) {
            // The cellView was not mounted when the update was requested.
            // The update was postponed until the cellView is mounted.
            this.update(cellView, nodeSelector);
            this.transform();
            return;
        }
        const { vel: cellViewRoot, paper } = cellView;
        const { layer: layerName } = options;
        if (layerName) {
            let vGroup;
            if (detachedTransformGroup) {
                vGroup = detachedTransformGroup;
                this.detachedTransformGroup = null;
            } else {
                vGroup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('g').addClass('highlight-transform').append(el);
            }
            this.transformGroup = vGroup;
            paper.getLayerView(layerName).insertSortedNode(vGroup.node, options.z);
        } else {
            // TODO: prepend vs append
            if (!el.parentNode || el.nextSibling) {
                // Not appended yet or not the last child
                cellViewRoot.append(el);
            }
        }
    },
    unmount () {
        const { MOUNTABLE, transformGroup, vel } = this;
        if (!MOUNTABLE) return;
        if (transformGroup) {
            this.transformGroup = null;
            this.detachedTransformGroup = transformGroup;
            transformGroup.remove();
        } else {
            vel.remove();
        }
    },
    transform () {
        const { transformGroup, cellView, updateRequested } = this;
        if (!transformGroup || cellView.model.isLink() || updateRequested) return;
        const translateMatrix = cellView.getRootTranslateMatrix();
        const rotateMatrix = cellView.getRootRotateMatrix();
        const transformMatrix = translateMatrix.multiply(rotateMatrix);
        transformGroup.attr('transform', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].matrixToTransformString(transformMatrix));
    },
    update () {
        const { node: prevNode, cellView, nodeSelector, updateRequested, id } = this;
        if (updateRequested) return;
        this.postponedUpdate = false;
        const node = this.node = this.findNode(cellView, nodeSelector);
        if (prevNode) {
            this.unhighlight(cellView, prevNode);
        }
        if (node) {
            this.highlight(cellView, node);
            this.mount();
        } else {
            this.unmount();
            cellView.notify('cell:highlight:invalid', id, this);
        }
    },
    onRemove () {
        const { node, cellView, id, constructor } = this;
        if (node) {
            this.unhighlight(cellView, node);
        }
        this.unmount();
        constructor._removeRef(cellView, id);
    },
    highlight (_cellView, _node) {
    // to be overridden
    },
    unhighlight (_cellView, _node) {
    // to be overridden
    },
    // Update Attributes
    listenToUpdateAttributes (cellView) {
        const attributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["result"])(this, 'UPDATE_ATTRIBUTES');
        if (!Array.isArray(attributes) || attributes.length === 0) return;
        this.listenTo(cellView.model, 'change', this.onCellAttributeChange);
    },
    onCellAttributeChange () {
        const { cellView } = this;
        if (!cellView) return;
        const { model, paper } = cellView;
        const attributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["result"])(this, 'UPDATE_ATTRIBUTES');
        if (!attributes.some((attribute)=>model.hasChanged(attribute))) return;
        paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);
    }
}, {
    _views: {},
    // Used internally by CellView highlight()
    highlight: function(cellView, node, opt) {
        const id = this.uniqueId(node, opt);
        this.add(cellView, node, id, opt);
    },
    // Used internally by CellView unhighlight()
    unhighlight: function(cellView, node, opt) {
        const id = this.uniqueId(node, opt);
        this.remove(cellView, id);
    },
    get (cellView, id = null) {
        const { cid } = cellView;
        const { _views } = this;
        const refs = _views[cid];
        if (id === null) {
            // all highlighters
            const views = [];
            if (!refs) return views;
            for(let hid in refs){
                const ref = refs[hid];
                if (ref instanceof this) {
                    views.push(ref);
                }
            }
            return views;
        } else {
            // single highlighter
            if (!refs) return null;
            if (id in refs) {
                const ref = refs[id];
                if (ref instanceof this) return ref;
            }
            return null;
        }
    },
    add (cellView, nodeSelector, id, opt = {}) {
        if (!id) throw new Error('dia.HighlighterView: An ID required.');
        // Search the existing view amongst all the highlighters
        const previousView = HighlighterView.get(cellView, id);
        if (previousView) previousView.remove();
        const view = new this(opt);
        view.id = id;
        this._addRef(cellView, id, view);
        view.requestUpdate(cellView, nodeSelector);
        view.listenToUpdateAttributes(cellView);
        return view;
    },
    _addRef (cellView, id, view) {
        const { cid } = cellView;
        const { _views } = this;
        let refs = _views[cid];
        if (!refs) refs = _views[cid] = {};
        refs[id] = view;
    },
    _removeRef (cellView, id) {
        const { cid } = cellView;
        const { _views } = this;
        const refs = _views[cid];
        if (!refs) return;
        if (id) delete refs[id];
        for(let _ in refs)return;
        delete _views[cid];
    },
    remove (cellView, id = null) {
        toArray(this.get(cellView, id)).forEach((view)=>{
            view.remove();
        });
    },
    getAll (paper, id = null) {
        const views = [];
        const { _views } = this;
        for(let cid in _views){
            for(let hid in _views[cid]){
                const view = _views[cid][hid];
                if (view.cellView.paper === paper && view instanceof this && (id === null || hid === id)) {
                    views.push(view);
                }
            }
        }
        return views;
    },
    removeAll (paper, id = null) {
        this.getAll(paper, id).forEach((view)=>view.remove());
    },
    update (cellView, id = null, dirty = false) {
        toArray(this.get(cellView, id)).forEach((view)=>{
            if (dirty || view.UPDATABLE) view.update();
        });
    },
    transform (cellView, id = null) {
        toArray(this.get(cellView, id)).forEach((view)=>{
            if (view.UPDATABLE) view.transform();
        });
    },
    unmount (cellView, id = null) {
        toArray(this.get(cellView, id)).forEach((view)=>view.unmount());
    },
    mount (cellView, id = null) {
        toArray(this.get(cellView, id)).forEach((view)=>view.mount());
    },
    uniqueId (node, opt = '') {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ensureId(node) + JSON.stringify(opt);
    }
});
}}),
"[project]/node_modules/@joint/core/src/dia/CellView.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CellView": (()=>CellView)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$View$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/mvc/View.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/utilHelpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/util.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/mvc/Dom/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/V/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/point.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$eval$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/attributes/eval.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/rect.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/HighlighterView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$config$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/config/index.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const HighlightingTypes = {
    DEFAULT: 'default',
    EMBEDDING: 'embedding',
    CONNECTING: 'connecting',
    MAGNET_AVAILABILITY: 'magnetAvailability',
    ELEMENT_AVAILABILITY: 'elementAvailability'
};
const Flags = {
    TOOLS: 'TOOLS'
};
const CellView = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$View$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"].extend({
    tagName: 'g',
    svgElement: true,
    selector: 'root',
    metrics: null,
    className: function() {
        var classNames = [
            'cell'
        ];
        var type = this.model.get('type');
        if (type) {
            type.toLowerCase().split('.').forEach(function(value, index, list) {
                classNames.push('type-' + list.slice(0, index + 1).join('-'));
            });
        }
        return classNames.join(' ');
    },
    _presentationAttributes: null,
    _flags: null,
    setFlags: function() {
        var flags = {};
        var attributes = {};
        var shift = 0;
        var i, n, label;
        var presentationAttributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["result"])(this, 'presentationAttributes');
        for(var attribute in presentationAttributes){
            if (!presentationAttributes.hasOwnProperty(attribute)) continue;
            var labels = presentationAttributes[attribute];
            if (!Array.isArray(labels)) labels = [
                labels
            ];
            for(i = 0, n = labels.length; i < n; i++){
                label = labels[i];
                var flag = flags[label];
                if (!flag) {
                    flag = flags[label] = 1 << shift++;
                }
                attributes[attribute] |= flag;
            }
        }
        var initFlag = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["result"])(this, 'initFlag');
        if (!Array.isArray(initFlag)) initFlag = [
            initFlag
        ];
        for(i = 0, n = initFlag.length; i < n; i++){
            label = initFlag[i];
            if (!flags[label]) flags[label] = 1 << shift++;
        }
        // 26 - 30 are reserved for paper flags
        // 31+ overflows maximal number
        if (shift > 25) throw new Error('dia.CellView: Maximum number of flags exceeded.');
        this._flags = flags;
        this._presentationAttributes = attributes;
    },
    hasFlag: function(flag, label) {
        return flag & this.getFlag(label);
    },
    removeFlag: function(flag, label) {
        return flag ^ flag & this.getFlag(label);
    },
    getFlag: function(label) {
        var flags = this._flags;
        if (!flags) return 0;
        var flag = 0;
        if (Array.isArray(label)) {
            for(var i = 0, n = label.length; i < n; i++)flag |= flags[label[i]];
        } else {
            flag |= flags[label];
        }
        return flag;
    },
    attributes: function() {
        var cell = this.model;
        return {
            'model-id': cell.id,
            'data-type': cell.attributes.type
        };
    },
    constructor: function(options) {
        // Make sure a global unique id is assigned to this view. Store this id also to the properties object.
        // The global unique id makes sure that the same view can be rendered on e.g. different machines and
        // still be associated to the same object among all those clients. This is necessary for real-time
        // collaboration mechanism.
        options.id = options.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["guid"])(this);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$View$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"].call(this, options);
    },
    initialize: function() {
        this.setFlags();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$View$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"].prototype.initialize.apply(this, arguments);
        this.cleanNodesCache();
        this.startListening();
    },
    startListening: function() {
        this.listenTo(this.model, 'change', this.onAttributesChange);
    },
    onAttributesChange: function(model, opt) {
        var flag = model.getChangeFlag(this._presentationAttributes);
        if (opt.updateHandled || !flag) return;
        if (opt.dirty && this.hasFlag(flag, 'UPDATE')) flag |= this.getFlag('RENDER');
        // TODO: tool changes does not need to be sync
        // Fix Segments tools
        if (opt.tool) opt.async = false;
        this.requestUpdate(flag, opt);
    },
    requestUpdate: function(flags, opt) {
        const { paper } = this;
        if (paper && flags > 0) {
            paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);
        }
    },
    parseDOMJSON: function(markup, root) {
        var doc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parseDOMJSON"])(markup);
        var selectors = doc.selectors;
        var groups = doc.groupSelectors;
        for(var group in groups){
            if (selectors[group]) throw new Error('dia.CellView: ambiguous group selector');
            selectors[group] = groups[group];
        }
        if (root) {
            var rootSelector = this.selector;
            if (selectors[rootSelector]) throw new Error('dia.CellView: ambiguous root selector.');
            selectors[rootSelector] = root;
        }
        return {
            fragment: doc.fragment,
            selectors: selectors
        };
    },
    // Return `true` if cell link is allowed to perform a certain UI `feature`.
    // Example: `can('labelMove')`.
    can: function(feature) {
        var interactive = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(this.options.interactive) ? this.options.interactive(this) : this.options.interactive;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(interactive) && interactive[feature] !== false || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBoolean"])(interactive) && interactive !== false;
    },
    findBySelector: function(selector, root, selectors) {
        // These are either descendants of `this.$el` of `this.$el` itself.
        // `.` is a special selector used to select the wrapping `<g>` element.
        if (!selector || selector === '.') return [
            root
        ];
        if (selectors) {
            var nodes = selectors[selector];
            if (nodes) {
                if (Array.isArray(nodes)) return nodes;
                return [
                    nodes
                ];
            }
        }
        // Maintaining backwards compatibility
        // e.g. `circle:first` would fail with querySelector() call
        if (this.useCSSSelectors) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(root).find(selector).toArray();
        return [];
    },
    findNodes: function(selector) {
        return this.findBySelector(selector, this.el, this.selectors);
    },
    findNode: function(selector) {
        const [node = null] = this.findNodes(selector);
        return node;
    },
    notify: function(eventName) {
        if (this.paper) {
            var args = Array.prototype.slice.call(arguments, 1);
            // Trigger the event on both the element itself and also on the paper.
            this.trigger.apply(this, [
                eventName
            ].concat(args));
            // Paper event handlers receive the view object as the first argument.
            this.paper.trigger.apply(this.paper, [
                eventName,
                this
            ].concat(args));
        }
    },
    getBBox: function(opt) {
        var bbox;
        if (opt && opt.useModelGeometry) {
            var model = this.model;
            bbox = model.getBBox().bbox(model.angle());
        } else {
            bbox = this.getNodeBBox(this.el);
        }
        return this.paper.localToPaperRect(bbox);
    },
    getNodeBBox: function(magnet) {
        const rect = this.getNodeBoundingRect(magnet);
        const transformMatrix = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(magnet));
        const magnetMatrix = this.getNodeMatrix(magnet);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformRect(rect, transformMatrix.multiply(magnetMatrix));
    },
    getNodeRotateMatrix (node) {
        if (!this.rotatableNode || this.rotatableNode.contains(node)) {
            // Rotate transformation is applied to all nodes when no rotatableGroup
            // is present or to nodes inside the rotatableGroup only.
            return this.getRootRotateMatrix();
        }
        // Nodes outside the rotatable group
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createSVGMatrix();
    },
    getNodeUnrotatedBBox: function(magnet) {
        var rect = this.getNodeBoundingRect(magnet);
        var magnetMatrix = this.getNodeMatrix(magnet);
        var translateMatrix = this.getRootTranslateMatrix();
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformRect(rect, translateMatrix.multiply(magnetMatrix));
    },
    getRootTranslateMatrix: function() {
        var model = this.model;
        var position = model.position();
        var mt = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createSVGMatrix().translate(position.x, position.y);
        return mt;
    },
    getRootRotateMatrix: function() {
        var mr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createSVGMatrix();
        var model = this.model;
        var angle = model.angle();
        if (angle) {
            var bbox = model.getBBox();
            var cx = bbox.width / 2;
            var cy = bbox.height / 2;
            mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);
        }
        return mr;
    },
    _notifyHighlight: function(eventName, el, opt = {}) {
        const { el: rootNode } = this;
        let node;
        if (typeof el === 'string') {
            node = this.findNode(el) || rootNode;
        } else {
            [node = rootNode] = this.$(el);
        }
        // set partial flag if the highlighted element is not the entire view.
        opt.partial = node !== rootNode;
        // translate type flag into a type string
        if (opt.type === undefined) {
            let type;
            switch(true){
                case opt.embedding:
                    type = HighlightingTypes.EMBEDDING;
                    break;
                case opt.connecting:
                    type = HighlightingTypes.CONNECTING;
                    break;
                case opt.magnetAvailability:
                    type = HighlightingTypes.MAGNET_AVAILABILITY;
                    break;
                case opt.elementAvailability:
                    type = HighlightingTypes.ELEMENT_AVAILABILITY;
                    break;
                default:
                    type = HighlightingTypes.DEFAULT;
                    break;
            }
            opt.type = type;
        }
        this.notify(eventName, node, opt);
        return this;
    },
    highlight: function(el, opt) {
        return this._notifyHighlight('cell:highlight', el, opt);
    },
    unhighlight: function(el, opt = {}) {
        return this._notifyHighlight('cell:unhighlight', el, opt);
    },
    // Find the closest element that has the `magnet` attribute set to `true`. If there was not such
    // an element found, return the root element of the cell view.
    findMagnet: function(el) {
        const root = this.el;
        let magnet = this.$(el)[0];
        if (!magnet) {
            magnet = root;
        }
        do {
            const magnetAttribute = magnet.getAttribute('magnet');
            const isMagnetRoot = magnet === root;
            if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {
                return magnet;
            }
            if (isMagnetRoot) {
                // If the overall cell has set `magnet === false`, then return `undefined` to
                // announce there is no magnet found for this cell.
                // This is especially useful to set on cells that have 'ports'. In this case,
                // only the ports have set `magnet === true` and the overall element has `magnet === false`.
                return undefined;
            }
            magnet = magnet.parentNode;
        }while (magnet)
        return undefined;
    },
    findProxyNode: function(el, type) {
        el || (el = this.el);
        const nodeSelector = el.getAttribute(`${type}-selector`);
        if (nodeSelector) {
            const proxyNode = this.findNode(nodeSelector);
            if (proxyNode) return proxyNode;
        }
        return el;
    },
    // Construct a unique selector for the `el` element within this view.
    // `prevSelector` is being collected through the recursive call.
    // No value for `prevSelector` is expected when using this method.
    getSelector: function(el, prevSelector) {
        var selector;
        if (el === this.el) {
            if (typeof prevSelector === 'string') selector = ':scope > ' + prevSelector;
            return selector;
        }
        if (el) {
            var nthChild = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(el).index() + 1;
            selector = el.tagName + ':nth-child(' + nthChild + ')';
            if (prevSelector) {
                selector += ' > ' + prevSelector;
            }
            selector = this.getSelector(el.parentNode, selector);
        }
        return selector;
    },
    addLinkFromMagnet: function(magnet, x, y) {
        var paper = this.paper;
        var graph = paper.model;
        var link = paper.getDefaultLink(this, magnet);
        link.set({
            source: this.getLinkEnd(magnet, x, y, link, 'source'),
            target: {
                x: x,
                y: y
            }
        }).addTo(graph, {
            async: false,
            ui: true
        });
        return link.findView(paper);
    },
    getLinkEnd: function(magnet, ...args) {
        const model = this.model;
        const id = model.id;
        // Find a node with the `port` attribute set on it.
        const portNode = this.findAttributeNode('port', magnet);
        // Find a unique `selector` of the element under pointer that is a magnet.
        const selector = magnet.getAttribute('joint-selector');
        const end = {
            id: id
        };
        if (selector != null) end.magnet = selector;
        if (portNode != null) {
            let port = portNode.getAttribute('port');
            if (portNode.getAttribute('port-id-type') === 'number') {
                port = parseInt(port, 10);
            }
            end.port = port;
            if (!model.hasPort(port) && !selector) {
                // port created via the `port` attribute (not API)
                end.selector = this.getSelector(magnet);
            }
        } else if (selector == null && this.el !== magnet) {
            end.selector = this.getSelector(magnet);
        }
        return this.customizeLinkEnd(end, magnet, ...args);
    },
    customizeLinkEnd: function(end, magnet, x, y, link, endType) {
        const { paper } = this;
        const { connectionStrategy } = paper.options;
        if (typeof connectionStrategy === 'function') {
            var strategy = connectionStrategy.call(paper, end, this, magnet, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](x, y), link, endType, paper);
            if (strategy) return strategy;
        }
        return end;
    },
    getMagnetFromLinkEnd: function(end) {
        var port = end.port;
        var selector = end.magnet;
        var model = this.model;
        var magnet;
        if (port != null && model.isElement() && model.hasPort(port)) {
            magnet = this.findPortNode(port, selector) || this.el;
        } else {
            if (!selector) selector = end.selector;
            if (!selector && port != null) {
                // link end has only `id` and `port` property referencing
                // a port created via the `port` attribute (not API).
                selector = '[port="' + port + '"]';
            }
            magnet = this.findNode(selector);
        }
        return this.findProxyNode(magnet, 'magnet');
    },
    dragLinkStart: function(evt, magnet, x, y) {
        this.model.startBatch('add-link');
        const linkView = this.addLinkFromMagnet(magnet, x, y);
        // backwards compatibility events
        linkView.notifyPointerdown(evt, x, y);
        linkView.eventData(evt, linkView.startArrowheadMove('target', {
            whenNotAllowed: 'remove'
        }));
        this.eventData(evt, {
            linkView
        });
    },
    dragLink: function(evt, x, y) {
        var data = this.eventData(evt);
        var linkView = data.linkView;
        if (linkView) {
            linkView.pointermove(evt, x, y);
        } else {
            var paper = this.paper;
            var magnetThreshold = paper.options.magnetThreshold;
            var currentTarget = this.getEventTarget(evt);
            var targetMagnet = data.targetMagnet;
            if (magnetThreshold === 'onleave') {
                // magnetThreshold when the pointer leaves the magnet
                if (targetMagnet === currentTarget || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(targetMagnet).contains(currentTarget)) return;
            } else {
                // magnetThreshold defined as a number of movements
                if (paper.eventData(evt).mousemoved <= magnetThreshold) return;
            }
            this.dragLinkStart(evt, targetMagnet, x, y);
        }
    },
    dragLinkEnd: function(evt, x, y) {
        var data = this.eventData(evt);
        var linkView = data.linkView;
        if (!linkView) return;
        linkView.pointerup(evt, x, y);
        this.model.stopBatch('add-link');
    },
    getAttributeDefinition: function(attrName) {
        return this.model.constructor.getAttributeDefinition(attrName);
    },
    setNodeAttributes: function(node, attrs) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmpty"])(attrs)) {
            if (node instanceof SVGElement) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(node).attr(attrs);
            } else {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(node).attr(attrs);
            }
        }
    },
    processNodeAttributes: function(node, attrs) {
        var attrName, attrVal, def, i, n;
        var normalAttrs, setAttrs, positionAttrs, offsetAttrs;
        var relatives = [];
        const rawAttrs = {};
        for(attrName in attrs){
            if (!attrs.hasOwnProperty(attrName)) continue;
            rawAttrs[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].attributeNames[attrName]] = attrs[attrName];
        }
        // divide the attributes between normal and special
        for(attrName in rawAttrs){
            if (!rawAttrs.hasOwnProperty(attrName)) continue;
            attrVal = rawAttrs[attrName];
            def = this.getAttributeDefinition(attrName);
            if (def) {
                if (attrVal === null) {
                    // Assign the unset attribute name.
                    let unsetAttrName;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(def.unset)) {
                        unsetAttrName = def.unset.call(this, node, rawAttrs, this);
                    } else {
                        unsetAttrName = def.unset;
                    }
                    if (!unsetAttrName && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(def.set)) {
                        // We unset an alias attribute.
                        unsetAttrName = def.set;
                    }
                    if (!unsetAttrName) {
                        // There is no alias for the attribute. We unset the attribute itself.
                        unsetAttrName = attrName;
                    }
                    // Unset the attribute.
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(unsetAttrName) && unsetAttrName) {
                        // Unset a single attribute.
                        normalAttrs || (normalAttrs = {});
                        // values takes precedence over unset values
                        if (unsetAttrName in normalAttrs) continue;
                        normalAttrs[unsetAttrName] = attrVal;
                    } else if (Array.isArray(unsetAttrName) && unsetAttrName.length > 0) {
                        // Unset multiple attributes.
                        normalAttrs || (normalAttrs = {});
                        for(i = 0, n = unsetAttrName.length; i < n; i++){
                            const attrName = unsetAttrName[i];
                            // values takes precedence over unset values
                            if (attrName in normalAttrs) continue;
                            normalAttrs[attrName] = attrVal;
                        }
                    }
                // The unset value is neither a string nor an array.
                // The attribute is not unset.
                } else {
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(def.qualify) || def.qualify.call(this, attrVal, node, rawAttrs, this)) {
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(def.set)) {
                            // An alias e.g 'xlink:href' -> 'href'
                            normalAttrs || (normalAttrs = {});
                            normalAttrs[def.set] = attrVal;
                        }
                        relatives.push(attrName, def);
                    } else {
                        normalAttrs || (normalAttrs = {});
                        normalAttrs[attrName] = attrVal;
                    }
                }
            } else {
                normalAttrs || (normalAttrs = {});
                normalAttrs[attrName] = attrVal;
            }
        }
        // handle the rest of attributes via related method
        // from the special attributes namespace.
        for(i = 0, n = relatives.length; i < n; i += 2){
            attrName = relatives[i];
            def = relatives[i + 1];
            attrVal = attrs[attrName];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(def.set)) {
                setAttrs || (setAttrs = {});
                setAttrs[attrName] = attrVal;
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(def.position)) {
                positionAttrs || (positionAttrs = {});
                positionAttrs[attrName] = attrVal;
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(def.offset)) {
                offsetAttrs || (offsetAttrs = {});
                offsetAttrs[attrName] = attrVal;
            }
        }
        return {
            raw: rawAttrs,
            normal: normalAttrs,
            set: setAttrs,
            position: positionAttrs,
            offset: offsetAttrs
        };
    },
    updateRelativeAttributes: function(node, attrs, refBBox, opt) {
        opt || (opt = {});
        var attrName, attrVal, def;
        var evalAttrs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$eval$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["evalAttributes"])(attrs.raw || {}, refBBox);
        var nodeAttrs = attrs.normal || {};
        for(const nodeAttrName in nodeAttrs){
            nodeAttrs[nodeAttrName] = evalAttrs[nodeAttrName];
        }
        var setAttrs = attrs.set;
        var positionAttrs = attrs.position;
        var offsetAttrs = attrs.offset;
        for(attrName in setAttrs){
            attrVal = evalAttrs[attrName];
            def = this.getAttributeDefinition(attrName);
            // SET - set function should return attributes to be set on the node,
            // which will affect the node dimensions based on the reference bounding
            // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points
            var setResult = def.set.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(setResult)) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(nodeAttrs, setResult);
            } else if (setResult !== undefined) {
                nodeAttrs[attrName] = setResult;
            }
        }
        if (node instanceof HTMLElement) {
            // TODO: setting the `transform` attribute on HTMLElements
            // via `node.style.transform = 'matrix(...)';` would introduce
            // a breaking change (e.g. basic.TextBlock).
            this.setNodeAttributes(node, nodeAttrs);
            return;
        }
        // The final translation of the subelement.
        var nodeTransform = nodeAttrs.transform;
        var nodeMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformStringToMatrix(nodeTransform);
        var nodePosition = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"])(nodeMatrix.e, nodeMatrix.f);
        if (nodeTransform) {
            nodeAttrs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["omit"])(nodeAttrs, 'transform');
            nodeMatrix.e = nodeMatrix.f = 0;
        }
        // Calculate node scale determined by the scalable group
        // only if later needed.
        var sx, sy, translation;
        if (positionAttrs || offsetAttrs) {
            var nodeScale = this.getNodeScale(node, opt.scalableNode);
            sx = nodeScale.sx;
            sy = nodeScale.sy;
        }
        var positioned = false;
        for(attrName in positionAttrs){
            attrVal = evalAttrs[attrName];
            def = this.getAttributeDefinition(attrName);
            // POSITION - position function should return a point from the
            // reference bounding box. The default position of the node is x:0, y:0 of
            // the reference bounding box or could be further specify by some
            // SVG attributes e.g. `x`, `y`
            translation = def.position.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);
            if (translation) {
                nodePosition.offset((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"])(translation).scale(sx, sy));
                positioned || (positioned = true);
            }
        }
        // The node bounding box could depend on the `size` set from the previous loop.
        // Here we know, that all the size attributes have been already set.
        this.setNodeAttributes(node, nodeAttrs);
        var offseted = false;
        if (offsetAttrs) {
            // Check if the node is visible
            var nodeBoundingRect = this.getNodeBoundingRect(node);
            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {
                var nodeBBox = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);
                for(attrName in offsetAttrs){
                    attrVal = evalAttrs[attrName];
                    def = this.getAttributeDefinition(attrName);
                    // OFFSET - offset function should return a point from the element
                    // bounding box. The default offset point is x:0, y:0 (origin) or could be further
                    // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`
                    translation = def.offset.call(this, attrVal, nodeBBox, node, evalAttrs, this);
                    if (translation) {
                        nodePosition.offset((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"])(translation).scale(sx, sy));
                        offseted || (offseted = true);
                    }
                }
            }
        }
        // Do not touch node's transform attribute if there is no transformation applied.
        if (nodeTransform !== undefined || positioned || offseted) {
            // Round the coordinates to 1 decimal point.
            nodePosition.round(1);
            nodeMatrix.e = nodePosition.x;
            nodeMatrix.f = nodePosition.y;
            node.setAttribute('transform', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].matrixToTransformString(nodeMatrix));
        // TODO: store nodeMatrix metrics?
        }
    },
    getNodeScale: function(node, scalableNode) {
        // Check if the node is a descendant of the scalable group.
        var sx, sy;
        if (scalableNode && scalableNode.contains(node)) {
            var scale = scalableNode.scale();
            sx = 1 / scale.sx;
            sy = 1 / scale.sy;
        } else {
            sx = 1;
            sy = 1;
        }
        return {
            sx: sx,
            sy: sy
        };
    },
    cleanNodesCache: function() {
        this.metrics = {};
    },
    cleanNodeCache: function(node) {
        const id = node.id;
        if (!id) return;
        delete this.metrics[id];
    },
    nodeCache: function(magnet) {
        var metrics = this.metrics;
        // Don't use cache? It most likely a custom view with overridden update.
        if (!metrics) return {};
        var id = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ensureId(magnet);
        var value = metrics[id];
        if (!value) value = metrics[id] = {};
        return value;
    },
    getNodeData: function(magnet) {
        var metrics = this.nodeCache(magnet);
        if (!metrics.data) metrics.data = {};
        return metrics.data;
    },
    getNodeBoundingRect: function(magnet) {
        var metrics = this.nodeCache(magnet);
        if (metrics.boundingRect === undefined) metrics.boundingRect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(magnet).getBBox();
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](metrics.boundingRect);
    },
    getNodeMatrix: function(magnet) {
        const metrics = this.nodeCache(magnet);
        if (metrics.magnetMatrix === undefined) {
            const { rotatableNode, el } = this;
            let target;
            if (rotatableNode && rotatableNode.contains(magnet)) {
                target = rotatableNode;
            } else {
                target = el;
            }
            metrics.magnetMatrix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(magnet).getTransformToElement(target);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createSVGMatrix(metrics.magnetMatrix);
    },
    getNodeShape: function(magnet) {
        var metrics = this.nodeCache(magnet);
        if (metrics.geometryShape === undefined) metrics.geometryShape = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(magnet).toGeometryShape();
        return metrics.geometryShape.clone();
    },
    isNodeConnection: function(node) {
        return this.model.isLink() && (!node || node === this.el);
    },
    findNodesAttributes: function(attrs, root, selectorCache, selectors) {
        var i, n, nodeAttrs, nodeId;
        var nodesAttrs = {};
        var mergeIds = [];
        for(var selector in attrs){
            if (!attrs.hasOwnProperty(selector)) continue;
            nodeAttrs = attrs[selector];
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(nodeAttrs)) continue; // Not a valid selector-attributes pair
            var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);
            for(i = 0, n = selected.length; i < n; i++){
                var node = selected[i];
                nodeId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ensureId(node);
                // "unique" selectors are selectors that referencing a single node (defined by `selector`)
                // groupSelector referencing a single node is not "unique"
                var unique = selectors && selectors[selector] === node;
                var prevNodeAttrs = nodesAttrs[nodeId];
                if (prevNodeAttrs) {
                    // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.
                    // e.g. css:`.circle` and selector:`circle` can be applied in a random order
                    if (!prevNodeAttrs.array) {
                        mergeIds.push(nodeId);
                        prevNodeAttrs.array = true;
                        prevNodeAttrs.attributes = [
                            prevNodeAttrs.attributes
                        ];
                        prevNodeAttrs.selectedLength = [
                            prevNodeAttrs.selectedLength
                        ];
                    }
                    var attributes = prevNodeAttrs.attributes;
                    var selectedLength = prevNodeAttrs.selectedLength;
                    if (unique) {
                        // node referenced by `selector`
                        attributes.unshift(nodeAttrs);
                        selectedLength.unshift(-1);
                    } else {
                        // node referenced by `groupSelector`
                        var sortIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sortedIndex"])(selectedLength, n);
                        attributes.splice(sortIndex, 0, nodeAttrs);
                        selectedLength.splice(sortIndex, 0, n);
                    }
                } else {
                    nodesAttrs[nodeId] = {
                        attributes: nodeAttrs,
                        selectedLength: unique ? -1 : n,
                        node: node,
                        array: false
                    };
                }
            }
        }
        for(i = 0, n = mergeIds.length; i < n; i++){
            nodeId = mergeIds[i];
            nodeAttrs = nodesAttrs[nodeId];
            nodeAttrs.attributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])({}, ...nodeAttrs.attributes.reverse());
        }
        return nodesAttrs;
    },
    getEventTarget: function(evt, opt = {}) {
        const { target, type, clientX = 0, clientY = 0 } = evt;
        if (// Explicitly defined `fromPoint` option
        opt.fromPoint || // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.
        // It holds the element when a touchstart triggered.
        type === 'touchmove' || type === 'touchend' || 'pointerId' in evt && target.hasPointerCapture(evt.pointerId)) {
            return document.elementFromPoint(clientX, clientY);
        }
        return target;
    },
    // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,
    // unless `attrs` parameter was passed.
    updateDOMSubtreeAttributes: function(rootNode, attrs, opt) {
        opt || (opt = {});
        opt.rootBBox || (opt.rootBBox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"])());
        opt.selectors || (opt.selectors = this.selectors); // selector collection to use
        // Cache table for query results and bounding box calculation.
        // Note that `selectorCache` needs to be invalidated for all
        // `updateAttributes` calls, as the selectors might pointing
        // to nodes designated by an attribute or elements dynamically
        // created.
        var selectorCache = {};
        var bboxCache = {};
        var relativeItems = [];
        var relativeRefItems = [];
        var item, node, nodeAttrs, nodeData, processedAttrs;
        var roAttrs = opt.roAttributes;
        var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);
        // `nodesAttrs` are different from all attributes, when
        // rendering only  attributes sent to this method.
        var nodesAllAttrs = roAttrs ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors) : nodesAttrs;
        for(var nodeId in nodesAttrs){
            nodeData = nodesAttrs[nodeId];
            nodeAttrs = nodeData.attributes;
            node = nodeData.node;
            processedAttrs = this.processNodeAttributes(node, nodeAttrs);
            if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset && !processedAttrs.raw.ref) {
                // Set all the normal attributes right on the SVG/HTML element.
                this.setNodeAttributes(node, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$eval$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["evalAttributes"])(processedAttrs.normal, opt.rootBBox));
            } else {
                var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;
                var refSelector = nodeAllAttrs && nodeAttrs.ref === undefined ? nodeAllAttrs.ref : nodeAttrs.ref;
                var refNode;
                if (refSelector) {
                    refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];
                    if (!refNode) {
                        throw new Error('dia.CellView: "' + refSelector + '" reference does not exist.');
                    }
                } else {
                    refNode = null;
                }
                item = {
                    node: node,
                    refNode: refNode,
                    processedAttributes: processedAttrs,
                    allAttributes: nodeAllAttrs
                };
                if (refNode) {
                    // If an element in the list is positioned relative to this one, then
                    // we want to insert this one before it in the list.
                    var itemIndex = relativeRefItems.findIndex(function(item) {
                        return item.refNode === node;
                    });
                    if (itemIndex > -1) {
                        relativeRefItems.splice(itemIndex, 0, item);
                    } else {
                        relativeRefItems.push(item);
                    }
                } else {
                    // A node with no ref attribute. To be updated before the nodes referencing other nodes.
                    // The order of no-ref-items is not specified/important.
                    relativeItems.push(item);
                }
            }
        }
        relativeItems.push(...relativeRefItems);
        for(let i = 0, n = relativeItems.length; i < n; i++){
            item = relativeItems[i];
            node = item.node;
            refNode = item.refNode;
            // Find the reference element bounding box. If no reference was provided, we
            // use the optional bounding box.
            const refNodeId = refNode ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ensureId(refNode) : '';
            let refBBox = bboxCache[refNodeId];
            if (!refBBox) {
                // Get the bounding box of the reference element using to the common ancestor
                // transformation space.
                //
                // @example 1
                // <g transform="translate(11, 13)">
                //     <rect @selector="b" x="1" y="2" width="3" height="4"/>
                //     <rect @selector="a"/>
                // </g>
                //
                // In this case, the reference bounding box can not be affected
                // by the `transform` attribute of the `<g>` element,
                // because the exact transformation will be applied to the `a` element
                // as well as to the `b` element.
                //
                // @example 2
                // <g transform="translate(11, 13)">
                //     <rect @selector="b" x="1" y="2" width="3" height="4"/>
                // </g>
                // <rect @selector="a"/>
                //
                // In this case, the reference bounding box have to be affected by the
                // `transform` attribute of the `<g>` element, because the `a` element
                // is not descendant of the `<g>` element and will not be affected
                // by the transformation.
                refBBox = bboxCache[refNodeId] = refNode ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(refNode).getBBox({
                    target: getCommonAncestorNode(node, refNode)
                }) : opt.rootBBox;
            }
            if (roAttrs) {
                // if there was a special attribute affecting the position amongst passed-in attributes
                // we have to merge it with the rest of the element's attributes as they are necessary
                // to update the position relatively (i.e `ref-x` && 'ref-dx')
                processedAttrs = this.processNodeAttributes(node, item.allAttributes);
                this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);
            } else {
                processedAttrs = item.processedAttributes;
            }
            this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);
        }
    },
    mergeProcessedAttributes: function(processedAttrs, roProcessedAttrs) {
        processedAttrs.set || (processedAttrs.set = {});
        processedAttrs.position || (processedAttrs.position = {});
        processedAttrs.offset || (processedAttrs.offset = {});
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(processedAttrs.set, roProcessedAttrs.set);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(processedAttrs.position, roProcessedAttrs.position);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(processedAttrs.offset, roProcessedAttrs.offset);
        // Handle also the special transform property.
        var transform = processedAttrs.normal && processedAttrs.normal.transform;
        if (transform !== undefined && roProcessedAttrs.normal) {
            roProcessedAttrs.normal.transform = transform;
        }
        processedAttrs.normal = roProcessedAttrs.normal;
    },
    // Lifecycle methods
    // Called when the view is attached to the DOM,
    // as result of `cell.addTo(graph)` being called (isInitialMount === true)
    // or `paper.options.viewport` returning `true` (isInitialMount === false).
    onMount (isInitialMount) {
        if (isInitialMount) return;
        this.mountTools();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HighlighterView"].mount(this);
    },
    // Called when the view is detached from the DOM,
    // as result of `paper.options.viewport` returning `false`.
    onDetach () {
        this.unmountTools();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HighlighterView"].unmount(this);
    },
    // Called when the view is removed from the DOM
    // as result of `cell.remove()`.
    onRemove: function() {
        this.removeTools();
        this.removeHighlighters();
    },
    _toolsView: null,
    hasTools: function(name) {
        var toolsView = this._toolsView;
        if (!toolsView) return false;
        if (!name) return true;
        return toolsView.getName() === name;
    },
    addTools: function(toolsView) {
        this.removeTools();
        if (toolsView) {
            this._toolsView = toolsView;
            toolsView.configure({
                relatedView: this
            });
            toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));
        }
        return this;
    },
    unmountTools () {
        const toolsView = this._toolsView;
        if (toolsView) toolsView.unmount();
        return this;
    },
    mountTools () {
        const toolsView = this._toolsView;
        // Prevent unnecessary re-appending of the tools.
        if (toolsView && !toolsView.isMounted()) toolsView.mount();
        return this;
    },
    updateTools: function(opt) {
        var toolsView = this._toolsView;
        if (toolsView) toolsView.update(opt);
        return this;
    },
    removeTools: function() {
        var toolsView = this._toolsView;
        if (toolsView) {
            toolsView.remove();
            this._toolsView = null;
        }
        return this;
    },
    hideTools: function() {
        var toolsView = this._toolsView;
        if (toolsView) toolsView.hide();
        return this;
    },
    showTools: function() {
        var toolsView = this._toolsView;
        if (toolsView) toolsView.show();
        return this;
    },
    onToolEvent: function(event) {
        switch(event){
            case 'remove':
                this.removeTools();
                break;
            case 'hide':
                this.hideTools();
                break;
            case 'show':
                this.showTools();
                break;
        }
    },
    removeHighlighters: function() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HighlighterView"].remove(this);
    },
    updateHighlighters: function(dirty = false) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HighlighterView"].update(this, null, dirty);
    },
    transformHighlighters: function() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HighlighterView"].transform(this);
    },
    // Interaction. The controller part.
    // ---------------------------------
    preventDefaultInteraction (evt) {
        this.eventData(evt, {
            defaultInteractionPrevented: true
        });
    },
    isDefaultInteractionPrevented (evt) {
        const { defaultInteractionPrevented = false } = this.eventData(evt);
        return defaultInteractionPrevented;
    },
    // Interaction is handled by the paper and delegated to the view in interest.
    // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.
    // If necessary, real coordinates can be obtained from the `evt` event object.
    // These functions are supposed to be overridden by the views that inherit from `joint.dia.Cell`,
    // i.e. `joint.dia.Element` and `joint.dia.Link`.
    pointerdblclick: function(evt, x, y) {
        this.notify('cell:pointerdblclick', evt, x, y);
    },
    pointerclick: function(evt, x, y) {
        this.notify('cell:pointerclick', evt, x, y);
    },
    contextmenu: function(evt, x, y) {
        this.notify('cell:contextmenu', evt, x, y);
    },
    pointerdown: function(evt, x, y) {
        const { model } = this;
        const { graph } = model;
        if (graph) {
            model.startBatch('pointer');
            this.eventData(evt, {
                graph
            });
        }
        this.notify('cell:pointerdown', evt, x, y);
    },
    pointermove: function(evt, x, y) {
        this.notify('cell:pointermove', evt, x, y);
    },
    pointerup: function(evt, x, y) {
        const { graph } = this.eventData(evt);
        this.notify('cell:pointerup', evt, x, y);
        if (graph) {
            // we don't want to trigger event on model as model doesn't
            // need to be member of collection anymore (remove)
            graph.stopBatch('pointer', {
                cell: this.model
            });
        }
    },
    mouseover: function(evt) {
        this.notify('cell:mouseover', evt);
    },
    mouseout: function(evt) {
        this.notify('cell:mouseout', evt);
    },
    mouseenter: function(evt) {
        this.notify('cell:mouseenter', evt);
    },
    mouseleave: function(evt) {
        this.notify('cell:mouseleave', evt);
    },
    mousewheel: function(evt, x, y, delta) {
        this.notify('cell:mousewheel', evt, x, y, delta);
    },
    onevent: function(evt, eventName, x, y) {
        this.notify(eventName, evt, x, y);
    },
    onmagnet: function() {
    // noop
    },
    magnetpointerdblclick: function() {
    // noop
    },
    magnetcontextmenu: function() {
    // noop
    },
    checkMouseleave (evt) {
        const { paper, model } = this;
        if (paper.isAsync()) {
            // Make sure the source/target views are updated before this view.
            // It's not 100% bulletproof (see below) but it's a good enough solution for now.
            // The connected cells could be links as well. In that case, we would
            // need to recursively go through all the connected links and update
            // their source/target views as well.
            if (model.isLink()) {
                // The `this.sourceView` and `this.targetView` might not be updated yet.
                // We need to find the view by the model.
                const sourceElement = model.getSourceElement();
                if (sourceElement) {
                    const sourceView = paper.findViewByModel(sourceElement);
                    if (sourceView) {
                        paper.dumpView(sourceView);
                        paper.checkViewVisibility(sourceView);
                    }
                }
                const targetElement = model.getTargetElement();
                if (targetElement) {
                    const targetView = paper.findViewByModel(targetElement);
                    if (targetView) {
                        paper.dumpView(targetView);
                        paper.checkViewVisibility(targetView);
                    }
                }
            }
            // Do the updates of the current view synchronously now
            paper.dumpView(this);
            paper.checkViewVisibility(this);
        }
        const target = this.getEventTarget(evt, {
            fromPoint: true
        });
        const view = paper.findView(target);
        if (view === this) return;
        // Leaving the current view
        this.mouseleave(evt);
        if (!view) return;
        // Entering another view
        view.mouseenter(evt);
    },
    setInteractivity: function(value) {
        this.options.interactive = value;
    },
    isIntersecting: function(geometryShape, geometryData) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["intersection"].exists(geometryShape, this.getNodeBBox(this.el), geometryData);
    },
    isEnclosedIn: function(geometryRect) {
        return geometryRect.containsRect(this.getNodeBBox(this.el));
    },
    isInArea: function(geometryRect, options = {}) {
        if (options.strict) {
            return this.isEnclosedIn(geometryRect);
        }
        return this.isIntersecting(geometryRect);
    },
    isAtPoint: function(point, options) {
        return this.getNodeBBox(this.el).containsPoint(point, options);
    }
}, {
    Flags,
    Highlighting: HighlightingTypes,
    addPresentationAttributes: function(presentationAttributes) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])({}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["result"])(this.prototype, 'presentationAttributes'), presentationAttributes, function(a, b) {
            if (!a || !b) return;
            if (typeof a === 'string') a = [
                a
            ];
            if (typeof b === 'string') b = [
                b
            ];
            if (Array.isArray(a) && Array.isArray(b)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uniq"])(a.concat(b));
        });
    },
    evalAttribute: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$eval$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["evalAttribute"]
});
Object.defineProperty(CellView.prototype, 'useCSSSelectors', {
    get () {
        const localUse = this.model.useCSSSelectors;
        if (localUse !== undefined) return localUse;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$config$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["config"].useCSSSelectors;
    }
});
// TODO: Move to Vectorizer library.
function getCommonAncestorNode(node1, node2) {
    let parent = node1;
    do {
        if (parent.contains(node2)) return parent;
        parent = parent.parentNode;
    }while (parent)
    return null;
}
}}),
"[project]/node_modules/@joint/core/src/dia/ports.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "elementPortPrototype": (()=>elementPortPrototype),
    "elementViewPortPrototype": (()=>elementViewPortPrototype)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$layout$2f$ports$2f$port$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/layout/ports/port.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$layout$2f$ports$2f$portLabel$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/layout/ports/portLabel.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/point.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/rect.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/V/index.mjs [app-client] (ecmascript)");
;
;
;
;
;
var PortData = function(data) {
    var clonedData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.cloneDeep(data) || {};
    this.ports = [];
    this.groups = {};
    this.portLayoutNamespace = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$layout$2f$ports$2f$port$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__;
    this.portLabelLayoutNamespace = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$layout$2f$ports$2f$portLabel$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__;
    this._init(clonedData);
};
PortData.prototype = {
    getPorts: function() {
        return this.ports;
    },
    getGroup: function(name) {
        return this.groups[name] || {};
    },
    getPortsByGroup: function(groupName) {
        return this.ports.filter(function(port) {
            return port.group === groupName;
        });
    },
    getGroupPortsMetrics: function(groupName, elBBox) {
        var group = this.getGroup(groupName);
        var ports = this.getPortsByGroup(groupName);
        var groupPosition = group.position || {};
        var groupPositionName = groupPosition.name;
        var namespace = this.portLayoutNamespace;
        if (!namespace[groupPositionName]) {
            groupPositionName = 'left';
        }
        var groupArgs = groupPosition.args || {};
        var portsArgs = ports.map(function(port) {
            return port && port.position && port.position.args;
        });
        var groupPortTransformations = namespace[groupPositionName](portsArgs, elBBox, groupArgs);
        var accumulator = {
            ports: ports,
            result: []
        };
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(groupPortTransformations).reduce((function(res, portTransformation, index) {
            var port = res.ports[index];
            res.result.push({
                portId: port.id,
                portTransformation: portTransformation,
                labelTransformation: this._getPortLabelLayout(port, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"])(portTransformation), elBBox),
                portAttrs: port.attrs,
                portSize: port.size,
                labelSize: port.label.size
            });
            return res;
        }).bind(this), accumulator);
        return accumulator.result;
    },
    _getPortLabelLayout: function(port, portPosition, elBBox) {
        var namespace = this.portLabelLayoutNamespace;
        var labelPosition = port.label.position.name || 'left';
        if (namespace[labelPosition]) {
            return namespace[labelPosition](portPosition, elBBox, port.label.position.args);
        }
        return null;
    },
    _init: function(data) {
        // prepare groups
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isObject(data.groups)) {
            var groups = Object.keys(data.groups);
            for(var i = 0, n = groups.length; i < n; i++){
                var key = groups[i];
                this.groups[key] = this._evaluateGroup(data.groups[key]);
            }
        }
        // prepare ports
        var ports = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(data.items);
        for(var j = 0, m = ports.length; j < m; j++){
            this.ports.push(this._evaluatePort(ports[j]));
        }
    },
    _evaluateGroup: function(group) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.merge(group, {
            position: this._getPosition(group.position, true),
            label: this._getLabel(group, true)
        });
    },
    _evaluatePort: function(port) {
        var evaluated = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign({}, port);
        var group = this.getGroup(port.group);
        evaluated.markup = evaluated.markup || group.markup;
        evaluated.attrs = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.merge({}, group.attrs, evaluated.attrs);
        evaluated.position = this._createPositionNode(group, evaluated);
        evaluated.label = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.merge({}, group.label, this._getLabel(evaluated));
        evaluated.z = this._getZIndex(group, evaluated);
        evaluated.size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign({}, group.size, evaluated.size);
        return evaluated;
    },
    _getZIndex: function(group, port) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isNumber(port.z)) {
            return port.z;
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isNumber(group.z) || group.z === 'auto') {
            return group.z;
        }
        return 'auto';
    },
    _createPositionNode: function(group, port) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.merge({
            name: 'left',
            args: {}
        }, group.position, {
            args: port.args
        });
    },
    _getPosition: function(position, setDefault) {
        var args = {};
        var positionName;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isFunction(position)) {
            positionName = 'fn';
            args.fn = position;
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isString(position)) {
            positionName = position;
        } else if (position === undefined) {
            positionName = setDefault ? 'left' : null;
        } else if (Array.isArray(position)) {
            positionName = 'absolute';
            args.x = position[0];
            args.y = position[1];
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isObject(position)) {
            positionName = position.name;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign(args, position.args);
        }
        var result = {
            args: args
        };
        if (positionName) {
            result.name = positionName;
        }
        return result;
    },
    _getLabel: function(item, setDefaults) {
        var label = item.label || {};
        var ret = label;
        ret.position = this._getPosition(label.position, setDefaults);
        return ret;
    }
};
const elementPortPrototype = {
    _initializePorts: function() {
        this._createPortData();
        this.on('change:ports', function() {
            this._processRemovedPort();
            this._createPortData();
        }, this);
    },
    /**
     * remove links tied wiht just removed element
     * @private
     */ _processRemovedPort: function() {
        var current = this.get('ports') || {};
        var currentItemsMap = {};
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(current.items).forEach(function(item) {
            currentItemsMap[item.id] = true;
        });
        var previous = this.previous('ports') || {};
        var removed = {};
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(previous.items).forEach(function(item) {
            if (!currentItemsMap[item.id]) {
                removed[item.id] = true;
            }
        });
        var graph = this.graph;
        if (graph && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isEmpty(removed)) {
            var inboundLinks = graph.getConnectedLinks(this, {
                inbound: true
            });
            inboundLinks.forEach(function(link) {
                if (removed[link.get('target').port]) link.remove();
            });
            var outboundLinks = graph.getConnectedLinks(this, {
                outbound: true
            });
            outboundLinks.forEach(function(link) {
                if (removed[link.get('source').port]) link.remove();
            });
        }
    },
    /**
     * @returns {boolean}
     */ hasPorts: function() {
        var ports = this.prop('ports/items');
        return Array.isArray(ports) && ports.length > 0;
    },
    /**
     * @param {string} id
     * @returns {boolean}
     */ hasPort: function(id) {
        return this.getPortIndex(id) !== -1;
    },
    /**
     * @returns {Array<object>}
     */ getPorts: function() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.cloneDeep(this.prop('ports/items')) || [];
    },
    /**
     * @returns {Array<object>}
     */ getGroupPorts: function(groupName) {
        const groupPorts = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(this.prop([
            'ports',
            'items'
        ])).filter((port)=>port.group === groupName);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.cloneDeep(groupPorts);
    },
    /**
     * @param {string} id
     * @returns {object}
     */ getPort: function(id) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.cloneDeep(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(this.prop('ports/items')).find(function(port) {
            return port.id && port.id === id;
        }));
    },
    getPortGroupNames: function() {
        return Object.keys(this._portSettingsData.groups);
    },
    /**
     * @param {string} groupName
     * @returns {Object<portId, {x: number, y: number, angle: number}>}
     */ getPortsPositions: function(groupName) {
        var portsMetrics = this._portSettingsData.getGroupPortsMetrics(groupName, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"])(this.size()));
        return portsMetrics.reduce(function(positions, metrics) {
            var transformation = metrics.portTransformation;
            positions[metrics.portId] = {
                x: transformation.x,
                y: transformation.y,
                angle: transformation.angle
            };
            return positions;
        }, {});
    },
    /**
     * @param {string|Port} port port id or port
     * @returns {number} port index
     */ getPortIndex: function(port) {
        var id = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isObject(port) ? port.id : port;
        if (!this._isValidPortId(id)) {
            return -1;
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(this.prop('ports/items')).findIndex(function(item) {
            return item.id === id;
        });
    },
    /**
     * @param {object} port
     * @param {object} [opt]
     * @returns {joint.dia.Element}
     */ addPort: function(port, opt) {
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isObject(port) || Array.isArray(port)) {
            throw new Error('Element: addPort requires an object.');
        }
        var ports = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign([], this.prop('ports/items'));
        ports.push(port);
        this.prop('ports/items', ports, opt);
        return this;
    },
    /**
     * @param {string|Port|number} before
     * @param {object} port
     * @param {object} [opt]
     * @returns {joint.dia.Element}
     */ insertPort: function(before, port, opt) {
        const index = typeof before === 'number' ? before : this.getPortIndex(before);
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isObject(port) || Array.isArray(port)) {
            throw new Error('dia.Element: insertPort requires an object.');
        }
        const ports = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign([], this.prop('ports/items'));
        ports.splice(index, 0, port);
        this.prop('ports/items', ports, opt);
        return this;
    },
    /**
     * @param {string} portId
     * @param {string|object=} path
     * @param {*=} value
     * @param {object=} opt
     * @returns {joint.dia.Element}
     */ portProp: function(portId, path, value, opt) {
        var index = this.getPortIndex(portId);
        if (index === -1) {
            throw new Error('Element: unable to find port with id ' + portId);
        }
        var args = Array.prototype.slice.call(arguments, 1);
        if (Array.isArray(path)) {
            args[0] = [
                'ports',
                'items',
                index
            ].concat(path);
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isString(path)) {
            // Get/set an attribute by a special path syntax that delimits
            // nested objects by the colon character.
            args[0] = [
                'ports/items/',
                index,
                '/',
                path
            ].join('');
        } else {
            args = [
                'ports/items/' + index
            ];
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isPlainObject(path)) {
                args.push(path);
                args.push(value);
            }
        }
        return this.prop.apply(this, args);
    },
    _validatePorts: function() {
        var portsAttr = this.get('ports') || {};
        var errorMessages = [];
        portsAttr = portsAttr || {};
        var ports = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(portsAttr.items);
        ports.forEach(function(p) {
            if (typeof p !== 'object') {
                errorMessages.push('Element: invalid port ', p);
            }
            if (!this._isValidPortId(p.id)) {
                p.id = this.generatePortId();
            }
        }, this);
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.uniq(ports, 'id').length !== ports.length) {
            errorMessages.push('Element: found id duplicities in ports.');
        }
        return errorMessages;
    },
    generatePortId: function() {
        return this.generateId();
    },
    /**
     * @param {string} id port id
     * @returns {boolean}
     * @private
     */ _isValidPortId: function(id) {
        return id !== null && id !== undefined && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isObject(id);
    },
    addPorts: function(ports, opt) {
        if (ports.length) {
            this.prop('ports/items', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign([], this.prop('ports/items')).concat(ports), opt);
        }
        return this;
    },
    removePort: function(port, opt) {
        const options = opt || {};
        const index = this.getPortIndex(port);
        if (index !== -1) {
            const ports = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign([], this.prop([
                'ports',
                'items'
            ]));
            ports.splice(index, 1);
            options.rewrite = true;
            this.startBatch('port-remove');
            this.prop([
                'ports',
                'items'
            ], ports, options);
            this.stopBatch('port-remove');
        }
        return this;
    },
    removePorts: function(portsForRemoval, opt) {
        let options, newPorts;
        if (Array.isArray(portsForRemoval)) {
            options = opt || {};
            if (portsForRemoval.length === 0) return this.this;
            const currentPorts = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign([], this.prop([
                'ports',
                'items'
            ]));
            newPorts = currentPorts.filter(function(cp) {
                return !portsForRemoval.some(function(rp) {
                    const rpId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isObject(rp) ? rp.id : rp;
                    return cp.id === rpId;
                });
            });
        } else {
            options = portsForRemoval || {};
            newPorts = [];
        }
        this.startBatch('port-remove');
        options.rewrite = true;
        this.prop([
            'ports',
            'items'
        ], newPorts, options);
        this.stopBatch('port-remove');
        return this;
    },
    /**
     * @private
     */ _createPortData: function() {
        var err = this._validatePorts();
        if (err.length > 0) {
            this.set('ports', this.previous('ports'));
            throw new Error(err.join(' '));
        }
        var prevPortData;
        if (this._portSettingsData) {
            prevPortData = this._portSettingsData.getPorts();
        }
        this._portSettingsData = new PortData(this.get('ports'));
        var curPortData = this._portSettingsData.getPorts();
        if (prevPortData) {
            var added = curPortData.filter(function(item) {
                if (!prevPortData.find(function(prevPort) {
                    return prevPort.id === item.id;
                })) {
                    return item;
                }
            });
            var removed = prevPortData.filter(function(item) {
                if (!curPortData.find(function(curPort) {
                    return curPort.id === item.id;
                })) {
                    return item;
                }
            });
            if (removed.length > 0) {
                this.trigger('ports:remove', this, removed);
            }
            if (added.length > 0) {
                this.trigger('ports:add', this, added);
            }
        }
    }
};
const elementViewPortPrototype = {
    portContainerMarkup: 'g',
    portMarkup: [
        {
            tagName: 'circle',
            selector: 'circle',
            attributes: {
                'r': 10,
                'fill': '#FFFFFF',
                'stroke': '#000000'
            }
        }
    ],
    portLabelMarkup: [
        {
            tagName: 'text',
            selector: 'text',
            attributes: {
                'fill': '#000000'
            }
        }
    ],
    /** @type {Object<string, {portElement: Vectorizer, portLabelElement: Vectorizer}>} */ _portElementsCache: null,
    /**
     * @private
     */ _initializePorts: function() {
        this._cleanPortsCache();
    },
    /**
     * @typedef {Object} Port
     *
     * @property {string} id
     * @property {Object} position
     * @property {Object} label
     * @property {Object} attrs
     * @property {string} markup
     * @property {string} group
     */ /**
     * @private
     */ _refreshPorts: function() {
        this._removePorts();
        this._cleanPortsCache();
        this._renderPorts();
    },
    _cleanPortsCache: function() {
        this._portElementsCache = {};
    },
    /**
     * @private
     */ _renderPorts: function() {
        // references to rendered elements without z-index
        var elementReferences = [];
        var elem = this._getContainerElement();
        for(var i = 0, count = elem.node.childNodes.length; i < count; i++){
            elementReferences.push(elem.node.childNodes[i]);
        }
        var portsGropsByZ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.groupBy(this.model._portSettingsData.getPorts(), 'z');
        var withoutZKey = 'auto';
        // render non-z first
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(portsGropsByZ[withoutZKey]).forEach(function(port) {
            var portElement = this._getPortElement(port);
            elem.append(portElement);
            elementReferences.push(portElement);
        }, this);
        var groupNames = Object.keys(portsGropsByZ);
        for(var k = 0; k < groupNames.length; k++){
            var groupName = groupNames[k];
            if (groupName !== withoutZKey) {
                var z = parseInt(groupName, 10);
                this._appendPorts(portsGropsByZ[groupName], z, elementReferences);
            }
        }
        this._updatePorts();
    },
    /**
     * @returns {V}
     * @private
     */ _getContainerElement: function() {
        return this.rotatableNode || this.vel;
    },
    /**
     * @param {Array<Port>}ports
     * @param {number} z
     * @param refs
     * @private
     */ _appendPorts: function(ports, z, refs) {
        var containerElement = this._getContainerElement();
        var portElements = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(ports).map(this._getPortElement, this);
        if (refs[z] || z < 0) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(refs[Math.max(z, 0)]).before(portElements);
        } else {
            containerElement.append(portElements);
        }
    },
    /**
     * Try to get element from cache,
     * @param port
     * @returns {*}
     * @private
     */ _getPortElement: function(port) {
        if (this._portElementsCache[port.id]) {
            return this._portElementsCache[port.id].portElement;
        }
        return this._createPortElement(port);
    },
    findPortNodes: function(portId, selector) {
        const portCache = this._portElementsCache[portId];
        if (!portCache) return [];
        if (!selector) return [
            portCache.portContentElement.node
        ];
        const portRoot = portCache.portElement.node;
        const portSelectors = portCache.portSelectors;
        return this.findBySelector(selector, portRoot, portSelectors);
    },
    findPortNode: function(portId, selector) {
        const [node = null] = this.findPortNodes(portId, selector);
        return node;
    },
    /**
     * @private
     */ _updatePorts: function() {
        // layout ports without group
        this._updatePortGroup(undefined);
        // layout ports with explicit group
        var groupsNames = Object.keys(this.model._portSettingsData.groups);
        groupsNames.forEach(this._updatePortGroup, this);
    },
    /**
     * @private
     */ _removePorts: function() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.invoke(this._portElementsCache, 'portElement.remove');
    },
    /**
     * @param {Port} port
     * @returns {V}
     * @private
     */ _createPortElement: function(port) {
        let portElement;
        let labelElement;
        let labelSelectors;
        let portSelectors;
        var portContainerElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.portContainerMarkup).addClass('joint-port');
        var portMarkup = this._getPortMarkup(port);
        if (Array.isArray(portMarkup)) {
            var portDoc = this.parseDOMJSON(portMarkup, portContainerElement.node);
            var portFragment = portDoc.fragment;
            if (portFragment.childNodes.length > 1) {
                portElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('g').append(portFragment);
            } else {
                portElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(portFragment.firstChild);
            }
            portSelectors = portDoc.selectors;
        } else {
            portElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(portMarkup);
            if (Array.isArray(portElement)) {
                portElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('g').append(portElement);
            }
        }
        if (!portElement) {
            throw new Error('ElementView: Invalid port markup.');
        }
        portElement.attr({
            'port': port.id,
            'port-group': port.group
        });
        // If the port ID is a number, we need to add
        // extra information to the port element to distinguish
        // between ports with the same ID but different types.
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isNumber(port.id)) {
            portElement.attr('port-id-type', 'number');
        }
        const labelMarkupDef = this._getPortLabelMarkup(port.label);
        if (Array.isArray(labelMarkupDef)) {
            // JSON Markup
            const { fragment, selectors } = this.parseDOMJSON(labelMarkupDef, portContainerElement.node);
            const childCount = fragment.childNodes.length;
            if (childCount > 0) {
                labelSelectors = selectors;
                labelElement = childCount === 1 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(fragment.firstChild) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('g').append(fragment);
            }
        } else {
            // String Markup
            labelElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(labelMarkupDef);
            if (Array.isArray(labelElement)) {
                labelElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('g').append(labelElement);
            }
        }
        var portContainerSelectors;
        if (portSelectors && labelSelectors) {
            for(var key in labelSelectors){
                if (portSelectors[key] && key !== this.selector) throw new Error('ElementView: selectors within port must be unique.');
            }
            portContainerSelectors = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign({}, portSelectors, labelSelectors);
        } else {
            portContainerSelectors = portSelectors || labelSelectors || {};
        }
        // The `portRootSelector` points to the root SVGNode of the port.
        // Either the implicit wrapping group <g/> in case the port consist of multiple SVGNodes.
        // Or the single SVGNode of the port.
        const portRootSelector = 'portRoot';
        // The `labelRootSelector` points to the root SVGNode of the label.
        const labelRootSelector = 'labelRoot';
        // The `labelTextSelector` points to all text SVGNodes of the label.
        const labelTextSelector = 'labelText';
        if (!(portRootSelector in portContainerSelectors)) {
            portContainerSelectors[portRootSelector] = portElement.node;
        }
        if (labelElement) {
            const labelNode = labelElement.node;
            if (!(labelRootSelector in portContainerSelectors)) {
                portContainerSelectors[labelRootSelector] = labelNode;
            }
            if (!(labelTextSelector in portContainerSelectors)) {
                // If the label is a <text> element, we can use it directly.
                // Otherwise, we need to find the <text> element within the label.
                const labelTextNode = labelElement.tagName() === 'TEXT' ? labelNode : Array.from(labelNode.querySelectorAll('text'));
                portContainerSelectors[labelTextSelector] = labelTextNode;
                if (!labelSelectors) labelSelectors = {};
                labelSelectors[labelTextSelector] = labelTextNode;
            }
        }
        portContainerElement.append(portElement.addClass('joint-port-body'));
        if (labelElement) {
            portContainerElement.append(labelElement.addClass('joint-port-label'));
        }
        this._portElementsCache[port.id] = {
            portElement: portContainerElement,
            portLabelElement: labelElement,
            portSelectors: portContainerSelectors,
            portLabelSelectors: labelSelectors,
            portContentElement: portElement,
            portContentSelectors: portSelectors
        };
        return portContainerElement;
    },
    /**
     * @param {string=} groupName
     * @private
     */ _updatePortGroup: function(groupName) {
        var elementBBox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"])(this.model.size());
        var portsMetrics = this.model._portSettingsData.getGroupPortsMetrics(groupName, elementBBox);
        for(var i = 0, n = portsMetrics.length; i < n; i++){
            var metrics = portsMetrics[i];
            var portId = metrics.portId;
            var cached = this._portElementsCache[portId] || {};
            var portTransformation = metrics.portTransformation;
            var labelTransformation = metrics.labelTransformation;
            if (labelTransformation && cached.portLabelElement) {
                this.updateDOMSubtreeAttributes(cached.portLabelElement.node, labelTransformation.attrs, {
                    rootBBox: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](metrics.labelSize),
                    selectors: cached.portLabelSelectors
                });
                this.applyPortTransform(cached.portLabelElement, labelTransformation, -portTransformation.angle || 0);
            }
            this.updateDOMSubtreeAttributes(cached.portElement.node, metrics.portAttrs, {
                rootBBox: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](metrics.portSize),
                selectors: cached.portSelectors
            });
            this.applyPortTransform(cached.portElement, portTransformation);
        }
    },
    /**
     * @param {Vectorizer} element
     * @param {{dx:number, dy:number, angle: number, attrs: Object, x:number: y:number}} transformData
     * @param {number=} initialAngle
     * @constructor
     */ applyPortTransform: function(element, transformData, initialAngle) {
        var matrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createSVGMatrix().rotate(initialAngle || 0).translate(transformData.x || 0, transformData.y || 0).rotate(transformData.angle || 0);
        element.transform(matrix, {
            absolute: true
        });
    },
    /**
     * @param {Port} port
     * @returns {string}
     * @private
     */ _getPortMarkup: function(port) {
        return port.markup || this.model.get('portMarkup') || this.model.portMarkup || this.portMarkup;
    },
    /**
     * @param {Object} label
     * @returns {string}
     * @private
     */ _getPortLabelMarkup: function(label) {
        return label.markup || this.model.get('portLabelMarkup') || this.model.portLabelMarkup || this.portLabelMarkup;
    }
};
}}),
"[project]/node_modules/@joint/core/src/dia/Element.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Element": (()=>Element)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Cell$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/Cell.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/utilHelpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/point.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/util.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$geometry$2e$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/geometry.helpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/rect.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$ports$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/ports.mjs [app-client] (ecmascript)");
;
;
;
;
const Element = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Cell$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Cell"].extend({
    defaults: {
        position: {
            x: 0,
            y: 0
        },
        size: {
            width: 1,
            height: 1
        },
        angle: 0
    },
    initialize: function() {
        this._initializePorts();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Cell$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Cell"].prototype.initialize.apply(this, arguments);
    },
    /**
     * @abstract
     */ _initializePorts: function() {
    // implemented in ports.js
    },
    _refreshPorts: function() {
    // implemented in ports.js
    },
    isElement: function() {
        return true;
    },
    position: function(x, y, opt) {
        const isSetter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(y);
        opt = (isSetter ? opt : x) || {};
        const { parentRelative, deep, restrictedArea } = opt;
        // option `parentRelative` for setting the position relative to the element's parent.
        let parentPosition;
        if (parentRelative) {
            // Getting the parent's position requires the collection.
            // Cell.parent() holds cell id only.
            if (!this.graph) throw new Error('Element must be part of a graph.');
            const parent = this.getParentCell();
            if (parent && !parent.isLink()) {
                parentPosition = parent.get('position');
            }
        }
        if (isSetter) {
            if (parentPosition) {
                x += parentPosition.x;
                y += parentPosition.y;
            }
            if (deep || restrictedArea) {
                const { x: x0, y: y0 } = this.get('position');
                this.translate(x - x0, y - y0, opt);
            } else {
                this.set('position', {
                    x,
                    y
                }, opt);
            }
            return this;
        } else {
            const elementPosition = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"])(this.get('position'));
            return parentRelative ? elementPosition.difference(parentPosition) : elementPosition;
        }
    },
    translate: function(tx, ty, opt) {
        tx = tx || 0;
        ty = ty || 0;
        if (tx === 0 && ty === 0) {
            // Like nothing has happened.
            return this;
        }
        opt = opt || {};
        // Pass the initiator of the translation.
        opt.translateBy = opt.translateBy || this.id;
        var position = this.get('position') || {
            x: 0,
            y: 0
        };
        var ra = opt.restrictedArea;
        if (ra && opt.translateBy === this.id) {
            if (typeof ra === 'function') {
                var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);
                tx = newPosition.x - position.x;
                ty = newPosition.y - position.y;
            } else {
                // We are restricting the translation for the element itself only. We get
                // the bounding box of the element including all its embeds.
                // All embeds have to be translated the exact same way as the element.
                var bbox = this.getBBox({
                    deep: true
                });
                //- - - - - - - - - - - - -> ra.x + ra.width
                // - - - -> position.x      |
                // -> bbox.x
                //                   |
                //         
                //                 |
                //   
                //                  |
                //   <-dx->                     | restricted area right border
                //         <-width->        |    translated element
                //   <- - bbox.width - ->        embedded element
                var dx = position.x - bbox.x;
                var dy = position.y - bbox.y;
                // Find the maximal/minimal coordinates that the element can be translated
                // while complies the restrictions.
                var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));
                var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));
                // recalculate the translation taking the restrictions into account.
                tx = x - position.x;
                ty = y - position.y;
            }
        }
        var translatedPosition = {
            x: position.x + tx,
            y: position.y + ty
        };
        // To find out by how much an element was translated in event 'change:position' handlers.
        opt.tx = tx;
        opt.ty = ty;
        if (opt.transition) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(opt.transition)) opt.transition = {};
            this.transition('position', translatedPosition, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])({}, opt.transition, {
                valueFunction: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["interpolate"].object
            }));
            // Recursively call `translate()` on all the embeds cells.
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["invoke"])(this.getEmbeddedCells(), 'translate', tx, ty, opt);
        } else {
            this.startBatch('translate', opt);
            this.set('position', translatedPosition, opt);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["invoke"])(this.getEmbeddedCells(), 'translate', tx, ty, opt);
            this.stopBatch('translate', opt);
        }
        return this;
    },
    size: function(width, height, opt) {
        var currentSize = this.get('size');
        // Getter
        // () signature
        if (width === undefined) {
            return {
                width: currentSize.width,
                height: currentSize.height
            };
        }
        // Setter
        // (size, opt) signature
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(width)) {
            opt = height;
            height = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(width.height) ? width.height : currentSize.height;
            width = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(width.width) ? width.width : currentSize.width;
        }
        return this.resize(width, height, opt);
    },
    resize: function(width, height, opt) {
        opt = opt || {};
        this.startBatch('resize', opt);
        if (opt.direction) {
            var currentSize = this.get('size');
            switch(opt.direction){
                case 'left':
                case 'right':
                    // Don't change height when resizing horizontally.
                    height = currentSize.height;
                    break;
                case 'top':
                case 'bottom':
                    // Don't change width when resizing vertically.
                    width = currentSize.width;
                    break;
            }
            // Get the angle and clamp its value between 0 and 360 degrees.
            var angle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$geometry$2e$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeAngle"])(this.get('angle') || 0);
            // This is a rectangle in size of the un-rotated element.
            var bbox = this.getBBox();
            var origin;
            if (angle) {
                var quadrant = {
                    'top-right': 0,
                    'right': 0,
                    'top-left': 1,
                    'top': 1,
                    'bottom-left': 2,
                    'left': 2,
                    'bottom-right': 3,
                    'bottom': 3
                }[opt.direction];
                if (opt.absolute) {
                    // We are taking the element's rotation into account
                    quadrant += Math.floor((angle + 45) / 90);
                    quadrant %= 4;
                }
                // Pick the corner point on the element, which meant to stay on its place before and
                // after the rotation.
                var fixedPoint = bbox[[
                    'bottomLeft',
                    'corner',
                    'topRight',
                    'origin'
                ][quadrant]]();
                // Find  an image of the previous indent point. This is the position, where is the
                // point actually located on the screen.
                var imageFixedPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"])(fixedPoint).rotate(bbox.center(), -angle);
                // Every point on the element rotates around a circle with the centre of rotation
                // in the middle of the element while the whole element is being rotated. That means
                // that the distance from a point in the corner of the element (supposed its always rect) to
                // the center of the element doesn't change during the rotation and therefore it equals
                // to a distance on un-rotated element.
                // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.
                var radius = Math.sqrt(width * width + height * height) / 2;
                // Now we are looking for an angle between x-axis and the line starting at image of fixed point
                // and ending at the center of the element. We call this angle `alpha`.
                // The image of a fixed point is located in n-th quadrant. For each quadrant passed
                // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.
                //
                // 3 | 2
                // --c-- Quadrant positions around the element's center `c`
                // 0 | 1
                //
                var alpha = quadrant * Math.PI / 2;
                // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis
                // going through the center of the element) and line crossing the indent of the fixed point and the center
                // of the element. This is the angle we need but on the un-rotated element.
                alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);
                // Lastly we have to deduct the original angle the element was rotated by and that's it.
                alpha -= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$geometry$2e$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toRad"])(angle);
                // With this angle and distance we can easily calculate the centre of the un-rotated element.
                // Note that fromPolar constructor accepts an angle in radians.
                var center = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].fromPolar(radius, alpha, imageFixedPoint);
                // The top left corner on the un-rotated element has to be half a width on the left
                // and half a height to the top from the center. This will be the origin of rectangle
                // we were looking for.
                origin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"])(center).offset(width / -2, height / -2);
            } else {
                // calculation for the origin Point when there is no rotation of the element
                origin = bbox.topLeft();
                switch(opt.direction){
                    case 'top':
                    case 'top-right':
                        origin.offset(0, bbox.height - height);
                        break;
                    case 'left':
                    case 'bottom-left':
                        origin.offset(bbox.width - width, 0);
                        break;
                    case 'top-left':
                        origin.offset(bbox.width - width, bbox.height - height);
                        break;
                }
            }
            // Resize the element (before re-positioning it).
            this.set('size', {
                width: width,
                height: height
            }, opt);
            // Finally, re-position the element.
            this.position(origin.x, origin.y, opt);
        } else {
            // Resize the element.
            this.set('size', {
                width: width,
                height: height
            }, opt);
        }
        this.stopBatch('resize', opt);
        return this;
    },
    scale: function(sx, sy, origin, opt) {
        var scaledBBox = this.getBBox().scale(sx, sy, origin);
        this.startBatch('scale', opt);
        this.position(scaledBBox.x, scaledBBox.y, opt);
        this.resize(scaledBBox.width, scaledBBox.height, opt);
        this.stopBatch('scale');
        return this;
    },
    fitEmbeds: function(opt) {
        return this.fitToChildren(opt);
    },
    fitToChildren: function(opt = {}) {
        // Getting the children's size and position requires the collection.
        // Cell.get('embeds') holds an array of cell ids only.
        const { graph } = this;
        if (!graph) throw new Error('Element must be part of a graph.');
        const childElements = this.getEmbeddedCells().filter((cell)=>cell.isElement());
        if (childElements.length === 0) return this;
        this.startBatch('fit-embeds', opt);
        if (opt.deep) {
            // `opt.deep = true` means "fit to all descendants".
            // As the first action of the fitting algorithm, recursively apply `fitToChildren()` on all descendants.
            // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant, then go up (= this element).
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["invoke"])(childElements, 'fitToChildren', opt);
        }
        // Set new size and position of this element, based on:
        // - union of bboxes of all children
        // - inflated by given `opt.padding`
        this._fitToElements(Object.assign({
            elements: childElements
        }, opt));
        this.stopBatch('fit-embeds');
        return this;
    },
    fitParent: function(opt = {}) {
        const { graph } = this;
        if (!graph) throw new Error('Element must be part of a graph.');
        // When `opt.deep = true`, we want `opt.terminator` to be the last ancestor processed.
        // If the current element is `opt.terminator`, it means that this element has already been processed as parent so we can exit now.
        if (opt.deep && opt.terminator && (opt.terminator === this || opt.terminator === this.id)) return this;
        const parentElement = this.getParentCell();
        if (!parentElement || !parentElement.isElement()) return this;
        // Get all children of parent element (i.e. this element + any sibling elements).
        const siblingElements = parentElement.getEmbeddedCells().filter((cell)=>cell.isElement());
        if (siblingElements.length === 0) return this;
        this.startBatch('fit-parent', opt);
        // Set new size and position of parent element, based on:
        // - union of bboxes of all children of parent element (i.e. this element + any sibling elements)
        // - inflated by given `opt.padding`
        parentElement._fitToElements(Object.assign({
            elements: siblingElements
        }, opt));
        if (opt.deep) {
            // `opt.deep = true` means "fit all ancestors to their respective children".
            // As the last action of the fitting algorithm, recursively apply `fitParent()` on all ancestors.
            // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant (= this element), then go up.
            parentElement.fitParent(opt);
        }
        this.stopBatch('fit-parent');
        return this;
    },
    // Assumption: This element is part of a graph.
    _fitToElements: function(opt = {}) {
        const elementsBBox = this.graph.getCellsBBox(opt.elements);
        // If no `opt.elements` were provided, do nothing.
        if (!elementsBBox) return;
        const { expandOnly, shrinkOnly } = opt;
        // This combination is meaningless, do nothing.
        if (expandOnly && shrinkOnly) return;
        // Calculate new size and position of this element based on:
        // - union of bboxes of `opt.elements`
        // - inflated by `opt.padding` (if not provided, all four properties = 0)
        let { x, y, width, height } = elementsBBox;
        const { left, right, top, bottom } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeSides"])(opt.padding);
        x -= left;
        y -= top;
        width += left + right;
        height += bottom + top;
        let resultBBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](x, y, width, height);
        if (expandOnly) {
            // Non-shrinking is enforced by taking union of this element's current bbox with bbox calculated from `opt.elements`.
            resultBBox = this.getBBox().union(resultBBox);
        } else if (shrinkOnly) {
            // Non-expansion is enforced by taking intersection of this element's current bbox with bbox calculated from `opt.elements`.
            const intersectionBBox = this.getBBox().intersect(resultBBox);
            // If all children are outside this element's current bbox, then `intersectionBBox` is `null` - does not make sense, do nothing.
            if (!intersectionBBox) return;
            resultBBox = intersectionBBox;
        }
        // Set the new size and position of this element.
        this.set({
            position: {
                x: resultBBox.x,
                y: resultBBox.y
            },
            size: {
                width: resultBBox.width,
                height: resultBBox.height
            }
        }, opt);
    },
    // Rotate element by `angle` degrees, optionally around `origin` point.
    // If `origin` is not provided, it is considered to be the center of the element.
    // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not
    // the difference from the previous angle.
    rotate: function(angle, absolute, origin, opt) {
        if (origin) {
            var center = this.getBBox().center();
            var size = this.get('size');
            var position = this.get('position');
            center.rotate(origin, this.get('angle') - angle);
            var dx = center.x - size.width / 2 - position.x;
            var dy = center.y - size.height / 2 - position.y;
            this.startBatch('rotate', {
                angle: angle,
                absolute: absolute,
                origin: origin
            });
            this.position(position.x + dx, position.y + dy, opt);
            this.rotate(angle, absolute, null, opt);
            this.stopBatch('rotate');
        } else {
            this.set('angle', absolute ? angle : (this.get('angle') + angle) % 360, opt);
        }
        return this;
    },
    angle: function() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$geometry$2e$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeAngle"])(this.get('angle') || 0);
    },
    getBBox: function(opt = {}) {
        const { graph, attributes } = this;
        const { deep, rotate } = opt;
        if (deep && graph) {
            // Get all the embedded elements using breadth first algorithm.
            const elements = this.getEmbeddedCells({
                deep: true,
                breadthFirst: true
            });
            // Add the model itself.
            elements.push(this);
            // Note: the default of getCellsBBox() is rotate=true and can't be
            // changed without a breaking change
            return graph.getCellsBBox(elements, opt);
        }
        const { angle = 0, position: { x, y }, size: { width, height } } = attributes;
        const bbox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](x, y, width, height);
        if (rotate) {
            bbox.rotateAroundCenter(angle);
        }
        return bbox;
    },
    getPointFromConnectedLink: function(link, endType) {
        // Center of the model
        var bbox = this.getBBox();
        var center = bbox.center();
        // Center of a port
        var endDef = link.get(endType);
        if (!endDef) return center;
        var portId = endDef.port;
        if (!portId || !this.hasPort(portId)) return center;
        var portGroup = this.portProp(portId, [
            'group'
        ]);
        var portsPositions = this.getPortsPositions(portGroup);
        var portCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](portsPositions[portId]).offset(bbox.origin());
        var angle = this.angle();
        if (angle) portCenter.rotate(center, -angle);
        return portCenter;
    }
});
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(Element.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$ports$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["elementPortPrototype"]);
}}),
"[project]/node_modules/@joint/core/src/dia/ElementView.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ElementView": (()=>ElementView)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/CellView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/rect.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/V/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/utilHelpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Cell$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/Cell.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$geometry$2e$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/geometry.helpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$ports$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/ports.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
const Flags = {
    TOOLS: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].Flags.TOOLS,
    UPDATE: 'UPDATE',
    TRANSLATE: 'TRANSLATE',
    RESIZE: 'RESIZE',
    PORTS: 'PORTS',
    ROTATE: 'ROTATE',
    RENDER: 'RENDER'
};
const DragActions = {
    MOVE: 'move',
    MAGNET: 'magnet'
};
const ElementView = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].extend({
    /**
     * @abstract
     */ _removePorts: function() {
    // implemented in ports.js
    },
    /**
     *
     * @abstract
     */ _renderPorts: function() {
    // implemented in ports.js
    },
    className: function() {
        var classNames = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.className.apply(this).split(' ');
        classNames.push('element');
        return classNames.join(' ');
    },
    initialize: function() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.initialize.apply(this, arguments);
        this._initializePorts();
    },
    presentationAttributes: {
        'attrs': [
            Flags.UPDATE
        ],
        'position': [
            Flags.TRANSLATE,
            Flags.TOOLS
        ],
        'size': [
            Flags.RESIZE,
            Flags.PORTS,
            Flags.TOOLS
        ],
        'angle': [
            Flags.ROTATE,
            Flags.TOOLS
        ],
        'markup': [
            Flags.RENDER
        ],
        'ports': [
            Flags.PORTS
        ]
    },
    initFlag: [
        Flags.RENDER
    ],
    UPDATE_PRIORITY: 0,
    confirmUpdate: function(flag, opt) {
        const { useCSSSelectors } = this;
        if (this.hasFlag(flag, Flags.PORTS)) {
            this._removePorts();
            this._cleanPortsCache();
        }
        let transformHighlighters = false;
        if (this.hasFlag(flag, Flags.RENDER)) {
            this.render();
            this.updateTools(opt);
            this.updateHighlighters(true);
            transformHighlighters = true;
            flag = this.removeFlag(flag, [
                Flags.RENDER,
                Flags.UPDATE,
                Flags.RESIZE,
                Flags.TRANSLATE,
                Flags.ROTATE,
                Flags.PORTS,
                Flags.TOOLS
            ]);
        } else {
            let updateHighlighters = false;
            // Skip this branch if render is required
            if (this.hasFlag(flag, Flags.RESIZE)) {
                this.resize(opt);
                updateHighlighters = true;
                // Resize method is calling `update()` internally
                flag = this.removeFlag(flag, [
                    Flags.RESIZE,
                    Flags.UPDATE
                ]);
                if (useCSSSelectors) {
                    // `resize()` rendered the ports when useCSSSelectors are enabled
                    flag = this.removeFlag(flag, Flags.PORTS);
                }
            }
            if (this.hasFlag(flag, Flags.UPDATE)) {
                this.update(this.model, null, opt);
                flag = this.removeFlag(flag, Flags.UPDATE);
                updateHighlighters = true;
                if (useCSSSelectors) {
                    // `update()` will render ports when useCSSSelectors are enabled
                    flag = this.removeFlag(flag, Flags.PORTS);
                }
            }
            if (this.hasFlag(flag, Flags.TRANSLATE)) {
                this.translate();
                flag = this.removeFlag(flag, Flags.TRANSLATE);
                transformHighlighters = true;
            }
            if (this.hasFlag(flag, Flags.ROTATE)) {
                this.rotate();
                flag = this.removeFlag(flag, Flags.ROTATE);
                transformHighlighters = true;
            }
            if (this.hasFlag(flag, Flags.PORTS)) {
                this._renderPorts();
                updateHighlighters = true;
                flag = this.removeFlag(flag, Flags.PORTS);
            }
            if (updateHighlighters) {
                this.updateHighlighters(false);
            }
        }
        if (transformHighlighters) {
            this.transformHighlighters();
        }
        if (this.hasFlag(flag, Flags.TOOLS)) {
            this.updateTools(opt);
            flag = this.removeFlag(flag, Flags.TOOLS);
        }
        return flag;
    },
    /**
     * @abstract
     */ _initializePorts: function() {
    // implemented in ports.js
    },
    update: function(_, renderingOnlyAttrs) {
        this.cleanNodesCache();
        // When CSS selector strings are used, make sure no rule matches port nodes.
        const { useCSSSelectors } = this;
        if (useCSSSelectors) this._removePorts();
        var model = this.model;
        var modelAttrs = model.attr();
        this.updateDOMSubtreeAttributes(this.el, modelAttrs, {
            rootBBox: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](model.size()),
            selectors: this.selectors,
            scalableNode: this.scalableNode,
            rotatableNode: this.rotatableNode,
            // Use rendering only attributes if they differs from the model attributes
            roAttributes: renderingOnlyAttrs === modelAttrs ? null : renderingOnlyAttrs
        });
        if (useCSSSelectors) {
            this._renderPorts();
        }
    },
    rotatableSelector: 'rotatable',
    scalableSelector: 'scalable',
    scalableNode: null,
    rotatableNode: null,
    // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the
    // default markup is not desirable.
    renderMarkup: function() {
        var element = this.model;
        var markup = element.get('markup') || element.markup;
        if (!markup) throw new Error('dia.ElementView: markup required');
        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);
        if (typeof markup === 'string') return this.renderStringMarkup(markup);
        throw new Error('dia.ElementView: invalid markup');
    },
    renderJSONMarkup: function(markup) {
        var doc = this.parseDOMJSON(markup, this.el);
        var selectors = this.selectors = doc.selectors;
        this.rotatableNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(selectors[this.rotatableSelector]) || null;
        this.scalableNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(selectors[this.scalableSelector]) || null;
        // Fragment
        this.vel.append(doc.fragment);
    },
    renderStringMarkup: function(markup) {
        var vel = this.vel;
        vel.append((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(markup));
        // Cache transformation groups
        this.rotatableNode = vel.findOne('.rotatable');
        this.scalableNode = vel.findOne('.scalable');
        var selectors = this.selectors = {};
        selectors[this.selector] = this.el;
    },
    render: function() {
        this.vel.empty();
        this.renderMarkup();
        if (this.scalableNode) {
            // Double update is necessary for elements with the scalable group only
            // Note the resize() triggers the other `update`.
            this.update();
        }
        this.resize();
        if (this.rotatableNode) {
            // Translate transformation is applied on `this.el` while the rotation transformation
            // on `this.rotatableNode`
            this.rotate();
            this.translate();
        } else {
            this.updateTransformation();
        }
        if (!this.useCSSSelectors) this._renderPorts();
        return this;
    },
    resize: function(opt) {
        if (this.scalableNode) return this.sgResize(opt);
        if (this.model.attributes.angle) this.rotate();
        this.update();
    },
    translate: function() {
        if (this.rotatableNode) return this.rgTranslate();
        this.updateTransformation();
    },
    rotate: function() {
        if (this.rotatableNode) {
            this.rgRotate();
            // It's necessary to call the update for the nodes outside
            // the rotatable group referencing nodes inside the group
            this.update();
            return;
        }
        this.updateTransformation();
    },
    updateTransformation: function() {
        var transformation = this.getTranslateString();
        var rotateString = this.getRotateString();
        if (rotateString) transformation += ' ' + rotateString;
        this.vel.attr('transform', transformation);
    },
    getTranslateString: function() {
        const { x, y } = this.model.position();
        return `translate(${x},${y})`;
    },
    getRotateString: function() {
        const angle = this.model.angle();
        if (!angle) return null;
        const { width, height } = this.model.size();
        return `rotate(${angle},${width / 2},${height / 2})`;
    },
    // Rotatable & Scalable Group
    // always slower, kept mainly for backwards compatibility
    rgRotate: function() {
        this.rotatableNode.attr('transform', this.getRotateString());
    },
    rgTranslate: function() {
        this.vel.attr('transform', this.getTranslateString());
    },
    sgResize: function(opt) {
        var model = this.model;
        var angle = model.angle();
        var size = model.size();
        var scalable = this.scalableNode;
        // Getting scalable group's bbox.
        // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.
        // To work around the issue, we need to check whether there are any path elements inside the scalable group.
        var recursive = false;
        if (scalable.node.getElementsByTagName('path').length > 0) {
            // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.
            // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.
            recursive = true;
        }
        var scalableBBox = scalable.getBBox({
            recursive: recursive
        });
        // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making
        // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.
        var sx = size.width / (scalableBBox.width || 1);
        var sy = size.height / (scalableBBox.height || 1);
        scalable.attr('transform', 'scale(' + sx + ',' + sy + ')');
        // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`
        // Order of transformations is significant but we want to reconstruct the object always in the order:
        // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,
        // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the
        // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation
        // around the center of the resized object (which is a different origin then the origin of the previous rotation)
        // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.
        // Cancel the rotation but now around a different origin, which is the center of the scaled object.
        var rotatable = this.rotatableNode;
        var rotation = rotatable && rotatable.attr('transform');
        if (rotation) {
            rotatable.attr('transform', rotation + ' rotate(' + -angle + ',' + size.width / 2 + ',' + size.height / 2 + ')');
            var rotatableBBox = scalable.getBBox({
                target: this.paper.cells
            });
            // Store new x, y and perform rotate() again against the new rotation origin.
            model.set('position', {
                x: rotatableBBox.x,
                y: rotatableBBox.y
            }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])({
                updateHandled: true
            }, opt));
            this.translate();
            this.rotate();
        }
        // Update must always be called on non-rotated element. Otherwise, relative positioning
        // would work with wrong (rotated) bounding boxes.
        this.update();
    },
    // Embedding mode methods.
    // -----------------------
    prepareEmbedding: function(data = {}) {
        const element = data.model || this.model;
        const paper = data.paper || this.paper;
        const graph = paper.model;
        const initialZIndices = data.initialZIndices = {};
        const embeddedCells = element.getEmbeddedCells({
            deep: true
        });
        const connectedLinks = graph.getConnectedLinks(element, {
            deep: true,
            includeEnclosed: true
        });
        // Note: an embedded cell can be a connect link, but it's fine
        // to iterate over the cell twice.
        [
            element,
            ...embeddedCells,
            ...connectedLinks
        ].forEach((cell)=>initialZIndices[cell.id] = cell.attributes.z);
        element.startBatch('to-front');
        // Bring the model to the front with all his embeds.
        element.toFront({
            deep: true,
            ui: true
        });
        // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see
        // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.
        const maxZ = graph.getElements().reduce((max, cell)=>Math.max(max, cell.attributes.z || 0), 0);
        // Move to front also all the inbound and outbound links that are connected
        // to any of the element descendant. If we bring to front only embedded elements,
        // links connected to them would stay in the background.
        connectedLinks.forEach((link)=>{
            if (link.attributes.z <= maxZ) {
                link.set('z', maxZ + 1, {
                    ui: true
                });
            }
        });
        element.stopBatch('to-front');
        // Before we start looking for suitable parent we remove the current one.
        const parentId = element.parent();
        if (parentId) {
            const parent = graph.getCell(parentId);
            parent.unembed(element, {
                ui: true
            });
            data.initialParentId = parentId;
        } else {
            data.initialParentId = null;
        }
    },
    processEmbedding: function(data = {}, evt, x, y) {
        const model = data.model || this.model;
        const paper = data.paper || this.paper;
        const graph = paper.model;
        const { findParentBy, frontParentOnly, validateEmbedding } = paper.options;
        let candidates;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(findParentBy)) {
            candidates = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"])(findParentBy.call(graph, this, evt, x, y));
        } else if (findParentBy === 'pointer') {
            candidates = graph.findElementsAtPoint({
                x,
                y
            });
        } else {
            candidates = graph.findElementsUnderElement(model, {
                searchBy: findParentBy
            });
        }
        candidates = candidates.filter((el)=>{
            return el instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Cell$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Cell"] && model.id !== el.id && !el.isEmbeddedIn(model);
        });
        if (frontParentOnly) {
            // pick the element with the highest `z` index
            candidates = candidates.slice(-1);
        }
        let newCandidateView = null;
        const prevCandidateView = data.candidateEmbedView;
        // iterate over all candidates starting from the last one (has the highest z-index).
        for(let i = candidates.length - 1; i >= 0; i--){
            const candidate = candidates[i];
            if (prevCandidateView && prevCandidateView.model.id == candidate.id) {
                // candidate remains the same
                newCandidateView = prevCandidateView;
                break;
            } else {
                const view = candidate.findView(paper);
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(validateEmbedding) || validateEmbedding.call(paper, this, view)) {
                    // flip to the new candidate
                    newCandidateView = view;
                    break;
                }
            }
        }
        if (newCandidateView && newCandidateView != prevCandidateView) {
            // A new candidate view found. Highlight the new one.
            this.clearEmbedding(data);
            data.candidateEmbedView = newCandidateView.highlight(newCandidateView.findProxyNode(null, 'container'), {
                embedding: true
            });
        }
        if (!newCandidateView && prevCandidateView) {
            // No candidate view found. Unhighlight the previous candidate.
            this.clearEmbedding(data);
        }
    },
    clearEmbedding: function(data) {
        data || (data = {});
        var candidateView = data.candidateEmbedView;
        if (candidateView) {
            // No candidate view found. Unhighlight the previous candidate.
            candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), {
                embedding: true
            });
            data.candidateEmbedView = null;
        }
    },
    finalizeEmbedding: function(data = {}) {
        const candidateView = data.candidateEmbedView;
        const element = data.model || this.model;
        const paper = data.paper || this.paper;
        if (candidateView) {
            // We finished embedding. Candidate view is chosen to become the parent of the model.
            candidateView.model.embed(element, {
                ui: true
            });
            candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), {
                embedding: true
            });
            data.candidateEmbedView = null;
        } else {
            const { validateUnembedding } = paper.options;
            const { initialParentId } = data;
            // The element was originally embedded into another element.
            // The interaction would unembed the element. Let's validate
            // if the element can be unembedded.
            if (initialParentId && typeof validateUnembedding === 'function' && !validateUnembedding.call(paper, this)) {
                this._disallowUnembed(data);
                return;
            }
        }
        paper.model.getConnectedLinks(element, {
            deep: true
        }).forEach((link)=>{
            link.reparent({
                ui: true
            });
        });
    },
    _disallowUnembed: function(data) {
        const { model, whenNotAllowed = 'revert' } = data;
        const element = model || this.model;
        const paper = data.paper || this.paper;
        const graph = paper.model;
        switch(whenNotAllowed){
            case 'remove':
                {
                    element.remove({
                        ui: true
                    });
                    break;
                }
            case 'revert':
                {
                    const { initialParentId, initialPosition, initialZIndices } = data;
                    // Revert the element's position (and the position of its embedded cells if any)
                    if (initialPosition) {
                        const { x, y } = initialPosition;
                        element.position(x, y, {
                            deep: true,
                            ui: true
                        });
                    }
                    // Revert all the z-indices changed during the embedding
                    if (initialZIndices) {
                        Object.keys(initialZIndices).forEach((id)=>{
                            const cell = graph.getCell(id);
                            if (cell) {
                                cell.set('z', initialZIndices[id], {
                                    ui: true
                                });
                            }
                        });
                    }
                    // Revert the original parent
                    const parent = graph.getCell(initialParentId);
                    if (parent) {
                        parent.embed(element, {
                            ui: true
                        });
                    }
                    break;
                }
        }
    },
    getTargetParentView: function(evt) {
        const { candidateEmbedView = null } = this.eventData(evt);
        return candidateEmbedView;
    },
    getDelegatedView: function() {
        var view = this;
        var model = view.model;
        var paper = view.paper;
        while(view){
            if (model.isLink()) break;
            if (!model.isEmbedded() || view.can('stopDelegation')) return view;
            model = model.getParentCell();
            view = paper.findViewByModel(model);
        }
        return null;
    },
    findProxyNode: function(el, type) {
        el || (el = this.el);
        const nodeSelector = el.getAttribute(`${type}-selector`);
        if (nodeSelector) {
            const port = this.findAttribute('port', el);
            if (port) {
                const proxyPortNode = this.findPortNode(port, nodeSelector);
                if (proxyPortNode) return proxyPortNode;
            } else {
                const proxyNode = this.findNode(nodeSelector);
                if (proxyNode) return proxyNode;
            }
        }
        return el;
    },
    // Interaction. The controller part.
    // ---------------------------------
    notifyPointerdown (evt, x, y) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.pointerdown.call(this, evt, x, y);
        this.notify('element:pointerdown', evt, x, y);
    },
    notifyPointermove (evt, x, y) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.pointermove.call(this, evt, x, y);
        this.notify('element:pointermove', evt, x, y);
    },
    notifyPointerup (evt, x, y) {
        this.notify('element:pointerup', evt, x, y);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.pointerup.call(this, evt, x, y);
    },
    pointerdblclick: function(evt, x, y) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.pointerdblclick.apply(this, arguments);
        this.notify('element:pointerdblclick', evt, x, y);
    },
    pointerclick: function(evt, x, y) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.pointerclick.apply(this, arguments);
        this.notify('element:pointerclick', evt, x, y);
    },
    contextmenu: function(evt, x, y) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.contextmenu.apply(this, arguments);
        this.notify('element:contextmenu', evt, x, y);
    },
    pointerdown: function(evt, x, y) {
        this.notifyPointerdown(evt, x, y);
        this.dragStart(evt, x, y);
    },
    pointermove: function(evt, x, y) {
        const data = this.eventData(evt);
        const { targetMagnet, action, delegatedView } = data;
        if (targetMagnet) {
            this.magnetpointermove(evt, targetMagnet, x, y);
        }
        switch(action){
            case DragActions.MAGNET:
                this.dragMagnet(evt, x, y);
                break;
            case DragActions.MOVE:
                (delegatedView || this).drag(evt, x, y);
            // eslint: no-fallthrough=false
            default:
                if (data.preventPointerEvents) break;
                this.notifyPointermove(evt, x, y);
                break;
        }
        // Make sure the element view data is passed along.
        // It could have been wiped out in the handlers above.
        this.eventData(evt, data);
    },
    pointerup: function(evt, x, y) {
        const data = this.eventData(evt);
        const { targetMagnet, action, delegatedView } = data;
        if (targetMagnet) {
            this.magnetpointerup(evt, targetMagnet, x, y);
        }
        switch(action){
            case DragActions.MAGNET:
                this.dragMagnetEnd(evt, x, y);
                break;
            case DragActions.MOVE:
                (delegatedView || this).dragEnd(evt, x, y);
            // eslint: no-fallthrough=false
            default:
                if (data.preventPointerEvents) break;
                this.notifyPointerup(evt, x, y);
        }
        if (targetMagnet) {
            this.magnetpointerclick(evt, targetMagnet, x, y);
        }
        this.checkMouseleave(evt);
    },
    mouseover: function(evt) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.mouseover.apply(this, arguments);
        this.notify('element:mouseover', evt);
    },
    mouseout: function(evt) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.mouseout.apply(this, arguments);
        this.notify('element:mouseout', evt);
    },
    mouseenter: function(evt) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.mouseenter.apply(this, arguments);
        this.notify('element:mouseenter', evt);
    },
    mouseleave: function(evt) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.mouseleave.apply(this, arguments);
        this.notify('element:mouseleave', evt);
    },
    mousewheel: function(evt, x, y, delta) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.mousewheel.apply(this, arguments);
        this.notify('element:mousewheel', evt, x, y, delta);
    },
    onmagnet: function(evt, x, y) {
        const { currentTarget: targetMagnet } = evt;
        this.magnetpointerdown(evt, targetMagnet, x, y);
        this.eventData(evt, {
            targetMagnet
        });
        this.dragMagnetStart(evt, x, y);
    },
    magnetpointerdown: function(evt, magnet, x, y) {
        this.notify('element:magnet:pointerdown', evt, magnet, x, y);
    },
    magnetpointermove: function(evt, magnet, x, y) {
        this.notify('element:magnet:pointermove', evt, magnet, x, y);
    },
    magnetpointerup: function(evt, magnet, x, y) {
        this.notify('element:magnet:pointerup', evt, magnet, x, y);
    },
    magnetpointerdblclick: function(evt, magnet, x, y) {
        this.notify('element:magnet:pointerdblclick', evt, magnet, x, y);
    },
    magnetcontextmenu: function(evt, magnet, x, y) {
        this.notify('element:magnet:contextmenu', evt, magnet, x, y);
    },
    // Drag Start Handlers
    dragStart: function(evt, x, y) {
        if (this.isDefaultInteractionPrevented(evt)) return;
        var view = this.getDelegatedView();
        if (!view || !view.can('elementMove')) return;
        this.eventData(evt, {
            action: DragActions.MOVE,
            delegatedView: view
        });
        const position = view.model.position();
        view.eventData(evt, {
            initialPosition: position,
            pointerOffset: position.difference(x, y),
            restrictedArea: this.paper.getRestrictedArea(view, x, y)
        });
    },
    dragMagnetStart: function(evt, x, y) {
        const { paper } = this;
        const isPropagationAlreadyStopped = evt.isPropagationStopped();
        if (isPropagationAlreadyStopped) {
            // Special case when the propagation was already stopped
            // on the `element:magnet:pointerdown` event.
            // Do not trigger any `element:pointer*` events
            // but still start the magnet dragging.
            this.eventData(evt, {
                preventPointerEvents: true
            });
        }
        if (this.isDefaultInteractionPrevented(evt) || !this.can('addLinkFromMagnet')) {
            // Stop the default action, which is to start dragging a link.
            return;
        }
        const { targetMagnet = evt.currentTarget } = this.eventData(evt);
        evt.stopPropagation();
        // Invalid (Passive) magnet. Start dragging the element.
        if (!paper.options.validateMagnet.call(paper, this, targetMagnet, evt)) {
            if (isPropagationAlreadyStopped) {
                // Do not trigger `element:pointerdown` and start element dragging
                // if the propagation was stopped.
                this.dragStart(evt, x, y);
            // The `element:pointerdown` event is not triggered because
            // of `preventPointerEvents` flag.
            } else {
                // We need to reset the action
                // to `MOVE` so that the element is dragged.
                this.pointerdown(evt, x, y);
            }
            return;
        }
        // Valid magnet. Start dragging a link.
        if (paper.options.magnetThreshold <= 0) {
            this.dragLinkStart(evt, targetMagnet, x, y);
        }
        this.eventData(evt, {
            action: DragActions.MAGNET
        });
    },
    // Drag Handlers
    drag: function(evt, x, y) {
        var paper = this.paper;
        var grid = paper.options.gridSize;
        var element = this.model;
        var data = this.eventData(evt);
        var { pointerOffset, restrictedArea, embedding } = data;
        // Make sure the new element's position always snaps to the current grid
        var elX = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$geometry$2e$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["snapToGrid"])(x + pointerOffset.x, grid);
        var elY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$geometry$2e$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["snapToGrid"])(y + pointerOffset.y, grid);
        element.position(elX, elY, {
            restrictedArea,
            deep: true,
            ui: true
        });
        if (paper.options.embeddingMode) {
            if (!embedding) {
                // Prepare the element for embedding only if the pointer moves.
                // We don't want to do unnecessary action with the element
                // if an user only clicks/dblclicks on it.
                this.prepareEmbedding(data);
                embedding = true;
            }
            this.processEmbedding(data, evt, x, y);
        }
        this.eventData(evt, {
            embedding
        });
    },
    dragMagnet: function(evt, x, y) {
        this.dragLink(evt, x, y);
    },
    // Drag End Handlers
    dragEnd: function(evt, x, y) {
        var data = this.eventData(evt);
        if (data.embedding) this.finalizeEmbedding(data);
    },
    dragMagnetEnd: function(evt, x, y) {
        this.dragLinkEnd(evt, x, y);
    },
    magnetpointerclick: function(evt, magnet, x, y) {
        var paper = this.paper;
        if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;
        this.notify('element:magnet:pointerclick', evt, magnet, x, y);
    }
}, {
    Flags: Flags
});
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(ElementView.prototype, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$ports$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["elementViewPortPrototype"]);
}}),
"[project]/node_modules/@joint/core/src/dia/Link.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Link": (()=>Link)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Cell$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/Cell.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/utilHelpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/point.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$polyline$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/polyline.mjs [app-client] (ecmascript)");
;
;
;
const Link = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Cell$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Cell"].extend({
    // may be overwritten by user to change default label (its markup, size, attrs, position)
    defaultLabel: undefined,
    // deprecated
    // may be overwritten by user to change default label markup
    // lower priority than defaultLabel.markup
    labelMarkup: undefined,
    // private
    _builtins: {
        defaultLabel: {
            // builtin default markup:
            // used if neither defaultLabel.markup
            // nor label.markup is set
            markup: [
                {
                    tagName: 'rect',
                    selector: 'rect' // faster than tagName CSS selector
                },
                {
                    tagName: 'text',
                    selector: 'text' // faster than tagName CSS selector
                }
            ],
            // builtin default attributes:
            // applied only if builtin default markup is used
            attrs: {
                text: {
                    fill: '#000000',
                    fontSize: 14,
                    textAnchor: 'middle',
                    textVerticalAnchor: 'middle',
                    pointerEvents: 'none'
                },
                rect: {
                    ref: 'text',
                    fill: '#ffffff',
                    rx: 3,
                    ry: 3,
                    x: 'calc(x)',
                    y: 'calc(y)',
                    width: 'calc(w)',
                    height: 'calc(h)'
                }
            },
            // builtin default position:
            // used if neither defaultLabel.position
            // nor label.position is set
            position: {
                distance: 0.5
            }
        }
    },
    defaults: {
        source: {},
        target: {}
    },
    isLink: function() {
        return true;
    },
    disconnect: function(opt) {
        return this.set({
            source: {
                x: 0,
                y: 0
            },
            target: {
                x: 0,
                y: 0
            }
        }, opt);
    },
    source: function(source, args, opt) {
        // getter
        if (source === undefined) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this.get('source'));
        }
        // setter
        var setSource;
        var setOpt;
        // `source` is a cell
        // take only its `id` and combine with `args`
        var isCellProvided = source instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Cell$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Cell"];
        if (isCellProvided) {
            setSource = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(args) || {};
            setSource.id = source.id;
            setOpt = opt;
            return this.set('source', setSource, setOpt);
        }
        // `source` is a point-like object
        // for example, a g.Point
        // take only its `x` and `y` and combine with `args`
        var isPointProvided = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(source);
        if (isPointProvided) {
            setSource = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(args) || {};
            setSource.x = source.x;
            setSource.y = source.y;
            setOpt = opt;
            return this.set('source', setSource, setOpt);
        }
        // `source` is an object
        // no checking
        // two arguments
        setSource = source;
        setOpt = args;
        return this.set('source', setSource, setOpt);
    },
    target: function(target, args, opt) {
        // getter
        if (target === undefined) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this.get('target'));
        }
        // setter
        var setTarget;
        var setOpt;
        // `target` is a cell
        // take only its `id` argument and combine with `args`
        var isCellProvided = target instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Cell$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Cell"];
        if (isCellProvided) {
            setTarget = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(args) || {};
            setTarget.id = target.id;
            setOpt = opt;
            return this.set('target', setTarget, setOpt);
        }
        // `target` is a point-like object
        // for example, a g.Point
        // take only its `x` and `y` and combine with `args`
        var isPointProvided = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(target);
        if (isPointProvided) {
            setTarget = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(args) || {};
            setTarget.x = target.x;
            setTarget.y = target.y;
            setOpt = opt;
            return this.set('target', setTarget, setOpt);
        }
        // `target` is an object
        // no checking
        // two arguments
        setTarget = target;
        setOpt = args;
        return this.set('target', setTarget, setOpt);
    },
    router: function(name, args, opt) {
        // getter
        if (name === undefined) {
            var router = this.get('router');
            if (!router) {
                return null;
            }
            if (typeof router === 'object') return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(router);
            return router; // e.g. a function
        }
        // setter
        var isRouterProvided = typeof name === 'object' || typeof name === 'function';
        var localRouter = isRouterProvided ? name : {
            name: name,
            args: args
        };
        var localOpt = isRouterProvided ? args : opt;
        return this.set('router', localRouter, localOpt);
    },
    connector: function(name, args, opt) {
        // getter
        if (name === undefined) {
            var connector = this.get('connector');
            if (!connector) {
                return null;
            }
            if (typeof connector === 'object') return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(connector);
            return connector; // e.g. a function
        }
        // setter
        var isConnectorProvided = typeof name === 'object' || typeof name === 'function';
        var localConnector = isConnectorProvided ? name : {
            name: name,
            args: args
        };
        var localOpt = isConnectorProvided ? args : opt;
        return this.set('connector', localConnector, localOpt);
    },
    // Labels API
    // A convenient way to set labels. Currently set values will be mixined with `value` if used as a setter.
    label: function(idx, label, opt) {
        var labels = this.labels();
        idx = isFinite(idx) && idx !== null ? idx | 0 : 0;
        if (idx < 0) idx = labels.length + idx;
        // getter
        if (arguments.length <= 1) return this.prop([
            'labels',
            idx
        ]);
        // setter
        return this.prop([
            'labels',
            idx
        ], label, opt);
    },
    labels: function(labels, opt) {
        // getter
        if (arguments.length === 0) {
            labels = this.get('labels');
            if (!Array.isArray(labels)) return [];
            return labels.slice();
        }
        // setter
        if (!Array.isArray(labels)) labels = [];
        return this.set('labels', labels, opt);
    },
    hasLabels: function() {
        const { labels } = this.attributes;
        return Array.isArray(labels) && labels.length > 0;
    },
    insertLabel: function(idx, label, opt) {
        if (!label) throw new Error('dia.Link: no label provided');
        var labels = this.labels();
        var n = labels.length;
        idx = isFinite(idx) && idx !== null ? idx | 0 : n;
        if (idx < 0) idx = n + idx + 1;
        labels.splice(idx, 0, label);
        return this.labels(labels, opt);
    },
    // convenience function
    // add label to end of labels array
    appendLabel: function(label, opt) {
        return this.insertLabel(-1, label, opt);
    },
    removeLabel: function(idx, opt) {
        var labels = this.labels();
        idx = isFinite(idx) && idx !== null ? idx | 0 : -1;
        labels.splice(idx, 1);
        return this.labels(labels, opt);
    },
    // Vertices API
    vertex: function(idx, vertex, opt) {
        var vertices = this.vertices();
        idx = isFinite(idx) && idx !== null ? idx | 0 : 0;
        if (idx < 0) idx = vertices.length + idx;
        // getter
        if (arguments.length <= 1) return this.prop([
            'vertices',
            idx
        ]);
        // setter
        var setVertex = this._normalizeVertex(vertex);
        return this.prop([
            'vertices',
            idx
        ], setVertex, opt);
    },
    vertices: function(vertices, opt) {
        // getter
        if (arguments.length === 0) {
            vertices = this.get('vertices');
            if (!Array.isArray(vertices)) return [];
            return vertices.slice();
        }
        // setter
        if (!Array.isArray(vertices)) vertices = [];
        var setVertices = [];
        for(var i = 0; i < vertices.length; i++){
            var vertex = vertices[i];
            var setVertex = this._normalizeVertex(vertex);
            setVertices.push(setVertex);
        }
        return this.set('vertices', setVertices, opt);
    },
    insertVertex: function(idx, vertex, opt) {
        if (!vertex) throw new Error('dia.Link: no vertex provided');
        var vertices = this.vertices();
        var n = vertices.length;
        idx = isFinite(idx) && idx !== null ? idx | 0 : n;
        if (idx < 0) idx = n + idx + 1;
        var setVertex = this._normalizeVertex(vertex);
        vertices.splice(idx, 0, setVertex);
        return this.vertices(vertices, opt);
    },
    removeVertex: function(idx, opt) {
        var vertices = this.vertices();
        idx = isFinite(idx) && idx !== null ? idx | 0 : -1;
        vertices.splice(idx, 1);
        return this.vertices(vertices, opt);
    },
    _normalizeVertex: function(vertex) {
        // is vertex a point-like object?
        // for example, a g.Point
        var isPointProvided = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(vertex);
        if (isPointProvided) return {
            x: vertex.x,
            y: vertex.y
        };
        // else: return vertex unchanged
        return vertex;
    },
    // Transformations
    translate: function(tx, ty, opt) {
        // enrich the option object
        opt = opt || {};
        opt.translateBy = opt.translateBy || this.id;
        opt.tx = tx;
        opt.ty = ty;
        return this.applyToPoints(function(p) {
            return {
                x: (p.x || 0) + tx,
                y: (p.y || 0) + ty
            };
        }, opt);
    },
    scale: function(sx, sy, origin, opt) {
        return this.applyToPoints(function(p) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"])(p).scale(sx, sy, origin).toJSON();
        }, opt);
    },
    applyToPoints: function(fn, opt) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(fn)) {
            throw new TypeError('dia.Link: applyToPoints expects its first parameter to be a function.');
        }
        var attrs = {};
        var { source, target } = this.attributes;
        if (!source.id) {
            attrs.source = fn(source);
        }
        if (!target.id) {
            attrs.target = fn(target);
        }
        var vertices = this.vertices();
        if (vertices.length > 0) {
            attrs.vertices = vertices.map(fn);
        }
        return this.set(attrs, opt);
    },
    getSourcePoint: function() {
        var sourceCell = this.getSourceCell();
        if (!sourceCell) return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](this.source());
        return sourceCell.getPointFromConnectedLink(this, 'source');
    },
    getTargetPoint: function() {
        var targetCell = this.getTargetCell();
        if (!targetCell) return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](this.target());
        return targetCell.getPointFromConnectedLink(this, 'target');
    },
    getPointFromConnectedLink: function() {
        return this.getPolyline().pointAt(0.5);
    },
    getPolyline: function() {
        const points = [
            this.getSourcePoint(),
            ...this.vertices().map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]),
            this.getTargetPoint()
        ];
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$polyline$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Polyline"](points);
    },
    getBBox: function() {
        return this.getPolyline().bbox();
    },
    reparent: function(opt) {
        var newParent;
        if (this.graph) {
            var source = this.getSourceElement();
            var target = this.getTargetElement();
            var prevParent = this.getParentCell();
            if (source && target) {
                if (source === target || source.isEmbeddedIn(target)) {
                    newParent = target;
                } else if (target.isEmbeddedIn(source)) {
                    newParent = source;
                } else {
                    newParent = this.graph.getCommonAncestor(source, target);
                }
            }
            if (prevParent && (!newParent || newParent.id !== prevParent.id)) {
                // Unembed the link if source and target has no common ancestor
                // or common ancestor changed
                prevParent.unembed(this, opt);
            }
            if (newParent) {
                newParent.embed(this, opt);
            }
        }
        return newParent;
    },
    hasLoop: function(opt) {
        opt = opt || {};
        var { source, target } = this.attributes;
        var sourceId = source.id;
        var targetId = target.id;
        if (!sourceId || !targetId) {
            // Link "pinned" to the paper does not have a loop.
            return false;
        }
        var loop = sourceId === targetId;
        // Note that there in the deep mode a link can have a loop,
        // even if it connects only a parent and its embed.
        // A loop "target equals source" is valid in both shallow and deep mode.
        if (!loop && opt.deep && this.graph) {
            var sourceElement = this.getSourceCell();
            var targetElement = this.getTargetCell();
            loop = sourceElement.isEmbeddedIn(targetElement) || targetElement.isEmbeddedIn(sourceElement);
        }
        return loop;
    },
    // unlike source(), this method returns null if source is a point
    getSourceCell: function() {
        const { graph, attributes } = this;
        var source = attributes.source;
        return source && source.id && graph && graph.getCell(source.id) || null;
    },
    getSourceElement: function() {
        var cell = this;
        var visited = {};
        do {
            if (visited[cell.id]) return null;
            visited[cell.id] = true;
            cell = cell.getSourceCell();
        }while (cell && cell.isLink())
        return cell;
    },
    // unlike target(), this method returns null if target is a point
    getTargetCell: function() {
        const { graph, attributes } = this;
        var target = attributes.target;
        return target && target.id && graph && graph.getCell(target.id) || null;
    },
    getTargetElement: function() {
        var cell = this;
        var visited = {};
        do {
            if (visited[cell.id]) return null;
            visited[cell.id] = true;
            cell = cell.getTargetCell();
        }while (cell && cell.isLink())
        return cell;
    },
    // Returns the common ancestor for the source element,
    // target element and the link itself.
    getRelationshipAncestor: function() {
        var connectionAncestor;
        if (this.graph) {
            var cells = [
                this,
                this.getSourceElement(),
                this.getTargetElement() // null if target is a point
            ].filter(function(item) {
                return !!item;
            });
            connectionAncestor = this.graph.getCommonAncestor.apply(this.graph, cells);
        }
        return connectionAncestor || null;
    },
    // Is source, target and the link itself embedded in a given cell?
    isRelationshipEmbeddedIn: function(cell) {
        var cellId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(cell) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(cell) ? cell : cell.id;
        var ancestor = this.getRelationshipAncestor();
        return !!ancestor && (ancestor.id === cellId || ancestor.isEmbeddedIn(cellId));
    },
    // Get resolved default label.
    _getDefaultLabel: function() {
        var defaultLabel = this.get('defaultLabel') || this.defaultLabel || {};
        var label = {};
        label.markup = defaultLabel.markup || this.get('labelMarkup') || this.labelMarkup;
        label.position = defaultLabel.position;
        label.attrs = defaultLabel.attrs;
        label.size = defaultLabel.size;
        return label;
    }
}, {
    endsEqual: function(a, b) {
        var portsEqual = a.port === b.port || !a.port && !b.port;
        return a.id === b.id && portsEqual;
    }
});
}}),
"[project]/node_modules/@joint/core/src/dia/LinkView.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LinkView": (()=>LinkView)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/CellView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$env$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/env/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/V/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/util.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/utilHelpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/rect.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$polyline$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/polyline.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/point.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$line$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/line.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/routers/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/connectors/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$path$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/path.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$geometry$2e$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/geometry.helpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Link$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/Link.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const Flags = {
    TOOLS: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].Flags.TOOLS,
    RENDER: 'RENDER',
    UPDATE: 'UPDATE',
    LABELS: 'LABELS',
    SOURCE: 'SOURCE',
    TARGET: 'TARGET',
    CONNECTOR: 'CONNECTOR'
};
const LinkView = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].extend({
    className: function() {
        var classNames = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.className.apply(this).split(' ');
        classNames.push('link');
        return classNames.join(' ');
    },
    _labelCache: null,
    _labelSelectors: null,
    _V: null,
    _dragData: null,
    metrics: null,
    decimalsRounding: 2,
    initialize: function() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.initialize.apply(this, arguments);
        // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to
        // `<g class="label">` nodes wrapped by Vectorizer. This allows for quick access to the
        // nodes in `updateLabelPosition()` in order to update the label positions.
        this._labelCache = {};
        // a cache of label selectors
        this._labelSelectors = {};
        // cache of default markup nodes
        this._V = {};
        // connection path metrics
        this.cleanNodesCache();
    },
    presentationAttributes: {
        markup: [
            Flags.RENDER
        ],
        attrs: [
            Flags.UPDATE
        ],
        router: [
            Flags.UPDATE
        ],
        connector: [
            Flags.CONNECTOR
        ],
        labels: [
            Flags.LABELS,
            Flags.TOOLS
        ],
        labelMarkup: [
            Flags.LABELS
        ],
        vertices: [
            Flags.UPDATE
        ],
        source: [
            Flags.SOURCE,
            Flags.UPDATE
        ],
        target: [
            Flags.TARGET,
            Flags.UPDATE
        ]
    },
    initFlag: [
        Flags.RENDER,
        Flags.SOURCE,
        Flags.TARGET,
        Flags.TOOLS
    ],
    UPDATE_PRIORITY: 1,
    EPSILON: 1e-6,
    confirmUpdate: function(flags, opt) {
        opt || (opt = {});
        if (this.hasFlag(flags, Flags.SOURCE)) {
            if (!this.updateEndProperties('source')) return flags;
            flags = this.removeFlag(flags, Flags.SOURCE);
        }
        if (this.hasFlag(flags, Flags.TARGET)) {
            if (!this.updateEndProperties('target')) return flags;
            flags = this.removeFlag(flags, Flags.TARGET);
        }
        const { paper, sourceView, targetView } = this;
        if (paper && (sourceView && !paper.isViewMounted(sourceView) || targetView && !paper.isViewMounted(targetView))) {
            // Wait for the sourceView and targetView to be rendered
            return flags;
        }
        if (this.hasFlag(flags, Flags.RENDER)) {
            this.render();
            this.updateHighlighters(true);
            this.updateTools(opt);
            flags = this.removeFlag(flags, [
                Flags.RENDER,
                Flags.UPDATE,
                Flags.LABELS,
                Flags.TOOLS,
                Flags.CONNECTOR
            ]);
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$env$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["env"].test('isSafari')) {
                this.__fixSafariBug268376();
            }
            return flags;
        }
        let updateHighlighters = false;
        const { model } = this;
        const { attributes } = model;
        let updateLabels = this.hasFlag(flags, Flags.LABELS);
        if (updateLabels) {
            this.onLabelsChange(model, attributes.labels, opt);
            flags = this.removeFlag(flags, Flags.LABELS);
            updateHighlighters = true;
        }
        const updateAll = this.hasFlag(flags, Flags.UPDATE);
        const updateConnector = this.hasFlag(flags, Flags.CONNECTOR);
        if (updateAll || updateConnector) {
            if (!updateAll) {
                // Keep the current route and update the geometry
                this.updatePath();
                this.updateDOM();
            } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {
                // The link is being translated by an ancestor that will
                // shift source point, target point and all vertices
                // by an equal distance.
                this.translate(opt.tx, opt.ty);
            } else {
                this.update();
            }
            this.updateTools(opt);
            flags = this.removeFlag(flags, [
                Flags.UPDATE,
                Flags.TOOLS,
                Flags.CONNECTOR
            ]);
            updateLabels = false;
            updateHighlighters = true;
        }
        if (updateLabels) {
            this.updateLabelPositions();
        }
        if (updateHighlighters) {
            this.updateHighlighters();
        }
        if (this.hasFlag(flags, Flags.TOOLS)) {
            this.updateTools(opt);
            flags = this.removeFlag(flags, Flags.TOOLS);
        }
        return flags;
    },
    __fixSafariBug268376: function() {
        // Safari has a bug where any change after the first render is not reflected in the DOM.
        // https://bugs.webkit.org/show_bug.cgi?id=268376
        const { el } = this;
        const childNodes = Array.from(el.childNodes);
        const fragment = document.createDocumentFragment();
        for(let i = 0, n = childNodes.length; i < n; i++){
            el.removeChild(childNodes[i]);
            fragment.appendChild(childNodes[i]);
        }
        el.appendChild(fragment);
    },
    requestConnectionUpdate: function(opt) {
        this.requestUpdate(this.getFlag(Flags.UPDATE), opt);
    },
    isLabelsRenderRequired: function(opt = {}) {
        const previousLabels = this.model.previous('labels');
        if (!previousLabels) return true;
        // Here is an optimization for cases when we know, that change does
        // not require re-rendering of all labels.
        if ('propertyPathArray' in opt && 'propertyValue' in opt) {
            // The label is setting by `prop()` method
            var pathArray = opt.propertyPathArray || [];
            var pathLength = pathArray.length;
            if (pathLength > 1) {
                // We are changing a single label here e.g. 'labels/0/position'
                var labelExists = !!previousLabels[pathArray[1]];
                if (labelExists) {
                    if (pathLength === 2) {
                        // We are changing the entire label. Need to check if the
                        // markup is also being changed.
                        return 'markup' in Object(opt.propertyValue);
                    } else if (pathArray[2] !== 'markup') {
                        // We are changing a label property but not the markup
                        return false;
                    }
                }
            }
        }
        return true;
    },
    onLabelsChange: function(_link, _labels, opt) {
        // Note: this optimization works in async=false mode only
        if (this.isLabelsRenderRequired(opt)) {
            this.renderLabels();
        } else {
            this.updateLabels();
        }
    },
    // Rendering.
    // ----------
    render: function() {
        this.vel.empty();
        this.unmountLabels();
        this._V = {};
        this.renderMarkup();
        // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox
        // returns zero values)
        this.renderLabels();
        this.update();
        return this;
    },
    renderMarkup: function() {
        var link = this.model;
        var markup = link.get('markup') || link.markup;
        if (!markup) throw new Error('dia.LinkView: markup required');
        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);
        if (typeof markup === 'string') return this.renderStringMarkup(markup);
        throw new Error('dia.LinkView: invalid markup');
    },
    renderJSONMarkup: function(markup) {
        var doc = this.parseDOMJSON(markup, this.el);
        // Selectors
        this.selectors = doc.selectors;
        // Fragment
        this.vel.append(doc.fragment);
    },
    renderStringMarkup: function(markup) {
        // A special markup can be given in the `properties.markup` property. This might be handy
        // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.
        // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors
        // of elements with special meaning though. Therefore, those classes should be preserved in any
        // special markup passed in `properties.markup`.
        var children = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(markup);
        // custom markup may contain only one children
        if (!Array.isArray(children)) children = [
            children
        ];
        this.vel.append(children);
    },
    _getLabelMarkup: function(labelMarkup) {
        if (!labelMarkup) return undefined;
        if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);
        if (typeof labelMarkup === 'string') return this._getLabelStringMarkup(labelMarkup);
        throw new Error('dia.linkView: invalid label markup');
    },
    _getLabelStringMarkup: function(labelMarkup) {
        var children = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(labelMarkup);
        var fragment = document.createDocumentFragment();
        if (!Array.isArray(children)) {
            fragment.appendChild(children.node);
        } else {
            for(var i = 0, n = children.length; i < n; i++){
                var currentChild = children[i].node;
                fragment.appendChild(currentChild);
            }
        }
        return {
            fragment: fragment,
            selectors: {}
        }; // no selectors
    },
    // Label markup fragment may come wrapped in <g class="label" />, or not.
    // If it doesn't, add the <g /> container here.
    _normalizeLabelMarkup: function(markup) {
        if (!markup) return undefined;
        var fragment = markup.fragment;
        if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error('dia.LinkView: invalid label markup.');
        var vNode;
        var childNodes = fragment.childNodes;
        if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {
            // default markup fragment is not wrapped in <g />
            // add a <g /> container
            vNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('g').append(fragment);
        } else {
            vNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(childNodes[0]);
        }
        vNode.addClass('label');
        return {
            node: vNode.node,
            selectors: markup.selectors
        };
    },
    renderLabels: function() {
        var cache = this._V;
        var vLabels = cache.labels;
        var labelCache = this._labelCache = {};
        var labelSelectors = this._labelSelectors = {};
        var model = this.model;
        var labels = model.attributes.labels || [];
        var labelsCount = labels.length;
        if (labelsCount === 0) {
            if (vLabels) vLabels.remove();
            return this;
        }
        if (vLabels) {
            vLabels.empty();
        } else {
            // there is no label container in the markup but some labels are defined
            // add a <g class="labels" /> container
            vLabels = cache.labels = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('g').addClass('labels');
            if (this.options.labelsLayer) {
                vLabels.addClass((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addClassNamePrefix"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["result"])(this, 'className')));
                vLabels.attr('model-id', model.id);
            }
        }
        for(var i = 0; i < labelsCount; i++){
            var label = labels[i];
            var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));
            var labelNode;
            var selectors;
            if (labelMarkup) {
                labelNode = labelMarkup.node;
                selectors = labelMarkup.selectors;
            } else {
                var builtinDefaultLabel = model._builtins.defaultLabel;
                var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));
                var defaultLabel = model._getDefaultLabel();
                var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));
                var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;
                labelNode = defaultMarkup.node;
                selectors = defaultMarkup.selectors;
            }
            labelNode.setAttribute('label-idx', i); // assign label-idx
            vLabels.append(labelNode);
            labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions
            var rootSelector = this.selector;
            if (selectors[rootSelector]) throw new Error('dia.LinkView: ambiguous label root selector.');
            selectors[rootSelector] = labelNode;
            labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`
        }
        if (!vLabels.parent()) {
            this.mountLabels();
        }
        this.updateLabels();
        return this;
    },
    mountLabels: function() {
        const { el, paper, model, _V, options } = this;
        const { labels: vLabels } = _V;
        if (!vLabels || !model.hasLabels()) return;
        const { node } = vLabels;
        if (options.labelsLayer) {
            paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get('z'));
        } else {
            if (node.parentNode !== el) {
                el.appendChild(node);
            }
        }
    },
    unmountLabels: function() {
        const { options, _V } = this;
        if (!_V) return;
        const { labels: vLabels } = _V;
        if (vLabels && options.labelsLayer) {
            vLabels.remove();
        }
    },
    findLabelNodes: function(labelIndex, selector) {
        const labelRoot = this._labelCache[labelIndex];
        if (!labelRoot) return [];
        const labelSelectors = this._labelSelectors[labelIndex];
        return this.findBySelector(selector, labelRoot, labelSelectors);
    },
    findLabelNode: function(labelIndex, selector) {
        const [node = null] = this.findLabelNodes(labelIndex, selector);
        return node;
    },
    // merge default label attrs into label attrs (or use built-in default label attrs if neither is provided)
    // keep `undefined` or `null` because `{}` means something else
    _mergeLabelAttrs: function(hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {
        if (labelAttrs === null) return null;
        if (labelAttrs === undefined) {
            if (defaultLabelAttrs === null) return null;
            if (defaultLabelAttrs === undefined) {
                if (hasCustomMarkup) return undefined;
                return builtinDefaultLabelAttrs;
            }
            if (hasCustomMarkup) return defaultLabelAttrs;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])({}, builtinDefaultLabelAttrs, defaultLabelAttrs);
        }
        if (hasCustomMarkup) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])({}, defaultLabelAttrs, labelAttrs);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);
    },
    // merge default label size into label size (no built-in default)
    // keep `undefined` or `null` because `{}` means something else
    _mergeLabelSize: function(labelSize, defaultLabelSize) {
        if (labelSize === null) return null;
        if (labelSize === undefined) {
            if (defaultLabelSize === null) return null;
            if (defaultLabelSize === undefined) return undefined;
            return defaultLabelSize;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])({}, defaultLabelSize, labelSize);
    },
    updateLabels: function() {
        if (!this._V.labels) return this;
        if (!this.paper.options.labelLayer) {
            // If there is no label layer, the cache needs to be cleared
            // of the root node because the labels are attached
            // to it and could affect the bounding box.
            this.cleanNodeCache(this.el);
        }
        var model = this.model;
        var labels = model.get('labels') || [];
        var canLabelMove = this.can('labelMove');
        var builtinDefaultLabel = model._builtins.defaultLabel;
        var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;
        var defaultLabel = model._getDefaultLabel();
        var defaultLabelMarkup = defaultLabel.markup;
        var defaultLabelAttrs = defaultLabel.attrs;
        var defaultLabelSize = defaultLabel.size;
        for(var i = 0, n = labels.length; i < n; i++){
            var labelNode = this._labelCache[i];
            labelNode.setAttribute('cursor', canLabelMove ? 'move' : 'default');
            var selectors = this._labelSelectors[i];
            var label = labels[i];
            var labelMarkup = label.markup;
            var labelAttrs = label.attrs;
            var labelSize = label.size;
            var attrs = this._mergeLabelAttrs(labelMarkup || defaultLabelMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs);
            var size = this._mergeLabelSize(labelSize, defaultLabelSize);
            this.updateDOMSubtreeAttributes(labelNode, attrs, {
                rootBBox: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](size),
                selectors: selectors
            });
        }
        return this;
    },
    // remove vertices that lie on (or nearly on) straight lines within the link
    // return the number of removed points
    removeRedundantLinearVertices: function(opt) {
        const SIMPLIFY_THRESHOLD = 0.001;
        const link = this.model;
        const vertices = link.vertices();
        const routePoints = [
            this.sourceAnchor,
            ...vertices,
            this.targetAnchor
        ];
        const numRoutePoints = routePoints.length;
        // put routePoints into a polyline and try to simplify
        const polyline = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$polyline$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Polyline"](routePoints);
        polyline.simplify({
            threshold: SIMPLIFY_THRESHOLD
        });
        const polylinePoints = polyline.points.map((point)=>point.toJSON()); // JSON of points after simplification
        const numPolylinePoints = polylinePoints.length; // number of points after simplification
        // shortcut if simplification did not remove any redundant vertices:
        if (numRoutePoints === numPolylinePoints) return 0;
        // else: set simplified polyline points as link vertices
        // remove first and last polyline points again (= source/target anchors)
        link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);
        return numRoutePoints - numPolylinePoints;
    },
    getEndView: function(type) {
        switch(type){
            case 'source':
                return this.sourceView || null;
            case 'target':
                return this.targetView || null;
            default:
                throw new Error('dia.LinkView: type parameter required.');
        }
    },
    getEndAnchor: function(type) {
        switch(type){
            case 'source':
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](this.sourceAnchor);
            case 'target':
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](this.targetAnchor);
            default:
                throw new Error('dia.LinkView: type parameter required.');
        }
    },
    getEndConnectionPoint: function(type) {
        switch(type){
            case 'source':
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](this.sourcePoint);
            case 'target':
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](this.targetPoint);
            default:
                throw new Error('dia.LinkView: type parameter required.');
        }
    },
    getEndMagnet: function(type) {
        switch(type){
            case 'source':
                var sourceView = this.sourceView;
                if (!sourceView) break;
                return this.sourceMagnet || sourceView.el;
            case 'target':
                var targetView = this.targetView;
                if (!targetView) break;
                return this.targetMagnet || targetView.el;
            default:
                throw new Error('dia.LinkView: type parameter required.');
        }
        return null;
    },
    // Updating.
    // ---------
    update: function() {
        this.updateRoute();
        this.updatePath();
        this.updateDOM();
        return this;
    },
    translate: function(tx = 0, ty = 0) {
        const { route, path } = this;
        if (!route || !path) return;
        // translate the route
        const polyline = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$polyline$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Polyline"](route);
        polyline.translate(tx, ty);
        this.route = polyline.points;
        // translate source and target connection and anchor points.
        this.sourcePoint.offset(tx, ty);
        this.targetPoint.offset(tx, ty);
        this.sourceAnchor.offset(tx, ty);
        this.targetAnchor.offset(tx, ty);
        // translate the geometry path
        path.translate(tx, ty);
        this.updateDOM();
    },
    updateDOM () {
        const { el, model, selectors } = this;
        this.cleanNodesCache();
        // update SVG attributes defined by 'attrs/'.
        this.updateDOMSubtreeAttributes(el, model.attr(), {
            selectors
        });
        // update the label position etc.
        this.updateLabelPositions();
        // *Deprecated*
        // Local perpendicular flag (as opposed to one defined on paper).
        // Could be enabled inside a connector/router. It's valid only
        // during the update execution.
        this.options.perpendicular = null;
    },
    updateRoute: function() {
        const { model } = this;
        const vertices = model.vertices();
        // 1. Find Anchors
        const anchors = this.findAnchors(vertices);
        const sourceAnchor = this.sourceAnchor = anchors.source;
        const targetAnchor = this.targetAnchor = anchors.target;
        // 2. Find Route
        const route = this.findRoute(vertices);
        this.route = route;
        // 3. Find Connection Points
        var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);
        this.sourcePoint = connectionPoints.source;
        this.targetPoint = connectionPoints.target;
    },
    updatePath: function() {
        const { route, sourcePoint, targetPoint } = this;
        // 4. Find Connection
        const path = this.findPath(route, sourcePoint.clone(), targetPoint.clone());
        this.path = path;
    },
    findAnchorsOrdered: function(firstEndType, firstRef, secondEndType, secondRef) {
        var firstAnchor, secondAnchor;
        var firstAnchorRef, secondAnchorRef;
        var model = this.model;
        var firstDef = model.get(firstEndType);
        var secondDef = model.get(secondEndType);
        var firstView = this.getEndView(firstEndType);
        var secondView = this.getEndView(secondEndType);
        var firstMagnet = this.getEndMagnet(firstEndType);
        var secondMagnet = this.getEndMagnet(secondEndType);
        // Anchor first
        if (firstView) {
            if (firstRef) {
                firstAnchorRef = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](firstRef);
            } else if (secondView) {
                firstAnchorRef = secondMagnet;
            } else {
                firstAnchorRef = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](secondDef);
            }
            firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);
        } else {
            firstAnchor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](firstDef);
        }
        // Anchor second
        if (secondView) {
            secondAnchorRef = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](secondRef || firstAnchor);
            secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);
        } else {
            secondAnchor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](secondDef);
        }
        var res = {};
        res[firstEndType] = firstAnchor;
        res[secondEndType] = secondAnchor;
        return res;
    },
    findAnchors: function(vertices) {
        var model = this.model;
        var firstVertex = vertices[0];
        var lastVertex = vertices[vertices.length - 1];
        if (model.target().priority && !model.source().priority) {
            // Reversed order
            return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);
        }
        // Usual order
        return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);
    },
    findConnectionPoints: function(route, sourceAnchor, targetAnchor) {
        var firstWaypoint = route[0];
        var lastWaypoint = route[route.length - 1];
        var model = this.model;
        var sourceDef = model.get('source');
        var targetDef = model.get('target');
        var sourceView = this.sourceView;
        var targetView = this.targetView;
        var paperOptions = this.paper.options;
        var sourceMagnet, targetMagnet;
        // Connection Point Source
        var sourcePoint;
        if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {
            sourceMagnet = this.sourceMagnet || sourceView.el;
            var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;
            var sourcePointRef = firstWaypoint || targetAnchor;
            var sourceLine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$line$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"](sourcePointRef, sourceAnchor);
            sourcePoint = this.getConnectionPoint(sourceConnectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');
        } else {
            sourcePoint = sourceAnchor;
        }
        // Connection Point Target
        var targetPoint;
        if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {
            targetMagnet = this.targetMagnet || targetView.el;
            var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;
            var targetPointRef = lastWaypoint || sourceAnchor;
            var targetLine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$line$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"](targetPointRef, targetAnchor);
            targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');
        } else {
            targetPoint = targetAnchor;
        }
        return {
            source: sourcePoint,
            target: targetPoint
        };
    },
    getAnchor: function(anchorDef, cellView, magnet, ref, endType) {
        var isConnection = cellView.isNodeConnection(magnet);
        var paperOptions = this.paper.options;
        if (!anchorDef) {
            if (isConnection) {
                anchorDef = paperOptions.defaultLinkAnchor;
            } else {
                if (this.options.perpendicular) {
                    // Backwards compatibility
                    // See `manhattan` router for more details
                    anchorDef = {
                        name: 'perpendicular'
                    };
                } else {
                    anchorDef = paperOptions.defaultAnchor;
                }
            }
        }
        if (!anchorDef) throw new Error('Anchor required.');
        var anchorFn;
        if (typeof anchorDef === 'function') {
            anchorFn = anchorDef;
        } else {
            var anchorName = anchorDef.name;
            var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';
            anchorFn = paperOptions[anchorNamespace][anchorName];
            if (typeof anchorFn !== 'function') throw new Error('Unknown anchor: ' + anchorName);
        }
        var anchor = anchorFn.call(this, cellView, magnet, ref, anchorDef.args || {}, endType, this);
        if (!anchor) return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]();
        return anchor.round(this.decimalsRounding);
    },
    getConnectionPoint: function(connectionPointDef, view, magnet, line, endType) {
        var connectionPoint;
        var anchor = line.end;
        var paperOptions = this.paper.options;
        if (!connectionPointDef) return anchor;
        var connectionPointFn;
        if (typeof connectionPointDef === 'function') {
            connectionPointFn = connectionPointDef;
        } else {
            var connectionPointName = connectionPointDef.name;
            connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];
            if (typeof connectionPointFn !== 'function') throw new Error('Unknown connection point: ' + connectionPointName);
        }
        connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);
        if (!connectionPoint) return anchor;
        return connectionPoint.round(this.decimalsRounding);
    },
    isIntersecting: function(geometryShape, geometryData) {
        const connection = this.getConnection();
        if (!connection) return false;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["intersection"].exists(geometryShape, connection, geometryData, {
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
    },
    isEnclosedIn: function(geometryRect) {
        const connection = this.getConnection();
        if (!connection) return false;
        const bbox = connection.bbox();
        if (!bbox) return false;
        return geometryRect.containsRect(bbox);
    },
    isAtPoint: function(point /*, options */ ) {
        // Note: `strict` option is not applicable for links.
        // There is currently no method to determine if a path contains a point.
        const area = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](point);
        // Intersection with a zero-size area is not possible.
        area.inflate(this.EPSILON);
        return this.isIntersecting(area);
    },
    // combine default label position with built-in default label position
    _getDefaultLabelPositionProperty: function() {
        var model = this.model;
        var builtinDefaultLabel = model._builtins.defaultLabel;
        var builtinDefaultLabelPosition = builtinDefaultLabel.position;
        var defaultLabel = model._getDefaultLabel();
        var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])({}, builtinDefaultLabelPosition, defaultLabelPosition);
    },
    // if label position is a number, normalize it to a position object
    // this makes sure that label positions can be merged properly
    _normalizeLabelPosition: function(labelPosition) {
        if (typeof labelPosition === 'number') return {
            distance: labelPosition,
            offset: null,
            angle: 0,
            args: null
        };
        return labelPosition;
    },
    // expects normalized position properties
    // e.g. `this._normalizeLabelPosition(labelPosition)` and `this._getDefaultLabelPositionProperty()`
    _mergeLabelPositionProperty: function(normalizedLabelPosition, normalizedDefaultLabelPosition) {
        if (normalizedLabelPosition === null) return null;
        if (normalizedLabelPosition === undefined) {
            if (normalizedDefaultLabelPosition === null) return null;
            return normalizedDefaultLabelPosition;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])({}, normalizedDefaultLabelPosition, normalizedLabelPosition);
    },
    updateLabelPositions: function() {
        if (!this._V.labels) return this;
        var path = this.path;
        if (!path) return this;
        // This method assumes all the label nodes are stored in the `this._labelCache` hash table
        // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.
        var model = this.model;
        var labels = model.get('labels') || [];
        if (!labels.length) return this;
        var defaultLabelPosition = this._getDefaultLabelPositionProperty();
        for(var idx = 0, n = labels.length; idx < n; idx++){
            var labelNode = this._labelCache[idx];
            if (!labelNode) continue;
            var label = labels[idx];
            var labelPosition = this._normalizeLabelPosition(label.position);
            var position = this._mergeLabelPositionProperty(labelPosition, defaultLabelPosition);
            var transformationMatrix = this._getLabelTransformationMatrix(position);
            labelNode.setAttribute('transform', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].matrixToTransformString(transformationMatrix));
            this._cleanLabelMatrices(idx);
        }
        return this;
    },
    _cleanLabelMatrices: function(index) {
        // Clean magnetMatrix for all nodes of the label.
        // Cached BoundingRect does not need to updated when the position changes
        // TODO: this doesn't work for labels with XML String markups.
        const { metrics, _labelSelectors } = this;
        const selectors = _labelSelectors[index];
        if (!selectors) return;
        for(let selector in selectors){
            const { id } = selectors[selector];
            if (id && id in metrics) delete metrics[id].magnetMatrix;
        }
    },
    updateEndProperties: function(endType) {
        const { model, paper } = this;
        const endViewProperty = `${endType}View`;
        const endDef = model.get(endType);
        const endId = endDef && endDef.id;
        if (!endId) {
            // the link end is a point ~ rect 0x0
            this[endViewProperty] = null;
            this.updateEndMagnet(endType);
            return true;
        }
        const endModel = paper.getModelById(endId);
        if (!endModel) throw new Error('LinkView: invalid ' + endType + ' cell.');
        const endView = endModel.findView(paper);
        if (!endView) {
            // A view for a model should always exist
            return false;
        }
        this[endViewProperty] = endView;
        this.updateEndMagnet(endType);
        return true;
    },
    updateEndMagnet: function(endType) {
        const endMagnetProperty = `${endType}Magnet`;
        const endView = this.getEndView(endType);
        if (endView) {
            let connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));
            if (connectedMagnet === endView.el) connectedMagnet = null;
            this[endMagnetProperty] = connectedMagnet;
        } else {
            this[endMagnetProperty] = null;
        }
    },
    _getLabelPositionProperty: function(idx) {
        return this.model.label(idx).position || {};
    },
    _getLabelPositionAngle: function(idx) {
        var labelPosition = this._getLabelPositionProperty(idx);
        return labelPosition.angle || 0;
    },
    _getLabelPositionArgs: function(idx) {
        var labelPosition = this._getLabelPositionProperty(idx);
        return labelPosition.args;
    },
    _getDefaultLabelPositionArgs: function() {
        var defaultLabel = this.model._getDefaultLabel();
        var defaultLabelPosition = defaultLabel.position || {};
        return defaultLabelPosition.args;
    },
    // merge default label position args into label position args
    // keep `undefined` or `null` because `{}` means something else
    _mergeLabelPositionArgs: function(labelPositionArgs, defaultLabelPositionArgs) {
        if (labelPositionArgs === null) return null;
        if (labelPositionArgs === undefined) {
            if (defaultLabelPositionArgs === null) return null;
            return defaultLabelPositionArgs;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])({}, defaultLabelPositionArgs, labelPositionArgs);
    },
    // Add default label at given position at end of `labels` array.
    // Four signatures:
    // - obj, obj = point, opt
    // - obj, num, obj = point, angle, opt
    // - num, num, obj = x, y, opt
    // - num, num, num, obj = x, y, angle, opt
    // Assigns relative coordinates by default:
    // `opt.absoluteDistance` forces absolute coordinates.
    // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).
    // `opt.absoluteOffset` forces absolute coordinates for offset.
    // Additional args:
    // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.
    // `opt.ensureLegibility` rotates labels so they are never upside-down.
    addLabel: function(p1, p2, p3, p4) {
        // normalize data from the four possible signatures
        var localX;
        var localY;
        var localAngle = 0;
        var localOpt;
        if (typeof p1 !== 'number') {
            // {x, y} object provided as first parameter
            localX = p1.x;
            localY = p1.y;
            if (typeof p2 === 'number') {
                // angle and opt provided as second and third parameters
                localAngle = p2;
                localOpt = p3;
            } else {
                // opt provided as second parameter
                localOpt = p2;
            }
        } else {
            // x and y provided as first and second parameters
            localX = p1;
            localY = p2;
            if (typeof p3 === 'number') {
                // angle and opt provided as third and fourth parameters
                localAngle = p3;
                localOpt = p4;
            } else {
                // opt provided as third parameter
                localOpt = p3;
            }
        }
        // merge label position arguments
        var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();
        var labelPositionArgs = localOpt;
        var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);
        // append label to labels array
        var label = {
            position: this.getLabelPosition(localX, localY, localAngle, positionArgs)
        };
        var idx = -1;
        this.model.insertLabel(idx, label, localOpt);
        return idx;
    },
    // Add a new vertex at calculated index to the `vertices` array.
    addVertex: function(x, y, opt) {
        // accept input in form `{ x, y }, opt` or `x, y, opt`
        var isPointProvided = typeof x !== 'number';
        var localX = isPointProvided ? x.x : x;
        var localY = isPointProvided ? x.y : y;
        var localOpt = isPointProvided ? y : opt;
        var vertex = {
            x: localX,
            y: localY
        };
        var idx = this.getVertexIndex(localX, localY);
        this.model.insertVertex(idx, vertex, localOpt);
        return idx;
    },
    // Send a token (an SVG element, usually a circle) along the connection path.
    // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`
    // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.
    // `opt.direction` is optional and it determines whether the token goes from source to target or other way round (`reverse`)
    // `opt.connection` is an optional selector to the connection path.
    // `callback` is optional and is a function to be called once the token reaches the target.
    sendToken: function(token, opt, callback) {
        function onAnimationEnd(vToken, callback) {
            return function() {
                vToken.remove();
                if (typeof callback === 'function') {
                    callback();
                }
            };
        }
        var duration, isReversed, selector;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(opt)) {
            duration = opt.duration;
            isReversed = opt.direction === 'reverse';
            selector = opt.connection;
        } else {
            // Backwards compatibility
            duration = opt;
            isReversed = false;
            selector = null;
        }
        duration = duration || 1000;
        var animationAttributes = {
            dur: duration + 'ms',
            repeatCount: 1,
            calcMode: 'linear',
            fill: 'freeze'
        };
        if (isReversed) {
            animationAttributes.keyPoints = '1;0';
            animationAttributes.keyTimes = '0;1';
        }
        var vToken = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(token);
        var connection;
        if (typeof selector === 'string') {
            // Use custom connection path.
            connection = this.findNode(selector);
        } else {
            // Select connection path automatically.
            var cache = this._V;
            connection = cache.connection ? cache.connection.node : this.el.querySelector('path');
        }
        if (!(connection instanceof SVGPathElement)) {
            throw new Error('dia.LinkView: token animation requires a valid connection path.');
        }
        vToken.appendTo(this.paper.cells).animateAlongPath(animationAttributes, connection);
        setTimeout(onAnimationEnd(vToken, callback), duration);
    },
    findRoute: function(vertices) {
        vertices || (vertices = []);
        var namespace = this.paper.options.routerNamespace || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__;
        var router = this.model.router();
        var defaultRouter = this.paper.options.defaultRouter;
        if (!router) {
            if (defaultRouter) router = defaultRouter;
            else return vertices.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]); // no router specified
        }
        var routerFn = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(router) ? router : namespace[router.name];
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(routerFn)) {
            throw new Error('dia.LinkView: unknown router: "' + router.name + '".');
        }
        var args = router.args || {};
        var route = routerFn.call(this, vertices, args, this // linkView
        );
        if (!route) return vertices.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"]);
        return route;
    },
    // Return the `d` attribute value of the `<path>` element representing the link
    // between `source` and `target`.
    findPath: function(route, sourcePoint, targetPoint) {
        var namespace = this.paper.options.connectorNamespace || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__;
        var connector = this.model.connector();
        var defaultConnector = this.paper.options.defaultConnector;
        if (!connector) {
            connector = defaultConnector || {};
        }
        var connectorFn = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(connector) ? connector : namespace[connector.name];
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(connectorFn)) {
            throw new Error('dia.LinkView: unknown connector: "' + connector.name + '".');
        }
        var args = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(connector.args || {});
        args.raw = true; // Request raw g.Path as the result.
        var path = connectorFn.call(this, sourcePoint, targetPoint, route, args, this // linkView
        );
        if (typeof path === 'string') {
            // Backwards compatibility for connectors not supporting `raw` option.
            path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$path$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].normalizePathData(path));
        }
        return path;
    },
    // Public API.
    // -----------
    getConnection: function() {
        var path = this.path;
        if (!path) return null;
        return path.clone();
    },
    getSerializedConnection: function() {
        var path = this.path;
        if (!path) return null;
        var metrics = this.metrics;
        if (metrics.hasOwnProperty('data')) return metrics.data;
        var data = path.serialize();
        metrics.data = data;
        return data;
    },
    getConnectionSubdivisions: function() {
        var path = this.path;
        if (!path) return null;
        var metrics = this.metrics;
        if (metrics.hasOwnProperty('segmentSubdivisions')) return metrics.segmentSubdivisions;
        var subdivisions = path.getSegmentSubdivisions();
        metrics.segmentSubdivisions = subdivisions;
        return subdivisions;
    },
    getConnectionLength: function() {
        var path = this.path;
        if (!path) return 0;
        var metrics = this.metrics;
        if (metrics.hasOwnProperty('length')) return metrics.length;
        var length = path.length({
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
        metrics.length = length;
        return length;
    },
    getPointAtLength: function(length) {
        var path = this.path;
        if (!path) return null;
        return path.pointAtLength(length, {
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
    },
    getPointAtRatio: function(ratio) {
        var path = this.path;
        if (!path) return null;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isPercentage"])(ratio)) ratio = parseFloat(ratio) / 100;
        return path.pointAt(ratio, {
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
    },
    getTangentAtLength: function(length) {
        var path = this.path;
        if (!path) return null;
        return path.tangentAtLength(length, {
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
    },
    getTangentAtRatio: function(ratio) {
        var path = this.path;
        if (!path) return null;
        return path.tangentAt(ratio, {
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
    },
    getClosestPoint: function(point) {
        var path = this.path;
        if (!path) return null;
        return path.closestPoint(point, {
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
    },
    getClosestPointLength: function(point) {
        var path = this.path;
        if (!path) return null;
        return path.closestPointLength(point, {
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
    },
    getClosestPointRatio: function(point) {
        var path = this.path;
        if (!path) return null;
        return path.closestPointNormalizedLength(point, {
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
    },
    // Get label position object based on two provided coordinates, x and y.
    // (Used behind the scenes when user moves labels around.)
    // Two signatures:
    // - num, num, obj = x, y, options
    // - num, num, num, obj = x, y, angle, options
    // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`
    // - `absoluteOffset` is necessary in order to move beyond connection endpoints
    // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`
    getLabelPosition: function(x, y, p3, p4) {
        var position = {};
        // normalize data from the two possible signatures
        var localAngle = 0;
        var localOpt;
        if (typeof p3 === 'number') {
            // angle and opt provided as third and fourth argument
            localAngle = p3;
            localOpt = p4;
        } else {
            // opt provided as third argument
            localOpt = p3;
        }
        // save localOpt as `args` of the position object that is passed along
        if (localOpt) position.args = localOpt;
        // identify distance/offset settings
        var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default
        var isDistanceAbsoluteReverse = localOpt && localOpt.absoluteDistance && localOpt.reverseDistance; // non-reverse by default
        var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default
        // find closest point t
        var path = this.path;
        var pathOpt = {
            segmentSubdivisions: this.getConnectionSubdivisions()
        };
        var labelPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](x, y);
        var t = path.closestPointT(labelPoint, pathOpt);
        // DISTANCE:
        var labelDistance = path.lengthAtT(t, pathOpt);
        if (isDistanceRelative) labelDistance = labelDistance / this.getConnectionLength() || 0; // fix to prevent NaN for 0 length
        if (isDistanceAbsoluteReverse) labelDistance = -1 * (this.getConnectionLength() - labelDistance) || 1; // fix for end point (-0 => 1)
        position.distance = labelDistance;
        // OFFSET:
        // use absolute offset if:
        // - opt.absoluteOffset is true,
        // - opt.absoluteOffset is not true but there is no tangent
        var tangent;
        if (!isOffsetAbsolute) tangent = path.tangentAtT(t);
        var labelOffset;
        if (tangent) {
            labelOffset = tangent.pointOffset(labelPoint);
        } else {
            var closestPoint = path.pointAtT(t);
            var labelOffsetDiff = labelPoint.difference(closestPoint);
            labelOffset = {
                x: labelOffsetDiff.x,
                y: labelOffsetDiff.y
            };
        }
        position.offset = labelOffset;
        // ANGLE:
        position.angle = localAngle;
        return position;
    },
    _getLabelTransformationMatrix: function(labelPosition) {
        var labelDistance;
        var labelAngle = 0;
        var args = {};
        if (typeof labelPosition === 'number') {
            labelDistance = labelPosition;
        } else if (typeof labelPosition.distance === 'number') {
            args = labelPosition.args || {};
            labelDistance = labelPosition.distance;
            labelAngle = labelPosition.angle || 0;
        } else {
            throw new Error('dia.LinkView: invalid label position distance.');
        }
        var isDistanceRelative = labelDistance > 0 && labelDistance <= 1;
        var labelOffset = 0;
        var labelOffsetCoordinates = {
            x: 0,
            y: 0
        };
        if (labelPosition.offset) {
            var positionOffset = labelPosition.offset;
            if (typeof positionOffset === 'number') labelOffset = positionOffset;
            if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;
            if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;
        }
        var isOffsetAbsolute = labelOffsetCoordinates.x !== 0 || labelOffsetCoordinates.y !== 0 || labelOffset === 0;
        var isKeepGradient = args.keepGradient;
        var isEnsureLegibility = args.ensureLegibility;
        var path = this.path;
        var pathOpt = {
            segmentSubdivisions: this.getConnectionSubdivisions()
        };
        var distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;
        var tangent = path.tangentAtLength(distance, pathOpt);
        var translation;
        var angle = labelAngle;
        if (tangent) {
            if (isOffsetAbsolute) {
                translation = tangent.start.clone();
                translation.offset(labelOffsetCoordinates);
            } else {
                var normal = tangent.clone();
                normal.rotate(tangent.start, -90);
                normal.setLength(labelOffset);
                translation = normal.end;
            }
            if (isKeepGradient) {
                angle = tangent.angle() + labelAngle;
                if (isEnsureLegibility) {
                    angle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$geometry$2e$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeAngle"])((angle + 90) % 180 - 90);
                }
            }
        } else {
            // fallback - the connection has zero length
            translation = path.start.clone();
            if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createSVGMatrix().translate(translation.x, translation.y).rotate(angle);
    },
    getLabelCoordinates: function(labelPosition) {
        var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](transformationMatrix.e, transformationMatrix.f);
    },
    getVertexIndex: function(x, y) {
        var model = this.model;
        var vertices = model.vertices();
        var vertexLength = this.getClosestPointLength(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](x, y));
        var idx = 0;
        for(var n = vertices.length; idx < n; idx++){
            var currentVertex = vertices[idx];
            var currentVertexLength = this.getClosestPointLength(currentVertex);
            if (vertexLength < currentVertexLength) break;
        }
        return idx;
    },
    // Interaction. The controller part.
    // ---------------------------------
    notifyPointerdown (evt, x, y) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.pointerdown.call(this, evt, x, y);
        this.notify('link:pointerdown', evt, x, y);
    },
    notifyPointermove (evt, x, y) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.pointermove.call(this, evt, x, y);
        this.notify('link:pointermove', evt, x, y);
    },
    notifyPointerup (evt, x, y) {
        this.notify('link:pointerup', evt, x, y);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.pointerup.call(this, evt, x, y);
    },
    pointerdblclick: function(evt, x, y) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.pointerdblclick.apply(this, arguments);
        this.notify('link:pointerdblclick', evt, x, y);
    },
    pointerclick: function(evt, x, y) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.pointerclick.apply(this, arguments);
        this.notify('link:pointerclick', evt, x, y);
    },
    contextmenu: function(evt, x, y) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.contextmenu.apply(this, arguments);
        this.notify('link:contextmenu', evt, x, y);
    },
    pointerdown: function(evt, x, y) {
        this.notifyPointerdown(evt, x, y);
        this.dragStart(evt, x, y);
    },
    pointermove: function(evt, x, y) {
        // Backwards compatibility
        var dragData = this._dragData;
        if (dragData) this.eventData(evt, dragData);
        var data = this.eventData(evt);
        switch(data.action){
            case 'label-move':
                this.dragLabel(evt, x, y);
                break;
            case 'arrowhead-move':
                this.dragArrowhead(evt, x, y);
                break;
            case 'move':
                this.drag(evt, x, y);
                break;
        }
        // Backwards compatibility
        if (dragData) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(dragData, this.eventData(evt));
        this.notifyPointermove(evt, x, y);
    },
    pointerup: function(evt, x, y) {
        // Backwards compatibility
        var dragData = this._dragData;
        if (dragData) {
            this.eventData(evt, dragData);
            this._dragData = null;
        }
        var data = this.eventData(evt);
        switch(data.action){
            case 'label-move':
                this.dragLabelEnd(evt, x, y);
                break;
            case 'arrowhead-move':
                this.dragArrowheadEnd(evt, x, y);
                break;
            case 'move':
                this.dragEnd(evt, x, y);
        }
        this.notifyPointerup(evt, x, y);
        this.checkMouseleave(evt);
    },
    mouseover: function(evt) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.mouseover.apply(this, arguments);
        this.notify('link:mouseover', evt);
    },
    mouseout: function(evt) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.mouseout.apply(this, arguments);
        this.notify('link:mouseout', evt);
    },
    mouseenter: function(evt) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.mouseenter.apply(this, arguments);
        this.notify('link:mouseenter', evt);
    },
    mouseleave: function(evt) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.mouseleave.apply(this, arguments);
        this.notify('link:mouseleave', evt);
    },
    mousewheel: function(evt, x, y, delta) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.mousewheel.apply(this, arguments);
        this.notify('link:mousewheel', evt, x, y, delta);
    },
    onlabel: function(evt, x, y) {
        this.notifyPointerdown(evt, x, y);
        this.dragLabelStart(evt, x, y);
        var stopPropagation = this.eventData(evt).stopPropagation;
        if (stopPropagation) evt.stopPropagation();
    },
    // Drag Start Handlers
    dragLabelStart: function(evt, x, y) {
        if (this.can('labelMove')) {
            if (this.isDefaultInteractionPrevented(evt)) return;
            var labelNode = evt.currentTarget;
            var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);
            var defaultLabelPosition = this._getDefaultLabelPositionProperty();
            var initialLabelPosition = this._normalizeLabelPosition(this._getLabelPositionProperty(labelIdx));
            var position = this._mergeLabelPositionProperty(initialLabelPosition, defaultLabelPosition);
            var coords = this.getLabelCoordinates(position);
            var dx = coords.x - x; // how much needs to be added to cursor x to get to label x
            var dy = coords.y - y; // how much needs to be added to cursor y to get to label y
            var positionAngle = this._getLabelPositionAngle(labelIdx);
            var labelPositionArgs = this._getLabelPositionArgs(labelIdx);
            var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();
            var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);
            this.eventData(evt, {
                action: 'label-move',
                labelIdx: labelIdx,
                dx: dx,
                dy: dy,
                positionAngle: positionAngle,
                positionArgs: positionArgs,
                stopPropagation: true
            });
        } else {
            // Backwards compatibility:
            // If labels can't be dragged no default action is triggered.
            this.eventData(evt, {
                stopPropagation: true
            });
        }
        this.paper.delegateDragEvents(this, evt.data);
    },
    dragArrowheadStart: function(evt, x, y) {
        if (!this.can('arrowheadMove')) return;
        var arrowheadNode = evt.target;
        var arrowheadType = arrowheadNode.getAttribute('end');
        var data = this.startArrowheadMove(arrowheadType, {
            ignoreBackwardsCompatibility: true
        });
        this.eventData(evt, data);
    },
    dragStart: function(evt, x, y) {
        if (this.isDefaultInteractionPrevented(evt)) return;
        if (!this.can('linkMove')) return;
        this.eventData(evt, {
            action: 'move',
            dx: x,
            dy: y
        });
    },
    // Drag Handlers
    dragLabel: function(evt, x, y) {
        var data = this.eventData(evt);
        var label = {
            position: this.getLabelPosition(x + data.dx, y + data.dy, data.positionAngle, data.positionArgs)
        };
        if (this.paper.options.snapLabels) delete label.position.offset;
        // The `touchmove' events are not fired
        // when the original event target is removed from the DOM.
        // The labels are currently re-rendered completely when only
        // the position changes. This is why we need to make sure that
        // the label is updated synchronously.
        // TODO: replace `touchmove` with `pointermove` (breaking change).
        const setOptions = {
            ui: true
        };
        if (this.paper.isAsync() && evt.type === 'touchmove') {
            setOptions.async = false;
        }
        this.model.label(data.labelIdx, label, setOptions);
    },
    dragArrowhead: function(evt, x, y) {
        if (this.paper.options.snapLinks) {
            const isSnapped = this._snapArrowhead(evt, x, y);
            if (!isSnapped && this.paper.options.snapLinksSelf) {
                this._snapArrowheadSelf(evt, x, y);
            }
        } else {
            if (this.paper.options.snapLinksSelf) {
                this._snapArrowheadSelf(evt, x, y);
            } else {
                this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));
            }
        }
    },
    drag: function(evt, x, y) {
        var data = this.eventData(evt);
        this.model.translate(x - data.dx, y - data.dy, {
            ui: true
        });
        this.eventData(evt, {
            dx: x,
            dy: y
        });
    },
    // Drag End Handlers
    dragLabelEnd: function() {
    // noop
    },
    dragArrowheadEnd: function(evt, x, y) {
        var data = this.eventData(evt);
        var paper = this.paper;
        if (paper.options.snapLinks) {
            this._snapArrowheadEnd(data);
        } else {
            this._connectArrowheadEnd(data, x, y);
        }
        if (!paper.linkAllowed(this)) {
            // If the changed link is not allowed, revert to its previous state.
            this._disallow(data);
        } else {
            this._finishEmbedding(data);
            this._notifyConnectEvent(data, evt);
        }
        this._afterArrowheadMove(data);
    },
    dragEnd: function() {
    // noop
    },
    _disallow: function(data) {
        switch(data.whenNotAllowed){
            case 'remove':
                this.model.remove({
                    ui: true
                });
                break;
            case 'revert':
            default:
                this.model.set(data.arrowhead, data.initialEnd, {
                    ui: true
                });
                break;
        }
    },
    _finishEmbedding: function(data) {
        // Reparent the link if embedding is enabled
        if (this.paper.options.embeddingMode && this.model.reparent()) {
            // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).
            data.z = null;
        }
    },
    _notifyConnectEvent: function(data, evt) {
        var arrowhead = data.arrowhead;
        var initialEnd = data.initialEnd;
        var currentEnd = this.model.prop(arrowhead);
        var endChanged = currentEnd && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Link$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Link"].endsEqual(initialEnd, currentEnd);
        if (endChanged) {
            var paper = this.paper;
            if (initialEnd.id) {
                this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);
            }
            if (currentEnd.id) {
                this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);
            }
        }
    },
    _snapToPoints: function(snapPoint, points, radius) {
        let closestPointX = null;
        let closestDistanceX = Infinity;
        let closestPointY = null;
        let closestDistanceY = Infinity;
        let x = snapPoint.x;
        let y = snapPoint.y;
        for(let i = 0; i < points.length; i++){
            const distX = Math.abs(points[i].x - snapPoint.x);
            if (distX < closestDistanceX) {
                closestDistanceX = distX;
                closestPointX = points[i];
            }
            const distY = Math.abs(points[i].y - snapPoint.y);
            if (distY < closestDistanceY) {
                closestDistanceY = distY;
                closestPointY = points[i];
            }
        }
        if (closestDistanceX < radius) {
            x = closestPointX.x;
        }
        if (closestDistanceY < radius) {
            y = closestPointY.y;
        }
        return {
            x,
            y
        };
    },
    _snapArrowheadSelf: function(evt, x, y) {
        const { paper, model } = this;
        const { snapLinksSelf } = paper.options;
        const data = this.eventData(evt);
        const radius = snapLinksSelf.radius || 20;
        const anchor = this.getEndAnchor(data.arrowhead === 'source' ? 'target' : 'source');
        const vertices = model.vertices();
        const points = [
            anchor,
            ...vertices
        ];
        const snapPoint = this._snapToPoints({
            x: x,
            y: y
        }, points, radius);
        const point = paper.localToClientPoint(snapPoint);
        this._connectArrowhead(document.elementFromPoint(point.x, point.y), snapPoint.x, snapPoint.y, this.eventData(evt));
    },
    _snapArrowhead: function(evt, x, y) {
        const { paper } = this;
        const { snapLinks, connectionStrategy } = paper.options;
        const data = this.eventData(evt);
        let isSnapped = false;
        // checking view in close area of the pointer
        var r = snapLinks.radius || 50;
        var viewsInArea = paper.findElementViewsInArea({
            x: x - r,
            y: y - r,
            width: 2 * r,
            height: 2 * r
        }, snapLinks.findInAreaOptions);
        var prevClosestView = data.closestView || null;
        var prevClosestMagnet = data.closestMagnet || null;
        var prevMagnetProxy = data.magnetProxy || null;
        data.closestView = data.closestMagnet = data.magnetProxy = null;
        var minDistance = Number.MAX_VALUE;
        var pointer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](x, y);
        viewsInArea.forEach(function(view) {
            const candidates = [];
            // skip connecting to the element in case '.': { magnet: false } attribute present
            if (view.el.getAttribute('magnet') !== 'false') {
                candidates.push({
                    bbox: view.model.getBBox(),
                    magnet: view.el
                });
            }
            view.$('[magnet]').toArray().forEach((magnet)=>{
                candidates.push({
                    bbox: view.getNodeBBox(magnet),
                    magnet
                });
            });
            candidates.forEach((candidate)=>{
                const { magnet, bbox } = candidate;
                // find distance from the center of the model to pointer coordinates
                const distance = bbox.center().squaredDistance(pointer);
                // the connection is looked up in a circle area by `distance < r`
                if (distance < minDistance) {
                    const isAlreadyValidated = prevClosestMagnet === magnet;
                    if (isAlreadyValidated || paper.options.validateConnection.apply(paper, data.validateConnectionArgs(view, view.el === magnet ? null : magnet))) {
                        minDistance = distance;
                        data.closestView = view;
                        data.closestMagnet = magnet;
                    }
                }
            });
        }, this);
        var end;
        var magnetProxy = null;
        var closestView = data.closestView;
        var closestMagnet = data.closestMagnet;
        if (closestMagnet) {
            magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');
        }
        var endType = data.arrowhead;
        var newClosestMagnet = prevClosestMagnet !== closestMagnet;
        if (prevClosestView && newClosestMagnet) {
            prevClosestView.unhighlight(prevMagnetProxy, {
                connecting: true,
                snapping: true
            });
        }
        if (closestView) {
            const { prevEnd, prevX, prevY } = data;
            data.prevX = x;
            data.prevY = y;
            isSnapped = true;
            if (!newClosestMagnet) {
                if (typeof connectionStrategy !== 'function' || prevX === x && prevY === y) {
                    // the magnet has not changed and the link's end does not depend on the x and y
                    return isSnapped;
                }
            }
            end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);
            if (!newClosestMagnet && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEqual"])(prevEnd, end)) {
                // the source/target json has not changed
                return isSnapped;
            }
            data.prevEnd = end;
            if (newClosestMagnet) {
                closestView.highlight(magnetProxy, {
                    connecting: true,
                    snapping: true
                });
            }
        } else {
            end = {
                x: x,
                y: y
            };
        }
        this.model.set(endType, end || {
            x: x,
            y: y
        }, {
            ui: true
        });
        if (prevClosestView) {
            this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);
        }
        if (closestView) {
            this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);
        }
        return isSnapped;
    },
    _snapArrowheadEnd: function(data) {
        // Finish off link snapping.
        // Everything except view unhighlighting was already done on pointermove.
        var closestView = data.closestView;
        var closestMagnet = data.closestMagnet;
        if (closestView && closestMagnet) {
            closestView.unhighlight(data.magnetProxy, {
                connecting: true,
                snapping: true
            });
            data.magnetUnderPointer = closestView.findMagnet(closestMagnet);
        }
        data.closestView = data.closestMagnet = null;
    },
    _connectArrowhead: function(target, x, y, data) {
        // checking views right under the pointer
        const { paper, model } = this;
        if (data.eventTarget !== target) {
            // Unhighlight the previous view under pointer if there was one.
            if (data.magnetProxy) {
                data.viewUnderPointer.unhighlight(data.magnetProxy, {
                    connecting: true
                });
            }
            const viewUnderPointer = data.viewUnderPointer = paper.findView(target);
            if (viewUnderPointer) {
                // If we found a view that is under the pointer, we need to find the closest
                // magnet based on the real target element of the event.
                const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);
                const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');
                if (magnetUnderPointer && this.paper.options.validateConnection.apply(paper, data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer))) {
                    // If there was no magnet found, do not highlight anything and assume there
                    // is no view under pointer we're interested in reconnecting to.
                    // This can only happen if the overall element has the attribute `'.': { magnet: false }`.
                    if (magnetProxy) {
                        viewUnderPointer.highlight(magnetProxy, {
                            connecting: true
                        });
                    }
                } else {
                    // This type of connection is not valid. Disregard this magnet.
                    data.magnetUnderPointer = null;
                    data.magnetProxy = null;
                }
            } else {
                // Make sure we'll unset previous magnet.
                data.magnetUnderPointer = null;
                data.magnetProxy = null;
            }
        }
        data.eventTarget = target;
        model.set(data.arrowhead, {
            x: x,
            y: y
        }, {
            ui: true
        });
    },
    _connectArrowheadEnd: function(data = {}, x, y) {
        const { model } = this;
        const { viewUnderPointer, magnetUnderPointer, magnetProxy, arrowhead } = data;
        if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;
        viewUnderPointer.unhighlight(magnetProxy, {
            connecting: true
        });
        // The link end is taken from the magnet under the pointer, not the proxy.
        const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);
        model.set(arrowhead, end, {
            ui: true
        });
    },
    _beforeArrowheadMove: function(data) {
        data.z = this.model.get('z');
        this.model.toFront();
        // Let the pointer propagate through the link view elements so that
        // the `evt.target` is another element under the pointer, not the link itself.
        var style = this.el.style;
        data.pointerEvents = style.pointerEvents;
        style.pointerEvents = 'none';
        if (this.paper.options.markAvailable) {
            this._markAvailableMagnets(data);
        }
    },
    _afterArrowheadMove: function(data) {
        if (data.z !== null) {
            this.model.set('z', data.z, {
                ui: true
            });
            data.z = null;
        }
        // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.
        this.el.style.pointerEvents = data.pointerEvents;
        if (this.paper.options.markAvailable) {
            this._unmarkAvailableMagnets(data);
        }
    },
    _createValidateConnectionArgs: function(arrowhead) {
        // It makes sure the arguments for validateConnection have the following form:
        // (source view, source magnet, target view, target magnet and link view)
        var args = [];
        args[4] = arrowhead;
        args[5] = this;
        var oppositeArrowhead;
        var i = 0;
        var j = 0;
        if (arrowhead === 'source') {
            i = 2;
            oppositeArrowhead = 'target';
        } else {
            j = 2;
            oppositeArrowhead = 'source';
        }
        var end = this.model.get(oppositeArrowhead);
        if (end.id) {
            var view = args[i] = this.paper.findViewByModel(end.id);
            var magnet = view.getMagnetFromLinkEnd(end);
            if (magnet === view.el) magnet = undefined;
            args[i + 1] = magnet;
        }
        function validateConnectionArgs(cellView, magnet) {
            args[j] = cellView;
            args[j + 1] = cellView.el === magnet ? undefined : magnet;
            return args;
        }
        return validateConnectionArgs;
    },
    _markAvailableMagnets: function(data) {
        function isMagnetAvailable(view, magnet) {
            var paper = view.paper;
            var validate = paper.options.validateConnection;
            return validate.apply(paper, this.validateConnectionArgs(view, magnet));
        }
        var paper = this.paper;
        var elements = paper.model.getCells();
        data.marked = {};
        for(var i = 0, n = elements.length; i < n; i++){
            var view = elements[i].findView(paper);
            if (!view) {
                continue;
            }
            var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));
            if (view.el.getAttribute('magnet') !== 'false') {
                // Element wrapping group is also a magnet
                magnets.push(view.el);
            }
            var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));
            if (availableMagnets.length > 0) {
                // highlight all available magnets
                for(var j = 0, m = availableMagnets.length; j < m; j++){
                    view.highlight(availableMagnets[j], {
                        magnetAvailability: true
                    });
                }
                // highlight the entire view
                view.highlight(null, {
                    elementAvailability: true
                });
                data.marked[view.model.id] = availableMagnets;
            }
        }
    },
    _unmarkAvailableMagnets: function(data) {
        var markedKeys = Object.keys(data.marked);
        var id;
        var markedMagnets;
        for(var i = 0, n = markedKeys.length; i < n; i++){
            id = markedKeys[i];
            markedMagnets = data.marked[id];
            var view = this.paper.findViewByModel(id);
            if (view) {
                for(var j = 0, m = markedMagnets.length; j < m; j++){
                    view.unhighlight(markedMagnets[j], {
                        magnetAvailability: true
                    });
                }
                view.unhighlight(null, {
                    elementAvailability: true
                });
            }
        }
        data.marked = null;
    },
    startArrowheadMove: function(end, opt) {
        opt || (opt = {});
        // Allow to delegate events from an another view to this linkView in order to trigger arrowhead
        // move without need to click on the actual arrowhead dom element.
        var data = {
            action: 'arrowhead-move',
            arrowhead: end,
            whenNotAllowed: opt.whenNotAllowed || 'revert',
            initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),
            initialEnd: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this.model.get(end)),
            validateConnectionArgs: this._createValidateConnectionArgs(end)
        };
        this._beforeArrowheadMove(data);
        if (opt.ignoreBackwardsCompatibility !== true) {
            this._dragData = data;
        }
        return data;
    },
    // Lifecycle methods
    onMount: function() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.onMount.apply(this, arguments);
        this.mountLabels();
    },
    onDetach: function() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.onDetach.apply(this, arguments);
        this.unmountLabels();
    },
    onRemove: function() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].prototype.onRemove.apply(this, arguments);
        this.unmountLabels();
    }
}, {
    Flags: Flags
});
Object.defineProperty(LinkView.prototype, 'sourceBBox', {
    enumerable: true,
    get: function() {
        var sourceView = this.sourceView;
        if (!sourceView) {
            var sourceDef = this.model.source();
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](sourceDef.x, sourceDef.y);
        }
        var sourceMagnet = this.sourceMagnet;
        if (sourceView.isNodeConnection(sourceMagnet)) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](this.sourceAnchor);
        }
        return sourceView.getNodeBBox(sourceMagnet || sourceView.el);
    }
});
Object.defineProperty(LinkView.prototype, 'targetBBox', {
    enumerable: true,
    get: function() {
        var targetView = this.targetView;
        if (!targetView) {
            var targetDef = this.model.target();
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](targetDef.x, targetDef.y);
        }
        var targetMagnet = this.targetMagnet;
        if (targetView.isNodeConnection(targetMagnet)) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](this.targetAnchor);
        }
        return targetView.getNodeBBox(targetMagnet || targetView.el);
    }
});
}}),
"[project]/node_modules/@joint/core/src/dia/layers/GridLayer.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "GridLayer": (()=>GridLayer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/PaperLayer.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/utilHelpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/V/index.mjs [app-client] (ecmascript)");
;
;
;
const GridLayer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PaperLayer"].extend({
    style: {
        'pointer-events': 'none'
    },
    _gridCache: null,
    _gridSettings: null,
    init () {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PaperLayer"].prototype.init.apply(this, arguments);
        const { options: { paper } } = this;
        this._gridCache = null;
        this._gridSettings = [];
        this.listenTo(paper, 'transform resize', this.updateGrid);
    },
    setGrid (drawGrid) {
        this._gridSettings = this.getGridSettings(drawGrid);
        this.renderGrid();
    },
    getGridSettings (drawGrid) {
        const gridSettings = [];
        if (drawGrid) {
            const optionsList = Array.isArray(drawGrid) ? drawGrid : [
                drawGrid || {}
            ];
            optionsList.forEach((item)=>{
                gridSettings.push(...this._resolveDrawGridOption(item));
            });
        }
        return gridSettings;
    },
    removeGrid () {
        const { _gridCache: grid } = this;
        if (!grid) return;
        grid.root.remove();
        this._gridCache = null;
    },
    renderGrid () {
        const { options: { paper } } = this;
        const { _gridSettings: gridSettings } = this;
        this.removeGrid();
        if (gridSettings.length === 0) return;
        const gridSize = paper.options.drawGridSize || paper.options.gridSize;
        if (gridSize <= 1) {
            return;
        }
        const refs = this._getGridRefs();
        gridSettings.forEach((gridLayerSetting, index)=>{
            const id = this._getPatternId(index);
            const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])({}, gridLayerSetting);
            const { scaleFactor = 1 } = options;
            options.width = gridSize * scaleFactor || 1;
            options.height = gridSize * scaleFactor || 1;
            let vPattern;
            if (!refs.exist(id)) {
                vPattern = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('pattern', {
                    id: id,
                    patternUnits: 'userSpaceOnUse'
                }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options.markup));
                refs.add(id, vPattern);
            } else {
                vPattern = refs.get(id);
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(options.render)) {
                options.render(vPattern.node.firstChild, options, paper);
            }
            vPattern.attr({
                width: options.width,
                height: options.height
            });
        });
        refs.root.appendTo(this.el);
        this.updateGrid();
    },
    updateGrid () {
        const { _gridCache: grid, _gridSettings: gridSettings, options: { paper } } = this;
        if (!grid) return;
        const { root: vSvg, patterns } = grid;
        const { x, y, width, height } = paper.getArea();
        vSvg.attr({
            x,
            y,
            width,
            height
        });
        for(const patternId in patterns){
            const vPattern = patterns[patternId];
            vPattern.attr({
                x: -x,
                y: -y
            });
        }
        gridSettings.forEach((options, index)=>{
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(options.update)) {
                const vPattern = patterns[this._getPatternId(index)];
                options.update(vPattern.node.firstChild, options, paper);
            }
        });
    },
    _getPatternId (index) {
        return `pattern_${this.options.paper.cid}_${index}`;
    },
    _getGridRefs () {
        let { _gridCache: grid } = this;
        if (grid) return grid;
        const defsVEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('defs');
        const svgVEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('svg', {
            width: '100%',
            height: '100%'
        }, [
            defsVEl
        ]);
        grid = this._gridCache = {
            root: svgVEl,
            patterns: {},
            add: function(id, patternVEl) {
                const rectVEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('rect', {
                    width: '100%',
                    height: '100%',
                    fill: `url(#${id})`
                });
                defsVEl.append(patternVEl);
                svgVEl.append(rectVEl);
                this.patterns[id] = patternVEl;
            },
            get: function(id) {
                return this.patterns[id];
            },
            exist: function(id) {
                return this.patterns[id] !== undefined;
            }
        };
        return grid;
    },
    _resolveDrawGridOption (opt) {
        var namespace = this.options.patterns;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(opt) && Array.isArray(namespace[opt])) {
            return namespace[opt].map(function(item) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])({}, item);
            });
        }
        var options = opt || {
            args: [
                {}
            ]
        };
        var isArray = Array.isArray(options);
        var name = options.name;
        if (!isArray && !name && !options.markup) {
            name = 'dot';
        }
        if (name && Array.isArray(namespace[name])) {
            var pattern = namespace[name].map(function(item) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])({}, item);
            });
            var args = Array.isArray(options.args) ? options.args : [
                options.args || {}
            ];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaults"])(args[0], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["omit"])(opt, 'args'));
            for(var i = 0; i < args.length; i++){
                if (pattern[i]) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])(pattern[i], args[i]);
                }
            }
            return pattern;
        }
        return isArray ? options : [
            options
        ];
    }
});
}}),
"[project]/node_modules/@joint/core/src/dia/Paper.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Paper": (()=>Paper)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/CellView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/PaperLayer.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$View$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/mvc/View.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$ElementView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/ElementView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$LinkView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/LinkView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/util.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/highlighters/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$anchors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/anchors/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$linkAnchors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/linkAnchors/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectionPoints$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/connectionPoints/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/utilHelpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Graph$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/Graph.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/V/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$layers$2f$GridLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/layers/GridLayer.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/rect.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/point.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$ViewBase$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/mvc/ViewBase.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/mvc/Dom/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Cell$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/Cell.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$geometry$2e$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/geometry.helpers.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const sortingTypes = {
    NONE: 'sorting-none',
    APPROX: 'sorting-approximate',
    EXACT: 'sorting-exact'
};
const WHEEL_CAP = 50;
const WHEEL_WAIT_MS = 20;
const MOUNT_BATCH_SIZE = 1000;
const UPDATE_BATCH_SIZE = Infinity;
const MIN_PRIORITY = 9007199254740991; // Number.MAX_SAFE_INTEGER
const HighlightingTypes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"].Highlighting;
const defaultHighlighting = {
    [HighlightingTypes.DEFAULT]: {
        name: 'stroke',
        options: {
            padding: 3
        }
    },
    [HighlightingTypes.MAGNET_AVAILABILITY]: {
        name: 'addClass',
        options: {
            className: 'available-magnet'
        }
    },
    [HighlightingTypes.ELEMENT_AVAILABILITY]: {
        name: 'addClass',
        options: {
            className: 'available-cell'
        }
    }
};
const defaultLayers = [
    {
        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"].GRID
    },
    {
        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"].BACK
    },
    {
        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"].CELLS
    },
    {
        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"].LABELS
    },
    {
        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"].FRONT
    },
    {
        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"].TOOLS
    }
];
const Paper = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$View$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"].extend({
    className: 'paper',
    options: {
        width: 800,
        height: 600,
        gridSize: 1,
        // Whether or not to draw the grid lines on the paper's DOM element.
        // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }
        drawGrid: false,
        // If not set, the size of the visual grid is the same as the `gridSize`.
        drawGridSize: null,
        // Whether or not to draw the background on the paper's DOM element.
        // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }
        background: false,
        elementView: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$ElementView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementView"],
        linkView: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$LinkView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinkView"],
        snapLabels: false,
        snapLinks: false,
        snapLinksSelf: false,
        // Should the link labels be rendered into its own layer?
        // `false` - the labels are part of the links
        // `true` - the labels are appended to LayersName.LABELS
        // [LayersName] - the labels are appended to the layer specified
        labelsLayer: false,
        // When set to FALSE, an element may not have more than 1 link with the same source and target element.
        multiLinks: true,
        // For adding custom guard logic.
        guard: function(evt, view) {
            // FALSE means the event isn't guarded.
            return false;
        },
        highlighting: defaultHighlighting,
        // Prevent the default context menu from being displayed.
        preventContextMenu: true,
        // Prevent the default action for blank:pointer<action>.
        preventDefaultBlankAction: true,
        // Prevent the default action for cell:pointer<action>.
        preventDefaultViewAction: true,
        // Restrict the translation of elements by given bounding box.
        // Option accepts a boolean:
        //  true - the translation is restricted to the paper area
        //  false - no restrictions
        // A method:
        // restrictTranslate: function(elementView) {
        //     var parentId = elementView.model.get('parent');
        //     return parentId && this.model.getCell(parentId).getBBox();
        // },
        // Or a bounding box:
        // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }
        restrictTranslate: false,
        // Marks all available magnets with 'available-magnet' class name and all available cells with
        // 'available-cell' class name. Marks them when dragging a link is started and unmark
        // when the dragging is stopped.
        markAvailable: false,
        // Defines what link model is added to the graph after an user clicks on an active magnet.
        // Value could be the mvc.model or a function returning the mvc.model
        // defaultLink: (elementView, magnet) => {
        //   return condition ? new customLink1() : new customLink2()
        // }
        defaultLink: function() {
            // Do not create hard dependency on the joint.shapes.standard namespace (by importing the standard.Link model directly)
            const { cellNamespace } = this.model.get('cells');
            const ctor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getByPath"])(cellNamespace, [
                'standard',
                'Link'
            ]);
            if (!ctor) throw new Error('dia.Paper: no default link model found. Use `options.defaultLink` to specify a default link model.');
            return new ctor();
        },
        // A connector that is used by links with no connector defined on the model.
        // e.g. { name: 'rounded', args: { radius: 5 }} or a function
        defaultConnector: {
            name: 'normal'
        },
        // A router that is used by links with no router defined on the model.
        // e.g. { name: 'oneSide', args: { padding: 10 }} or a function
        defaultRouter: {
            name: 'normal'
        },
        defaultAnchor: {
            name: 'center'
        },
        defaultLinkAnchor: {
            name: 'connectionRatio'
        },
        defaultConnectionPoint: {
            name: 'boundary'
        },
        /* CONNECTING */ connectionStrategy: null,
        // Check whether to add a new link to the graph when user clicks on an a magnet.
        validateMagnet: function(_cellView, magnet, _evt) {
            return magnet.getAttribute('magnet') !== 'passive';
        },
        // Check whether to allow or disallow the link connection while an arrowhead end (source/target)
        // being changed.
        validateConnection: function(cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {
            return (end === 'target' ? cellViewT : cellViewS) instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$ElementView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementView"];
        },
        /* EMBEDDING */ // Enables embedding. Re-parent the dragged element with elements under it and makes sure that
        // all links and elements are visible taken the level of embedding into account.
        embeddingMode: false,
        // Check whether to allow or disallow the element embedding while an element being translated.
        validateEmbedding: function(childView, parentView) {
            // by default all elements can be in relation child-parent
            return true;
        },
        // Check whether to allow or disallow an embedded element to be unembedded / to become a root.
        validateUnembedding: function(childView) {
            // by default all elements can become roots
            return true;
        },
        // Determines the way how a cell finds a suitable parent when it's dragged over the paper.
        // The cell with the highest z-index (visually on the top) will be chosen.
        findParentBy: 'bbox',
        // If enabled only the element on the very front is taken into account for the embedding.
        // If disabled the elements under the dragged view are tested one by one
        // (from front to back) until a valid parent found.
        frontParentOnly: true,
        // Interactive flags. See online docs for the complete list of interactive flags.
        interactive: {
            labelMove: false
        },
        // When set to true the links can be pinned to the paper.
        // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };
        linkPinning: true,
        // Custom validation after an interaction with a link ends.
        // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)
        // (linkView, paper) => boolean
        allowLink: null,
        // Allowed number of mousemove events after which the pointerclick event will be still triggered.
        clickThreshold: 0,
        // Number of required mousemove events before the first pointermove event will be triggered.
        moveThreshold: 0,
        // Number of required mousemove events before a link is created out of the magnet.
        // Or string `onleave` so the link is created when the pointer leaves the magnet
        magnetThreshold: 0,
        // Rendering Options
        sorting: sortingTypes.APPROX,
        frozen: false,
        autoFreeze: false,
        // no docs yet
        onViewUpdate: function(view, flag, priority, opt, paper) {
            // Do not update connected links when:
            // 1. the view was just inserted (added to the graph and rendered)
            // 2. the view was just mounted (added back to the paper by viewport function)
            // 3. the change was marked as `isolate`.
            // 4. the view model was just removed from the graph
            if (flag & (view.FLAG_INSERT | view.FLAG_REMOVE) || opt.mounting || opt.isolate) return;
            paper.requestConnectedLinksUpdate(view, priority, opt);
        },
        // no docs yet
        onViewPostponed: function(view, flag, paper) {
            return paper.forcePostponedViewUpdate(view, flag);
        },
        beforeRender: null,
        afterRender: null,
        viewport: null,
        // Default namespaces
        cellViewNamespace: null,
        routerNamespace: null,
        connectorNamespace: null,
        highlighterNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$highlighters$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
        anchorNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$anchors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
        linkAnchorNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$linkAnchors$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
        connectionPointNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$connectionPoints$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
        overflow: false
    },
    events: {
        'dblclick': 'pointerdblclick',
        'dbltap': 'pointerdblclick',
        'contextmenu': 'contextmenu',
        'mousedown': 'pointerdown',
        'touchstart': 'pointerdown',
        'mouseover': 'mouseover',
        'mouseout': 'mouseout',
        'mouseenter': 'mouseenter',
        'mouseleave': 'mouseleave',
        'wheel': 'mousewheel',
        'mouseenter .joint-cell': 'mouseenter',
        'mouseleave .joint-cell': 'mouseleave',
        'mouseenter .joint-tools': 'mouseenter',
        'mouseleave .joint-tools': 'mouseleave',
        'dblclick .joint-cell [magnet]': 'magnetpointerdblclick',
        'contextmenu .joint-cell [magnet]': 'magnetcontextmenu',
        'mousedown .joint-link .label': 'onlabel',
        'touchstart .joint-link .label': 'onlabel',
        'dragstart .joint-cell image': 'onImageDragStart' // firefox fix
    },
    documentEvents: {
        'mousemove': 'pointermove',
        'touchmove': 'pointermove',
        'mouseup': 'pointerup',
        'touchend': 'pointerup',
        'touchcancel': 'pointerup'
    },
    /* CSS within the SVG document
    * 1. Adding vector-effect: non-scaling-stroke; to prevent the stroke width from scaling for
    *    elements that use the `scalable` group.
    */ stylesheet: /*css*/ `
        .joint-element .scalable * {
            vector-effect: non-scaling-stroke;
        }
    `,
    svg: null,
    viewport: null,
    defs: null,
    tools: null,
    layers: null,
    // For storing the current transformation matrix (CTM) of the paper's viewport.
    _viewportMatrix: null,
    // For verifying whether the CTM is up-to-date. The viewport transform attribute
    // could have been manipulated directly.
    _viewportTransformString: null,
    // Updates data (priorities, unmounted views etc.)
    _updates: null,
    // Paper Layers
    _layers: null,
    SORT_DELAYING_BATCHES: [
        'add',
        'to-front',
        'to-back'
    ],
    UPDATE_DELAYING_BATCHES: [
        'translate'
    ],
    // If you interact with these elements,
    // the default interaction such as `element move` is prevented.
    FORM_CONTROL_TAG_NAMES: [
        'TEXTAREA',
        'INPUT',
        'BUTTON',
        'SELECT',
        'OPTION'
    ],
    // If you interact with these elements, the events are not propagated to the paper
    // i.e. paper events such as `element:pointerdown` are not triggered.
    GUARDED_TAG_NAMES: [
        // Guard <select> for consistency. When you click on it:
        // Chrome: triggers `pointerdown`, `pointerup`, `pointerclick` to open
        // Firefox: triggers `pointerdown` on open, `pointerup` (and `pointerclick` only if you haven't moved).
        //          on close. However, if you open and then close by clicking elsewhere on the page,
        //           no other event is triggered.
        // Safari: when you open it, it triggers `pointerdown`. That's it.
        'SELECT'
    ],
    MIN_SCALE: 1e-6,
    // Default find buffer for the findViewsInArea and findViewsAtPoint methods.
    // The find buffer is used to extend the area of the search
    // to mitigate the differences between the model and view geometry.
    DEFAULT_FIND_BUFFER: 200,
    init: function() {
        const { options } = this;
        if (!options.cellViewNamespace) {
            /* eslint-disable no-undef */ options.cellViewNamespace = typeof joint !== 'undefined' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["has"])(joint, 'shapes') ? joint.shapes : null;
        /* eslint-enable no-undef */ }
        const model = this.model = options.model || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Graph$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Graph"];
        // Layers (SVGGroups)
        this._layers = {};
        this.cloneOptions();
        this.render();
        this._setDimensions();
        this.startListening();
        // Hash of all cell views.
        this._views = {};
        // Mouse wheel events buffer
        this._mw_evt_buffer = {
            event: null,
            deltas: []
        };
        // Render existing cells in the graph
        this.resetViews(model.attributes.cells.models);
        // Start the Rendering Loop
        if (!this.isFrozen() && this.isAsync()) this.updateViewsAsync();
    },
    _resetUpdates: function() {
        if (this._updates && this._updates.id) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["cancelFrame"])(this._updates.id);
        return this._updates = {
            id: null,
            priorities: [
                {},
                {},
                {}
            ],
            unmountedCids: [],
            mountedCids: [],
            unmounted: {},
            mounted: {},
            count: 0,
            keyFrozen: false,
            freezeKey: null,
            sort: false,
            disabled: false,
            idle: false
        };
    },
    startListening: function() {
        var model = this.model;
        this.listenTo(model, 'add', this.onCellAdded).listenTo(model, 'remove', this.onCellRemoved).listenTo(model, 'change', this.onCellChange).listenTo(model, 'reset', this.onGraphReset).listenTo(model, 'sort', this.onGraphSort).listenTo(model, 'batch:stop', this.onGraphBatchStop);
        this.on('cell:highlight', this.onCellHighlight).on('cell:unhighlight', this.onCellUnhighlight).on('transform', this.update);
    },
    onCellAdded: function(cell, _, opt) {
        var position = opt.position;
        if (this.isAsync() || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(position)) {
            this.renderView(cell, opt);
        } else {
            if (opt.maxPosition === position) this.freeze({
                key: 'addCells'
            });
            this.renderView(cell, opt);
            if (position === 0) this.unfreeze({
                key: 'addCells'
            });
        }
    },
    onCellRemoved: function(cell, _, opt) {
        const view = this.findViewByModel(cell);
        if (view) this.requestViewUpdate(view, view.FLAG_REMOVE, view.UPDATE_PRIORITY, opt);
    },
    onCellChange: function(cell, opt) {
        if (cell === this.model.attributes.cells) return;
        if (cell.hasChanged('z') && this.options.sorting === sortingTypes.APPROX) {
            const view = this.findViewByModel(cell);
            if (view) this.requestViewUpdate(view, view.FLAG_INSERT, view.UPDATE_PRIORITY, opt);
        }
    },
    onGraphReset: function(collection, opt) {
        this.resetLayers();
        this.resetViews(collection.models, opt);
    },
    onGraphSort: function() {
        if (this.model.hasActiveBatch(this.SORT_DELAYING_BATCHES)) return;
        this.sortViews();
    },
    onGraphBatchStop: function(data) {
        if (this.isFrozen()) return;
        var name = data && data.batchName;
        var graph = this.model;
        if (!this.isAsync()) {
            var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;
            if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) {
                this.updateViews(data);
            }
        }
        var sortDelayingBatches = this.SORT_DELAYING_BATCHES;
        if (sortDelayingBatches.includes(name) && !graph.hasActiveBatch(sortDelayingBatches)) {
            this.sortViews();
        }
    },
    cloneOptions: function() {
        const { options } = this;
        const { defaultConnector, defaultRouter, defaultConnectionPoint, defaultAnchor, defaultLinkAnchor, highlighting, cellViewNamespace, interactive } = options;
        // Default cellView namespace for ES5
        /* eslint-disable no-undef */ if (!cellViewNamespace && typeof joint !== 'undefined' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["has"])(joint, 'shapes')) {
            options.cellViewNamespace = joint.shapes;
        }
        /* eslint-enable no-undef */ // Here if a function was provided, we can not clone it, as this would result in loosing the function.
        // If the default is used, the cloning is necessary in order to prevent modifying the options on prototype.
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(defaultConnector)) {
            options.defaultConnector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneDeep"])(defaultConnector);
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(defaultRouter)) {
            options.defaultRouter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneDeep"])(defaultRouter);
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(defaultConnectionPoint)) {
            options.defaultConnectionPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneDeep"])(defaultConnectionPoint);
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(defaultAnchor)) {
            options.defaultAnchor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneDeep"])(defaultAnchor);
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(defaultLinkAnchor)) {
            options.defaultLinkAnchor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneDeep"])(defaultLinkAnchor);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(interactive)) {
            options.interactive = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])({}, interactive);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(highlighting)) {
            // Return the default highlighting options into the user specified options.
            options.highlighting = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultsDeep"])({}, highlighting, defaultHighlighting);
        }
    },
    children: function() {
        var ns = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].namespace;
        return [
            {
                namespaceURI: ns.xhtml,
                tagName: 'div',
                className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addClassNamePrefix"])('paper-background'),
                selector: 'background',
                style: {
                    position: 'absolute',
                    inset: 0
                }
            },
            {
                namespaceURI: ns.svg,
                tagName: 'svg',
                attributes: {
                    'width': '100%',
                    'height': '100%',
                    'xmlns:xlink': ns.xlink
                },
                selector: 'svg',
                style: {
                    position: 'absolute',
                    inset: 0
                },
                children: [
                    {
                        // Append `<defs>` element to the SVG document. This is useful for filters and gradients.
                        // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).
                        tagName: 'defs',
                        selector: 'defs'
                    },
                    {
                        tagName: 'g',
                        className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addClassNamePrefix"])('layers'),
                        selector: 'layers'
                    }
                ]
            }
        ];
    },
    hasLayerView (layerName) {
        return layerName in this._layers;
    },
    getLayerView (layerName) {
        const { _layers } = this;
        if (layerName in _layers) return _layers[layerName];
        throw new Error(`dia.Paper: Unknown layer "${layerName}"`);
    },
    getLayerNode (layerName) {
        return this.getLayerView(layerName).el;
    },
    render: function() {
        this.renderChildren();
        const { el, childNodes, options, stylesheet } = this;
        const { svg, defs, layers } = childNodes;
        el.style.position = 'relative';
        svg.style.overflow = options.overflow ? 'visible' : 'hidden';
        this.svg = svg;
        this.defs = defs;
        this.layers = layers;
        this.renderLayers();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].ensureId(svg);
        this.addStylesheet(stylesheet);
        if (options.background) {
            this.drawBackground(options.background);
        }
        if (options.drawGrid) {
            this.setGrid(options.drawGrid);
        }
        return this;
    },
    addStylesheet: function(css) {
        if (!css) return;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.svg).prepend(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createSVGStyle(css));
    },
    createLayer (name) {
        switch(name){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"].GRID:
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$layers$2f$GridLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GridLayer"]({
                    name,
                    paper: this,
                    patterns: this.constructor.gridPatterns
                });
            default:
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PaperLayer"]({
                    name
                });
        }
    },
    renderLayers: function(layers = defaultLayers) {
        this.removeLayers();
        // TODO: Layers to be read from the graph `layers` attribute
        layers.forEach(({ name, sorted })=>{
            const layerView = this.createLayer(name);
            this.layers.appendChild(layerView.el);
            this._layers[name] = layerView;
        });
        // Throws an exception if doesn't exist
        const cellsLayerView = this.getLayerView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"].CELLS);
        const toolsLayerView = this.getLayerView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"].TOOLS);
        const labelsLayerView = this.getLayerView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"].LABELS);
        // backwards compatibility
        this.tools = toolsLayerView.el;
        this.cells = this.viewport = cellsLayerView.el;
        // user-select: none;
        cellsLayerView.vel.addClass((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addClassNamePrefix"])('viewport'));
        labelsLayerView.vel.addClass((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addClassNamePrefix"])('viewport'));
        cellsLayerView.el.style.webkitUserSelect = 'none';
        cellsLayerView.el.style.userSelect = 'none';
        labelsLayerView.el.style.webkitUserSelect = 'none';
        labelsLayerView.el.style.userSelect = 'none';
    },
    removeLayers: function() {
        const { _layers } = this;
        Object.keys(_layers).forEach((name)=>{
            _layers[name].remove();
            delete _layers[name];
        });
    },
    resetLayers: function() {
        const { _layers } = this;
        Object.keys(_layers).forEach((name)=>{
            _layers[name].removePivots();
        });
    },
    update: function() {
        if (this._background) {
            this.updateBackgroundImage(this._background);
        }
        return this;
    },
    scale: function(sx, sy, data) {
        const ctm = this.matrix();
        // getter
        if (sx === undefined) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].matrixToScale(ctm);
        }
        // setter
        if (sy === undefined) {
            sy = sx;
        }
        sx = Math.max(sx || 0, this.MIN_SCALE);
        sy = Math.max(sy || 0, this.MIN_SCALE);
        ctm.a = sx;
        ctm.d = sy;
        this.matrix(ctm, data);
        return this;
    },
    scaleUniformAtPoint: function(scale, point, data) {
        const { a: sx, d: sy, e: tx, f: ty } = this.matrix();
        scale = Math.max(scale || 0, this.MIN_SCALE);
        if (scale === sx && scale === sy) {
            // The scale is the same as the current one.
            return this;
        }
        const matrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createSVGMatrix().translate(tx - point.x * (scale - sx), ty - point.y * (scale - sy)).scale(scale, scale);
        this.matrix(matrix, data);
        return this;
    },
    translate: function(tx, ty, data) {
        const ctm = this.matrix();
        // getter
        if (tx === undefined) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].matrixToTranslate(ctm);
        }
        // setter
        tx || (tx = 0);
        ty || (ty = 0);
        if (ctm.e === tx && ctm.f === ty) return this;
        ctm.e = tx;
        ctm.f = ty;
        this.matrix(ctm, data);
        return this;
    },
    matrix: function(ctm, data = {}) {
        var viewport = this.layers;
        // Getter:
        if (ctm === undefined) {
            var transformString = viewport.getAttribute('transform');
            if ((this._viewportTransformString || null) === transformString) {
                // It's ok to return the cached matrix. The transform attribute has not changed since
                // the matrix was stored.
                ctm = this._viewportMatrix;
            } else {
                // The viewport transform attribute has changed. Measure the matrix and cache again.
                ctm = viewport.getCTM();
                this._viewportMatrix = ctm;
                this._viewportTransformString = transformString;
            }
            // Clone the cached current transformation matrix.
            // If no matrix previously stored the identity matrix is returned.
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createSVGMatrix(ctm);
        }
        // Setter:
        const prev = this.matrix();
        const current = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createSVGMatrix(ctm);
        const currentTransformString = this._viewportTransformString;
        const ctmString = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].matrixToTransformString(current);
        if (ctmString === currentTransformString) {
            // The new transform string is the same as the current one.
            // No need to update the transform attribute.
            return this;
        }
        if (!currentTransformString && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].matrixToTransformString() === ctmString) {
            // The current transform string is empty and the new one is an identity matrix.
            // No need to update the transform attribute.
            return this;
        }
        const { a, d, e, f } = current;
        viewport.setAttribute('transform', ctmString);
        this._viewportMatrix = current;
        this._viewportTransformString = viewport.getAttribute('transform');
        // scale event
        if (a !== prev.a || d !== prev.d) {
            this.trigger('scale', a, d, data);
        }
        // translate event
        if (e !== prev.e || f !== prev.f) {
            this.trigger('translate', e, f, data);
        }
        this.trigger('transform', current, data);
        return this;
    },
    clientMatrix: function() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createSVGMatrix(this.cells.getScreenCTM());
    },
    requestConnectedLinksUpdate: function(view, priority, opt) {
        if (view instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"]) {
            var model = view.model;
            var links = this.model.getConnectedLinks(model);
            for(var j = 0, n = links.length; j < n; j++){
                var link = links[j];
                var linkView = this.findViewByModel(link);
                if (!linkView) continue;
                var flagLabels = [
                    'UPDATE'
                ];
                if (link.getTargetCell() === model) flagLabels.push('TARGET');
                if (link.getSourceCell() === model) flagLabels.push('SOURCE');
                var nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);
                this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);
            }
        }
    },
    forcePostponedViewUpdate: function(view, flag) {
        if (!view || !(view instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"])) return false;
        var model = view.model;
        if (model.isElement()) return false;
        if ((flag & view.getFlag([
            'SOURCE',
            'TARGET'
        ])) === 0) {
            var dumpOptions = {
                silent: true
            };
            // LinkView is waiting for the target or the source cellView to be rendered
            // This can happen when the cells are not in the viewport.
            var sourceFlag = 0;
            var sourceView = this.findViewByModel(model.getSourceCell());
            if (sourceView && !this.isViewMounted(sourceView)) {
                sourceFlag = this.dumpView(sourceView, dumpOptions);
                view.updateEndMagnet('source');
            }
            var targetFlag = 0;
            var targetView = this.findViewByModel(model.getTargetCell());
            if (targetView && !this.isViewMounted(targetView)) {
                targetFlag = this.dumpView(targetView, dumpOptions);
                view.updateEndMagnet('target');
            }
            if (sourceFlag === 0 && targetFlag === 0) {
                // If leftover flag is 0, all view updates were done.
                return !this.dumpView(view, dumpOptions);
            }
        }
        return false;
    },
    requestViewUpdate: function(view, flag, priority, opt) {
        opt || (opt = {});
        this.scheduleViewUpdate(view, flag, priority, opt);
        var isAsync = this.isAsync();
        if (this.isFrozen() || isAsync && opt.async !== false) return;
        if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) return;
        var stats = this.updateViews(opt);
        if (isAsync) this.notifyAfterRender(stats, opt);
    },
    scheduleViewUpdate: function(view, type, priority, opt) {
        const { _updates: updates, options } = this;
        if (updates.idle) {
            if (options.autoFreeze) {
                updates.idle = false;
                this.unfreeze();
            }
        }
        const { FLAG_REMOVE, FLAG_INSERT, UPDATE_PRIORITY, cid } = view;
        let priorityUpdates = updates.priorities[priority];
        if (!priorityUpdates) priorityUpdates = updates.priorities[priority] = {};
        // Move higher priority updates to this priority
        if (priority > UPDATE_PRIORITY) {
            // Not the default priority for this view. It's most likely a link view
            // connected to another link view, which triggered the update.
            // TODO: If there is an update scheduled with a lower priority already, we should
            // change the requested priority to the lowest one. Does not seem to be critical
            // right now, as it "only" results in multiple updates on the same view.
            for(let i = priority - 1; i >= UPDATE_PRIORITY; i--){
                const prevPriorityUpdates = updates.priorities[i];
                if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) continue;
                priorityUpdates[cid] |= prevPriorityUpdates[cid];
                delete prevPriorityUpdates[cid];
            }
        }
        let currentType = priorityUpdates[cid] || 0;
        // Prevent cycling
        if ((currentType & type) === type) return;
        if (!currentType) updates.count++;
        if (type & FLAG_REMOVE && currentType & FLAG_INSERT) {
            // When a view is removed we need to remove the insert flag as this is a reinsert
            priorityUpdates[cid] ^= FLAG_INSERT;
        } else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) {
            // When a view is added we need to remove the remove flag as this is view was previously removed
            priorityUpdates[cid] ^= FLAG_REMOVE;
        }
        priorityUpdates[cid] |= type;
        const viewUpdateFn = options.onViewUpdate;
        if (typeof viewUpdateFn === 'function') viewUpdateFn.call(this, view, type, priority, opt || {}, this);
    },
    dumpViewUpdate: function(view) {
        if (!view) return 0;
        var updates = this._updates;
        var cid = view.cid;
        var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];
        var flag = this.registerMountedView(view) | priorityUpdates[cid];
        delete priorityUpdates[cid];
        return flag;
    },
    dumpView: function(view, opt = {}) {
        const flag = this.dumpViewUpdate(view);
        if (!flag) return 0;
        const shouldNotify = !opt.silent;
        if (shouldNotify) this.notifyBeforeRender(opt);
        const leftover = this.updateView(view, flag, opt);
        if (shouldNotify) {
            const stats = {
                updated: 1,
                priority: view.UPDATE_PRIORITY
            };
            this.notifyAfterRender(stats, opt);
        }
        return leftover;
    },
    updateView: function(view, flag, opt) {
        if (!view) return 0;
        const { FLAG_REMOVE, FLAG_INSERT, FLAG_INIT, model } = view;
        if (view instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"]) {
            if (flag & FLAG_REMOVE) {
                this.removeView(model);
                return 0;
            }
            if (flag & FLAG_INSERT) {
                const isInitialInsert = !!(flag & FLAG_INIT);
                if (isInitialInsert) {
                    flag ^= FLAG_INIT;
                }
                this.insertView(view, isInitialInsert);
                flag ^= FLAG_INSERT;
            }
        }
        if (!flag) return 0;
        return view.confirmUpdate(flag, opt || {});
    },
    requireView: function(model, opt) {
        var view = this.findViewByModel(model);
        if (!view) return null;
        this.dumpView(view, opt);
        return view;
    },
    registerUnmountedView: function(view) {
        var cid = view.cid;
        var updates = this._updates;
        if (cid in updates.unmounted) return 0;
        var flag = updates.unmounted[cid] |= view.FLAG_INSERT;
        updates.unmountedCids.push(cid);
        delete updates.mounted[cid];
        return flag;
    },
    registerMountedView: function(view) {
        var cid = view.cid;
        var updates = this._updates;
        if (cid in updates.mounted) return 0;
        updates.mounted[cid] = true;
        updates.mountedCids.push(cid);
        var flag = updates.unmounted[cid] || 0;
        delete updates.unmounted[cid];
        return flag;
    },
    isViewMounted: function(view) {
        if (!view) return false;
        var cid = view.cid;
        var updates = this._updates;
        return cid in updates.mounted;
    },
    dumpViews: function(opt) {
        var passingOpt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaults"])({}, opt, {
            viewport: null
        });
        this.checkViewport(passingOpt);
        this.updateViews(passingOpt);
    },
    // Synchronous views update
    updateViews: function(opt) {
        this.notifyBeforeRender(opt);
        let batchStats;
        let updateCount = 0;
        let batchCount = 0;
        let priority = MIN_PRIORITY;
        do {
            batchCount++;
            batchStats = this.updateViewsBatch(opt);
            updateCount += batchStats.updated;
            priority = Math.min(batchStats.priority, priority);
        }while (!batchStats.empty)
        const stats = {
            updated: updateCount,
            batches: batchCount,
            priority
        };
        this.notifyAfterRender(stats, opt);
        return stats;
    },
    hasScheduledUpdates: function() {
        const priorities = this._updates.priorities;
        const priorityIndexes = Object.keys(priorities); // convert priorities to a dense array
        let i = priorityIndexes.length;
        while(i > 0 && i--){
            // a faster way how to check if an object is empty
            for(let _key in priorities[priorityIndexes[i]])return true;
        }
        return false;
    },
    updateViewsAsync: function(opt, data) {
        opt || (opt = {});
        data || (data = {
            processed: 0,
            priority: MIN_PRIORITY
        });
        const { _updates: updates, options } = this;
        const id = updates.id;
        if (id) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["cancelFrame"])(id);
            if (data.processed === 0 && this.hasScheduledUpdates()) {
                this.notifyBeforeRender(opt);
            }
            const stats = this.updateViewsBatch(opt);
            const passingOpt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaults"])({}, opt, {
                mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,
                unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted
            });
            const checkStats = this.checkViewport(passingOpt);
            const unmountCount = checkStats.unmounted;
            const mountCount = checkStats.mounted;
            let processed = data.processed;
            const total = updates.count;
            if (stats.updated > 0) {
                // Some updates have been just processed
                processed += stats.updated + stats.unmounted;
                stats.processed = processed;
                data.priority = Math.min(stats.priority, data.priority);
                if (stats.empty && mountCount === 0) {
                    stats.unmounted += unmountCount;
                    stats.mounted += mountCount;
                    stats.priority = data.priority;
                    this.notifyAfterRender(stats, opt);
                    data.processed = 0;
                    data.priority = MIN_PRIORITY;
                    updates.count = 0;
                } else {
                    data.processed = processed;
                }
            } else {
                if (!updates.idle) {
                    if (options.autoFreeze) {
                        this.freeze();
                        updates.idle = true;
                        this.trigger('render:idle', opt);
                    }
                }
            }
            // Progress callback
            const progressFn = opt.progress;
            if (total && typeof progressFn === 'function') {
                progressFn.call(this, stats.empty, processed, total, stats, this);
            }
            // The current frame could have been canceled in a callback
            if (updates.id !== id) return;
        }
        if (updates.disabled) {
            throw new Error('dia.Paper: can not unfreeze the paper after it was removed');
        }
        updates.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nextFrame"])(this.updateViewsAsync, this, opt, data);
    },
    notifyBeforeRender: function(opt = {}) {
        let beforeFn = opt.beforeRender;
        if (typeof beforeFn !== 'function') {
            beforeFn = this.options.beforeRender;
            if (typeof beforeFn !== 'function') return;
        }
        beforeFn.call(this, opt, this);
    },
    notifyAfterRender: function(stats, opt = {}) {
        let afterFn = opt.afterRender;
        if (typeof afterFn !== 'function') {
            afterFn = this.options.afterRender;
        }
        if (typeof afterFn === 'function') {
            afterFn.call(this, stats, opt, this);
        }
        this.trigger('render:done', stats, opt);
    },
    updateViewsBatch: function(opt) {
        opt || (opt = {});
        var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;
        var updates = this._updates;
        var updateCount = 0;
        var postponeCount = 0;
        var unmountCount = 0;
        var mountCount = 0;
        var maxPriority = MIN_PRIORITY;
        var empty = true;
        var options = this.options;
        var priorities = updates.priorities;
        var viewportFn = 'viewport' in opt ? opt.viewport : options.viewport;
        if (typeof viewportFn !== 'function') viewportFn = null;
        var postponeViewFn = options.onViewPostponed;
        if (typeof postponeViewFn !== 'function') postponeViewFn = null;
        var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array
        main: for(var i = 0, n = priorityIndexes.length; i < n; i++){
            var priority = +priorityIndexes[i];
            var priorityUpdates = priorities[priority];
            for(var cid in priorityUpdates){
                if (updateCount >= batchSize) {
                    empty = false;
                    break main;
                }
                var view = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$View$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["views"][cid];
                if (!view) {
                    // This should not occur
                    delete priorityUpdates[cid];
                    continue;
                }
                var currentFlag = priorityUpdates[cid];
                if ((currentFlag & view.FLAG_REMOVE) === 0) {
                    // We should never check a view for viewport if we are about to remove the view
                    var isDetached = cid in updates.unmounted;
                    if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, !isDetached, this)) {
                        // Unmount View
                        if (!isDetached) {
                            this.registerUnmountedView(view);
                            this.detachView(view);
                        }
                        updates.unmounted[cid] |= currentFlag;
                        delete priorityUpdates[cid];
                        unmountCount++;
                        continue;
                    }
                    // Mount View
                    if (isDetached) {
                        currentFlag |= view.FLAG_INSERT;
                        mountCount++;
                    }
                    currentFlag |= this.registerMountedView(view);
                }
                var leftoverFlag = this.updateView(view, currentFlag, opt);
                if (leftoverFlag > 0) {
                    // View update has not finished completely
                    priorityUpdates[cid] = leftoverFlag;
                    if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {
                        postponeCount++;
                        empty = false;
                        continue;
                    }
                }
                if (maxPriority > priority) maxPriority = priority;
                updateCount++;
                delete priorityUpdates[cid];
            }
        }
        return {
            priority: maxPriority,
            updated: updateCount,
            postponed: postponeCount,
            unmounted: unmountCount,
            mounted: mountCount,
            empty: empty
        };
    },
    getUnmountedViews: function() {
        const updates = this._updates;
        const unmountedCids = Object.keys(updates.unmounted);
        const n = unmountedCids.length;
        const unmountedViews = new Array(n);
        for(var i = 0; i < n; i++){
            unmountedViews[i] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$View$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["views"][unmountedCids[i]];
        }
        return unmountedViews;
    },
    getMountedViews: function() {
        const updates = this._updates;
        const mountedCids = Object.keys(updates.mounted);
        const n = mountedCids.length;
        const mountedViews = new Array(n);
        for(var i = 0; i < n; i++){
            mountedViews[i] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$View$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["views"][mountedCids[i]];
        }
        return mountedViews;
    },
    checkUnmountedViews: function(viewportFn, opt) {
        opt || (opt = {});
        var mountCount = 0;
        if (typeof viewportFn !== 'function') viewportFn = null;
        var batchSize = 'mountBatchSize' in opt ? opt.mountBatchSize : Infinity;
        var updates = this._updates;
        var unmountedCids = updates.unmountedCids;
        var unmounted = updates.unmounted;
        for(var i = 0, n = Math.min(unmountedCids.length, batchSize); i < n; i++){
            var cid = unmountedCids[i];
            if (!(cid in unmounted)) continue;
            var view = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$View$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["views"][cid];
            if (!view) continue;
            if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, false, this)) {
                // Push at the end of all unmounted ids, so this can be check later again
                unmountedCids.push(cid);
                continue;
            }
            mountCount++;
            var flag = this.registerMountedView(view);
            if (flag) this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, {
                mounting: true
            });
        }
        // Get rid of views, that have been mounted
        unmountedCids.splice(0, i);
        return mountCount;
    },
    checkMountedViews: function(viewportFn, opt) {
        opt || (opt = {});
        var unmountCount = 0;
        if (typeof viewportFn !== 'function') return unmountCount;
        var batchSize = 'unmountBatchSize' in opt ? opt.unmountBatchSize : Infinity;
        var updates = this._updates;
        var mountedCids = updates.mountedCids;
        var mounted = updates.mounted;
        for(var i = 0, n = Math.min(mountedCids.length, batchSize); i < n; i++){
            var cid = mountedCids[i];
            if (!(cid in mounted)) continue;
            var view = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$View$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["views"][cid];
            if (!view) continue;
            if (!view.DETACHABLE || viewportFn.call(this, view, true, this)) {
                // Push at the end of all mounted ids, so this can be check later again
                mountedCids.push(cid);
                continue;
            }
            unmountCount++;
            var flag = this.registerUnmountedView(view);
            if (flag) this.detachView(view);
        }
        // Get rid of views, that have been unmounted
        mountedCids.splice(0, i);
        return unmountCount;
    },
    checkViewVisibility: function(cellView, opt = {}) {
        let viewportFn = 'viewport' in opt ? opt.viewport : this.options.viewport;
        if (typeof viewportFn !== 'function') viewportFn = null;
        const updates = this._updates;
        const { mounted, unmounted } = updates;
        const visible = !cellView.DETACHABLE || !viewportFn || viewportFn.call(this, cellView, false, this);
        let isUnmounted = false;
        let isMounted = false;
        if (cellView.cid in mounted && !visible) {
            const flag = this.registerUnmountedView(cellView);
            if (flag) this.detachView(cellView);
            const i = updates.mountedCids.indexOf(cellView.cid);
            updates.mountedCids.splice(i, 1);
            isUnmounted = true;
        }
        if (!isUnmounted && cellView.cid in unmounted && visible) {
            const i = updates.unmountedCids.indexOf(cellView.cid);
            updates.unmountedCids.splice(i, 1);
            var flag = this.registerMountedView(cellView);
            if (flag) this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, {
                mounting: true
            });
            isMounted = true;
        }
        return {
            mounted: isMounted ? 1 : 0,
            unmounted: isUnmounted ? 1 : 0
        };
    },
    checkViewport: function(opt) {
        var passingOpt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaults"])({}, opt, {
            mountBatchSize: Infinity,
            unmountBatchSize: Infinity
        });
        var viewportFn = 'viewport' in passingOpt ? passingOpt.viewport : this.options.viewport;
        var unmountedCount = this.checkMountedViews(viewportFn, passingOpt);
        if (unmountedCount > 0) {
            // Do not check views, that have been just unmounted and pushed at the end of the cids array
            var unmountedCids = this._updates.unmountedCids;
            passingOpt.mountBatchSize = Math.min(unmountedCids.length - unmountedCount, passingOpt.mountBatchSize);
        }
        var mountedCount = this.checkUnmountedViews(viewportFn, passingOpt);
        return {
            mounted: mountedCount,
            unmounted: unmountedCount
        };
    },
    freeze: function(opt) {
        opt || (opt = {});
        var updates = this._updates;
        var key = opt.key;
        var isFrozen = this.options.frozen;
        var freezeKey = updates.freezeKey;
        if (key && key !== freezeKey) {
            // key passed, but the paper is already freezed with another key
            if (isFrozen && freezeKey) return;
            updates.freezeKey = key;
            updates.keyFrozen = isFrozen;
        }
        this.options.frozen = true;
        var id = updates.id;
        updates.id = null;
        if (this.isAsync() && id) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["cancelFrame"])(id);
    },
    unfreeze: function(opt) {
        opt || (opt = {});
        var updates = this._updates;
        var key = opt.key;
        var freezeKey = updates.freezeKey;
        // key passed, but the paper is already freezed with another key
        if (key && freezeKey && key !== freezeKey) return;
        updates.freezeKey = null;
        // key passed, but the paper is already freezed
        if (key && key === freezeKey && updates.keyFrozen) return;
        if (this.isAsync()) {
            this.freeze();
            this.updateViewsAsync(opt);
        } else {
            this.updateViews(opt);
        }
        this.options.frozen = updates.keyFrozen = false;
        if (updates.sort) {
            this.sortViews();
            updates.sort = false;
        }
    },
    isAsync: function() {
        return !!this.options.async;
    },
    isFrozen: function() {
        return !!this.options.frozen;
    },
    isExactSorting: function() {
        return this.options.sorting === sortingTypes.EXACT;
    },
    onRemove: function() {
        this.freeze();
        this._updates.disabled = true;
        //clean up all DOM elements/views to prevent memory leaks
        this.removeLayers();
        this.removeViews();
    },
    getComputedSize: function() {
        var options = this.options;
        var w = options.width;
        var h = options.height;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(w)) w = this.el.clientWidth;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(h)) h = this.el.clientHeight;
        return {
            width: w,
            height: h
        };
    },
    setDimensions: function(width, height, data = {}) {
        const { options } = this;
        const { width: currentWidth, height: currentHeight } = options;
        let w = width === undefined ? currentWidth : width;
        let h = height === undefined ? currentHeight : height;
        if (currentWidth === w && currentHeight === h) return;
        options.width = w;
        options.height = h;
        this._setDimensions();
        const computedSize = this.getComputedSize();
        this.trigger('resize', computedSize.width, computedSize.height, data);
    },
    _setDimensions: function() {
        const { options } = this;
        let w = options.width;
        let h = options.height;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(w)) w = `${Math.round(w)}px`;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(h)) h = `${Math.round(h)}px`;
        this.$el.css({
            width: w === null ? '' : w,
            height: h === null ? '' : h
        });
    },
    // Expand/shrink the paper to fit the content.
    // Alternatively signature function(opt)
    fitToContent: function(gridWidth, gridHeight, padding, opt) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(gridWidth)) {
            // first parameter is an option object
            opt = gridWidth;
        } else {
            // Support for a deprecated signature
            opt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])({
                gridWidth,
                gridHeight,
                padding
            }, opt);
        }
        const { x, y, width, height } = this.getFitToContentArea(opt);
        const { sx, sy } = this.scale();
        this.translate(-x * sx, -y * sy, opt);
        this.setDimensions(width * sx, height * sy, opt);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](x, y, width, height);
    },
    getFitToContentArea: function(opt = {}) {
        // Calculate the paper size to accommodate all the graph's elements.
        const gridWidth = opt.gridWidth || 1;
        const gridHeight = opt.gridHeight || 1;
        const padding = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeSides"])(opt.padding || 0);
        const minWidth = Math.max(opt.minWidth || 0, gridWidth);
        const minHeight = Math.max(opt.minHeight || 0, gridHeight);
        const maxWidth = opt.maxWidth || Number.MAX_VALUE;
        const maxHeight = opt.maxHeight || Number.MAX_VALUE;
        const newOrigin = opt.allowNewOrigin;
        const area = 'contentArea' in opt ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](opt.contentArea) : this.getContentArea(opt);
        const { sx, sy } = this.scale();
        area.x *= sx;
        area.y *= sy;
        area.width *= sx;
        area.height *= sy;
        let calcWidth = Math.ceil((area.width + area.x) / gridWidth);
        let calcHeight = Math.ceil((area.height + area.y) / gridHeight);
        if (!opt.allowNegativeBottomRight) {
            calcWidth = Math.max(calcWidth, 1);
            calcHeight = Math.max(calcHeight, 1);
        }
        calcWidth *= gridWidth;
        calcHeight *= gridHeight;
        let tx = 0;
        if (newOrigin === 'negative' && area.x < 0 || newOrigin === 'positive' && area.x >= 0 || newOrigin === 'any') {
            tx = Math.ceil(-area.x / gridWidth) * gridWidth;
            tx += padding.left;
            calcWidth += tx;
        }
        let ty = 0;
        if (newOrigin === 'negative' && area.y < 0 || newOrigin === 'positive' && area.y >= 0 || newOrigin === 'any') {
            ty = Math.ceil(-area.y / gridHeight) * gridHeight;
            ty += padding.top;
            calcHeight += ty;
        }
        calcWidth += padding.right;
        calcHeight += padding.bottom;
        // Make sure the resulting width and height are greater than minimum.
        calcWidth = Math.max(calcWidth, minWidth);
        calcHeight = Math.max(calcHeight, minHeight);
        // Make sure the resulting width and height are lesser than maximum.
        calcWidth = Math.min(calcWidth, maxWidth);
        calcHeight = Math.min(calcHeight, maxHeight);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);
    },
    transformToFitContent: function(opt) {
        opt || (opt = {});
        let contentBBox, contentLocalOrigin;
        if ('contentArea' in opt) {
            const contentArea = opt.contentArea;
            contentBBox = this.localToPaperRect(contentArea);
            contentLocalOrigin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](contentArea);
        } else {
            contentBBox = this.getContentBBox(opt);
            contentLocalOrigin = this.paperToLocalPoint(contentBBox);
        }
        if (!contentBBox.width || !contentBBox.height) return;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaults"])(opt, {
            padding: 0,
            preserveAspectRatio: true,
            scaleGrid: null,
            minScale: 0,
            maxScale: Number.MAX_VALUE,
            verticalAlign: 'top',
            horizontalAlign: 'left'
        });
        const padding = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeSides"])(opt.padding);
        const minScaleX = opt.minScaleX || opt.minScale;
        const maxScaleX = opt.maxScaleX || opt.maxScale;
        const minScaleY = opt.minScaleY || opt.minScale;
        const maxScaleY = opt.maxScaleY || opt.maxScale;
        let fittingBBox;
        if (opt.fittingBBox) {
            fittingBBox = opt.fittingBBox;
        } else {
            const currentTranslate = this.translate();
            const computedSize = this.getComputedSize();
            fittingBBox = {
                x: currentTranslate.tx,
                y: currentTranslate.ty,
                width: computedSize.width,
                height: computedSize.height
            };
        }
        fittingBBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](fittingBBox).moveAndExpand({
            x: padding.left,
            y: padding.top,
            width: -padding.left - padding.right,
            height: -padding.top - padding.bottom
        });
        const ctm = this.matrix();
        const { a: sx, d: sy, e: tx, f: ty } = ctm;
        let newSx = fittingBBox.width / contentBBox.width * sx;
        let newSy = fittingBBox.height / contentBBox.height * sy;
        if (opt.preserveAspectRatio) {
            newSx = newSy = Math.min(newSx, newSy);
        }
        // snap scale to a grid
        if (opt.scaleGrid) {
            const gridSize = opt.scaleGrid;
            newSx = gridSize * Math.floor(newSx / gridSize);
            newSy = gridSize * Math.floor(newSy / gridSize);
        }
        // scale min/max boundaries
        newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));
        newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));
        const scaleDiff = {
            x: newSx / sx,
            y: newSy / sy
        };
        let newOx = fittingBBox.x - contentLocalOrigin.x * newSx - tx;
        let newOy = fittingBBox.y - contentLocalOrigin.y * newSy - ty;
        switch(opt.verticalAlign){
            case 'middle':
                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y) / 2;
                break;
            case 'bottom':
                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y);
                break;
            case 'top':
            default:
                break;
        }
        switch(opt.horizontalAlign){
            case 'middle':
                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x) / 2;
                break;
            case 'right':
                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x);
                break;
            case 'left':
            default:
                break;
        }
        ctm.a = newSx;
        ctm.d = newSy;
        ctm.e = newOx;
        ctm.f = newOy;
        this.matrix(ctm, opt);
    },
    scaleContentToFit: function(opt) {
        this.transformToFitContent(opt);
    },
    // Return the dimensions of the content area in local units (without transformations).
    getContentArea: function(opt) {
        if (opt && opt.useModelGeometry) {
            return this.model.getBBox() || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"]();
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.cells).getBBox();
    },
    // Return the dimensions of the content bbox in the paper units (as it appears on screen).
    getContentBBox: function(opt) {
        return this.localToPaperRect(this.getContentArea(opt));
    },
    // Returns a geometry rectangle representing the entire
    // paper area (coordinates from the left paper border to the right one
    // and the top border to the bottom one).
    getArea: function() {
        return this.paperToLocalRect(this.getComputedSize());
    },
    getRestrictedArea: function(...args) {
        const { restrictTranslate } = this.options;
        let restrictedArea;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(restrictTranslate)) {
            // A method returning a bounding box
            restrictedArea = restrictTranslate.apply(this, args);
        } else if (restrictTranslate === true) {
            // The paper area
            restrictedArea = this.getArea();
        } else if (!restrictTranslate) {
            // falsy value
            restrictedArea = null;
        } else {
            // any other value
            restrictedArea = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](restrictTranslate);
        }
        return restrictedArea;
    },
    createViewForModel: function(cell) {
        const { options } = this;
        // A class taken from the paper options.
        var optionalViewClass;
        // A default basic class (either dia.ElementView or dia.LinkView)
        var defaultViewClass;
        // A special class defined for this model in the corresponding namespace.
        // e.g. joint.shapes.standard.Rectangle searches for joint.shapes.standard.RectangleView
        var namespace = options.cellViewNamespace;
        var type = cell.get('type') + 'View';
        var namespaceViewClass = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getByPath"])(namespace, type, '.');
        if (cell.isLink()) {
            optionalViewClass = options.linkView;
            defaultViewClass = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$LinkView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinkView"];
        } else {
            optionalViewClass = options.elementView;
            defaultViewClass = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$ElementView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementView"];
        }
        // a) the paper options view is a class (deprecated)
        //  1. search the namespace for a view
        //  2. if no view was found, use view from the paper options
        // b) the paper options view is a function
        //  1. call the function from the paper options
        //  2. if no view was return, search the namespace for a view
        //  3. if no view was found, use the default
        var ViewClass = optionalViewClass.prototype instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$ViewBase$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ViewBase"] ? namespaceViewClass || optionalViewClass : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;
        return new ViewClass({
            model: cell,
            interactive: options.interactive,
            labelsLayer: options.labelsLayer === true ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"].LABELS : options.labelsLayer
        });
    },
    removeView: function(cell) {
        const { id } = cell;
        const { _views, _updates } = this;
        const view = _views[id];
        if (view) {
            var { cid } = view;
            const { mounted, unmounted } = _updates;
            view.remove();
            delete _views[id];
            delete mounted[cid];
            delete unmounted[cid];
        }
        return view;
    },
    renderView: function(cell, opt) {
        const { id } = cell;
        const views = this._views;
        let view, flag;
        let create = true;
        if (id in views) {
            view = views[id];
            if (view.model === cell) {
                flag = view.FLAG_INSERT;
                create = false;
            } else {
                // The view for this `id` already exist.
                // The cell is a new instance of the model with identical id
                // We simply remove the existing view and create a new one
                this.removeView(cell);
            }
        }
        if (create) {
            view = views[id] = this.createViewForModel(cell);
            view.paper = this;
            flag = this.registerUnmountedView(view) | this.FLAG_INIT | view.getFlag((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["result"])(view, 'initFlag'));
        }
        this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);
        return view;
    },
    onImageDragStart: function() {
        // This is the only way to prevent image dragging in Firefox that works.
        // Setting -moz-user-select: none, draggable="false" attribute or user-drag: none didn't help.
        return false;
    },
    resetViews: function(cells, opt) {
        opt || (opt = {});
        cells || (cells = []);
        this._resetUpdates();
        // clearing views removes any event listeners
        this.removeViews();
        // Allows to unfreeze normally while in the idle state using autoFreeze option
        const key = this.options.autoFreeze ? null : 'reset';
        this.freeze({
            key
        });
        for(var i = 0, n = cells.length; i < n; i++){
            this.renderView(cells[i], opt);
        }
        this.unfreeze({
            key
        });
        this.sortViews();
    },
    removeViews: function() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["invoke"])(this._views, 'remove');
        this._views = {};
    },
    sortViews: function() {
        if (!this.isExactSorting()) {
            // noop
            return;
        }
        if (this.isFrozen()) {
            // sort views once unfrozen
            this._updates.sort = true;
            return;
        }
        this.sortViewsExact();
    },
    sortViewsExact: function() {
        // Run insertion sort algorithm in order to efficiently sort DOM elements according to their
        // associated model `z` attribute.
        var cellNodes = Array.from(this.cells.childNodes).filter((node)=>node.getAttribute('model-id'));
        var cells = this.model.get('cells');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["sortElements"])(cellNodes, function(a, b) {
            var cellA = cells.get(a.getAttribute('model-id'));
            var cellB = cells.get(b.getAttribute('model-id'));
            var zA = cellA.attributes.z || 0;
            var zB = cellB.attributes.z || 0;
            return zA === zB ? 0 : zA < zB ? -1 : 1;
        });
    },
    insertView: function(view, isInitialInsert) {
        const layerView = this.getLayerView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"].CELLS);
        const { el, model } = view;
        switch(this.options.sorting){
            case sortingTypes.APPROX:
                layerView.insertSortedNode(el, model.get('z'));
                break;
            case sortingTypes.EXACT:
            default:
                layerView.insertNode(el);
                break;
        }
        view.onMount(isInitialInsert);
    },
    detachView (view) {
        view.unmount();
        view.onDetach();
    },
    // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also
    // be a selector or a jQuery object.
    findView: function($el) {
        var el = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])($el) ? this.cells.querySelector($el) : $el instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] ? $el[0] : $el;
        var id = this.findAttribute('model-id', el);
        if (id) return this._views[id];
        return undefined;
    },
    // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.
    findViewByModel: function(cell) {
        var id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(cell) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(cell) ? cell : cell && cell.id;
        return this._views[id];
    },
    // Find all views at given point
    findViewsFromPoint: function(p) {
        p = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](p);
        var views = this.model.getElements().map(this.findViewByModel, this);
        return views.filter(function(view) {
            return view && view.vel.getBBox({
                target: this.cells
            }).containsPoint(p);
        }, this);
    },
    // Find all views in given area
    findViewsInArea: function(rect, opt) {
        opt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaults"])(opt || {}, {
            strict: false
        });
        rect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](rect);
        var views = this.model.getElements().map(this.findViewByModel, this);
        var method = opt.strict ? 'containsRect' : 'intersect';
        return views.filter(function(view) {
            return view && rect[method](view.vel.getBBox({
                target: this.cells
            }));
        }, this);
    },
    findElementViewsInArea (plainArea, opt) {
        return this._filterViewsInArea(plainArea, (extArea, findOpt)=>this.model.findElementsInArea(extArea, findOpt), opt);
    },
    findLinkViewsInArea: function(plainArea, opt) {
        return this._filterViewsInArea(plainArea, (extArea, findOpt)=>this.model.findLinksInArea(extArea, findOpt), opt);
    },
    findCellViewsInArea: function(plainArea, opt) {
        return this._filterViewsInArea(plainArea, (extArea, findOpt)=>this.model.findCellsInArea(extArea, findOpt), opt);
    },
    findElementViewsAtPoint: function(plainPoint, opt) {
        return this._filterViewsAtPoint(plainPoint, (extArea)=>this.model.findElementsInArea(extArea), opt);
    },
    findLinkViewsAtPoint: function(plainPoint, opt) {
        return this._filterViewsAtPoint(plainPoint, (extArea)=>this.model.findLinksInArea(extArea), opt);
    },
    findCellViewsAtPoint: function(plainPoint, opt) {
        return this._filterViewsAtPoint(plainPoint, // Note: we do not want to pass `opt` to `findCellsInArea`
        // because the `strict` option works differently for querying at a point
        (extArea)=>this.model.findCellsInArea(extArea), opt);
    },
    _findInExtendedArea: function(area, findCellsFn, opt = {}) {
        const { buffer = this.DEFAULT_FIND_BUFFER } = opt;
        const extendedArea = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](area).inflate(buffer);
        const cellsInExtendedArea = findCellsFn(extendedArea, opt);
        return cellsInExtendedArea.map((element)=>this.findViewByModel(element));
    },
    _filterViewsInArea: function(plainArea, findCells, opt = {}) {
        const area = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](plainArea);
        const viewsInExtendedArea = this._findInExtendedArea(area, findCells, opt);
        const viewsInArea = viewsInExtendedArea.filter((view)=>{
            if (!view) return false;
            return view.isInArea(area, opt);
        });
        return viewsInArea;
    },
    _filterViewsAtPoint: function(plainPoint, findCells, opt = {}) {
        const area = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](plainPoint); // zero-size area
        const viewsInExtendedArea = this._findInExtendedArea(area, findCells, opt);
        const viewsAtPoint = viewsInExtendedArea.filter((view)=>{
            if (!view) return false;
            return view.isAtPoint(plainPoint, opt);
        });
        return viewsAtPoint;
    },
    removeTools: function() {
        this.dispatchToolsEvent('remove');
        return this;
    },
    hideTools: function() {
        this.dispatchToolsEvent('hide');
        return this;
    },
    showTools: function() {
        this.dispatchToolsEvent('show');
        return this;
    },
    dispatchToolsEvent: function(event, ...args) {
        if (typeof event !== 'string') return;
        this.trigger('tools:event', event, ...args);
    },
    getModelById: function(id) {
        return this.model.getCell(id);
    },
    snapToGrid: function(x, y) {
        // Convert global coordinates to the local ones of the `viewport`. Otherwise,
        // improper transformation would be applied when the viewport gets transformed (scaled/rotated).
        return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);
    },
    localToPaperPoint: function(x, y) {
        // allow `x` to be a point and `y` undefined
        var localPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](x, y);
        var paperPoint = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformPoint(localPoint, this.matrix());
        return paperPoint;
    },
    localToPaperRect: function(x, y, width, height) {
        // allow `x` to be a rectangle and rest arguments undefined
        var localRect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](x, y, width, height);
        var paperRect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformRect(localRect, this.matrix());
        return paperRect;
    },
    paperToLocalPoint: function(x, y) {
        // allow `x` to be a point and `y` undefined
        var paperPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](x, y);
        var localPoint = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformPoint(paperPoint, this.matrix().inverse());
        return localPoint;
    },
    paperToLocalRect: function(x, y, width, height) {
        // allow `x` to be a rectangle and rest arguments undefined
        var paperRect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](x, y, width, height);
        var localRect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformRect(paperRect, this.matrix().inverse());
        return localRect;
    },
    localToClientPoint: function(x, y) {
        // allow `x` to be a point and `y` undefined
        var localPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](x, y);
        var clientPoint = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformPoint(localPoint, this.clientMatrix());
        return clientPoint;
    },
    localToClientRect: function(x, y, width, height) {
        // allow `x` to be a point and `y` undefined
        var localRect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](x, y, width, height);
        var clientRect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformRect(localRect, this.clientMatrix());
        return clientRect;
    },
    // Transform client coordinates to the paper local coordinates.
    // Useful when you have a mouse event object and you'd like to get coordinates
    // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.
    // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });
    clientToLocalPoint: function(x, y) {
        // allow `x` to be a point and `y` undefined
        var clientPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](x, y);
        var localPoint = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformPoint(clientPoint, this.clientMatrix().inverse());
        return localPoint;
    },
    clientToLocalRect: function(x, y, width, height) {
        // allow `x` to be a point and `y` undefined
        var clientRect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](x, y, width, height);
        var localRect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].transformRect(clientRect, this.clientMatrix().inverse());
        return localRect;
    },
    localToPagePoint: function(x, y) {
        return this.localToPaperPoint(x, y).offset(this.pageOffset());
    },
    localToPageRect: function(x, y, width, height) {
        return this.localToPaperRect(x, y, width, height).offset(this.pageOffset());
    },
    pageToLocalPoint: function(x, y) {
        var pagePoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](x, y);
        var paperPoint = pagePoint.difference(this.pageOffset());
        return this.paperToLocalPoint(paperPoint);
    },
    pageToLocalRect: function(x, y, width, height) {
        var pageOffset = this.pageOffset();
        var paperRect = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](x, y, width, height);
        paperRect.x -= pageOffset.x;
        paperRect.y -= pageOffset.y;
        return this.paperToLocalRect(paperRect);
    },
    clientOffset: function() {
        var clientRect = this.svg.getBoundingClientRect();
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$point$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"](clientRect.left, clientRect.top);
    },
    pageOffset: function() {
        return this.clientOffset().offset(window.scrollX, window.scrollY);
    },
    linkAllowed: function(linkView) {
        if (!(linkView instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$LinkView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinkView"])) {
            throw new Error('Must provide a linkView.');
        }
        var link = linkView.model;
        var paperOptions = this.options;
        var graph = this.model;
        var ns = graph.constructor.validations;
        if (!paperOptions.multiLinks) {
            if (!ns.multiLinks.call(this, graph, link)) return false;
        }
        if (!paperOptions.linkPinning) {
            // Link pinning is not allowed and the link is not connected to the target.
            if (!ns.linkPinning.call(this, graph, link)) return false;
        }
        if (typeof paperOptions.allowLink === 'function') {
            if (!paperOptions.allowLink.call(this, linkView, this)) return false;
        }
        return true;
    },
    getDefaultLink: function(cellView, magnet) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(this.options.defaultLink) ? this.options.defaultLink.call(this, cellView, magnet) : this.options.defaultLink.clone();
    },
    // Cell highlighting.
    // ------------------
    resolveHighlighter: function(opt = {}) {
        let { highlighter: highlighterDef, type } = opt;
        const { highlighting, highlighterNamespace } = this.options;
        /*
            Expecting opt.highlighter to have the following structure:
            {
                name: 'highlighter-name',
                options: {
                    some: 'value'
                }
            }
        */ if (highlighterDef === undefined) {
            // Is highlighting disabled?
            if (!highlighting) return false;
            // check for built-in types
            if (type) {
                highlighterDef = highlighting[type];
                // Is a specific type highlight disabled?
                if (highlighterDef === false) return false;
            }
            if (!highlighterDef) {
                // Type not defined use default highlight
                highlighterDef = highlighting['default'];
            }
        }
        // Do nothing if opt.highlighter is falsy.
        // This allows the case to not highlight cell(s) in certain cases.
        // For example, if you want to NOT highlight when embedding elements
        // or use a custom highlighter.
        if (!highlighterDef) return false;
        // Allow specifying a highlighter by name.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(highlighterDef)) {
            highlighterDef = {
                name: highlighterDef
            };
        }
        const name = highlighterDef.name;
        const highlighter = highlighterNamespace[name];
        // Highlighter validation
        if (!highlighter) {
            throw new Error('Unknown highlighter ("' + name + '")');
        }
        if (typeof highlighter.highlight !== 'function') {
            throw new Error('Highlighter ("' + name + '") is missing required highlight() method');
        }
        if (typeof highlighter.unhighlight !== 'function') {
            throw new Error('Highlighter ("' + name + '") is missing required unhighlight() method');
        }
        return {
            highlighter,
            options: highlighterDef.options || {},
            name
        };
    },
    onCellHighlight: function(cellView, magnetEl, opt) {
        const highlighterDescriptor = this.resolveHighlighter(opt);
        if (!highlighterDescriptor) return;
        const { highlighter, options } = highlighterDescriptor;
        highlighter.highlight(cellView, magnetEl, options);
    },
    onCellUnhighlight: function(cellView, magnetEl, opt) {
        const highlighterDescriptor = this.resolveHighlighter(opt);
        if (!highlighterDescriptor) return;
        const { highlighter, options } = highlighterDescriptor;
        highlighter.unhighlight(cellView, magnetEl, options);
    },
    // Interaction.
    // ------------
    pointerdblclick: function(evt) {
        evt.preventDefault();
        // magnetpointerdblclick can stop propagation
        evt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(evt);
        var view = this.findView(evt.target);
        if (this.guard(evt, view)) return;
        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
        if (view) {
            view.pointerdblclick(evt, localPoint.x, localPoint.y);
        } else {
            this.trigger('blank:pointerdblclick', evt, localPoint.x, localPoint.y);
        }
    },
    pointerclick: function(evt) {
        // magnetpointerclick can stop propagation
        var data = this.eventData(evt);
        // Trigger event only if mouse has not moved.
        if (data.mousemoved <= this.options.clickThreshold) {
            evt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(evt);
            var view = this.findView(evt.target);
            if (this.guard(evt, view)) return;
            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
            if (view) {
                view.pointerclick(evt, localPoint.x, localPoint.y);
            } else {
                this.trigger('blank:pointerclick', evt, localPoint.x, localPoint.y);
            }
        }
    },
    contextmenu: function(evt) {
        if (this.options.preventContextMenu) evt.preventDefault();
        if (this.contextMenuFired) {
            this.contextMenuFired = false;
            return;
        }
        evt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(evt);
        this.contextMenuTrigger(evt);
    },
    contextMenuTrigger: function(evt) {
        var view = this.findView(evt.target);
        if (this.guard(evt, view)) return;
        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
        if (view) {
            view.contextmenu(evt, localPoint.x, localPoint.y);
        } else {
            this.trigger('blank:contextmenu', evt, localPoint.x, localPoint.y);
        }
    },
    pointerdown: function(evt) {
        evt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(evt);
        const { target, button } = evt;
        const view = this.findView(target);
        const isContextMenu = button === 2;
        if (view) {
            if (!isContextMenu && this.guard(evt, view)) return;
            const isTargetFormNode = this.FORM_CONTROL_TAG_NAMES.includes(target.tagName);
            if (this.options.preventDefaultViewAction && !isTargetFormNode) {
                // If the target is a form element, we do not want to prevent the default action.
                // For example, we want to be able to select text in a text input or
                // to be able to click on a checkbox.
                evt.preventDefault();
            }
            if (isTargetFormNode) {
                // If the target is a form element, we do not want to start dragging the element.
                // For example, we want to be able to select text by dragging the mouse.
                view.preventDefaultInteraction(evt);
            }
            // Custom event
            const eventEvt = this.customEventTrigger(evt, view);
            if (eventEvt) {
                // `onevent` could have stopped propagation
                if (eventEvt.isPropagationStopped()) return;
                evt.data = eventEvt.data;
            }
            // Element magnet
            const magnetNode = target.closest('[magnet]');
            if (magnetNode && view.el !== magnetNode && view.el.contains(magnetNode)) {
                const magnetEvt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Event(evt.originalEvent, {
                    data: evt.data,
                    // Originally the event listener was attached to the magnet element.
                    currentTarget: magnetNode
                }));
                this.onmagnet(magnetEvt);
                if (magnetEvt.isDefaultPrevented()) {
                    evt.preventDefault();
                }
                // `onmagnet` stops propagation when `addLinkFromMagnet` is allowed
                if (magnetEvt.isPropagationStopped()) {
                    // `magnet:pointermove` and `magnet:pointerup` events must be fired
                    if (isContextMenu) return;
                    this.delegateDragEvents(view, magnetEvt.data);
                    return;
                }
                evt.data = magnetEvt.data;
            }
        }
        if (isContextMenu) {
            this.contextMenuFired = true;
            const contextmenuEvt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Event(evt.originalEvent, {
                type: 'contextmenu',
                data: evt.data
            });
            this.contextMenuTrigger(contextmenuEvt);
        } else {
            const localPoint = this.snapToGrid(evt.clientX, evt.clientY);
            if (view) {
                view.pointerdown(evt, localPoint.x, localPoint.y);
            } else {
                if (this.options.preventDefaultBlankAction) {
                    evt.preventDefault();
                }
                this.trigger('blank:pointerdown', evt, localPoint.x, localPoint.y);
            }
            this.delegateDragEvents(view, evt.data);
        }
    },
    pointermove: function(evt) {
        // mouse moved counter
        var data = this.eventData(evt);
        if (!data.mousemoved) {
            data.mousemoved = 0;
            // Make sure that events like `mouseenter` and `mouseleave` are
            // not triggered while the user is dragging a cellView.
            this.undelegateEvents();
        // Note: the events are undelegated after the first `pointermove` event.
        // Not on `pointerdown` to make sure that `dbltap` is recognized.
        }
        var mousemoved = ++data.mousemoved;
        if (mousemoved <= this.options.moveThreshold) return;
        evt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(evt);
        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
        var view = data.sourceView;
        if (view) {
            view.pointermove(evt, localPoint.x, localPoint.y);
        } else {
            this.trigger('blank:pointermove', evt, localPoint.x, localPoint.y);
        }
        this.eventData(evt, data);
    },
    pointerup: function(evt) {
        this.undelegateDocumentEvents();
        var normalizedEvt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(evt);
        var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);
        var view = this.eventData(evt).sourceView;
        if (view) {
            view.pointerup(normalizedEvt, localPoint.x, localPoint.y);
        } else {
            this.trigger('blank:pointerup', normalizedEvt, localPoint.x, localPoint.y);
        }
        if (!normalizedEvt.isPropagationStopped()) {
            this.pointerclick(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Event(evt.originalEvent, {
                type: 'click',
                data: evt.data
            }));
        }
        this.delegateEvents();
    },
    mouseover: function(evt) {
        evt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(evt);
        var view = this.findView(evt.target);
        if (this.guard(evt, view)) return;
        if (view) {
            view.mouseover(evt);
        } else {
            if (this.el === evt.target) return; // prevent border of paper from triggering this
            this.trigger('blank:mouseover', evt);
        }
    },
    mouseout: function(evt) {
        evt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(evt);
        var view = this.findView(evt.target);
        if (this.guard(evt, view)) return;
        if (view) {
            view.mouseout(evt);
        } else {
            if (this.el === evt.target) return; // prevent border of paper from triggering this
            this.trigger('blank:mouseout', evt);
        }
    },
    mouseenter: function(evt) {
        evt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(evt);
        const { target, relatedTarget, currentTarget// The EventTarget on which the event listener was registered
         } = evt;
        const view = this.findView(target);
        if (this.guard(evt, view)) return;
        const relatedView = this.findView(relatedTarget);
        if (view) {
            if (relatedView === view) {
                // Mouse left a cell tool
                return;
            }
            view.mouseenter(evt);
            if (this.el.contains(relatedTarget)) {
                // The pointer remains inside the paper.
                return;
            }
        }
        if (relatedView) {
            return;
        }
        // prevent double `mouseenter` event if the `relatedTarget` is outside the paper
        // (mouseenter method would be fired twice)
        if (currentTarget === this.el) {
            // `paper` (more descriptive), not `blank`
            this.trigger('paper:mouseenter', evt);
        }
    },
    mouseleave: function(evt) {
        evt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(evt);
        const { target, relatedTarget, currentTarget// The EventTarget on which the event listener was registered
         } = evt;
        const view = this.findView(target);
        if (this.guard(evt, view)) return;
        const relatedView = this.findView(relatedTarget);
        if (view) {
            if (relatedView === view) {
                // Mouse entered a cell tool
                return;
            }
            view.mouseleave(evt);
            if (this.el.contains(relatedTarget)) {
                // The pointer has exited a cellView. The pointer is still inside of the paper.
                return;
            }
        }
        if (relatedView) {
            // The pointer has entered a new cellView
            return;
        }
        // prevent double `mouseleave` event if the `relatedTarget` is outside the paper
        // (mouseleave method would be fired twice)
        if (currentTarget === this.el) {
            // There is no cellView under the pointer, nor the blank area of the paper
            this.trigger('paper:mouseleave', evt);
        }
    },
    _processMouseWheelEvtBuf: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["debounce"])(function() {
        const { event, deltas } = this._mw_evt_buffer;
        const deltaY = deltas.reduce((acc, deltaY)=>acc + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["cap"])(deltaY, WHEEL_CAP), 0);
        const scale = Math.pow(0.995, deltaY); // 1.005 for inverted pinch/zoom
        const { x, y } = this.clientToLocalPoint(event.clientX, event.clientY);
        this.trigger('paper:pinch', event, x, y, scale);
        this._mw_evt_buffer = {
            event: null,
            deltas: []
        };
    }, WHEEL_WAIT_MS, {
        maxWait: WHEEL_WAIT_MS
    }),
    mousewheel: function(evt) {
        evt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(evt);
        const view = this.findView(evt.target);
        if (this.guard(evt, view)) return;
        const originalEvent = evt.originalEvent;
        const localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);
        const { deltaX, deltaY } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeWheel"])(originalEvent);
        const pinchHandlers = this._events['paper:pinch'];
        // Touchpad devices will send a fake CTRL press when a pinch is performed
        //
        // We also check if there are any subscribers to paper:pinch event. If there are none,
        // just skip the entire block of code (we don't want to blindly call
        // .preventDefault() if we really don't have to).
        if (evt.ctrlKey && pinchHandlers && pinchHandlers.length > 0) {
            // This is a pinch gesture, it's safe to assume that we must call .preventDefault()
            originalEvent.preventDefault();
            this._mw_evt_buffer.event = evt;
            this._mw_evt_buffer.deltas.push(deltaY);
            this._processMouseWheelEvtBuf();
        } else {
            const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta));
            if (view) {
                view.mousewheel(evt, localPoint.x, localPoint.y, delta);
            } else {
                this.trigger('blank:mousewheel', evt, localPoint.x, localPoint.y, delta);
            }
            this.trigger('paper:pan', evt, deltaX, deltaY);
        }
    },
    onevent: function(evt) {
        var eventNode = evt.currentTarget;
        var eventName = eventNode.getAttribute('event');
        if (eventName) {
            var view = this.findView(eventNode);
            if (view) {
                evt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(evt);
                if (this.guard(evt, view)) return;
                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
                view.onevent(evt, eventName, localPoint.x, localPoint.y);
            }
        }
    },
    magnetEvent: function(evt, handler) {
        var magnetNode = evt.currentTarget;
        var magnetValue = magnetNode.getAttribute('magnet');
        if (magnetValue) {
            var view = this.findView(magnetNode);
            if (view) {
                evt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(evt);
                if (this.guard(evt, view)) return;
                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
                handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);
            }
        }
    },
    onmagnet: function(evt) {
        if (evt.button === 2) {
            this.contextMenuFired = true;
            this.magnetContextMenuFired = true;
            const contextmenuEvt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Event(evt.originalEvent, {
                type: 'contextmenu',
                data: evt.data,
                currentTarget: evt.currentTarget
            });
            this.magnetContextMenuTrigger(contextmenuEvt);
            if (contextmenuEvt.isPropagationStopped()) {
                evt.stopPropagation();
            }
        } else {
            this.magnetEvent(evt, function(view, evt, _, x, y) {
                view.onmagnet(evt, x, y);
            });
        }
    },
    magnetpointerdblclick: function(evt) {
        this.magnetEvent(evt, function(view, evt, magnet, x, y) {
            view.magnetpointerdblclick(evt, magnet, x, y);
        });
    },
    magnetcontextmenu: function(evt) {
        if (this.options.preventContextMenu) evt.preventDefault();
        if (this.magnetContextMenuFired) {
            this.magnetContextMenuFired = false;
            return;
        }
        this.magnetContextMenuTrigger(evt);
    },
    magnetContextMenuTrigger: function(evt) {
        this.magnetEvent(evt, function(view, evt, magnet, x, y) {
            view.magnetcontextmenu(evt, magnet, x, y);
        });
    },
    onlabel: function(evt) {
        var labelNode = evt.currentTarget;
        var view = this.findView(labelNode);
        if (!view) return;
        evt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(evt);
        if (this.guard(evt, view)) return;
        // Custom event
        const eventEvt = this.customEventTrigger(evt, view, labelNode);
        if (eventEvt) {
            // `onevent` could have stopped propagation
            if (eventEvt.isPropagationStopped()) return;
            evt.data = eventEvt.data;
        }
        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
        view.onlabel(evt, localPoint.x, localPoint.y);
    },
    getPointerArgs (evt) {
        const normalizedEvt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(evt);
        const { x, y } = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);
        return [
            normalizedEvt,
            x,
            y
        ];
    },
    delegateDragEvents: function(view, data) {
        data || (data = {});
        this.eventData({
            data: data
        }, {
            sourceView: view || null,
            mousemoved: 0
        });
        this.delegateDocumentEvents(null, data);
    },
    // Guard the specified event. If the event should be ignored, guard returns `true`.
    // Otherwise, it returns `false`.
    guard: function(evt, view) {
        if (evt.type === 'mousedown' && evt.button === 2) {
            // handled as `contextmenu` type
            return true;
        }
        if (this.options.guard && this.options.guard(evt, view)) {
            return true;
        }
        if (evt.data && evt.data.guarded !== undefined) {
            return evt.data.guarded;
        }
        const { target } = evt;
        if (this.GUARDED_TAG_NAMES.includes(target.tagName)) {
            return true;
        }
        if (view && view.model && view.model instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Cell$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Cell"]) {
            return false;
        }
        if (this.el === target || this.svg.contains(target)) {
            return false;
        }
        return true; // Event guarded. Paper should not react on it in any way.
    },
    setGridSize: function(gridSize) {
        const { options } = this;
        options.gridSize = gridSize;
        if (options.drawGrid && !options.drawGridSize) {
            // Do not redraw the grid if the `drawGridSize` is set.
            this.getLayerView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"].GRID).renderGrid();
        }
        return this;
    },
    setGrid: function(drawGrid) {
        this.getLayerView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"].GRID).setGrid(drawGrid);
        return this;
    },
    updateBackgroundImage: function(opt) {
        opt = opt || {};
        var backgroundPosition = opt.position || 'center';
        var backgroundSize = opt.size || 'auto auto';
        var currentScale = this.scale();
        var currentTranslate = this.translate();
        // backgroundPosition
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(backgroundPosition)) {
            var x = currentTranslate.tx + currentScale.sx * (backgroundPosition.x || 0);
            var y = currentTranslate.ty + currentScale.sy * (backgroundPosition.y || 0);
            backgroundPosition = x + 'px ' + y + 'px';
        }
        // backgroundSize
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(backgroundSize)) {
            backgroundSize = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$rect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Rect"](backgroundSize).scale(currentScale.sx, currentScale.sy);
            backgroundSize = backgroundSize.width + 'px ' + backgroundSize.height + 'px';
        }
        const { background } = this.childNodes;
        background.style.backgroundSize = backgroundSize;
        background.style.backgroundPosition = backgroundPosition;
    },
    drawBackgroundImage: function(img, opt) {
        // Clear the background image if no image provided
        if (!(img instanceof HTMLImageElement)) {
            this.childNodes.background.style.backgroundImage = '';
            return;
        }
        if (!this._background || this._background.id !== opt.id) {
            // Draw only the last image requested (see drawBackground())
            return;
        }
        opt = opt || {};
        var backgroundImage;
        var backgroundSize = opt.size;
        var backgroundRepeat = opt.repeat || 'no-repeat';
        var backgroundOpacity = opt.opacity || 1;
        var backgroundQuality = Math.abs(opt.quality) || 1;
        var backgroundPattern = this.constructor.backgroundPatterns[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["camelCase"])(backgroundRepeat)];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(backgroundPattern)) {
            // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom
            img.width *= backgroundQuality;
            img.height *= backgroundQuality;
            var canvas = backgroundPattern(img, opt);
            if (!(canvas instanceof HTMLCanvasElement)) {
                throw new Error('dia.Paper: background pattern must return an HTML Canvas instance');
            }
            backgroundImage = canvas.toDataURL('image/png');
            backgroundRepeat = 'repeat';
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(backgroundSize)) {
                // recalculate the tile size if an object passed in
                backgroundSize.width *= canvas.width / img.width;
                backgroundSize.height *= canvas.height / img.height;
            } else if (backgroundSize === undefined) {
                // calculate the tile size if no provided
                opt.size = {
                    width: canvas.width / backgroundQuality,
                    height: canvas.height / backgroundQuality
                };
            }
        } else {
            // backgroundRepeat:
            // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'
            backgroundImage = img.src;
            if (backgroundSize === undefined) {
                // pass the image size for  the backgroundSize if no size provided
                opt.size = {
                    width: img.width,
                    height: img.height
                };
            }
        }
        this.childNodes.background.style.opacity = backgroundOpacity;
        this.childNodes.background.style.backgroundRepeat = backgroundRepeat;
        this.childNodes.background.style.backgroundImage = `url(${backgroundImage})`;
        this.updateBackgroundImage(opt);
    },
    updateBackgroundColor: function(color) {
        this.$el.css('backgroundColor', color || '');
    },
    drawBackground: function(opt) {
        opt = opt || {};
        this.updateBackgroundColor(opt.color);
        if (opt.image) {
            opt = this._background = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneDeep"])(opt);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["guid"])(opt);
            var img = document.createElement('img');
            img.onload = this.drawBackgroundImage.bind(this, img, opt);
            img.src = opt.image;
        } else {
            this.drawBackgroundImage(null);
            this._background = null;
        }
        return this;
    },
    setInteractivity: function(value) {
        this.options.interactive = value;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["invoke"])(this._views, 'setInteractivity', value);
    },
    // Paper definitions.
    // ------------------
    isDefined: function(defId) {
        return !!this.svg.getElementById(defId);
    },
    defineFilter: function(filter) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(filter)) {
            throw new TypeError('dia.Paper: defineFilter() requires 1. argument to be an object.');
        }
        var filterId = filter.id;
        var name = filter.name;
        // Generate a hash code from the stringified filter definition. This gives us
        // a unique filter ID for different definitions.
        if (!filterId) {
            filterId = name + this.svg.id + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["hashCode"])(JSON.stringify(filter));
        }
        // If the filter already exists in the document,
        // we're done and we can just use it (reference it using `url()`).
        // If not, create one.
        if (!this.isDefined(filterId)) {
            var namespace = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["filter"];
            var filterSVGString = namespace[name] && namespace[name](filter.args || {});
            if (!filterSVGString) {
                throw new Error('Non-existing filter ' + name);
            }
            // SVG <filter/> attributes
            var filterAttrs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assign"])({
                filterUnits: 'userSpaceOnUse'
            }, filter.attrs, {
                id: filterId
            });
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(filterSVGString, filterAttrs).appendTo(this.defs);
        }
        return filterId;
    },
    defineGradient: function(gradient) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(gradient)) {
            throw new TypeError('dia.Paper: defineGradient() requires 1. argument to be an object.');
        }
        const { svg, defs } = this;
        const { type, // Generate a hash code from the stringified filter definition. This gives us
        // a unique filter ID for different definitions.
        id = type + svg.id + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["hashCode"])(JSON.stringify(gradient)), stops, attrs = {} } = gradient;
        // If the gradient already exists in the document,
        // we're done and we can just use it (reference it using `url()`).
        if (this.isDefined(id)) return id;
        // If not, create one.
        const stopVEls = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"])(stops).map(({ offset, color, opacity })=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('stop').attr({
                'offset': offset,
                'stop-color': color,
                'stop-opacity': Number.isFinite(opacity) ? opacity : 1
            });
        });
        const gradientVEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(type, attrs, stopVEls);
        gradientVEl.id = id;
        gradientVEl.appendTo(defs);
        return id;
    },
    definePattern: function(pattern) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(pattern)) {
            throw new TypeError('dia.Paper: definePattern() requires 1. argument to be an object.');
        }
        const { svg, defs } = this;
        const { // Generate a hash code from the stringified filter definition. This gives us
        // a unique filter ID for different definitions.
        id = svg.id + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["hashCode"])(JSON.stringify(pattern)), markup, attrs = {} } = pattern;
        if (!markup) {
            throw new TypeError('dia.Paper: definePattern() requires markup.');
        }
        // If the gradient already exists in the document,
        // we're done and we can just use it (reference it using `url()`).
        if (this.isDefined(id)) return id;
        // If not, create one.
        const patternVEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('pattern', {
            patternUnits: 'userSpaceOnUse'
        });
        patternVEl.id = id;
        patternVEl.attr(attrs);
        if (typeof markup === 'string') {
            patternVEl.append((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(markup));
        } else {
            const { fragment } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parseDOMJSON"])(markup);
            patternVEl.append(fragment);
        }
        patternVEl.appendTo(defs);
        return id;
    },
    defineMarker: function(marker) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(marker)) {
            throw new TypeError('dia.Paper: defineMarker() requires the first argument to be an object.');
        }
        const { svg, defs } = this;
        const { // Generate a hash code from the stringified filter definition. This gives us
        // a unique filter ID for different definitions.
        id = svg.id + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["hashCode"])(JSON.stringify(marker)), // user-provided markup
        // (e.g. defined when creating link via `attrs/line/sourceMarker/markup`)
        markup, // user-provided attributes
        // (e.g. defined when creating link via `attrs/line/sourceMarker/attrs`)
        // note: `transform` attrs are ignored by browsers
        attrs = {}, // deprecated - use `attrs/markerUnits` instead (which has higher priority)
        markerUnits = 'userSpaceOnUse' } = marker;
        // If the marker already exists in the document,
        // we're done and we can just use it (reference it using `url()`).
        if (this.isDefined(id)) return id;
        // If not, create one.
        const markerVEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('marker', {
            orient: 'auto',
            overflow: 'visible',
            markerUnits: markerUnits
        });
        markerVEl.id = id;
        markerVEl.attr(attrs);
        let markerContentVEl;
        if (markup) {
            let markupVEl;
            if (typeof markup === 'string') {
                // Marker object has a `markup` property of type string.
                // - Construct V from the provided string.
                markupVEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(markup);
                // `markupVEl` is now either a single VEl, or an array of VEls.
                // - Coerce it to an array.
                markupVEl = Array.isArray(markupVEl) ? markupVEl : [
                    markupVEl
                ];
            } else {
                // Marker object has a `markup` property of type object.
                // - Construct V from the object by parsing it as DOM JSON.
                const { fragment } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parseDOMJSON"])(markup);
                markupVEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(fragment).children();
            }
            // `markupVEl` is an array with one or more VEls inside.
            // - If there are multiple VEls, wrap them in a newly-constructed <g> element
            if (markupVEl.length > 1) {
                markerContentVEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])('g').append(markupVEl);
            } else {
                markerContentVEl = markupVEl[0];
            }
        } else {
            // Marker object is a flat structure.
            // - Construct a new V of type `marker.type`.
            const { type = 'path' } = marker;
            markerContentVEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(type);
        }
        // `markerContentVEl` is a single VEl.
        // Assign additional attributes to it (= context attributes + marker attributes):
        // - Attribute values are taken from non-special properties of `marker`.
        const markerAttrs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["omit"])(marker, 'type', 'id', 'markup', 'attrs', 'markerUnits');
        const markerAttrsKeys = Object.keys(markerAttrs);
        markerAttrsKeys.forEach((key)=>{
            const value = markerAttrs[key];
            const markupValue = markerContentVEl.attr(key); // value coming from markupVEl (if any) = higher priority
            if (markupValue == null) {
                // Default logic:
                markerContentVEl.attr(key, value);
            } else {
                // Properties with special logic should be added as cases to this switch block:
                switch(key){
                    case 'transform':
                        // - Prepend `transform` to existing value.
                        markerContentVEl.attr(key, value + ' ' + markupValue);
                        break;
                }
            }
        });
        markerContentVEl.appendTo(markerVEl);
        markerVEl.appendTo(defs);
        return id;
    },
    customEventTrigger: function(evt, view, rootNode = view.el) {
        const eventNode = evt.target.closest('[event]');
        if (eventNode && rootNode !== eventNode && view.el.contains(eventNode)) {
            const eventEvt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizeEvent"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$Dom$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Event(evt.originalEvent, {
                data: evt.data,
                // Originally the event listener was attached to the event element.
                currentTarget: eventNode
            }));
            this.onevent(eventEvt);
            if (eventEvt.isDefaultPrevented()) {
                evt.preventDefault();
            }
            return eventEvt;
        }
        return null;
    }
}, {
    sorting: sortingTypes,
    Layers: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"],
    backgroundPatterns: {
        flipXy: function(img) {
            // d b
            // q p
            var canvas = document.createElement('canvas');
            var imgWidth = img.width;
            var imgHeight = img.height;
            canvas.width = 2 * imgWidth;
            canvas.height = 2 * imgHeight;
            var ctx = canvas.getContext('2d');
            // top-left image
            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
            // xy-flipped bottom-right image
            ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
            // x-flipped top-right image
            ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);
            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
            // y-flipped bottom-left image
            ctx.setTransform(1, 0, 0, -1, 0, canvas.height);
            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
            return canvas;
        },
        flipX: function(img) {
            // d b
            // d b
            var canvas = document.createElement('canvas');
            var imgWidth = img.width;
            var imgHeight = img.height;
            canvas.width = imgWidth * 2;
            canvas.height = imgHeight;
            var ctx = canvas.getContext('2d');
            // left image
            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
            // flipped right image
            ctx.translate(2 * imgWidth, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
            return canvas;
        },
        flipY: function(img) {
            // d d
            // q q
            var canvas = document.createElement('canvas');
            var imgWidth = img.width;
            var imgHeight = img.height;
            canvas.width = imgWidth;
            canvas.height = imgHeight * 2;
            var ctx = canvas.getContext('2d');
            // top image
            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
            // flipped bottom image
            ctx.translate(0, 2 * imgHeight);
            ctx.scale(1, -1);
            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
            return canvas;
        },
        watermark: function(img, opt) {
            //   d
            // d
            opt = opt || {};
            var imgWidth = img.width;
            var imgHeight = img.height;
            var canvas = document.createElement('canvas');
            canvas.width = imgWidth * 3;
            canvas.height = imgHeight * 3;
            var ctx = canvas.getContext('2d');
            var angle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$utilHelpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(opt.watermarkAngle) ? -opt.watermarkAngle : -20;
            var radians = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$geometry$2e$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toRad"])(angle);
            var stepX = canvas.width / 4;
            var stepY = canvas.height / 4;
            for(var i = 0; i < 4; i++){
                for(var j = 0; j < 4; j++){
                    if ((i + j) % 2 > 0) {
                        // reset the current transformations
                        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);
                        ctx.rotate(radians);
                        ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);
                    }
                }
            }
            return canvas;
        }
    },
    gridPatterns: {
        dot: [
            {
                color: '#AAAAAA',
                thickness: 1,
                markup: 'rect',
                render: function(el, opt) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(el).attr({
                        width: opt.thickness,
                        height: opt.thickness,
                        fill: opt.color
                    });
                }
            }
        ],
        fixedDot: [
            {
                color: '#AAAAAA',
                thickness: 1,
                markup: 'rect',
                render: function(el, opt) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(el).attr({
                        fill: opt.color
                    });
                },
                update: function(el, opt, paper) {
                    const { sx, sy } = paper.scale();
                    const width = sx <= 1 ? opt.thickness : opt.thickness / sx;
                    const height = sy <= 1 ? opt.thickness : opt.thickness / sy;
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(el).attr({
                        width,
                        height
                    });
                }
            }
        ],
        mesh: [
            {
                color: '#AAAAAA',
                thickness: 1,
                markup: 'path',
                render: function(el, opt) {
                    var d;
                    var width = opt.width;
                    var height = opt.height;
                    var thickness = opt.thickness;
                    if (width - thickness >= 0 && height - thickness >= 0) {
                        d = [
                            'M',
                            width,
                            0,
                            'H0 M0 0 V0',
                            height
                        ].join(' ');
                    } else {
                        d = 'M 0 0 0 0';
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(el).attr({
                        'd': d,
                        stroke: opt.color,
                        'stroke-width': opt.thickness
                    });
                }
            }
        ],
        doubleMesh: [
            {
                color: '#AAAAAA',
                thickness: 1,
                markup: 'path',
                render: function(el, opt) {
                    var d;
                    var width = opt.width;
                    var height = opt.height;
                    var thickness = opt.thickness;
                    if (width - thickness >= 0 && height - thickness >= 0) {
                        d = [
                            'M',
                            width,
                            0,
                            'H0 M0 0 V0',
                            height
                        ].join(' ');
                    } else {
                        d = 'M 0 0 0 0';
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(el).attr({
                        'd': d,
                        stroke: opt.color,
                        'stroke-width': opt.thickness
                    });
                }
            },
            {
                color: '#000000',
                thickness: 3,
                scaleFactor: 4,
                markup: 'path',
                render: function(el, opt) {
                    var d;
                    var width = opt.width;
                    var height = opt.height;
                    var thickness = opt.thickness;
                    if (width - thickness >= 0 && height - thickness >= 0) {
                        d = [
                            'M',
                            width,
                            0,
                            'H0 M0 0 V0',
                            height
                        ].join(' ');
                    } else {
                        d = 'M 0 0 0 0';
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$V$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(el).attr({
                        'd': d,
                        stroke: opt.color,
                        'stroke-width': opt.thickness
                    });
                }
            }
        ]
    }
});
}}),
"[project]/node_modules/@joint/core/src/dia/ToolView.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ToolView": (()=>ToolView)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/mvc/index.mjs [app-client] (ecmascript)");
;
const ToolView = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.View.extend({
    name: null,
    tagName: 'g',
    className: 'tool',
    svgElement: true,
    _visible: true,
    _visibleExplicit: true,
    init: function() {
        var name = this.name;
        if (name) this.vel.attr('data-tool-name', name);
    },
    configure: function(view, toolsView) {
        this.relatedView = view;
        this.paper = view.paper;
        this.parentView = toolsView;
        this.simulateRelatedView(this.el);
        // Delegate events in case the ToolView was removed from the DOM and reused.
        this.delegateEvents();
        return this;
    },
    simulateRelatedView: function(el) {
        if (el) el.setAttribute('model-id', this.relatedView.model.id);
    },
    getName: function() {
        return this.name;
    },
    // Evaluate the visibility of the tool and update the `display` CSS property
    updateVisibility: function() {
        const isVisible = this.computeVisibility();
        this.el.style.display = isVisible ? '' : 'none';
        this._visible = isVisible;
    },
    // Evaluate the visibility of the tool. The method returns `true` if the tool
    // should be visible in the DOM.
    computeVisibility () {
        if (!this.isExplicitlyVisible()) return false;
        const { visibility } = this.options;
        if (typeof visibility !== 'function') return true;
        return !!visibility.call(this, this.relatedView, this);
    },
    show: function() {
        this._visibleExplicit = true;
        this.updateVisibility();
    },
    hide: function() {
        this._visibleExplicit = false;
        this.updateVisibility();
    },
    // The method returns `false` if the `hide()` method was called on the tool.
    isExplicitlyVisible: function() {
        return !!this._visibleExplicit;
    },
    // The method returns `false` if the tool is not visible (it has `display: none`).
    // This can happen if the `hide()` method was called or the tool is not visible
    // because of the `visibility` option was evaluated to `false`.
    isVisible: function() {
        return !!this._visible;
    },
    focus: function() {
        var opacity = this.options.focusOpacity;
        if (isFinite(opacity)) this.el.style.opacity = opacity;
        this.parentView.focusTool(this);
    },
    blur: function() {
        this.el.style.opacity = '';
        this.parentView.blurTool(this);
    },
    update: function() {
    // to be overridden
    },
    guard: function(evt) {
        // Let the context-menu event bubble up to the relatedView
        const { paper, relatedView } = this;
        if (!paper || !relatedView) return true;
        return paper.guard(evt, relatedView);
    }
});
}}),
"[project]/node_modules/@joint/core/src/dia/ToolsView.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ToolsView": (()=>ToolsView)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/mvc/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/CellView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$ToolView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/ToolView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/PaperLayer.mjs [app-client] (ecmascript)");
;
;
;
;
;
const ToolsView = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$mvc$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.View.extend({
    tagName: 'g',
    className: 'tools',
    svgElement: true,
    tools: null,
    isRendered: false,
    options: {
        tools: null,
        relatedView: null,
        name: null
    },
    configure: function(options) {
        options = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign(this.options, options);
        var tools = options.tools;
        if (!Array.isArray(tools)) return this;
        var relatedView = options.relatedView;
        if (!(relatedView instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"])) return this;
        var views = this.tools = [];
        for(var i = 0, n = tools.length; i < n; i++){
            var tool = tools[i];
            if (!(tool instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$ToolView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToolView"])) continue;
            tool.configure(relatedView, this);
            this.vel.append(tool.el);
            views.push(tool);
        }
        this.isRendered = false;
        relatedView.requestUpdate(relatedView.getFlag('TOOLS'));
        return this;
    },
    getName: function() {
        return this.options.name;
    },
    update: function(opt) {
        opt || (opt = {});
        const tools = this.tools;
        if (!tools) return this;
        const n = tools.length;
        const wasRendered = this.isRendered;
        for(let i = 0; i < n; i++){
            const tool = tools[i];
            tool.updateVisibility();
            if (!tool.isVisible()) continue;
            if (this.ensureToolRendered(tools, i) && opt.tool !== tool.cid) {
                tool.update();
            }
        }
        if (!this.isRendered && n > 0) {
            // None of the tools is visible
            // Note: ToolsView with no tools are always mounted
            return this;
        }
        if (!this.isMounted()) {
            this.mount();
        }
        if (!wasRendered) {
            // Make sure tools are visible (if they were hidden and the tool removed)
            this.blurTool();
        }
        return this;
    },
    ensureToolRendered (tools, i) {
        if (!this.isRendered) {
            // There is at least one visible tool
            this.isRendered = Array(tools.length).fill(false);
        }
        if (!this.isRendered[i]) {
            // First update executes render()
            tools[i].render();
            this.isRendered[i] = true;
            return false;
        }
        return true;
    },
    focusTool: function(focusedTool) {
        var tools = this.tools;
        if (!tools) return this;
        for(var i = 0, n = tools.length; i < n; i++){
            var tool = tools[i];
            if (focusedTool === tool) {
                tool.show();
            } else {
                tool.hide();
            }
        }
        return this;
    },
    blurTool: function(blurredTool) {
        var tools = this.tools;
        if (!tools) return this;
        for(var i = 0, n = tools.length; i < n; i++){
            var tool = tools[i];
            if (tool !== blurredTool && !tool.isExplicitlyVisible()) {
                tool.show();
                // Check if the tool is conditionally visible too
                if (tool.isVisible()) {
                    this.ensureToolRendered(tools, i) && tool.update();
                }
            }
        }
        return this;
    },
    hide: function() {
        return this.focusTool(null);
    },
    show: function() {
        this.blurTool(null);
        // If this the first time the tools are shown, make sure they are mounted
        if (!this.isMounted()) {
            this.mount();
        }
        return this;
    },
    onRemove: function() {
        var tools = this.tools;
        if (!tools) return this;
        for(var i = 0, n = tools.length; i < n; i++){
            tools[i].remove();
        }
        this.tools = null;
    },
    mount: function() {
        const { options, el } = this;
        const { relatedView, layer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"].TOOLS, z } = options;
        if (relatedView) {
            if (layer) {
                relatedView.paper.getLayerView(layer).insertSortedNode(el, z);
            } else {
                relatedView.el.appendChild(el);
            }
        }
        return this;
    }
});
}}),
"[project]/node_modules/@joint/core/src/dia/index.mjs [app-client] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Cell": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Cell$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Cell"]),
    "CellView": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CellView"]),
    "Element": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"]),
    "ElementView": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$ElementView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ElementView"]),
    "Graph": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Graph$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Graph"]),
    "HighlighterView": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HighlighterView"]),
    "LayersNames": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LayersNames"]),
    "Link": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Link$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Link"]),
    "LinkView": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$LinkView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinkView"]),
    "Paper": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Paper$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Paper"]),
    "PaperLayer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PaperLayer"]),
    "ToolView": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$ToolView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToolView"]),
    "ToolsView": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$ToolsView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToolsView"]),
    "attributes": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attributes"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Graph$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/Graph.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$attributes$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/attributes/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$PaperLayer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/PaperLayer.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Cell$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/Cell.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$CellView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/CellView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Element$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/Element.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$ElementView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/ElementView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Link$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/Link.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$LinkView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/LinkView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$Paper$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/Paper.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$ToolView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/ToolView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$ToolsView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/ToolsView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$HighlighterView$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/HighlighterView.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/index.mjs [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@joint/core/src/dia/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Cell": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["Cell"]),
    "CellView": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["CellView"]),
    "Element": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["Element"]),
    "ElementView": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["ElementView"]),
    "Graph": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["Graph"]),
    "HighlighterView": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["HighlighterView"]),
    "LayersNames": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["LayersNames"]),
    "Link": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["Link"]),
    "LinkView": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["LinkView"]),
    "Paper": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["Paper"]),
    "PaperLayer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["PaperLayer"]),
    "ToolView": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["ToolView"]),
    "ToolsView": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["ToolsView"]),
    "attributes": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["attributes"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/index.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/index.mjs [app-client] (ecmascript) <exports>");
}}),
"[project]/node_modules/@joint/core/src/dia/index.mjs [app-client] (ecmascript) <export * as dia>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "dia": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$dia$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/dia/index.mjs [app-client] (ecmascript)");
}}),
}]);

//# sourceMappingURL=node_modules_%40joint_core_src_dia_6efaa3._.js.map