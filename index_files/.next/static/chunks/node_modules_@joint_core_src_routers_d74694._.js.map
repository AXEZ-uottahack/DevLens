{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 14, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/routers/normal.mjs"],"sourcesContent":["// Does not make any changes to vertices.\n// Returns the arguments that are passed to it, unchanged.\nexport const normal = function(vertices, opt, linkView) {\n\n    return vertices;\n};\n"],"names":[],"mappings":"AAAA,yCAAyC;AACzC,0DAA0D;;;;AACnD,MAAM,SAAS,SAAS,QAAQ,EAAE,GAAG,EAAE,QAAQ;IAElD,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 36, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 42, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/routers/oneSide.mjs"],"sourcesContent":["import * as util from '../util/index.mjs';\n\n// Routes the link always to/from a certain side\n//\n// Arguments:\n//   padding ... gap between the element and the first vertex. :: Default 40.\n//   side ... 'left' | 'right' | 'top' | 'bottom' :: Default 'bottom'.\n//\nexport const oneSide = function(vertices, opt, linkView) {\n\n    var side = opt.side || 'bottom';\n    var padding = util.normalizeSides(opt.padding || 40);\n\n    // LinkView contains cached source an target bboxes.\n    // Note that those are Geometry rectangle objects.\n    var sourceBBox = linkView.sourceBBox;\n    var targetBBox = linkView.targetBBox;\n    var sourcePoint = sourceBBox.center();\n    var targetPoint = targetBBox.center();\n\n    var coordinate, dimension, direction;\n\n    switch (side) {\n        case 'bottom':\n            direction = 1;\n            coordinate = 'y';\n            dimension = 'height';\n            break;\n        case 'top':\n            direction = -1;\n            coordinate = 'y';\n            dimension = 'height';\n            break;\n        case 'left':\n            direction = -1;\n            coordinate = 'x';\n            dimension = 'width';\n            break;\n        case 'right':\n            direction = 1;\n            coordinate = 'x';\n            dimension = 'width';\n            break;\n        default:\n            throw new Error('Router: invalid side');\n    }\n\n    // move the points from the center of the element to outside of it.\n    sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);\n    targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);\n\n    // make link orthogonal (at least the first and last vertex).\n    if ((direction * (sourcePoint[coordinate] - targetPoint[coordinate])) > 0) {\n        targetPoint[coordinate] = sourcePoint[coordinate];\n    } else {\n        sourcePoint[coordinate] = targetPoint[coordinate];\n    }\n\n    return [sourcePoint].concat(vertices, targetPoint);\n};\n"],"names":[],"mappings":";;;AAAA;;AAQO,MAAM,UAAU,SAAS,QAAQ,EAAE,GAAG,EAAE,QAAQ;IAEnD,IAAI,OAAO,IAAI,IAAI,IAAI;IACvB,IAAI,UAAU,4JAAK,cAAc,CAAC,IAAI,OAAO,IAAI;IAEjD,oDAAoD;IACpD,kDAAkD;IAClD,IAAI,aAAa,SAAS,UAAU;IACpC,IAAI,aAAa,SAAS,UAAU;IACpC,IAAI,cAAc,WAAW,MAAM;IACnC,IAAI,cAAc,WAAW,MAAM;IAEnC,IAAI,YAAY,WAAW;IAE3B,OAAQ;QACJ,KAAK;YACD,YAAY;YACZ,aAAa;YACb,YAAY;YACZ;QACJ,KAAK;YACD,YAAY,CAAC;YACb,aAAa;YACb,YAAY;YACZ;QACJ,KAAK;YACD,YAAY,CAAC;YACb,aAAa;YACb,YAAY;YACZ;QACJ,KAAK;YACD,YAAY;YACZ,aAAa;YACb,YAAY;YACZ;QACJ;YACI,MAAM,IAAI,MAAM;IACxB;IAEA,mEAAmE;IACnE,WAAW,CAAC,WAAW,IAAI,YAAY,CAAC,UAAU,CAAC,UAAU,GAAG,IAAI,OAAO,CAAC,KAAK;IACjF,WAAW,CAAC,WAAW,IAAI,YAAY,CAAC,UAAU,CAAC,UAAU,GAAG,IAAI,OAAO,CAAC,KAAK;IAEjF,6DAA6D;IAC7D,IAAI,AAAC,YAAY,CAAC,WAAW,CAAC,WAAW,GAAG,WAAW,CAAC,WAAW,IAAK,GAAG;QACvE,WAAW,CAAC,WAAW,GAAG,WAAW,CAAC,WAAW;IACrD,OAAO;QACH,WAAW,CAAC,WAAW,GAAG,WAAW,CAAC,WAAW;IACrD;IAEA,OAAO;QAAC;KAAY,CAAC,MAAM,CAAC,UAAU;AAC1C","ignoreList":[0]}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/routers/orthogonal.mjs"],"sourcesContent":["import * as g from '../g/index.mjs';\nimport * as util from '../util/index.mjs';\n\n// bearing -> opposite bearing\nvar opposites = {\n    N: 'S',\n    S: 'N',\n    E: 'W',\n    W: 'E'\n};\n\n// bearing -> radians\nvar radians = {\n    N: -Math.PI / 2 * 3,\n    S: -Math.PI / 2,\n    E: 0,\n    W: Math.PI\n};\n\n// HELPERS //\n\n// returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained\n// in the given box\nfunction freeJoin(p1, p2, bbox) {\n\n    var p = new g.Point(p1.x, p2.y);\n    if (bbox.containsPoint(p)) p = new g.Point(p2.x, p1.y);\n    // kept for reference\n    // if (bbox.containsPoint(p)) p = null;\n\n    return p;\n}\n\n// returns either width or height of a bbox based on the given bearing\nfunction getBBoxSize(bbox, bearing) {\n\n    return bbox[(bearing === 'W' || bearing === 'E') ? 'width' : 'height'];\n}\n\n// simple bearing method (calculates only orthogonal cardinals)\nfunction getBearing(from, to) {\n\n    if (from.x === to.x) return (from.y > to.y) ? 'N' : 'S';\n    if (from.y === to.y) return (from.x > to.x) ? 'W' : 'E';\n    return null;\n}\n\n// transform point to a rect\nfunction getPointBox(p) {\n\n    return new g.Rect(p.x, p.y, 0, 0);\n}\n\nfunction getPaddingBox(opt) {\n\n    // if both provided, opt.padding wins over opt.elementPadding\n    var sides = util.normalizeSides(opt.padding || opt.elementPadding || 20);\n\n    return {\n        x: -sides.left,\n        y: -sides.top,\n        width: sides.left + sides.right,\n        height: sides.top + sides.bottom\n    };\n}\n\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n\n    return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));\n}\n\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n\n    return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));\n}\n\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n\n    if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n    // fallback: center of bbox\n    var sourceBBox = getSourceBBox(linkView, opt);\n    return sourceBBox.center();\n}\n\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n\n    if (linkView.targetAnchor) return linkView.targetAnchor;\n\n    // fallback: center of bbox\n    var targetBBox = getTargetBBox(linkView, opt);\n    return targetBBox.center(); // default\n}\n\n// PARTIAL ROUTERS //\n\nfunction vertexVertex(from, to, bearing) {\n\n    var p1 = new g.Point(from.x, to.y);\n    var p2 = new g.Point(to.x, from.y);\n    var d1 = getBearing(from, p1);\n    var d2 = getBearing(from, p2);\n    var opposite = opposites[bearing];\n\n    var p = (d1 === bearing || (d1 !== opposite && (d2 === opposite || d2 !== bearing))) ? p1 : p2;\n\n    return { points: [p], direction: getBearing(p, to) };\n}\n\nfunction elementVertex(from, to, fromBBox) {\n\n    var p = freeJoin(from, to, fromBBox);\n\n    return { points: [p], direction: getBearing(p, to) };\n}\n\nfunction vertexElement(from, to, toBBox, bearing) {\n\n    var route = {};\n\n    var points = [new g.Point(from.x, to.y), new g.Point(to.x, from.y)];\n    var freePoints = points.filter(function(pt) {\n        return !toBBox.containsPoint(pt);\n    });\n    var freeBearingPoints = freePoints.filter(function(pt) {\n        return getBearing(pt, from) !== bearing;\n    });\n\n    var p;\n\n    if (freeBearingPoints.length > 0) {\n        // Try to pick a point which bears the same direction as the previous segment.\n\n        p = freeBearingPoints.filter(function(pt) {\n            return getBearing(from, pt) === bearing;\n        }).pop();\n        p = p || freeBearingPoints[0];\n\n        route.points = [p];\n        route.direction = getBearing(p, to);\n\n    } else {\n        // Here we found only points which are either contained in the element or they would create\n        // a link segment going in opposite direction from the previous one.\n        // We take the point inside element and move it outside the element in the direction the\n        // route is going. Now we can join this point with the current end (using freeJoin).\n\n        p = util.difference(points, freePoints)[0];\n\n        var p2 = (new g.Point(to)).move(p, -getBBoxSize(toBBox, bearing) / 2);\n        var p1 = freeJoin(p2, from, toBBox);\n\n        route.points = [p1, p2];\n        route.direction = getBearing(p2, to);\n    }\n\n    return route;\n}\n\nfunction elementElement(from, to, fromBBox, toBBox) {\n\n    var route = elementVertex(to, from, toBBox);\n    var p1 = route.points[0];\n\n    if (fromBBox.containsPoint(p1)) {\n\n        route = elementVertex(from, to, fromBBox);\n        var p2 = route.points[0];\n\n        if (toBBox.containsPoint(p2)) {\n\n            var fromBorder = (new g.Point(from)).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n            var toBorder = (new g.Point(to)).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n            var mid = (new g.Line(fromBorder, toBorder)).midpoint();\n\n            var startRoute = elementVertex(from, mid, fromBBox);\n            var endRoute = vertexVertex(mid, to, startRoute.direction);\n\n            route.points = [startRoute.points[0], endRoute.points[0]];\n            route.direction = endRoute.direction;\n        }\n    }\n\n    return route;\n}\n\n// Finds route for situations where one element is inside the other.\n// Typically the route is directed outside the outer element first and\n// then back towards the inner element.\nfunction insideElement(from, to, fromBBox, toBBox, bearing) {\n\n    var route = {};\n    var boundary = fromBBox.union(toBBox).inflate(1);\n\n    // start from the point which is closer to the boundary\n    var reversed = boundary.center().distance(to) > boundary.center().distance(from);\n    var start = reversed ? to : from;\n    var end = reversed ? from : to;\n\n    var p1, p2, p3;\n\n    if (bearing) {\n        // Points on circle with radius equals 'W + H` are always outside the rectangle\n        // with width W and height H if the center of that circle is the center of that rectangle.\n        p1 = g.Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n        p1 = boundary.pointNearestToPoint(p1).move(p1, -1);\n\n    } else {\n        p1 = boundary.pointNearestToPoint(start).move(start, 1);\n    }\n\n    p2 = freeJoin(p1, end, boundary);\n\n    if (p1.round().equals(p2.round())) {\n        p2 = g.Point.fromPolar(boundary.width + boundary.height, g.toRad(p1.theta(start)) + Math.PI / 2, end);\n        p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();\n        p3 = freeJoin(p1, p2, boundary);\n        route.points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n\n    } else {\n        route.points = reversed ? [p2, p1] : [p1, p2];\n    }\n\n    route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n\n    return route;\n}\n\n// MAIN ROUTER //\n\n// Return points through which a connection needs to be drawn in order to obtain an orthogonal link\n// routing from source to target going through `vertices`.\nexport function orthogonal(vertices, opt, linkView) {\n\n    var sourceBBox = getSourceBBox(linkView, opt);\n    var targetBBox = getTargetBBox(linkView, opt);\n\n    var sourceAnchor = getSourceAnchor(linkView, opt);\n    var targetAnchor = getTargetAnchor(linkView, opt);\n\n    // if anchor lies outside of bbox, the bbox expands to include it\n    sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));\n    targetBBox = targetBBox.union(getPointBox(targetAnchor));\n\n    vertices = util.toArray(vertices).map(g.Point);\n    vertices.unshift(sourceAnchor);\n    vertices.push(targetAnchor);\n\n    var bearing; // bearing of previous route segment\n\n    var orthogonalVertices = []; // the array of found orthogonal vertices to be returned\n    for (var i = 0, max = vertices.length - 1; i < max; i++) {\n\n        var route = null;\n\n        var from = vertices[i];\n        var to = vertices[i + 1];\n\n        var isOrthogonal = !!getBearing(from, to);\n\n        if (i === 0) { // source\n\n            if (i + 1 === max) { // route source -> target\n\n                // Expand one of the elements by 1px to detect situations when the two\n                // elements are positioned next to each other with no gap in between.\n                if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {\n                    route = insideElement(from, to, sourceBBox, targetBBox);\n\n                } else if (!isOrthogonal) {\n                    route = elementElement(from, to, sourceBBox, targetBBox);\n                }\n\n            } else { // route source -> vertex\n\n                if (sourceBBox.containsPoint(to)) {\n                    route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));\n\n                } else if (!isOrthogonal) {\n                    route = elementVertex(from, to, sourceBBox);\n                }\n            }\n\n        } else if (i + 1 === max) { // route vertex -> target\n\n            // prevent overlaps with previous line segment\n            var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;\n\n            if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n                route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);\n\n            } else if (!isOrthogonal) {\n                route = vertexElement(from, to, targetBBox, bearing);\n            }\n\n        } else if (!isOrthogonal) { // route vertex -> vertex\n            route = vertexVertex(from, to, bearing);\n        }\n\n        // applicable to all routes:\n\n        // set bearing for next iteration\n        if (route) {\n            Array.prototype.push.apply(orthogonalVertices, route.points);\n            bearing = route.direction;\n\n        } else {\n            // orthogonal route and not looped\n            bearing = getBearing(from, to);\n        }\n\n        // push `to` point to identified orthogonal vertices array\n        if (i + 1 < max) {\n            orthogonalVertices.push(to);\n        }\n    }\n\n    return orthogonalVertices;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 367, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 373, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/routers/manhattan.mjs"],"sourcesContent":["import * as g from '../g/index.mjs';\nimport * as util from '../util/index.mjs';\nimport { orthogonal } from './orthogonal.mjs';\n\nvar config = {\n\n    // size of the step to find a route (the grid of the manhattan pathfinder)\n    step: 10,\n\n    // the number of route finding loops that cause the router to abort\n    // returns fallback route instead\n    maximumLoops: 2000,\n\n    // the number of decimal places to round floating point coordinates\n    precision: 1,\n\n    // maximum change of direction\n    maxAllowedDirectionChange: 90,\n\n    // should the router use perpendicular linkView option?\n    // does not connect anchor of element but rather a point close-by that is orthogonal\n    // this looks much better\n    perpendicular: true,\n\n    // should the source and/or target not be considered as obstacles?\n    excludeEnds: [], // 'source', 'target'\n\n    // should certain types of elements not be considered as obstacles?\n    excludeTypes: [],\n\n    // possible starting directions from an element\n    startDirections: ['top', 'right', 'bottom', 'left'],\n\n    // possible ending directions to an element\n    endDirections: ['top', 'right', 'bottom', 'left'],\n\n    // specify the directions used above and what they mean\n    directionMap: {\n        top: { x: 0, y: -1 },\n        right: { x: 1, y: 0 },\n        bottom: { x: 0, y: 1 },\n        left: { x: -1, y: 0 }\n    },\n\n    // cost of an orthogonal step\n    cost: function() {\n\n        return this.step;\n    },\n\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions: function() {\n\n        var step = this.step;\n        var cost = this.cost();\n\n        return [\n            { offsetX: step, offsetY: 0, cost: cost },\n            { offsetX: -step, offsetY: 0, cost: cost },\n            { offsetX: 0, offsetY: step, cost: cost },\n            { offsetX: 0, offsetY: -step, cost: cost }\n        ];\n    },\n\n    // a penalty received for direction change\n    penalties: function() {\n\n        return {\n            0: 0,\n            45: this.step / 2,\n            90: this.step / 2\n        };\n    },\n\n    // padding applied on the element bounding boxes\n    paddingBox: function() {\n\n        var step = this.step;\n\n        return {\n            x: -step,\n            y: -step,\n            width: 2 * step,\n            height: 2 * step\n        };\n    },\n\n    // A function that determines whether a given point is an obstacle or not.\n    // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.\n    // (point: dia.Point) => boolean;\n    isPointObstacle: null,\n\n    // a router to use when the manhattan router fails\n    // (one of the partial routes returns null)\n    fallbackRouter: function(vertices, opt, linkView) {\n\n        if (!util.isFunction(orthogonal)) {\n            throw new Error('Manhattan requires the orthogonal router as default fallback.');\n        }\n\n        return orthogonal(vertices, util.assign({}, config, opt), linkView);\n    },\n\n    /* Deprecated */\n    // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute: function(from, to, opt) {\n\n        return null; // null result will trigger the fallbackRouter\n\n        // left for reference:\n        /*// Find an orthogonal route ignoring obstacles.\n\n        var point = ((opt.previousDirAngle || 0) % 180 === 0)\n                ? new g.Point(from.x, to.y)\n                : new g.Point(to.x, from.y);\n\n        return [point];*/\n    },\n\n    // if a function is provided, it's used to route the link while dragging an end\n    // i.e. function(from, to, opt) { return []; }\n    draggingRoute: null\n};\n\n// HELPER CLASSES //\n\n// Map of obstacles\n// Helper structure to identify whether a point lies inside an obstacle.\nfunction ObstacleMap(opt) {\n\n    this.map = {};\n    this.options = opt;\n    // tells how to divide the paper when creating the elements map\n    this.mapGridSize = 100;\n}\n\nObstacleMap.prototype.build = function(graph, link) {\n\n    var opt = this.options;\n\n    // source or target element could be excluded from set of obstacles\n    var excludedEnds = util.toArray(opt.excludeEnds).reduce(function(res, item) {\n\n        var end = link.get(item);\n        if (end) {\n            var cell = graph.getCell(end.id);\n            if (cell) {\n                res.push(cell);\n            }\n        }\n\n        return res;\n    }, []);\n\n    // Exclude any embedded elements from the source and the target element.\n    var excludedAncestors = [];\n\n    var source = graph.getCell(link.get('source').id);\n    if (source) {\n        excludedAncestors = util.union(excludedAncestors, source.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n    }\n\n    var target = graph.getCell(link.get('target').id);\n    if (target) {\n        excludedAncestors = util.union(excludedAncestors, target.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n    }\n\n    // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained\n    // in any obstacle?) (a simplified grid search).\n    // The paper is divided into smaller cells, where each holds information about which\n    // elements belong to it. When we query whether a point lies inside an obstacle we\n    // don't need to go through all obstacles, we check only those in a particular cell.\n    var mapGridSize = this.mapGridSize;\n\n    graph.getElements().reduce(function(map, element) {\n\n        var isExcludedType = util.toArray(opt.excludeTypes).includes(element.get('type'));\n        var isExcludedEnd = excludedEnds.find(function(excluded) {\n            return excluded.id === element.id;\n        });\n        var isExcludedAncestor = excludedAncestors.includes(element.id);\n\n        var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;\n        if (!isExcluded) {\n            var bbox = element.getBBox().moveAndExpand(opt.paddingBox);\n\n            var origin = bbox.origin().snapToGrid(mapGridSize);\n            var corner = bbox.corner().snapToGrid(mapGridSize);\n\n            for (var x = origin.x; x <= corner.x; x += mapGridSize) {\n                for (var y = origin.y; y <= corner.y; y += mapGridSize) {\n                    var gridKey = x + '@' + y;\n                    map[gridKey] = map[gridKey] || [];\n                    map[gridKey].push(bbox);\n                }\n            }\n        }\n\n        return map;\n    }, this.map);\n\n    return this;\n};\n\nObstacleMap.prototype.isPointAccessible = function(point) {\n\n    var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\n\n    return util.toArray(this.map[mapKey]).every(function(obstacle) {\n        return !obstacle.containsPoint(point);\n    });\n};\n\n// Sorted Set\n// Set of items sorted by given value.\nfunction SortedSet() {\n    this.items = [];\n    this.hash = {};\n    this.values = {};\n    this.OPEN = 1;\n    this.CLOSE = 2;\n}\n\nSortedSet.prototype.add = function(item, value) {\n\n    if (this.hash[item]) {\n        // item removal\n        this.items.splice(this.items.indexOf(item), 1);\n    } else {\n        this.hash[item] = this.OPEN;\n    }\n\n    this.values[item] = value;\n\n    var index = util.sortedIndex(this.items, item, function(i) {\n        return this.values[i];\n    }.bind(this));\n\n    this.items.splice(index, 0, item);\n};\n\nSortedSet.prototype.remove = function(item) {\n\n    this.hash[item] = this.CLOSE;\n};\n\nSortedSet.prototype.isOpen = function(item) {\n\n    return this.hash[item] === this.OPEN;\n};\n\nSortedSet.prototype.isClose = function(item) {\n\n    return this.hash[item] === this.CLOSE;\n};\n\nSortedSet.prototype.isEmpty = function() {\n\n    return this.items.length === 0;\n};\n\nSortedSet.prototype.pop = function() {\n\n    var item = this.items.shift();\n    this.remove(item);\n    return item;\n};\n\n// HELPERS //\n\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n\n    // expand by padding box\n    if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);\n\n    return linkView.sourceBBox.clone();\n}\n\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n\n    // expand by padding box\n    if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);\n\n    return linkView.targetBBox.clone();\n}\n\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n\n    if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n    // fallback: center of bbox\n    var sourceBBox = getSourceBBox(linkView, opt);\n    return sourceBBox.center();\n}\n\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n\n    if (linkView.targetAnchor) return linkView.targetAnchor;\n\n    // fallback: center of bbox\n    var targetBBox = getTargetBBox(linkView, opt);\n    return targetBBox.center(); // default\n}\n\n// returns a direction index from start point to end point\n// corrects for grid deformation between start and end\nfunction getDirectionAngle(start, end, numDirections, grid, opt) {\n\n    var quadrant = 360 / numDirections;\n    var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));\n    var normalizedAngle = g.normalizeAngle(angleTheta + (quadrant / 2));\n    return quadrant * Math.floor(normalizedAngle / quadrant);\n}\n\n// helper function for getDirectionAngle()\n// corrects for grid deformation\n// (if a point is one grid steps away from another in both dimensions,\n// it is considered to be 45 degrees away, even if the real angle is different)\n// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`\nfunction fixAngleEnd(start, end, grid, opt) {\n\n    var step = opt.step;\n\n    var diffX = end.x - start.x;\n    var diffY = end.y - start.y;\n\n    var gridStepsX = diffX / grid.x;\n    var gridStepsY = diffY / grid.y;\n\n    var distanceX = gridStepsX * step;\n    var distanceY = gridStepsY * step;\n\n    return new g.Point(start.x + distanceX, start.y + distanceY);\n}\n\n// return the change in direction between two direction angles\nfunction getDirectionChange(angle1, angle2) {\n\n    var directionChange = Math.abs(angle1 - angle2);\n    return (directionChange > 180) ? (360 - directionChange) : directionChange;\n}\n\n// fix direction offsets according to current grid\nfunction getGridOffsets(directions, grid, opt) {\n\n    var step = opt.step;\n\n    util.toArray(opt.directions).forEach(function(direction) {\n\n        direction.gridOffsetX = (direction.offsetX / step) * grid.x;\n        direction.gridOffsetY = (direction.offsetY / step) * grid.y;\n    });\n}\n\n// get grid size in x and y dimensions, adapted to source and target positions\nfunction getGrid(step, source, target) {\n\n    return {\n        source: source.clone(),\n        x: getGridDimension(target.x - source.x, step),\n        y: getGridDimension(target.y - source.y, step)\n    };\n}\n\n// helper function for getGrid()\nfunction getGridDimension(diff, step) {\n\n    // return step if diff = 0\n    if (!diff) return step;\n\n    var absDiff = Math.abs(diff);\n    var numSteps = Math.round(absDiff / step);\n\n    // return absDiff if less than one step apart\n    if (!numSteps) return absDiff;\n\n    // otherwise, return corrected step\n    var roundedDiff = numSteps * step;\n    var remainder = absDiff - roundedDiff;\n    var stepCorrection = remainder / numSteps;\n\n    return step + stepCorrection;\n}\n\n// return a clone of point snapped to grid\nfunction snapToGrid(point, grid) {\n\n    var source = grid.source;\n\n    var snappedX = g.snapToGrid(point.x - source.x, grid.x) + source.x;\n    var snappedY = g.snapToGrid(point.y - source.y, grid.y) + source.y;\n\n    return new g.Point(snappedX, snappedY);\n}\n\n// round the point to opt.precision\nfunction round(point, precision) {\n\n    return point.round(precision);\n}\n\n// snap to grid and then round the point\nfunction align(point, grid, precision) {\n\n    return round(snapToGrid(point.clone(), grid), precision);\n}\n\n// return a string representing the point\n// string is rounded in both dimensions\nfunction getKey(point) {\n\n    return point.clone().toString();\n}\n\n// return a normalized vector from given point\n// used to determine the direction of a difference of two points\nfunction normalizePoint(point) {\n\n    return new g.Point(\n        point.x === 0 ? 0 : Math.abs(point.x) / point.x,\n        point.y === 0 ? 0 : Math.abs(point.y) / point.y\n    );\n}\n\n// PATHFINDING //\n\n// reconstructs a route by concatenating points with their parents\nfunction reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {\n\n    var route = [];\n\n    var prevDiff = normalizePoint(to.difference(tailPoint));\n\n    // tailPoint is assumed to be aligned already\n    var currentKey = getKey(tailPoint);\n    var parent = parents[currentKey];\n\n    var point;\n    while (parent) {\n\n        // point is assumed to be aligned already\n        point = points[currentKey];\n\n        var diff = normalizePoint(point.difference(parent));\n        if (!diff.equals(prevDiff)) {\n            route.unshift(point);\n            prevDiff = diff;\n        }\n\n        // parent is assumed to be aligned already\n        currentKey = getKey(parent);\n        parent = parents[currentKey];\n    }\n\n    // leadPoint is assumed to be aligned already\n    var leadPoint = points[currentKey];\n\n    var fromDiff = normalizePoint(leadPoint.difference(from));\n    if (!fromDiff.equals(prevDiff)) {\n        route.unshift(leadPoint);\n    }\n\n    return route;\n}\n\n// heuristic method to determine the distance between two points\nfunction estimateCost(from, endPoints) {\n\n    var min = Infinity;\n\n    for (var i = 0, len = endPoints.length; i < len; i++) {\n        var cost = from.manhattanDistance(endPoints[i]);\n        if (cost < min) min = cost;\n    }\n\n    return min;\n}\n\n// find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\nfunction getRectPoints(anchor, bbox, directionList, grid, opt) {\n\n    var precision = opt.precision;\n    var directionMap = opt.directionMap;\n\n    var anchorCenterVector = anchor.difference(bbox.center());\n\n    var keys = util.isObject(directionMap) ? Object.keys(directionMap) : [];\n    var dirList = util.toArray(directionList);\n    var rectPoints = keys.reduce(function(res, key) {\n\n        if (dirList.includes(key)) {\n            var direction = directionMap[key];\n\n            // create a line that is guaranteed to intersect the bbox if bbox is in the direction\n            // even if anchor lies outside of bbox\n            var endpoint = new g.Point(\n                anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width),\n                anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height)\n            );\n            var intersectionLine = new g.Line(anchor, endpoint);\n\n            // get the farther intersection, in case there are two\n            // (that happens if anchor lies next to bbox)\n            var intersections = intersectionLine.intersect(bbox) || [];\n            var numIntersections = intersections.length;\n            var farthestIntersectionDistance;\n            var farthestIntersection = null;\n            for (var i = 0; i < numIntersections; i++) {\n                var currentIntersection = intersections[i];\n                var distance = anchor.squaredDistance(currentIntersection);\n                if ((farthestIntersectionDistance === undefined) || (distance > farthestIntersectionDistance)) {\n                    farthestIntersectionDistance = distance;\n                    farthestIntersection = currentIntersection;\n                }\n            }\n\n            // if an intersection was found in this direction, it is our rectPoint\n            if (farthestIntersection) {\n                var point = align(farthestIntersection, grid, precision);\n\n                // if the rectPoint lies inside the bbox, offset it by one more step\n                if (bbox.containsPoint(point)) {\n                    point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);\n                }\n\n                // then add the point to the result array\n                // aligned\n                res.push(point);\n            }\n        }\n\n        return res;\n    }, []);\n\n    // if anchor lies outside of bbox, add it to the array of points\n    if (!bbox.containsPoint(anchor)) {\n        // aligned\n        rectPoints.push(align(anchor, grid, precision));\n    }\n\n    return rectPoints;\n}\n\n// finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm\n// rectangles get rect points assigned by getRectPoints()\nfunction findRoute(from, to, isPointObstacle, opt) {\n\n    var precision = opt.precision;\n\n    // Get grid for this route.\n\n    var sourceAnchor, targetAnchor;\n\n    if (from instanceof g.Rect) { // `from` is sourceBBox\n        sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);\n    } else {\n        sourceAnchor = round(from.clone(), precision);\n    }\n\n    if (to instanceof g.Rect) { // `to` is targetBBox\n        targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);\n    } else {\n        targetAnchor = round(to.clone(), precision);\n    }\n\n    var grid = getGrid(opt.step, sourceAnchor, targetAnchor);\n\n    // Get pathfinding points.\n\n    var start, end; // aligned with grid by definition\n    var startPoints, endPoints; // assumed to be aligned with grid already\n\n    // set of points we start pathfinding from\n    if (from instanceof g.Rect) { // `from` is sourceBBox\n        start = sourceAnchor;\n        startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);\n\n    } else {\n        start = sourceAnchor;\n        startPoints = [start];\n    }\n\n    // set of points we want the pathfinding to finish at\n    if (to instanceof g.Rect) { // `to` is targetBBox\n        end = targetAnchor;\n        endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);\n\n    } else {\n        end = targetAnchor;\n        endPoints = [end];\n    }\n\n    // take into account only accessible rect points (those not under obstacles)\n    startPoints = startPoints.filter(p => !isPointObstacle(p));\n    endPoints = endPoints.filter(p => !isPointObstacle(p));\n\n    // Check that there is an accessible route point on both sides.\n    // Otherwise, use fallbackRoute().\n    if (startPoints.length > 0 && endPoints.length > 0) {\n\n        // The set of tentative points to be evaluated, initially containing the start points.\n        // Rounded to nearest integer for simplicity.\n        var openSet = new SortedSet();\n        // Keeps reference to actual points for given elements of the open set.\n        var points = {};\n        // Keeps reference to a point that is immediate predecessor of given element.\n        var parents = {};\n        // Cost from start to a point along best known path.\n        var costs = {};\n\n        for (var i = 0, n = startPoints.length; i < n; i++) {\n            // startPoint is assumed to be aligned already\n            var startPoint = startPoints[i];\n\n            var key = getKey(startPoint);\n\n            openSet.add(key, estimateCost(startPoint, endPoints));\n            points[key] = startPoint;\n            costs[key] = 0;\n        }\n\n        var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route\n        var isPathBeginning = (previousRouteDirectionAngle === undefined);\n\n        // directions\n        var direction, directionChange;\n        var directions = opt.directions;\n        getGridOffsets(directions, grid, opt);\n\n        var numDirections = directions.length;\n\n        var endPointsKeys = util.toArray(endPoints).reduce(function(res, endPoint) {\n            // endPoint is assumed to be aligned already\n\n            var key = getKey(endPoint);\n            res.push(key);\n            return res;\n        }, []);\n\n        // main route finding loop\n        var loopsRemaining = opt.maximumLoops;\n        while (!openSet.isEmpty() && loopsRemaining > 0) {\n\n            // remove current from the open list\n            var currentKey = openSet.pop();\n            var currentPoint = points[currentKey];\n            var currentParent = parents[currentKey];\n            var currentCost = costs[currentKey];\n\n            var isRouteBeginning = (currentParent === undefined); // undefined for route starts\n            var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction\n\n            var previousDirectionAngle;\n            if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); // a vertex on the route\n            else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle; // beginning of route on the path\n            else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); // beginning of path, start rect point\n            else previousDirectionAngle = null; // beginning of path, source anchor or `from` point\n\n            // check if we reached any endpoint\n            var samePoints = startPoints.length === endPoints.length;\n            if (samePoints) {\n                for (var j = 0; j < startPoints.length; j++) {\n                    if (!startPoints[j].equals(endPoints[j])) {\n                        samePoints = false;\n                        break;\n                    }\n                }\n            }\n            var skipEndCheck = (isRouteBeginning && samePoints);\n            if (!skipEndCheck && (endPointsKeys.indexOf(currentKey) >= 0)) {\n                opt.previousDirectionAngle = previousDirectionAngle;\n                return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);\n            }\n\n            // go over all possible directions and find neighbors\n            for (i = 0; i < numDirections; i++) {\n                direction = directions[i];\n\n                var directionAngle = direction.angle;\n                directionChange = getDirectionChange(previousDirectionAngle, directionAngle);\n\n                // if the direction changed rapidly, don't use this point\n                // any direction is allowed for starting points\n                if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;\n\n                var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);\n                var neighborKey = getKey(neighborPoint);\n\n                // Closed points from the openSet were already evaluated.\n                if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) continue;\n\n                // We can only enter end points at an acceptable angle.\n                if (endPointsKeys.indexOf(neighborKey) >= 0) { // neighbor is an end point\n\n                    var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction\n\n                    if (!isNeighborEnd) {\n                        var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);\n                        var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);\n\n                        if (endDirectionChange > opt.maxAllowedDirectionChange) continue;\n                    }\n                }\n\n                // The current direction is ok.\n\n                var neighborCost = direction.cost;\n                var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point\n                var costFromStart = currentCost + neighborCost + neighborPenalty;\n\n                if (!openSet.isOpen(neighborKey) || (costFromStart < costs[neighborKey])) {\n                    // neighbor point has not been processed yet\n                    // or the cost of the path from start is lower than previously calculated\n\n                    points[neighborKey] = neighborPoint;\n                    parents[neighborKey] = currentPoint;\n                    costs[neighborKey] = costFromStart;\n                    openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n                }\n            }\n\n            loopsRemaining--;\n        }\n    }\n\n    // no route found (`to` point either wasn't accessible or finding route took\n    // way too much calculation)\n    return opt.fallbackRoute.call(this, start, end, opt);\n}\n\n// resolve some of the options\nfunction resolveOptions(opt) {\n\n    opt.directions = util.result(opt, 'directions');\n    opt.penalties = util.result(opt, 'penalties');\n    opt.paddingBox = util.result(opt, 'paddingBox');\n    opt.padding = util.result(opt, 'padding');\n\n    if (opt.padding) {\n        // if both provided, opt.padding wins over opt.paddingBox\n        var sides = util.normalizeSides(opt.padding);\n        opt.paddingBox = {\n            x: -sides.left,\n            y: -sides.top,\n            width: sides.left + sides.right,\n            height: sides.top + sides.bottom\n        };\n    }\n\n    util.toArray(opt.directions).forEach(function(direction) {\n\n        var point1 = new g.Point(0, 0);\n        var point2 = new g.Point(direction.offsetX, direction.offsetY);\n\n        direction.angle = g.normalizeAngle(point1.theta(point2));\n    });\n}\n\n// initialization of the route finding\nfunction router(vertices, opt, linkView) {\n\n    resolveOptions(opt);\n\n    // enable/disable linkView perpendicular option\n    linkView.options.perpendicular = !!opt.perpendicular;\n\n    var sourceBBox = getSourceBBox(linkView, opt);\n    var targetBBox = getTargetBBox(linkView, opt);\n\n    var sourceAnchor = getSourceAnchor(linkView, opt);\n    //var targetAnchor = getTargetAnchor(linkView, opt);\n\n    // pathfinding\n    let isPointObstacle;\n    if (typeof opt.isPointObstacle === 'function') {\n        isPointObstacle = opt.isPointObstacle;\n    } else {\n        const map = new ObstacleMap(opt);\n        map.build(linkView.paper.model, linkView.model);\n        isPointObstacle = (point) => !map.isPointAccessible(point);\n    }\n\n    var oldVertices = util.toArray(vertices).map(g.Point);\n    var newVertices = [];\n    var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping\n\n    // find a route by concatenating all partial routes (routes need to pass through vertices)\n    // source -> vertex[1] -> ... -> vertex[n] -> target\n    var to, from;\n\n    for (var i = 0, len = oldVertices.length; i <= len; i++) {\n\n        var partialRoute = null;\n\n        from = to || sourceBBox;\n        to = oldVertices[i];\n\n        if (!to) {\n            // this is the last iteration\n            // we ran through all vertices in oldVertices\n            // 'to' is not a vertex.\n\n            to = targetBBox;\n\n            // If the target is a point (i.e. it's not an element), we\n            // should use dragging route instead of main routing method if it has been provided.\n            var isEndingAtPoint = !linkView.model.get('source').id || !linkView.model.get('target').id;\n\n            if (isEndingAtPoint && util.isFunction(opt.draggingRoute)) {\n                // Make sure we are passing points only (not rects).\n                var dragFrom = (from === sourceBBox) ? sourceAnchor : from;\n                var dragTo = to.origin();\n\n                partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);\n            }\n        }\n\n        // if partial route has not been calculated yet use the main routing method to find one\n        partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);\n\n        if (partialRoute === null) { // the partial route cannot be found\n            return opt.fallbackRouter(vertices, opt, linkView);\n        }\n\n        var leadPoint = partialRoute[0];\n\n        // remove the first point if the previous partial route had the same point as last\n        if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift();\n\n        // save tailPoint for next iteration\n        tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n\n        Array.prototype.push.apply(newVertices, partialRoute);\n    }\n\n    return newVertices;\n}\n\n// public function\nexport const manhattan = function(vertices, opt, linkView) {\n    return router(vertices, util.assign({}, config, opt), linkView);\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1051, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1057, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/routers/metro.mjs"],"sourcesContent":["import { manhattan } from './manhattan.mjs';\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\nvar config = {\n\n    maxAllowedDirectionChange: 45,\n\n    // cost of a diagonal step\n    diagonalCost: function() {\n\n        var step = this.step;\n        return Math.ceil(Math.sqrt(step * step << 1));\n    },\n\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions: function() {\n\n        var step = this.step;\n        var cost = this.cost();\n        var diagonalCost = this.diagonalCost();\n\n        return [\n            { offsetX: step, offsetY: 0, cost: cost },\n            { offsetX: step, offsetY: step, cost: diagonalCost },\n            { offsetX: 0, offsetY: step, cost: cost },\n            { offsetX: -step, offsetY: step, cost: diagonalCost },\n            { offsetX: -step, offsetY: 0, cost: cost },\n            { offsetX: -step, offsetY: -step, cost: diagonalCost },\n            { offsetX: 0, offsetY: -step, cost: cost },\n            { offsetX: step, offsetY: -step, cost: diagonalCost }\n        ];\n    },\n\n    // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute: function(from, to, opt) {\n\n        // Find a route which breaks by 45 degrees ignoring all obstacles.\n\n        var theta = from.theta(to);\n\n        var route = [];\n\n        var a = { x: to.x, y: from.y };\n        var b = { x: from.x, y: to.y };\n\n        if (theta % 180 > 90) {\n            var t = a;\n            a = b;\n            b = t;\n        }\n\n        var p1 = (theta % 90) < 45 ? a : b;\n        var l1 = new g.Line(from, p1);\n\n        var alpha = 90 * Math.ceil(theta / 90);\n\n        var p2 = g.Point.fromPolar(l1.squaredLength(), g.toRad(alpha + 135), p1);\n        var l2 = new g.Line(to, p2);\n\n        var intersectionPoint = l1.intersection(l2);\n        var point = intersectionPoint ? intersectionPoint : to;\n\n        var directionFrom = intersectionPoint ? point : from;\n\n        var quadrant = 360 / opt.directions.length;\n        var angleTheta = directionFrom.theta(to);\n        var normalizedAngle = g.normalizeAngle(angleTheta + (quadrant / 2));\n        var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n\n        opt.previousDirectionAngle = directionAngle;\n\n        if (point) route.push(point.round());\n        route.push(to);\n\n        return route;\n    }\n};\n\n// public function\nexport const metro = function(vertices, opt, linkView) {\n\n    if (!util.isFunction(manhattan)) {\n        throw new Error('Metro requires the manhattan router.');\n    }\n\n    return manhattan(vertices, util.assign({}, config, opt), linkView);\n};\n\n"],"names":[],"mappings":";;;AAEA;AADA;AADA;;;;AAIA,IAAI,SAAS;IAET,2BAA2B;IAE3B,0BAA0B;IAC1B,cAAc;QAEV,IAAI,OAAO,IAAI,CAAC,IAAI;QACpB,OAAO,KAAK,IAAI,CAAC,KAAK,IAAI,CAAC,OAAO,QAAQ;IAC9C;IAEA,0DAA0D;IAC1D,sCAAsC;IACtC,YAAY;QAER,IAAI,OAAO,IAAI,CAAC,IAAI;QACpB,IAAI,OAAO,IAAI,CAAC,IAAI;QACpB,IAAI,eAAe,IAAI,CAAC,YAAY;QAEpC,OAAO;YACH;gBAAE,SAAS;gBAAM,SAAS;gBAAG,MAAM;YAAK;YACxC;gBAAE,SAAS;gBAAM,SAAS;gBAAM,MAAM;YAAa;YACnD;gBAAE,SAAS;gBAAG,SAAS;gBAAM,MAAM;YAAK;YACxC;gBAAE,SAAS,CAAC;gBAAM,SAAS;gBAAM,MAAM;YAAa;YACpD;gBAAE,SAAS,CAAC;gBAAM,SAAS;gBAAG,MAAM;YAAK;YACzC;gBAAE,SAAS,CAAC;gBAAM,SAAS,CAAC;gBAAM,MAAM;YAAa;YACrD;gBAAE,SAAS;gBAAG,SAAS,CAAC;gBAAM,MAAM;YAAK;YACzC;gBAAE,SAAS;gBAAM,SAAS,CAAC;gBAAM,MAAM;YAAa;SACvD;IACL;IAEA,mEAAmE;IACnE,uDAAuD;IACvD,eAAe,SAAS,IAAI,EAAE,EAAE,EAAE,GAAG;QAEjC,kEAAkE;QAElE,IAAI,QAAQ,KAAK,KAAK,CAAC;QAEvB,IAAI,QAAQ,EAAE;QAEd,IAAI,IAAI;YAAE,GAAG,GAAG,CAAC;YAAE,GAAG,KAAK,CAAC;QAAC;QAC7B,IAAI,IAAI;YAAE,GAAG,KAAK,CAAC;YAAE,GAAG,GAAG,CAAC;QAAC;QAE7B,IAAI,QAAQ,MAAM,IAAI;YAClB,IAAI,IAAI;YACR,IAAI;YACJ,IAAI;QACR;QAEA,IAAI,KAAK,AAAC,QAAQ,KAAM,KAAK,IAAI;QACjC,IAAI,KAAK,IAAI,yJAAE,IAAI,CAAC,MAAM;QAE1B,IAAI,QAAQ,KAAK,KAAK,IAAI,CAAC,QAAQ;QAEnC,IAAI,KAAK,yJAAE,KAAK,CAAC,SAAS,CAAC,GAAG,aAAa,IAAI,yJAAE,KAAK,CAAC,QAAQ,MAAM;QACrE,IAAI,KAAK,IAAI,yJAAE,IAAI,CAAC,IAAI;QAExB,IAAI,oBAAoB,GAAG,YAAY,CAAC;QACxC,IAAI,QAAQ,oBAAoB,oBAAoB;QAEpD,IAAI,gBAAgB,oBAAoB,QAAQ;QAEhD,IAAI,WAAW,MAAM,IAAI,UAAU,CAAC,MAAM;QAC1C,IAAI,aAAa,cAAc,KAAK,CAAC;QACrC,IAAI,kBAAkB,yJAAE,cAAc,CAAC,aAAc,WAAW;QAChE,IAAI,iBAAiB,WAAW,KAAK,KAAK,CAAC,kBAAkB;QAE7D,IAAI,sBAAsB,GAAG;QAE7B,IAAI,OAAO,MAAM,IAAI,CAAC,MAAM,KAAK;QACjC,MAAM,IAAI,CAAC;QAEX,OAAO;IACX;AACJ;AAGO,MAAM,QAAQ,SAAS,QAAQ,EAAE,GAAG,EAAE,QAAQ;IAEjD,IAAI,CAAC,4JAAK,UAAU,CAAC,kKAAA,CAAA,YAAS,GAAG;QAC7B,MAAM,IAAI,MAAM;IACpB;IAEA,OAAO,CAAA,GAAA,kKAAA,CAAA,YAAS,AAAD,EAAE,UAAU,4JAAK,MAAM,CAAC,CAAC,GAAG,QAAQ,MAAM;AAC7D","ignoreList":[0]}},
    {"offset": {"line": 1165, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1171, "column": 0}, "map": {"version":3,"sources":["file:///home/phamhoaixuan/DevLens/index_files/node_modules/%40joint/core/src/routers/rightAngle.mjs"],"sourcesContent":["import * as g from '../g/index.mjs';\n\nconst Directions = {\n    AUTO: 'auto',\n    LEFT: 'left',\n    RIGHT: 'right',\n    TOP: 'top',\n    BOTTOM: 'bottom',\n    ANCHOR_SIDE: 'anchor-side',\n    MAGNET_SIDE: 'magnet-side'\n};\n\nconst DEFINED_DIRECTIONS = [Directions.LEFT, Directions.RIGHT, Directions.TOP, Directions.BOTTOM];\n\nconst OPPOSITE_DIRECTIONS = {\n    [Directions.LEFT]: Directions.RIGHT,\n    [Directions.RIGHT]: Directions.LEFT,\n    [Directions.TOP]: Directions.BOTTOM,\n    [Directions.BOTTOM]: Directions.TOP\n};\n\nconst VERTICAL_DIRECTIONS = [Directions.TOP, Directions.BOTTOM];\n\nconst ANGLE_DIRECTION_MAP = {\n    0: Directions.RIGHT,\n    180: Directions.LEFT,\n    270: Directions.TOP,\n    90: Directions.BOTTOM\n};\n\nfunction getSegmentAngle(line) {\n    // TODO: the angle() method is general and therefore unnecessarily heavy for orthogonal links\n    return line.angle();\n}\n\nfunction simplifyPoints(points) {\n    // TODO: use own more efficient implementation (filter points that do not change direction).\n    // To simplify segments that are almost aligned (start and end points differ by e.g. 0.5px), use a threshold of 1.\n    return new g.Polyline(points).simplify({ threshold: 1 }).points;\n}\n\nfunction resolveSides(source, target) {\n    const { point: sourcePoint, x0: sx0, y0: sy0, view: sourceView, bbox: sourceBBox, direction: sourceDirection } = source;\n    const { point: targetPoint, x0: tx0, y0: ty0, view: targetView, bbox: targetBBox, direction: targetDirection } = target;\n\n    let sourceSide;\n\n    if (!sourceView) {\n        const sourceLinkAnchorBBox = new g.Rect(sx0, sy0, 0, 0);\n        sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);\n    } else if (sourceView.model.isLink()) {\n        sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);\n    } else if (sourceDirection === Directions.ANCHOR_SIDE) {\n        sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);\n    } else if (sourceDirection === Directions.MAGNET_SIDE) {\n        sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);\n    } else {\n        sourceSide = sourceDirection;\n    }\n\n    let targetSide;\n\n    if (!targetView) {\n        const targetLinkAnchorBBox = new g.Rect(tx0, ty0, 0, 0);\n        targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);\n    } else if (targetView.model.isLink()) {\n        targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);\n    } else if (targetDirection === Directions.ANCHOR_SIDE) {\n        targetSide = targetBBox.sideNearestToPoint(targetPoint);\n    } else if (targetDirection === Directions.MAGNET_SIDE) {\n        targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);\n    } else {\n        targetSide = targetDirection;\n    }\n\n    return [sourceSide, targetSide];\n}\n\nfunction resolveForTopSourceSide(source, target, nextInLine) {\n    const { x0: sx0, y0: sy0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smx1 = sx1 + margin;\n    const smy0 = sy0 - margin;\n\n    const { x: ax } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx === ax && ty < sy0) return Directions.BOTTOM;\n    if (tx < ax && ty < smy0) {\n        if (nextInLine.point.x === ax) return Directions.BOTTOM;\n        return Directions.RIGHT;\n    }\n    if (tx > ax && ty < smy0) {\n        if (nextInLine.point.x === ax) return Directions.BOTTOM;\n        return Directions.LEFT;\n    }\n    if (tx < smx0 && ty > smy0) return Directions.TOP;\n    if (tx > smx1 && ty > smy0) return Directions.TOP;\n    if (tx >= smx0 && tx <= ax && ty > sy1) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n    if (tx <= smx1 && tx >= ax && ty > sy1) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n\n    return Directions.BOTTOM;\n}\n\nfunction resolveForBottomSourceSide(source, target, nextInLine) {\n    const { x0: sx0, y0: sy0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smx1 = sx1 + margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx === ax && ty > sy1) return Directions.TOP;\n    if (tx < ax && ty > smy1) {\n        if (nextInLine.point.x === ax) return Directions.TOP;\n        return Directions.RIGHT;\n    }\n    if (tx > ax && ty > smy1) {\n        if (nextInLine.point.x === ax) return Directions.TOP;\n        return Directions.LEFT;\n    }\n    if (tx < smx0 && ty < smy1) return Directions.BOTTOM;\n    if (tx > smx1 && ty < smy1) return Directions.BOTTOM;\n    if (tx >= smx0 && tx <= ax && ty < sy0) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n    if (tx <= smx1 && tx >= ax && ty < sy0) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n\n    return Directions.TOP;\n}\n\nfunction resolveForLeftSourceSide(source, target, nextInLine) {\n    const { y0: sy0, x0: sx0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smy0 = sy0 - margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax, y: ay } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx < ax && ty === ay) return Directions.RIGHT;\n    if (tx <= smx0 && ty < ay) return Directions.BOTTOM;\n    if (tx <= smx0 && ty > ay) return Directions.TOP;\n    if (tx >= smx0 && ty < smy0) return Directions.LEFT;\n    if (tx >= smx0 && ty > smy1) return Directions.LEFT;\n    if (tx > sx1 && ty >= smy0 && ty <= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n    if (tx > sx1 && ty <= smy1 && ty >= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n\n    return Directions.RIGHT;\n}\n\nfunction resolveForRightSourceSide(source, target, nextInLine) {\n    const { y0: sy0, x0: sx0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx1 = sx1 + margin;\n    const smy0 = sy0 - margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax, y: ay } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx > ax && ty === ay) return Directions.LEFT;\n    if (tx >= smx1 && ty < ay) return Directions.BOTTOM;\n    if (tx >= smx1 && ty > ay) return Directions.TOP;\n    if (tx <= smx1 && ty < smy0) return Directions.RIGHT;\n    if (tx <= smx1 && ty > smy1) return Directions.RIGHT;\n    if (tx < sx0 && ty >= smy0 && ty <= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n    if (tx < sx0 && ty <= smy1 && ty >= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n\n    return Directions.LEFT;\n}\n\nfunction resolveInitialDirection(source, target, nextInLine) {\n    const [sourceSide] = resolveSides(source, target);\n\n    switch (sourceSide) {\n        case Directions.TOP:\n            return resolveForTopSourceSide(source, target, nextInLine);\n        case Directions.RIGHT:\n            return resolveForRightSourceSide(source, target, nextInLine);\n        case Directions.BOTTOM:\n            return resolveForBottomSourceSide(source, target, nextInLine);\n        case Directions.LEFT:\n            return resolveForLeftSourceSide(source, target, nextInLine);\n    }\n}\n\nfunction getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {\n    const tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));\n    const roundedAngle = Math.round(getSegmentAngle(tangent) / 90) * 90;\n\n    if (roundedAngle % 180 === 0 && linkOrigin.y === connectionPoint.y) {\n        return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n    } else if (linkOrigin.x === connectionPoint.x) {\n        return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n    }\n\n    switch (roundedAngle) {\n        case 0:\n        case 180:\n        case 360:\n            return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n        case 90:\n        case 270:\n            return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n    }\n}\n\nfunction pointDataFromAnchor(view, point, bbox, direction, isPort, fallBackAnchor, margin) {\n    if (direction === Directions.AUTO) {\n        direction = isPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;\n    }\n\n    const isElement = view && view.model.isElement();\n\n    const {\n        x: x0,\n        y: y0,\n        width = 0,\n        height = 0\n    } = isElement ? g.Rect.fromRectUnion(bbox, view.model.getBBox()) : fallBackAnchor;\n\n    return {\n        point,\n        x0,\n        y0,\n        view,\n        bbox,\n        width,\n        height,\n        direction,\n        margin: isElement ? margin : 0\n    };\n}\n\nfunction pointDataFromVertex({ x, y }) {\n    const point = new g.Point(x, y);\n\n    return {\n        point,\n        x0: point.x,\n        y0: point.y,\n        view: null,\n        bbox: new g.Rect(x, y, 0, 0),\n        width: 0,\n        height: 0,\n        direction: null,\n        margin: 0\n    };\n}\n\nfunction getOutsidePoint(side, pointData, margin) {\n    const outsidePoint = pointData.point.clone();\n\n    const { x0, y0, width, height } = pointData;\n\n    switch (side) {\n        case 'left':\n            outsidePoint.x = x0 - margin;\n            break;\n        case 'right':\n            outsidePoint.x = x0 + width + margin;\n            break;\n        case 'top':\n            outsidePoint.y = y0 - margin;\n            break;\n        case 'bottom':\n            outsidePoint.y = y0 + height + margin;\n            break;\n    }\n\n    return outsidePoint;\n}\n\nfunction createLoop(from, to, { dx = 0, dy = 0 }) {\n    const p1 = { x: from.point.x + dx, y: from.point.y + dy };\n    const p2 = { x: to.point.x + dx, y: to.point.y + dy };\n\n    return [from.point, p1, p2, to.point];\n}\n\nfunction loopSegment(from, to, connectionSegmentAngle, margin) {\n    // Find out the loop coordinates.\n    const angle = g.normalizeAngle(connectionSegmentAngle - 90);\n\n    let dx = 0;\n    let dy = 0;\n\n    if (angle === 90) {\n        dy = -margin;\n    } else if (angle === 180) {\n        dx = -margin;\n    } else if (angle === 270) {\n        dy = margin;\n    } else if (angle === 0) {\n        dx = margin;\n    }\n\n    const loopRoute = createLoop(from, to, { dx, dy });\n\n    const secondCreatedPoint = loopRoute[2];\n    const loopEndSegment = new g.Line(to.point, secondCreatedPoint);\n    // The direction in which the loop should continue.\n    const continueDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];\n\n    return {\n        loopRoute,\n        continueDirection\n    };\n}\n\n// Calculates the distances along the horizontal axis for the left and right route.\nfunction getHorizontalDistance(source, target) {\n\n    const { x0: sx0, x1: sx1, outsidePoint: sourcePoint } = source;\n    const { x0: tx0, x1: tx1, outsidePoint: targetPoint } = target;\n\n    // Furthest left boundary\n    let leftBoundary = Math.min(sx0, tx0);\n    // Furthest right boundary\n    let rightBoundary = Math.max(sx1, tx1);\n\n    // If the source and target elements are on the same side, we need to figure out what shape defines the boundary.\n    if (source.direction === target.direction) {\n\n        const aboveShape = source.y0 < target.y0 ? source : target;\n        const belowShape = aboveShape === source ? target : source;\n\n        // The source and target anchors are on the top => then the `aboveShape` defines the boundary.\n        // The source and target anchors are on the bottom => then the `belowShape` defines the boundary.\n        const boundaryDefiningShape = source.direction === Directions.TOP ? aboveShape : belowShape;\n\n        leftBoundary = boundaryDefiningShape.x0;\n        rightBoundary = boundaryDefiningShape.x1;\n    }\n\n    const { x: sox } = sourcePoint;\n    const { x: tox } = targetPoint;\n\n    // Calculate the distances for the left route\n    const leftDistance1 = Math.abs(sox - leftBoundary);\n    const leftDistance2 = Math.abs(tox - leftBoundary);\n    const leftD = leftDistance1 + leftDistance2;\n\n    // Calculate the distances for the right route\n    const rightDistance1 = Math.abs(sox - rightBoundary);\n    const rightDistance2 = Math.abs(tox - rightBoundary);\n    const rightD = rightDistance1 + rightDistance2;\n\n    return [leftD, rightD];\n}\n\n// Calculates the distances along the vertical axis for the top and bottom route.\nfunction getVerticalDistance(source, target) {\n\n    const { y0: sy0, y1: sy1, outsidePoint: sourcePoint } = source;\n    const { y0: ty0, y1: ty1, outsidePoint: targetPoint } = target;\n\n    // Furthest top boundary\n    let topBoundary = Math.min(sy0, ty0);\n    // Furthest bottom boundary\n    let bottomBoundary = Math.max(sy1, ty1);\n\n    // If the source and target elements are on the same side, we need to figure out what shape defines the boundary.\n    if (source.direction === target.direction) {\n\n        const leftShape = source.x0 < target.x0 ? source : target;\n        const rightShape = leftShape === source ? target : source;\n\n        // The source and target anchors are on the left => then the `leftShape` defines the boundary.\n        // The source and target anchors are on the right => then the `rightShape` defines the boundary.\n        const boundaryDefiningShape = source.direction === Directions.LEFT ? leftShape : rightShape;\n\n        topBoundary = boundaryDefiningShape.y0;\n        bottomBoundary = boundaryDefiningShape.y1;  \n    }\n\n    const { y: soy } = sourcePoint;\n    const { y: toy } = targetPoint;\n\n    // Calculate the distances for the top route\n    const topDistance1 = Math.abs(soy - topBoundary);\n    const topDistance2 = Math.abs(toy - topBoundary);\n    const topD = topDistance1 + topDistance2;\n\n    // Calculate the distances for the bottom route\n    const bottomDistance1 = Math.abs(soy - bottomBoundary);\n    const bottomDistance2 = Math.abs(toy - bottomBoundary);\n    const bottomD = bottomDistance1 + bottomDistance2;\n\n    return [topD, bottomD];\n}\n\n// Inflate bbox in 3 directions depending on the direction of the anchor\n// don't inflate in the opposite direction of the anchor\nfunction moveAndExpandBBox(bbox, direction, margin) {\n    switch (direction) {\n        case Directions.LEFT:\n            bbox.inflate(0, margin).moveAndExpand({ x: -margin, width: margin });\n            break;\n        case Directions.RIGHT:\n            bbox.inflate(0, margin).moveAndExpand({ width: margin });\n            break;\n        case Directions.TOP:\n            bbox.inflate(margin, 0).moveAndExpand({ y: -margin, height: margin });\n            break;\n        case Directions.BOTTOM:\n            bbox.inflate(margin, 0).moveAndExpand({ height: margin });\n            break;\n    }\n\n    return bbox;\n}\n\nfunction routeBetweenPoints(source, target, opt = {}) {\n    const { point: sourcePoint, x0: sx0, y0: sy0, width: sourceWidth, height: sourceHeight, margin: sourceMargin } = source;\n    const { point: targetPoint, x0: tx0, y0: ty0, width: targetWidth, height: targetHeight, margin: targetMargin } = target;\n    const { targetInSourceBBox = false } = opt;\n\n    const tx1 = tx0 + targetWidth;\n    const ty1 = ty0 + targetHeight;\n    const sx1 = sx0 + sourceWidth;\n    const sy1 = sy0 + sourceHeight;\n\n    // Key coordinates including the margin\n    const smx0 = sx0 - sourceMargin;\n    const smx1 = sx1 + sourceMargin;\n    const smy0 = sy0 - sourceMargin;\n    const smy1 = sy1 + sourceMargin;\n\n    const tmx0 = tx0 - targetMargin;\n    const tmx1 = tx1 + targetMargin;\n    const tmy0 = ty0 - targetMargin;\n    const tmy1 = ty1 + targetMargin;\n\n    const [sourceSide, targetSide] = resolveSides(source, target);\n\n    const sourceOutsidePoint = getOutsidePoint(sourceSide, { point: sourcePoint, x0: sx0, y0: sy0, width: sourceWidth, height: sourceHeight }, sourceMargin);\n    const targetOutsidePoint = getOutsidePoint(targetSide, { point: targetPoint, x0: tx0, y0: ty0, width: targetWidth, height: targetHeight }, targetMargin);\n\n    const { x: sox, y: soy } = sourceOutsidePoint;\n    const { x: tox, y: toy } = targetOutsidePoint;\n    const tcx = (tx0 + tx1) / 2;\n    const tcy = (ty0 + ty1) / 2;\n    const scx = (sx0 + sx1) / 2;\n    const scy = (sy0 + sy1) / 2;\n    const middleOfVerticalSides = (scx < tcx ? (sx1 + tx0) : (tx1 + sx0)) / 2;\n    const middleOfHorizontalSides = (scy < tcy ? (sy1 + ty0) : (ty1 + sy0)) / 2;\n\n    const sourceBBox = new g.Rect(sx0, sy0, sourceWidth, sourceHeight);\n    const targetBBox = new g.Rect(tx0, ty0, targetWidth, targetHeight);\n    const inflatedSourceBBox = sourceBBox.clone().inflate(sourceMargin);\n    const inflatedTargetBBox = targetBBox.clone().inflate(targetMargin);\n\n    const sourceForDistance = Object.assign({}, source, { x1: sx1, y1: sy1, outsidePoint: sourceOutsidePoint, direction: sourceSide });\n    const targetForDistance = Object.assign({}, target, { x1: tx1, y1: ty1, outsidePoint: targetOutsidePoint, direction: targetSide });\n\n    // Distances used to determine the shortest route along the connections on horizontal sides for\n    // bottom => bottom\n    // top => bottom\n    // bottom => top\n    // top => top\n    const [leftD, rightD] = getHorizontalDistance(sourceForDistance, targetForDistance);\n\n    // Distances used to determine the shortest route along the connection on vertical sides for\n    // left => left\n    // left => right\n    // right => right\n    // right => left\n    const [topD, bottomD] = getVerticalDistance(sourceForDistance, targetForDistance);\n\n    // All possible combinations of source and target sides\n    if (sourceSide === 'left' && targetSide === 'right') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n        // Use S-shaped connection\n        if (isPointInsideSource || isPointInsideTarget) {\n            const middleOfAnchors = (soy + toy) / 2;\n            \n            return [\n                { x: sox, y: soy },\n                { x: sox, y: middleOfAnchors },\n                { x: tox, y: middleOfAnchors },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (smx0 < tox) {\n            let y = middleOfHorizontalSides;\n            let x1 = sox;\n            let x2 = tox;\n\n            const isUpwardsShorter = topD < bottomD;\n\n            // If the source and target elements overlap, we need to make sure the connection\n            // goes around the target element.\n            if ((y >= smy0 && y <= smy1) || (y >= tmy0 && y <= tmy1)) {\n                if (smy1 >= tmy0 && isUpwardsShorter) {\n                    y = Math.min(tmy0, smy0);\n                } else if (smy0 <= tmy1 && !isUpwardsShorter) {\n                    y = Math.max(tmy1, smy1);\n                }\n\n                // This handles the case when the source and target elements overlap as well as\n                // the case when the source is to the left of the target element.\n                x1 = Math.min(sox, tmx0);\n                x2 = Math.max(tox, smx1);\n            \n                // This is an edge case when the source and target intersect and\n                if ((isUpwardsShorter && soy < ty0) || (!isUpwardsShorter && soy > ty1)) {\n                    // the path should no longer rely on minimal x boundary in `x1`\n                    x1 = sox;\n                } else if ((isUpwardsShorter && toy < sy0) || (!isUpwardsShorter && toy > sy1)) {\n                    // the path should no longer rely on maximal x boundary in `x2`\n                    x2 = tox;\n                }\n            }\n\n            return [\n                { x: x1, y: soy },\n                { x: x1, y },\n                { x: x2, y },\n                { x: x2, y: toy }\n            ];\n        }\n\n        const x = (sox + tox) / 2;\n        return [\n            { x, y: soy },\n            { x, y: toy },\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'left') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n        // Use S-shaped connection\n        if (isPointInsideSource || isPointInsideTarget) {\n            const middleOfAnchors = (soy + toy) / 2;\n            \n            return [\n                { x: sox, y: soy },\n                { x: sox, y: middleOfAnchors },\n                { x: tox, y: middleOfAnchors },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (smx1 > tox) {\n            let y = middleOfHorizontalSides;\n            let x1 = sox;\n            let x2 = tox;\n\n            const isUpwardsShorter = topD < bottomD;\n\n            // If the source and target elements overlap, we need to make sure the connection\n            // goes around the target element.\n            if ((y >= smy0 && y <= smy1) || (y >= tmy0 && y <= tmy1)) {\n                if (smy1 >= tmy0 && isUpwardsShorter) {\n                    y = Math.min(tmy0, smy0);\n                } else if (smy0 <= tmy1 && !isUpwardsShorter) {\n                    y = Math.max(tmy1, smy1);\n                }\n\n                // This handles the case when the source and target elements overlap as well as\n                // the case when the source is to the left of the target element.\n                x1 = Math.max(sox, tmx1);\n                x2 = Math.min(tox, smx0);\n\n                // This is an edge case when the source and target intersect and\n                if ((isUpwardsShorter && soy < ty0) || (!isUpwardsShorter && soy > ty1)) {\n                    // the path should no longer rely on maximal x boundary in `x1`\n                    x1 = sox;\n                } else if ((isUpwardsShorter && toy < sy0) || (!isUpwardsShorter && toy > sy1)) {\n                    // the path should no longer rely on minimal x boundary in `x2`\n                    x2 = tox;\n                }\n            }\n\n            return [\n                { x: x1, y: soy },\n                { x: x1, y },\n                { x: x2, y },\n                { x: x2, y: toy }\n            ];\n        }\n\n        const x = (sox + tox) / 2;\n        return [\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'bottom') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n        // Use S-shaped connection\n        if (isPointInsideSource || isPointInsideTarget) {\n            const middleOfAnchors = (sox + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: middleOfAnchors, y: soy },\n                { x: middleOfAnchors, y: toy },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (smy0 < toy) {\n            let x = middleOfVerticalSides;\n            let y1 = soy;\n            let y2 = toy;\n\n            const isLeftShorter = leftD < rightD;\n\n            // If the source and target elements overlap, we need to make sure the connection\n            // goes around the target element.\n            if ((x >= smx0 && x <= smx1) || (x >= tmx0 && x <= tmx1)) {\n                if (smx1 >= tmx0 && isLeftShorter) {\n                    x = Math.min(tmx0, smx0);\n                } else if (smx0 <= tmx1 && !isLeftShorter) {\n                    x = Math.max(tmx1, smx1);\n                }\n\n                // This handles the case when the source and target elements overlap as well as\n                // the case when the source is to the left of the target element.\n                y1 = Math.min(soy, tmy0);\n                y2 = Math.max(toy, smy1);\n\n                // This is an edge case when the source and target intersect and\n                if ((isLeftShorter && sox < tx0) || (!isLeftShorter && sox > tx1)) {\n                    // the path should no longer rely on minimal y boundary in `y1`\n                    y1 = soy;\n                } else if ((isLeftShorter && tox < sx0) || (!isLeftShorter && tox > sx1)) {\n                    // the path should no longer rely on maximal y boundary in `y2`\n                    y2 = toy;\n                }\n            }\n\n            return [\n                { x: sox, y: y1 },\n                { x, y: y1 },\n                { x, y: y2 },\n                { x: tox, y: y2 }\n            ];\n        }\n\n        const y = (soy + toy) / 2;\n        return [\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'top') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n        // Use S-shaped connection\n        if (isPointInsideSource || isPointInsideTarget) {\n            const middleOfAnchors = (sox + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: middleOfAnchors, y: soy },\n                { x: middleOfAnchors, y: toy },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (smy1 > toy) {\n            let x = middleOfVerticalSides;\n            let y1 = soy;\n            let y2 = toy;\n            \n            const isLeftShorter = leftD < rightD;\n\n            // If the source and target elements overlap, we need to make sure the connection\n            // goes around the target element.\n            if ((x >= smx0 && x <= smx1) || (x >= tmx0 && x <= tmx1)) {\n                if (smx1 >= tmx0 && isLeftShorter) {\n                    x = Math.min(tmx0, smx0);\n                } else if (smx0 <= tmx1 && !isLeftShorter) {\n                    x = Math.max(tmx1, smx1);\n                }\n\n                // This handles the case when the source and target elements overlap as well as\n                // the case when the source is to the left of the target element.\n                y1 = Math.max(soy, tmy1);\n                y2 = Math.min(toy, smy0);\n\n                // This is an edge case when the source and target intersect and\n                if ((isLeftShorter && sox < tx0) || (!isLeftShorter && sox > tx1)) {\n                    // the path should no longer rely on maximal y boundary in `y1`\n                    y1 = soy;\n                } else if ((isLeftShorter && tox < sx0) || (!isLeftShorter && tox > sx1)) {\n                    // the path should no longer rely on minimal y boundary in `y2`\n                    y2 = toy;\n                }\n            }\n\n            return [\n                { x: sox, y: y1 },\n                { x, y: y1 },\n                { x, y: y2 },\n                { x: tox, y: y2 }\n            ];\n        }\n\n        const y = (soy + toy) / 2;\n        return [\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'top') {\n        const useUShapeConnection =\n            targetInSourceBBox ||\n            g.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (soy <= ty0 && (inflatedSourceBBox.bottomRight().x <= tox || inflatedSourceBBox.bottomLeft().x >= tox)) ||\n            (soy >= ty0 && (inflatedTargetBBox.bottomRight().x <= sox || inflatedTargetBBox.bottomLeft().x >= sox));\n\n        // U-shape connection is a straight line if `sox` and `tox` are the same\n        if (useUShapeConnection && sox !== tox) {\n            return [\n                { x: sox, y: Math.min(soy, toy) },\n                { x: tox, y: Math.min(soy, toy) }\n            ];\n        }\n\n        let x;\n        let y1 = Math.min((sy1 + ty0) / 2, toy);\n        let y2 = Math.min((sy0 + ty1) / 2, soy);\n\n        if (toy < soy) {\n            // Use the shortest path along the connections on horizontal sides\n            if (rightD > leftD) {\n                x = Math.min(sox, tmx0);\n            } else {\n                x = Math.max(sox, tmx1);\n            }\n        } else {\n            if (rightD > leftD) {\n                x = Math.min(tox, smx0);\n            } else {\n                x = Math.max(tox, smx1);\n            }\n        }\n\n        return [\n            { x: sox, y: y2 },\n            { x, y: y2 },\n            { x, y: y1 },\n            { x: tox, y: y1 }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'bottom') {\n        const useUShapeConnection =\n            targetInSourceBBox ||\n            g.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (soy >= toy && (inflatedSourceBBox.topRight().x <= tox || inflatedSourceBBox.topLeft().x >= tox)) ||\n            (soy <= toy && (inflatedTargetBBox.topRight().x <= sox || inflatedTargetBBox.topLeft().x >= sox));\n\n        // U-shape connection is a straight line if `sox` and `tox` are the same\n        if (useUShapeConnection && sox !== tox) {\n            return [\n                { x: sox, y: Math.max(soy, toy) },\n                { x: tox, y: Math.max(soy, toy) }\n            ];\n        }\n\n        let x;\n        let y1 = Math.max((sy0 + ty1) / 2, toy);\n        let y2 = Math.max((sy1 + ty0) / 2, soy);\n\n        if (toy > soy) {\n            // Use the shortest path along the connections on horizontal sides\n            if (rightD > leftD) {\n                x = Math.min(sox, tmx0);\n            } else {\n                x = Math.max(sox, tmx1);\n            }\n        } else {\n            if (rightD > leftD) {\n                x = Math.min(tox, smx0);\n            } else {\n                x = Math.max(tox, smx1);\n            }\n        }\n\n        return [\n            { x: sox, y: y2 },\n            { x, y: y2 },\n            { x, y: y1 },\n            { x: tox, y: y1 }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'left') {\n        const useUShapeConnection = \n            targetInSourceBBox ||\n            g.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (sox <= tox && (inflatedSourceBBox.bottomRight().y <= toy || inflatedSourceBBox.topRight().y >= toy)) ||\n            (sox >= tox && (inflatedTargetBBox.bottomRight().y <= soy || inflatedTargetBBox.topRight().y >= soy));\n\n        // U-shape connection is a straight line if `soy` and `toy` are the same\n        if (useUShapeConnection && soy !== toy) {\n            return [\n                { x: Math.min(sox, tox), y: soy },\n                { x: Math.min(sox, tox), y: toy }\n            ];\n        }\n\n        let y;\n        let x1 = Math.min((sx1 + tx0) / 2, tox);\n        let x2 = Math.min((sx0 + tx1) / 2, sox);\n\n        if (tox > sox) {\n            if (topD <= bottomD) {\n                y = Math.min(smy0, toy);\n            } else {\n                y = Math.max(smy1, toy);\n            }\n        } else {\n            if (topD <= bottomD) {\n                y = Math.min(tmy0, soy);\n            } else {\n                y = Math.max(tmy1, soy);\n            }\n        }\n\n        return [\n            { x: x2, y: soy },\n            { x: x2, y },\n            { x: x1, y },\n            { x: x1, y: toy }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'right') {\n        const useUShapeConnection =\n            targetInSourceBBox ||\n            g.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (sox >= tox && (inflatedSourceBBox.bottomLeft().y <= toy || inflatedSourceBBox.topLeft().y >= toy)) ||\n            (sox <= tox && (inflatedTargetBBox.bottomLeft().y <= soy || inflatedTargetBBox.topLeft().y >= soy));\n\n        // U-shape connection is a straight line if `soy` and `toy` are the same\n        if (useUShapeConnection && soy !== toy) {\n            return [\n                { x: Math.max(sox, tox), y: soy },\n                { x: Math.max(sox, tox), y: toy }\n            ];\n        }\n\n        let y;\n        let x1 = Math.max((sx0 + tx1) / 2, tox);\n        let x2 = Math.max((sx1 + tx0) / 2, sox);\n\n        if (tox <= sox) {\n            if (topD <= bottomD) {\n                y = Math.min(smy0, toy);\n            } else {\n                y = Math.max(smy1, toy);\n            }\n        } else {\n            if (topD <= bottomD) {\n                y = Math.min(tmy0, soy);\n            } else {\n                y = Math.max(tmy1, soy);\n            }\n        }\n\n        return [\n            { x: x2, y: soy },\n            { x: x2, y },\n            { x: x1, y },\n            { x: x1, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'right') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox <= tmx1) {\n                const x = Math.max(sox + sourceMargin, tox);\n                const y = Math.min(smy0, tmy0);\n\n                // Target anchor is on the right side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x: x, y },\n                    { x: x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the left side of the source anchor\n            // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor\n            const anchorMiddleX = (sox - sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy0 > toy) {\n            if (sox < tox) {\n                let y = tmy0;\n\n                if (tmy1 <= smy0 && tmx1 >= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.max(middleOfVerticalSides, tmx1);\n\n        if (sox > tox && sy1 >= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }\n            ];\n        }\n\n        if (x > smx0 && soy < ty1) {\n            const y = Math.min(smy0, tmy0);\n            const x = Math.max(smx1, tmx1);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'left') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox >= tmx0) {\n                const x = Math.min(sox - sourceMargin, tox);\n                const y = Math.min(smy0, tmy0);\n\n                // Target anchor is on the left side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x: x, y },\n                    { x: x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the right side of the source anchor\n            // Add the `sourceMargin` since the source anchor is on the left side of the target anchor\n            const anchorMiddleX = (sox + sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy0 > toy) {\n            if (sox > tox) {\n                let y = tmy0;\n\n                if (tmy1 <= smy0 && tmx0 <= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.min(tmx0, middleOfVerticalSides);\n\n        if (sox < tox && sy1 >= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }];\n        }\n\n        if (x < smx1 && soy < ty1) {\n            const y = Math.min(smy0, tmy0);\n            const x = Math.min(smx0, tmx0);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'right') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox <= tmx1) {\n                const x = Math.max(sox + sourceMargin, tox);\n                const y = Math.max(smy1, tmy1);\n\n                // Target anchor is on the right side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x, y },\n                    { x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the left side of the source anchor\n            // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor\n            const anchorMiddleX = (sox - sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy1 < toy) {\n            if (sox < tox) {\n                let y = tmy1;\n\n                if (tmy0 >= smy1 && tmx1 >= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.max(middleOfVerticalSides, tmx1);\n\n        if (sox > tox && sy0 <= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }\n            ];\n        }\n\n        if (x > smx0 && soy > ty0) {\n            const y = Math.max(smy1, tmy1);\n            const x = Math.max(smx1, tmx1);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'left') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox >= tmx0) {\n                const x = Math.min(sox - sourceMargin, tox);\n                const y = Math.max(smy1, tmy1);\n\n                // Target anchor is on the left side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x, y },\n                    { x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the right side of the source anchor\n            // Add the `sourceMargin` since the source anchor is on the left side of the target anchor\n            const anchorMiddleX = (sox + sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy1 < toy) {\n            if (sox > tox) {\n                let y = tmy1;\n\n                if (tmy0 >= smy1 && tmx0 <= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.min(tmx0, middleOfVerticalSides);\n\n        if (sox < tox && sy0 <= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }\n            ];\n        }\n\n        if (x < smx1 && soy > ty0) {\n            const y = Math.max(smy1, tmy1);\n            const x = Math.min(smx0, tmx0);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'bottom') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy <= tmy1) {\n                const x = Math.min(smx0, tmx0);\n                const y = Math.max(soy + sourceMargin, toy);\n\n                return [\n                    { x, y: soy },\n                    { x, y },\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is above the source anchor\n            const anchorMiddleY = (soy - sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx0 > tox) {\n            if (soy < toy) {\n                let x = tmx0;\n\n                if (tmx1 <= smx0 && tmy1 >= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.max(tmy1, middleOfHorizontalSides);\n\n        if (soy > toy && sx1 >= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }\n            ];\n        }\n\n        if (y > smy0 && sox < tx1) {\n            const x = Math.min(smx0, tmx0);\n            const y = Math.max(smy1, tmy1);\n\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'top') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy >= tmy0) {\n                const y = Math.min(soy - sourceMargin, toy);\n                const x = Math.min(smx0, tmx0);\n\n                // Target anchor is on the top side of the source anchor\n                return [\n                    { x, y: soy },\n                    { x, y },\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is below the source anchor\n            // Add the `sourceMargin` since the source anchor is above the target anchor\n            const anchorMiddleY = (soy + sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx0 > tox) {\n            if (soy > toy) {\n                let x = tmx0;\n\n                if (tmx1 <= smx0 && tmy0 <= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.min(tmy0, middleOfHorizontalSides);\n\n        if (soy < toy && sx1 >= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }];\n        }\n\n        if (y < smy1 && sox < tx1) {\n            const x = Math.min(smx0, tmx0);\n            const y = Math.min(smy0, tmy0);\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'top') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy >= tmy0) {\n                const x = Math.max(smx1, tmx1);\n                const y = Math.min(soy - sourceMargin, toy);\n\n                // Target anchor is on the top side of the source anchor\n                return [\n                    { x, y: soy },\n                    { x, y }, // Path adjustment for right side start\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is below the source anchor\n            // Adjust sourceMargin calculation since the source anchor is now on the right\n            const anchorMiddleY = (soy + sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx1 < tox) {\n            if (soy > toy) {\n                let x = tmx1;\n\n                if (tmx0 >= smx1 && tmy0 <= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.min(tmy0, middleOfHorizontalSides);\n\n        if (soy < toy && sx0 <= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }];\n        }\n\n        if (y < smy1 && sox > tx0) {\n            const x = Math.max(smx1, tmx1);\n            const y = Math.min(smy0, tmy0);\n\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'bottom') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy <= tmy1) {\n                const x = Math.max(smx1, tmx1);\n                const y = Math.max(soy + sourceMargin, toy);\n\n                return [\n                    { x, y: soy },\n                    { x, y },\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is above the source anchor\n            const anchorMiddleY = (soy - sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx1 < tox) {\n            if (soy < toy) {\n                let x = tmx1;\n\n                if (tmx0 >= smx1 && tmy1 >= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.max(tmy1, middleOfHorizontalSides);\n\n        if (soy > toy && sx0 <= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }\n            ];\n        }\n\n        if (y > smy0 && sox > tx0) {\n            const x = Math.max(smx1, tmx1);\n            const y = Math.max(smy1, tmy1);\n\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    }\n}\n\nfunction getLoopCoordinates(direction, angle, margin) {\n    const isHorizontal = direction === Directions.LEFT || direction === Directions.RIGHT;\n\n    let dx = 0;\n    let dy = 0;\n\n    switch (g.normalizeAngle(Math.round(angle))) {\n        case 0:\n        case 90:\n            dx = isHorizontal ? 0 : margin;\n            dy = isHorizontal ? margin : 0;\n            break;\n        case 180:\n        case 270:\n            dx = isHorizontal ? 0 : -margin;\n            dy = isHorizontal ? -margin : 0;\n            break;\n    }\n\n    return { dx, dy };\n}\n\nfunction rightAngleRouter(vertices, opt, linkView) {\n    const { sourceDirection = Directions.AUTO, targetDirection = Directions.AUTO } = opt;\n    const margin = opt.margin || 20;\n    const useVertices = opt.useVertices || false;\n\n    const isSourcePort = !!linkView.model.source().port;\n    const sourcePoint = pointDataFromAnchor(linkView.sourceView, linkView.sourceAnchor, linkView.sourceBBox, sourceDirection, isSourcePort, linkView.sourceAnchor, margin);\n\n    const isTargetPort = !!linkView.model.target().port;\n    const targetPoint = pointDataFromAnchor(linkView.targetView, linkView.targetAnchor, linkView.targetBBox, targetDirection, isTargetPort, linkView.targetAnchor, margin);\n\n    let resultVertices = [];\n\n    if (!useVertices || vertices.length === 0) {\n        return simplifyPoints(routeBetweenPoints(sourcePoint, targetPoint));\n    }\n\n    const verticesData = vertices.map((v) => pointDataFromVertex(v));\n    const [firstVertex] = verticesData;\n\n    const [resolvedSourceDirection] = resolveSides(sourcePoint, firstVertex);\n    const isElement = sourcePoint.view && sourcePoint.view.model.isElement();\n    const sourceBBox = isElement ? moveAndExpandBBox(sourcePoint.view.model.getBBox(), resolvedSourceDirection, margin) : null;\n    const isVertexInside = isElement ? sourceBBox.containsPoint(firstVertex.point) : false;\n\n    if (isVertexInside) {\n        const outsidePoint = getOutsidePoint(resolvedSourceDirection, sourcePoint, margin);\n        const firstPointOverlap = outsidePoint.equals(firstVertex.point);\n\n        const alignsVertically = sourcePoint.point.x === firstVertex.point.x;\n        const alignsHorizontally = sourcePoint.point.y === firstVertex.point.y;\n\n        const isVerticalAndAligns = alignsVertically && (resolvedSourceDirection === Directions.TOP || resolvedSourceDirection === Directions.BOTTOM);\n        const isHorizontalAndAligns = alignsHorizontally && (resolvedSourceDirection === Directions.LEFT || resolvedSourceDirection === Directions.RIGHT);\n\n        const firstSegment = new g.Line(sourcePoint.point, outsidePoint);\n        const isVertexOnSegment = firstSegment.containsPoint(firstVertex.point);\n\n        const isVertexAlignedAndInside = isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns);\n\n        \n\n        if (firstPointOverlap) {\n            resultVertices.push(sourcePoint.point, firstVertex.point);\n            // Set the access direction as the opposite of the source direction that will be used to connect the route with the next vertex\n            firstVertex.direction = OPPOSITE_DIRECTIONS[resolvedSourceDirection];\n        } else if (isVertexOnSegment || isVertexAlignedAndInside) {\n            // Case where there is a need to create a loop\n            const angle = getSegmentAngle(isVertexOnSegment ? firstSegment : new g.Line(sourcePoint.point, firstVertex.point));\n            const { dx, dy } = getLoopCoordinates(resolvedSourceDirection, angle, margin);\n\n            const loop = createLoop({ point: outsidePoint }, firstVertex, { dx, dy });\n            const secondCreatedPoint = loop[2];\n            const loopEndSegment = new g.Line(firstVertex.point, secondCreatedPoint);\n\n            const accessDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];\n            firstVertex.direction = accessDirection;\n            resultVertices.push(...loop);\n        } else {\n            // No need to create a route, use the `routeBetweenPoints` to construct a route\n            firstVertex.direction = resolvedSourceDirection;\n            firstVertex.margin = margin;\n            resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex, { targetInSourceBBox: true }), firstVertex.point);\n        }\n    } else {\n        // The first point responsible for the initial direction of the route\n        const next = verticesData[1] || targetPoint;\n        const direction = resolveInitialDirection(sourcePoint, firstVertex, next);\n        firstVertex.direction = direction;\n\n        resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex), firstVertex.point);\n    }\n\n    for (let i = 0; i < verticesData.length - 1; i++) {\n        const from = verticesData[i];\n        const to = verticesData[i + 1];\n\n        const connectionSegment = new g.Line(from.point, to.point);\n        const connectionSegmentAngle = getSegmentAngle(connectionSegment);\n        if (connectionSegmentAngle % 90 === 0) {\n            // Segment is horizontal or vertical\n            const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];\n\n            const simplifiedRoute = simplifyPoints([...resultVertices, from.point]);\n            // const simplifiedRoute2 = simplifyPoints([from.point, ...resultVertices]);\n            // Find out the direction that is used to connect the current route with the next vertex\n            const accessSegment = new g.Line(simplifiedRoute[simplifiedRoute.length - 2], simplifiedRoute[simplifiedRoute.length - 1]);\n            // const accessSegment2 = new g.Line(simplifiedRoute2[simplifiedRoute2.length - 2], simplifiedRoute2[simplifiedRoute2.length - 1]);\n            const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];\n            // const accessDirection2 = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment2))];\n            // console.log(accessDirection);\n            // console.log(accessDirection2);\n            // if (accessDirection !== accessDirection2) {\n            //     console.log('error');\n            // }\n            // console.log('------------------');\n\n            if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {\n                // The directions are not opposite, so we can connect the vertices directly\n                resultVertices.push(from.point, to.point);\n                const [, toDirection] = resolveSides(from, to);\n                to.direction = toDirection;\n            } else {\n                // The directions are overlapping, so we need to create a loop\n                const { loopRoute, continueDirection } = loopSegment(from, to, connectionSegmentAngle, margin);\n                to.direction = continueDirection;\n                // Constructing a loop\n                resultVertices.push(...loopRoute);\n            }\n\n            continue;\n        }\n\n        // Vertices are not aligned vertically nor horizontally\n        // so we need to route between them\n\n        const [fromDirection, toDirection] = resolveDirection(from, to);\n\n        from.direction = fromDirection;\n        to.direction = toDirection;\n\n        resultVertices.push(...routeBetweenPoints(from, to), to.point);\n    }\n\n    const lastVertex = verticesData[verticesData.length - 1];\n\n    if (targetPoint.view && targetPoint.view.model.isElement()) {\n        const [, resolvedTargetDirection] = resolveSides(lastVertex, targetPoint);\n        const outsidePoint = getOutsidePoint(resolvedTargetDirection, targetPoint, margin);\n\n        // the last point of `simplified` array is the last defined vertex\n        // this will ensure that the last segment continues in a straight line\n        const simplified = simplifyPoints([...resultVertices, lastVertex.point]);\n        const simplifiedSegment = new g.Line(simplified[simplified.length - 2], simplified[simplified.length - 1]);\n        const simplifiedSegmentAngle = Math.round(getSegmentAngle(simplifiedSegment));\n        const definedDirection = ANGLE_DIRECTION_MAP[simplifiedSegmentAngle];\n\n        const lastPointOverlap = outsidePoint.equals(lastVertex.point);\n\n        if (!lastPointOverlap || (lastPointOverlap && definedDirection === resolvedTargetDirection)) {\n\n            lastVertex.direction = definedDirection;\n\n            let lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            const [p1, p2] = simplifyPoints([...lastSegmentRoute, targetPoint.point]);\n\n            const lastSegment = new g.Line(p1, p2);\n            const roundedLastSegmentAngle = Math.round(getSegmentAngle(lastSegment));\n            const lastSegmentDirection = ANGLE_DIRECTION_MAP[roundedLastSegmentAngle];\n\n            const targetBBox = moveAndExpandBBox(targetPoint.view.model.getBBox(), resolvedTargetDirection, margin);\n\n            const alignsVertically = lastVertex.point.x === targetPoint.point.x;\n            const alignsHorizontally = lastVertex.point.y === targetPoint.point.y;\n            const isVertexInside = targetBBox.containsPoint(lastVertex.point);\n\n            const isVerticalAndAligns = alignsVertically && (resolvedTargetDirection === Directions.TOP || resolvedTargetDirection === Directions.BOTTOM);\n            const isHorizontalAndAligns = alignsHorizontally && (resolvedTargetDirection === Directions.LEFT || resolvedTargetDirection === Directions.RIGHT);\n\n            \n            if (!lastPointOverlap && isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns)) {\n                // Handle special cases when the last vertex is inside the target element\n                // and in is aligned with the connection point => construct a loop\n                const { dx, dy } = getLoopCoordinates(resolvedTargetDirection, simplifiedSegmentAngle, margin);\n                lastSegmentRoute = createLoop(lastVertex, { point: outsidePoint }, { dx, dy });\n            } else if (isVertexInside && resolvedTargetDirection !== OPPOSITE_DIRECTIONS[definedDirection]) {\n                lastVertex.margin = margin;\n                lastVertex.direction = resolvedTargetDirection;\n                lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            } else if (lastSegmentDirection !== definedDirection && definedDirection === OPPOSITE_DIRECTIONS[lastSegmentDirection]) {\n                lastVertex.margin = margin;\n                lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            }\n\n            resultVertices.push(...lastSegmentRoute);\n        }\n    } else {\n        // since the target is only a point we can apply the same logic as if we connected two verticesData\n        const from = lastVertex;\n        const to = targetPoint;\n\n        const connectionSegment = new g.Line(from.point, to.point);\n        const connectionSegmentAngle = getSegmentAngle(connectionSegment);\n        if (connectionSegmentAngle % 90 === 0) {\n            // Segment is horizontal or vertical\n            const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];\n\n            const simplifiedRoute = simplifyPoints(resultVertices);\n            // Find out the direction that is used to connect the current route with the next vertex\n            const accessSegment = new g.Line(simplifiedRoute[simplifiedRoute.length - 2], from.point);\n            const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];\n\n            if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {\n                // The directions are not opposite, so we can connect the vertices directly by adding the first point\n                // the target point is handled separately\n                resultVertices.push(from.point);\n            } else {\n                // The directions are overlapping, so we need to create a loop\n                const { loopRoute } = loopSegment(from, to, connectionSegmentAngle, margin);\n                // Remove the last point since it is the target that is handled separately\n                loopRoute.pop();\n                // Constructing a loop\n                resultVertices.push(...loopRoute);\n            }\n        } else {\n            // The last vertex and the target are not aligned vertically nor horizontally\n            // so we need to route between them\n            const [fromDirection, toDirection] = resolveDirection(from, to);\n\n            from.direction = fromDirection;\n            to.direction = toDirection;\n\n            resultVertices.push(...routeBetweenPoints(from, to));\n        }\n    }\n\n    return simplifyPoints(resultVertices);\n}\n\nfunction resolveDirection(from, to) {\n    const accessDirection = from.direction;\n    const isDirectionVertical = VERTICAL_DIRECTIONS.includes(accessDirection);\n\n    let sourceDirection = from.direction;\n    let targetDirection = to.direction;\n\n    if (isDirectionVertical) {\n        const isToAbove = from.point.y > to.point.y;\n        const dx = to.point.x - from.point.x;\n\n        if (accessDirection === Directions.BOTTOM) {\n            // If isToAbove === false and we need figure out if to go left or right\n            sourceDirection = isToAbove ? OPPOSITE_DIRECTIONS[accessDirection] : dx >= 0 ? Directions.RIGHT : Directions.LEFT;\n\n            if (dx > 0) {\n                targetDirection = isToAbove ? Directions.LEFT : Directions.TOP;\n            } else if (dx < 0) {\n                targetDirection = isToAbove ? Directions.RIGHT : Directions.TOP;\n            }\n        } else {\n            // If isToAbove === true and we need figure out if to go left or right\n            sourceDirection = isToAbove ? dx >= 0 ? Directions.RIGHT : Directions.LEFT : OPPOSITE_DIRECTIONS[accessDirection];\n\n            if (dx > 0) {\n                targetDirection = isToAbove ? Directions.BOTTOM : Directions.LEFT;\n            } else if (dx < 0) {\n                targetDirection = isToAbove ? Directions.BOTTOM : Directions.RIGHT;\n            }\n        }\n    } else {\n        const isToLeft = from.point.x > to.point.x;\n        const dy = to.point.y - from.point.y;\n\n        if (accessDirection === Directions.RIGHT) {\n            sourceDirection = isToLeft ? OPPOSITE_DIRECTIONS[accessDirection] : dy >= 0 ? Directions.BOTTOM : Directions.TOP;\n\n            if (dy > 0) {\n                targetDirection = isToLeft ? Directions.TOP : Directions.LEFT;\n            } else if (dy < 0) {\n                targetDirection = isToLeft ? Directions.BOTTOM : Directions.LEFT;\n            }\n        } else {\n            sourceDirection = isToLeft ? dy >= 0 ? Directions.BOTTOM : Directions.TOP : OPPOSITE_DIRECTIONS[accessDirection];\n\n            if (dy > 0) {\n                targetDirection = isToLeft ? Directions.RIGHT : Directions.TOP;\n            } else if (dy < 0) {\n                targetDirection = isToLeft ? Directions.RIGHT : Directions.BOTTOM;\n            }\n        }\n    }\n\n    return [sourceDirection, targetDirection];\n}\n\nrightAngleRouter.Directions = Directions;\n\nexport const rightAngle = rightAngleRouter;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3394, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}