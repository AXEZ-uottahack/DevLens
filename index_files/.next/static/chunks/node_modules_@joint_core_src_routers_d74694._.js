(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@joint_core_src_routers_d74694._.js", {

"[project]/node_modules/@joint/core/src/routers/index.mjs [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
;
;
;
;
;
}}),
"[project]/node_modules/@joint/core/src/routers/index.mjs [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/routers/index.mjs [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@joint/core/src/routers/normal.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// Does not make any changes to vertices.
// Returns the arguments that are passed to it, unchanged.
__turbopack_esm__({
    "normal": (()=>normal)
});
const normal = function(vertices, opt, linkView) {
    return vertices;
};
}}),
"[project]/node_modules/@joint/core/src/routers/oneSide.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "oneSide": (()=>oneSide)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/index.mjs [app-client] (ecmascript)");
;
const oneSide = function(vertices, opt, linkView) {
    var side = opt.side || 'bottom';
    var padding = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.normalizeSides(opt.padding || 40);
    // LinkView contains cached source an target bboxes.
    // Note that those are Geometry rectangle objects.
    var sourceBBox = linkView.sourceBBox;
    var targetBBox = linkView.targetBBox;
    var sourcePoint = sourceBBox.center();
    var targetPoint = targetBBox.center();
    var coordinate, dimension, direction;
    switch(side){
        case 'bottom':
            direction = 1;
            coordinate = 'y';
            dimension = 'height';
            break;
        case 'top':
            direction = -1;
            coordinate = 'y';
            dimension = 'height';
            break;
        case 'left':
            direction = -1;
            coordinate = 'x';
            dimension = 'width';
            break;
        case 'right':
            direction = 1;
            coordinate = 'x';
            dimension = 'width';
            break;
        default:
            throw new Error('Router: invalid side');
    }
    // move the points from the center of the element to outside of it.
    sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);
    targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);
    // make link orthogonal (at least the first and last vertex).
    if (direction * (sourcePoint[coordinate] - targetPoint[coordinate]) > 0) {
        targetPoint[coordinate] = sourcePoint[coordinate];
    } else {
        sourcePoint[coordinate] = targetPoint[coordinate];
    }
    return [
        sourcePoint
    ].concat(vertices, targetPoint);
};
}}),
"[project]/node_modules/@joint/core/src/routers/orthogonal.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "orthogonal": (()=>orthogonal)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/index.mjs [app-client] (ecmascript)");
;
;
// bearing -> opposite bearing
var opposites = {
    N: 'S',
    S: 'N',
    E: 'W',
    W: 'E'
};
// bearing -> radians
var radians = {
    N: -Math.PI / 2 * 3,
    S: -Math.PI / 2,
    E: 0,
    W: Math.PI
};
// HELPERS //
// returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained
// in the given box
function freeJoin(p1, p2, bbox) {
    var p = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(p1.x, p2.y);
    if (bbox.containsPoint(p)) p = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(p2.x, p1.y);
    // kept for reference
    // if (bbox.containsPoint(p)) p = null;
    return p;
}
// returns either width or height of a bbox based on the given bearing
function getBBoxSize(bbox, bearing) {
    return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height'];
}
// simple bearing method (calculates only orthogonal cardinals)
function getBearing(from, to) {
    if (from.x === to.x) return from.y > to.y ? 'N' : 'S';
    if (from.y === to.y) return from.x > to.x ? 'W' : 'E';
    return null;
}
// transform point to a rect
function getPointBox(p) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect(p.x, p.y, 0, 0);
}
function getPaddingBox(opt) {
    // if both provided, opt.padding wins over opt.elementPadding
    var sides = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.normalizeSides(opt.padding || opt.elementPadding || 20);
    return {
        x: -sides.left,
        y: -sides.top,
        width: sides.left + sides.right,
        height: sides.top + sides.bottom
    };
}
// return source bbox
function getSourceBBox(linkView, opt) {
    return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));
}
// return target bbox
function getTargetBBox(linkView, opt) {
    return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));
}
// return source anchor
function getSourceAnchor(linkView, opt) {
    if (linkView.sourceAnchor) return linkView.sourceAnchor;
    // fallback: center of bbox
    var sourceBBox = getSourceBBox(linkView, opt);
    return sourceBBox.center();
}
// return target anchor
function getTargetAnchor(linkView, opt) {
    if (linkView.targetAnchor) return linkView.targetAnchor;
    // fallback: center of bbox
    var targetBBox = getTargetBBox(linkView, opt);
    return targetBBox.center(); // default
}
// PARTIAL ROUTERS //
function vertexVertex(from, to, bearing) {
    var p1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(from.x, to.y);
    var p2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(to.x, from.y);
    var d1 = getBearing(from, p1);
    var d2 = getBearing(from, p2);
    var opposite = opposites[bearing];
    var p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;
    return {
        points: [
            p
        ],
        direction: getBearing(p, to)
    };
}
function elementVertex(from, to, fromBBox) {
    var p = freeJoin(from, to, fromBBox);
    return {
        points: [
            p
        ],
        direction: getBearing(p, to)
    };
}
function vertexElement(from, to, toBBox, bearing) {
    var route = {};
    var points = [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(from.x, to.y),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(to.x, from.y)
    ];
    var freePoints = points.filter(function(pt) {
        return !toBBox.containsPoint(pt);
    });
    var freeBearingPoints = freePoints.filter(function(pt) {
        return getBearing(pt, from) !== bearing;
    });
    var p;
    if (freeBearingPoints.length > 0) {
        // Try to pick a point which bears the same direction as the previous segment.
        p = freeBearingPoints.filter(function(pt) {
            return getBearing(from, pt) === bearing;
        }).pop();
        p = p || freeBearingPoints[0];
        route.points = [
            p
        ];
        route.direction = getBearing(p, to);
    } else {
        // Here we found only points which are either contained in the element or they would create
        // a link segment going in opposite direction from the previous one.
        // We take the point inside element and move it outside the element in the direction the
        // route is going. Now we can join this point with the current end (using freeJoin).
        p = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.difference(points, freePoints)[0];
        var p2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(to).move(p, -getBBoxSize(toBBox, bearing) / 2);
        var p1 = freeJoin(p2, from, toBBox);
        route.points = [
            p1,
            p2
        ];
        route.direction = getBearing(p2, to);
    }
    return route;
}
function elementElement(from, to, fromBBox, toBBox) {
    var route = elementVertex(to, from, toBBox);
    var p1 = route.points[0];
    if (fromBBox.containsPoint(p1)) {
        route = elementVertex(from, to, fromBBox);
        var p2 = route.points[0];
        if (toBBox.containsPoint(p2)) {
            var fromBorder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);
            var toBorder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);
            var mid = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(fromBorder, toBorder).midpoint();
            var startRoute = elementVertex(from, mid, fromBBox);
            var endRoute = vertexVertex(mid, to, startRoute.direction);
            route.points = [
                startRoute.points[0],
                endRoute.points[0]
            ];
            route.direction = endRoute.direction;
        }
    }
    return route;
}
// Finds route for situations where one element is inside the other.
// Typically the route is directed outside the outer element first and
// then back towards the inner element.
function insideElement(from, to, fromBBox, toBBox, bearing) {
    var route = {};
    var boundary = fromBBox.union(toBBox).inflate(1);
    // start from the point which is closer to the boundary
    var reversed = boundary.center().distance(to) > boundary.center().distance(from);
    var start = reversed ? to : from;
    var end = reversed ? from : to;
    var p1, p2, p3;
    if (bearing) {
        // Points on circle with radius equals 'W + H` are always outside the rectangle
        // with width W and height H if the center of that circle is the center of that rectangle.
        p1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);
        p1 = boundary.pointNearestToPoint(p1).move(p1, -1);
    } else {
        p1 = boundary.pointNearestToPoint(start).move(start, 1);
    }
    p2 = freeJoin(p1, end, boundary);
    if (p1.round().equals(p2.round())) {
        p2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point.fromPolar(boundary.width + boundary.height, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toRad(p1.theta(start)) + Math.PI / 2, end);
        p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();
        p3 = freeJoin(p1, p2, boundary);
        route.points = reversed ? [
            p2,
            p3,
            p1
        ] : [
            p1,
            p3,
            p2
        ];
    } else {
        route.points = reversed ? [
            p2,
            p1
        ] : [
            p1,
            p2
        ];
    }
    route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);
    return route;
}
function orthogonal(vertices, opt, linkView) {
    var sourceBBox = getSourceBBox(linkView, opt);
    var targetBBox = getTargetBBox(linkView, opt);
    var sourceAnchor = getSourceAnchor(linkView, opt);
    var targetAnchor = getTargetAnchor(linkView, opt);
    // if anchor lies outside of bbox, the bbox expands to include it
    sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));
    targetBBox = targetBBox.union(getPointBox(targetAnchor));
    vertices = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(vertices).map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point);
    vertices.unshift(sourceAnchor);
    vertices.push(targetAnchor);
    var bearing; // bearing of previous route segment
    var orthogonalVertices = []; // the array of found orthogonal vertices to be returned
    for(var i = 0, max = vertices.length - 1; i < max; i++){
        var route = null;
        var from = vertices[i];
        var to = vertices[i + 1];
        var isOrthogonal = !!getBearing(from, to);
        if (i === 0) {
            if (i + 1 === max) {
                // Expand one of the elements by 1px to detect situations when the two
                // elements are positioned next to each other with no gap in between.
                if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {
                    route = insideElement(from, to, sourceBBox, targetBBox);
                } else if (!isOrthogonal) {
                    route = elementElement(from, to, sourceBBox, targetBBox);
                }
            } else {
                if (sourceBBox.containsPoint(to)) {
                    route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));
                } else if (!isOrthogonal) {
                    route = elementVertex(from, to, sourceBBox);
                }
            }
        } else if (i + 1 === max) {
            // prevent overlaps with previous line segment
            var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;
            if (targetBBox.containsPoint(from) || isOrthogonalLoop) {
                route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);
            } else if (!isOrthogonal) {
                route = vertexElement(from, to, targetBBox, bearing);
            }
        } else if (!isOrthogonal) {
            route = vertexVertex(from, to, bearing);
        }
        // applicable to all routes:
        // set bearing for next iteration
        if (route) {
            Array.prototype.push.apply(orthogonalVertices, route.points);
            bearing = route.direction;
        } else {
            // orthogonal route and not looped
            bearing = getBearing(from, to);
        }
        // push `to` point to identified orthogonal vertices array
        if (i + 1 < max) {
            orthogonalVertices.push(to);
        }
    }
    return orthogonalVertices;
}
}}),
"[project]/node_modules/@joint/core/src/routers/manhattan.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "manhattan": (()=>manhattan)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$orthogonal$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/routers/orthogonal.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/index.mjs [app-client] (ecmascript)");
;
;
;
var config = {
    // size of the step to find a route (the grid of the manhattan pathfinder)
    step: 10,
    // the number of route finding loops that cause the router to abort
    // returns fallback route instead
    maximumLoops: 2000,
    // the number of decimal places to round floating point coordinates
    precision: 1,
    // maximum change of direction
    maxAllowedDirectionChange: 90,
    // should the router use perpendicular linkView option?
    // does not connect anchor of element but rather a point close-by that is orthogonal
    // this looks much better
    perpendicular: true,
    // should the source and/or target not be considered as obstacles?
    excludeEnds: [],
    // should certain types of elements not be considered as obstacles?
    excludeTypes: [],
    // possible starting directions from an element
    startDirections: [
        'top',
        'right',
        'bottom',
        'left'
    ],
    // possible ending directions to an element
    endDirections: [
        'top',
        'right',
        'bottom',
        'left'
    ],
    // specify the directions used above and what they mean
    directionMap: {
        top: {
            x: 0,
            y: -1
        },
        right: {
            x: 1,
            y: 0
        },
        bottom: {
            x: 0,
            y: 1
        },
        left: {
            x: -1,
            y: 0
        }
    },
    // cost of an orthogonal step
    cost: function() {
        return this.step;
    },
    // an array of directions to find next points on the route
    // different from start/end directions
    directions: function() {
        var step = this.step;
        var cost = this.cost();
        return [
            {
                offsetX: step,
                offsetY: 0,
                cost: cost
            },
            {
                offsetX: -step,
                offsetY: 0,
                cost: cost
            },
            {
                offsetX: 0,
                offsetY: step,
                cost: cost
            },
            {
                offsetX: 0,
                offsetY: -step,
                cost: cost
            }
        ];
    },
    // a penalty received for direction change
    penalties: function() {
        return {
            0: 0,
            45: this.step / 2,
            90: this.step / 2
        };
    },
    // padding applied on the element bounding boxes
    paddingBox: function() {
        var step = this.step;
        return {
            x: -step,
            y: -step,
            width: 2 * step,
            height: 2 * step
        };
    },
    // A function that determines whether a given point is an obstacle or not.
    // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.
    // (point: dia.Point) => boolean;
    isPointObstacle: null,
    // a router to use when the manhattan router fails
    // (one of the partial routes returns null)
    fallbackRouter: function(vertices, opt, linkView) {
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isFunction(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$orthogonal$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["orthogonal"])) {
            throw new Error('Manhattan requires the orthogonal router as default fallback.');
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$orthogonal$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["orthogonal"])(vertices, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign({}, config, opt), linkView);
    },
    /* Deprecated */ // a simple route used in situations when main routing method fails
    // (exceed max number of loop iterations, inaccessible)
    fallbackRoute: function(from, to, opt) {
        return null; // null result will trigger the fallbackRouter
    // left for reference:
    /*// Find an orthogonal route ignoring obstacles.

        var point = ((opt.previousDirAngle || 0) % 180 === 0)
                ? new g.Point(from.x, to.y)
                : new g.Point(to.x, from.y);

        return [point];*/ },
    // if a function is provided, it's used to route the link while dragging an end
    // i.e. function(from, to, opt) { return []; }
    draggingRoute: null
};
// HELPER CLASSES //
// Map of obstacles
// Helper structure to identify whether a point lies inside an obstacle.
function ObstacleMap(opt) {
    this.map = {};
    this.options = opt;
    // tells how to divide the paper when creating the elements map
    this.mapGridSize = 100;
}
ObstacleMap.prototype.build = function(graph, link) {
    var opt = this.options;
    // source or target element could be excluded from set of obstacles
    var excludedEnds = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(opt.excludeEnds).reduce(function(res, item) {
        var end = link.get(item);
        if (end) {
            var cell = graph.getCell(end.id);
            if (cell) {
                res.push(cell);
            }
        }
        return res;
    }, []);
    // Exclude any embedded elements from the source and the target element.
    var excludedAncestors = [];
    var source = graph.getCell(link.get('source').id);
    if (source) {
        excludedAncestors = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.union(excludedAncestors, source.getAncestors().map(function(cell) {
            return cell.id;
        }));
    }
    var target = graph.getCell(link.get('target').id);
    if (target) {
        excludedAncestors = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.union(excludedAncestors, target.getAncestors().map(function(cell) {
            return cell.id;
        }));
    }
    // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained
    // in any obstacle?) (a simplified grid search).
    // The paper is divided into smaller cells, where each holds information about which
    // elements belong to it. When we query whether a point lies inside an obstacle we
    // don't need to go through all obstacles, we check only those in a particular cell.
    var mapGridSize = this.mapGridSize;
    graph.getElements().reduce(function(map, element) {
        var isExcludedType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(opt.excludeTypes).includes(element.get('type'));
        var isExcludedEnd = excludedEnds.find(function(excluded) {
            return excluded.id === element.id;
        });
        var isExcludedAncestor = excludedAncestors.includes(element.id);
        var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;
        if (!isExcluded) {
            var bbox = element.getBBox().moveAndExpand(opt.paddingBox);
            var origin = bbox.origin().snapToGrid(mapGridSize);
            var corner = bbox.corner().snapToGrid(mapGridSize);
            for(var x = origin.x; x <= corner.x; x += mapGridSize){
                for(var y = origin.y; y <= corner.y; y += mapGridSize){
                    var gridKey = x + '@' + y;
                    map[gridKey] = map[gridKey] || [];
                    map[gridKey].push(bbox);
                }
            }
        }
        return map;
    }, this.map);
    return this;
};
ObstacleMap.prototype.isPointAccessible = function(point) {
    var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(this.map[mapKey]).every(function(obstacle) {
        return !obstacle.containsPoint(point);
    });
};
// Sorted Set
// Set of items sorted by given value.
function SortedSet() {
    this.items = [];
    this.hash = {};
    this.values = {};
    this.OPEN = 1;
    this.CLOSE = 2;
}
SortedSet.prototype.add = function(item, value) {
    if (this.hash[item]) {
        // item removal
        this.items.splice(this.items.indexOf(item), 1);
    } else {
        this.hash[item] = this.OPEN;
    }
    this.values[item] = value;
    var index = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.sortedIndex(this.items, item, (function(i) {
        return this.values[i];
    }).bind(this));
    this.items.splice(index, 0, item);
};
SortedSet.prototype.remove = function(item) {
    this.hash[item] = this.CLOSE;
};
SortedSet.prototype.isOpen = function(item) {
    return this.hash[item] === this.OPEN;
};
SortedSet.prototype.isClose = function(item) {
    return this.hash[item] === this.CLOSE;
};
SortedSet.prototype.isEmpty = function() {
    return this.items.length === 0;
};
SortedSet.prototype.pop = function() {
    var item = this.items.shift();
    this.remove(item);
    return item;
};
// HELPERS //
// return source bbox
function getSourceBBox(linkView, opt) {
    // expand by padding box
    if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);
    return linkView.sourceBBox.clone();
}
// return target bbox
function getTargetBBox(linkView, opt) {
    // expand by padding box
    if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);
    return linkView.targetBBox.clone();
}
// return source anchor
function getSourceAnchor(linkView, opt) {
    if (linkView.sourceAnchor) return linkView.sourceAnchor;
    // fallback: center of bbox
    var sourceBBox = getSourceBBox(linkView, opt);
    return sourceBBox.center();
}
// return target anchor
function getTargetAnchor(linkView, opt) {
    if (linkView.targetAnchor) return linkView.targetAnchor;
    // fallback: center of bbox
    var targetBBox = getTargetBBox(linkView, opt);
    return targetBBox.center(); // default
}
// returns a direction index from start point to end point
// corrects for grid deformation between start and end
function getDirectionAngle(start, end, numDirections, grid, opt) {
    var quadrant = 360 / numDirections;
    var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));
    var normalizedAngle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.normalizeAngle(angleTheta + quadrant / 2);
    return quadrant * Math.floor(normalizedAngle / quadrant);
}
// helper function for getDirectionAngle()
// corrects for grid deformation
// (if a point is one grid steps away from another in both dimensions,
// it is considered to be 45 degrees away, even if the real angle is different)
// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`
function fixAngleEnd(start, end, grid, opt) {
    var step = opt.step;
    var diffX = end.x - start.x;
    var diffY = end.y - start.y;
    var gridStepsX = diffX / grid.x;
    var gridStepsY = diffY / grid.y;
    var distanceX = gridStepsX * step;
    var distanceY = gridStepsY * step;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(start.x + distanceX, start.y + distanceY);
}
// return the change in direction between two direction angles
function getDirectionChange(angle1, angle2) {
    var directionChange = Math.abs(angle1 - angle2);
    return directionChange > 180 ? 360 - directionChange : directionChange;
}
// fix direction offsets according to current grid
function getGridOffsets(directions, grid, opt) {
    var step = opt.step;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(opt.directions).forEach(function(direction) {
        direction.gridOffsetX = direction.offsetX / step * grid.x;
        direction.gridOffsetY = direction.offsetY / step * grid.y;
    });
}
// get grid size in x and y dimensions, adapted to source and target positions
function getGrid(step, source, target) {
    return {
        source: source.clone(),
        x: getGridDimension(target.x - source.x, step),
        y: getGridDimension(target.y - source.y, step)
    };
}
// helper function for getGrid()
function getGridDimension(diff, step) {
    // return step if diff = 0
    if (!diff) return step;
    var absDiff = Math.abs(diff);
    var numSteps = Math.round(absDiff / step);
    // return absDiff if less than one step apart
    if (!numSteps) return absDiff;
    // otherwise, return corrected step
    var roundedDiff = numSteps * step;
    var remainder = absDiff - roundedDiff;
    var stepCorrection = remainder / numSteps;
    return step + stepCorrection;
}
// return a clone of point snapped to grid
function snapToGrid(point, grid) {
    var source = grid.source;
    var snappedX = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.snapToGrid(point.x - source.x, grid.x) + source.x;
    var snappedY = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.snapToGrid(point.y - source.y, grid.y) + source.y;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(snappedX, snappedY);
}
// round the point to opt.precision
function round(point, precision) {
    return point.round(precision);
}
// snap to grid and then round the point
function align(point, grid, precision) {
    return round(snapToGrid(point.clone(), grid), precision);
}
// return a string representing the point
// string is rounded in both dimensions
function getKey(point) {
    return point.clone().toString();
}
// return a normalized vector from given point
// used to determine the direction of a difference of two points
function normalizePoint(point) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);
}
// PATHFINDING //
// reconstructs a route by concatenating points with their parents
function reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {
    var route = [];
    var prevDiff = normalizePoint(to.difference(tailPoint));
    // tailPoint is assumed to be aligned already
    var currentKey = getKey(tailPoint);
    var parent = parents[currentKey];
    var point;
    while(parent){
        // point is assumed to be aligned already
        point = points[currentKey];
        var diff = normalizePoint(point.difference(parent));
        if (!diff.equals(prevDiff)) {
            route.unshift(point);
            prevDiff = diff;
        }
        // parent is assumed to be aligned already
        currentKey = getKey(parent);
        parent = parents[currentKey];
    }
    // leadPoint is assumed to be aligned already
    var leadPoint = points[currentKey];
    var fromDiff = normalizePoint(leadPoint.difference(from));
    if (!fromDiff.equals(prevDiff)) {
        route.unshift(leadPoint);
    }
    return route;
}
// heuristic method to determine the distance between two points
function estimateCost(from, endPoints) {
    var min = Infinity;
    for(var i = 0, len = endPoints.length; i < len; i++){
        var cost = from.manhattanDistance(endPoints[i]);
        if (cost < min) min = cost;
    }
    return min;
}
// find points around the bbox taking given directions into account
// lines are drawn from anchor in given directions, intersections recorded
// if anchor is outside bbox, only those directions that intersect get a rect point
// the anchor itself is returned as rect point (representing some directions)
// (since those directions are unobstructed by the bbox)
function getRectPoints(anchor, bbox, directionList, grid, opt) {
    var precision = opt.precision;
    var directionMap = opt.directionMap;
    var anchorCenterVector = anchor.difference(bbox.center());
    var keys = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isObject(directionMap) ? Object.keys(directionMap) : [];
    var dirList = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(directionList);
    var rectPoints = keys.reduce(function(res, key) {
        if (dirList.includes(key)) {
            var direction = directionMap[key];
            // create a line that is guaranteed to intersect the bbox if bbox is in the direction
            // even if anchor lies outside of bbox
            var endpoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height));
            var intersectionLine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(anchor, endpoint);
            // get the farther intersection, in case there are two
            // (that happens if anchor lies next to bbox)
            var intersections = intersectionLine.intersect(bbox) || [];
            var numIntersections = intersections.length;
            var farthestIntersectionDistance;
            var farthestIntersection = null;
            for(var i = 0; i < numIntersections; i++){
                var currentIntersection = intersections[i];
                var distance = anchor.squaredDistance(currentIntersection);
                if (farthestIntersectionDistance === undefined || distance > farthestIntersectionDistance) {
                    farthestIntersectionDistance = distance;
                    farthestIntersection = currentIntersection;
                }
            }
            // if an intersection was found in this direction, it is our rectPoint
            if (farthestIntersection) {
                var point = align(farthestIntersection, grid, precision);
                // if the rectPoint lies inside the bbox, offset it by one more step
                if (bbox.containsPoint(point)) {
                    point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);
                }
                // then add the point to the result array
                // aligned
                res.push(point);
            }
        }
        return res;
    }, []);
    // if anchor lies outside of bbox, add it to the array of points
    if (!bbox.containsPoint(anchor)) {
        // aligned
        rectPoints.push(align(anchor, grid, precision));
    }
    return rectPoints;
}
// finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm
// rectangles get rect points assigned by getRectPoints()
function findRoute(from, to, isPointObstacle, opt) {
    var precision = opt.precision;
    // Get grid for this route.
    var sourceAnchor, targetAnchor;
    if (from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect) {
        sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);
    } else {
        sourceAnchor = round(from.clone(), precision);
    }
    if (to instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect) {
        targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);
    } else {
        targetAnchor = round(to.clone(), precision);
    }
    var grid = getGrid(opt.step, sourceAnchor, targetAnchor);
    // Get pathfinding points.
    var start, end; // aligned with grid by definition
    var startPoints, endPoints; // assumed to be aligned with grid already
    // set of points we start pathfinding from
    if (from instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect) {
        start = sourceAnchor;
        startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);
    } else {
        start = sourceAnchor;
        startPoints = [
            start
        ];
    }
    // set of points we want the pathfinding to finish at
    if (to instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect) {
        end = targetAnchor;
        endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);
    } else {
        end = targetAnchor;
        endPoints = [
            end
        ];
    }
    // take into account only accessible rect points (those not under obstacles)
    startPoints = startPoints.filter((p)=>!isPointObstacle(p));
    endPoints = endPoints.filter((p)=>!isPointObstacle(p));
    // Check that there is an accessible route point on both sides.
    // Otherwise, use fallbackRoute().
    if (startPoints.length > 0 && endPoints.length > 0) {
        // The set of tentative points to be evaluated, initially containing the start points.
        // Rounded to nearest integer for simplicity.
        var openSet = new SortedSet();
        // Keeps reference to actual points for given elements of the open set.
        var points = {};
        // Keeps reference to a point that is immediate predecessor of given element.
        var parents = {};
        // Cost from start to a point along best known path.
        var costs = {};
        for(var i = 0, n = startPoints.length; i < n; i++){
            // startPoint is assumed to be aligned already
            var startPoint = startPoints[i];
            var key = getKey(startPoint);
            openSet.add(key, estimateCost(startPoint, endPoints));
            points[key] = startPoint;
            costs[key] = 0;
        }
        var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route
        var isPathBeginning = previousRouteDirectionAngle === undefined;
        // directions
        var direction, directionChange;
        var directions = opt.directions;
        getGridOffsets(directions, grid, opt);
        var numDirections = directions.length;
        var endPointsKeys = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(endPoints).reduce(function(res, endPoint) {
            // endPoint is assumed to be aligned already
            var key = getKey(endPoint);
            res.push(key);
            return res;
        }, []);
        // main route finding loop
        var loopsRemaining = opt.maximumLoops;
        while(!openSet.isEmpty() && loopsRemaining > 0){
            // remove current from the open list
            var currentKey = openSet.pop();
            var currentPoint = points[currentKey];
            var currentParent = parents[currentKey];
            var currentCost = costs[currentKey];
            var isRouteBeginning = currentParent === undefined; // undefined for route starts
            var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction
            var previousDirectionAngle;
            if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); // a vertex on the route
            else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle; // beginning of route on the path
            else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); // beginning of path, start rect point
            else previousDirectionAngle = null; // beginning of path, source anchor or `from` point
            // check if we reached any endpoint
            var samePoints = startPoints.length === endPoints.length;
            if (samePoints) {
                for(var j = 0; j < startPoints.length; j++){
                    if (!startPoints[j].equals(endPoints[j])) {
                        samePoints = false;
                        break;
                    }
                }
            }
            var skipEndCheck = isRouteBeginning && samePoints;
            if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {
                opt.previousDirectionAngle = previousDirectionAngle;
                return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);
            }
            // go over all possible directions and find neighbors
            for(i = 0; i < numDirections; i++){
                direction = directions[i];
                var directionAngle = direction.angle;
                directionChange = getDirectionChange(previousDirectionAngle, directionAngle);
                // if the direction changed rapidly, don't use this point
                // any direction is allowed for starting points
                if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;
                var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);
                var neighborKey = getKey(neighborPoint);
                // Closed points from the openSet were already evaluated.
                if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) continue;
                // We can only enter end points at an acceptable angle.
                if (endPointsKeys.indexOf(neighborKey) >= 0) {
                    var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction
                    if (!isNeighborEnd) {
                        var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);
                        var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);
                        if (endDirectionChange > opt.maxAllowedDirectionChange) continue;
                    }
                }
                // The current direction is ok.
                var neighborCost = direction.cost;
                var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point
                var costFromStart = currentCost + neighborCost + neighborPenalty;
                if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {
                    // neighbor point has not been processed yet
                    // or the cost of the path from start is lower than previously calculated
                    points[neighborKey] = neighborPoint;
                    parents[neighborKey] = currentPoint;
                    costs[neighborKey] = costFromStart;
                    openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));
                }
            }
            loopsRemaining--;
        }
    }
    // no route found (`to` point either wasn't accessible or finding route took
    // way too much calculation)
    return opt.fallbackRoute.call(this, start, end, opt);
}
// resolve some of the options
function resolveOptions(opt) {
    opt.directions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.result(opt, 'directions');
    opt.penalties = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.result(opt, 'penalties');
    opt.paddingBox = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.result(opt, 'paddingBox');
    opt.padding = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.result(opt, 'padding');
    if (opt.padding) {
        // if both provided, opt.padding wins over opt.paddingBox
        var sides = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.normalizeSides(opt.padding);
        opt.paddingBox = {
            x: -sides.left,
            y: -sides.top,
            width: sides.left + sides.right,
            height: sides.top + sides.bottom
        };
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(opt.directions).forEach(function(direction) {
        var point1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(0, 0);
        var point2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(direction.offsetX, direction.offsetY);
        direction.angle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.normalizeAngle(point1.theta(point2));
    });
}
// initialization of the route finding
function router(vertices, opt, linkView) {
    resolveOptions(opt);
    // enable/disable linkView perpendicular option
    linkView.options.perpendicular = !!opt.perpendicular;
    var sourceBBox = getSourceBBox(linkView, opt);
    var targetBBox = getTargetBBox(linkView, opt);
    var sourceAnchor = getSourceAnchor(linkView, opt);
    //var targetAnchor = getTargetAnchor(linkView, opt);
    // pathfinding
    let isPointObstacle;
    if (typeof opt.isPointObstacle === 'function') {
        isPointObstacle = opt.isPointObstacle;
    } else {
        const map = new ObstacleMap(opt);
        map.build(linkView.paper.model, linkView.model);
        isPointObstacle = (point)=>!map.isPointAccessible(point);
    }
    var oldVertices = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toArray(vertices).map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point);
    var newVertices = [];
    var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping
    // find a route by concatenating all partial routes (routes need to pass through vertices)
    // source -> vertex[1] -> ... -> vertex[n] -> target
    var to, from;
    for(var i = 0, len = oldVertices.length; i <= len; i++){
        var partialRoute = null;
        from = to || sourceBBox;
        to = oldVertices[i];
        if (!to) {
            // this is the last iteration
            // we ran through all vertices in oldVertices
            // 'to' is not a vertex.
            to = targetBBox;
            // If the target is a point (i.e. it's not an element), we
            // should use dragging route instead of main routing method if it has been provided.
            var isEndingAtPoint = !linkView.model.get('source').id || !linkView.model.get('target').id;
            if (isEndingAtPoint && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isFunction(opt.draggingRoute)) {
                // Make sure we are passing points only (not rects).
                var dragFrom = from === sourceBBox ? sourceAnchor : from;
                var dragTo = to.origin();
                partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);
            }
        }
        // if partial route has not been calculated yet use the main routing method to find one
        partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);
        if (partialRoute === null) {
            return opt.fallbackRouter(vertices, opt, linkView);
        }
        var leadPoint = partialRoute[0];
        // remove the first point if the previous partial route had the same point as last
        if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift();
        // save tailPoint for next iteration
        tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;
        Array.prototype.push.apply(newVertices, partialRoute);
    }
    return newVertices;
}
const manhattan = function(vertices, opt, linkView) {
    return router(vertices, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign({}, config, opt), linkView);
};
}}),
"[project]/node_modules/@joint/core/src/routers/metro.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "metro": (()=>metro)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/util/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$manhattan$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/routers/manhattan.mjs [app-client] (ecmascript)");
;
;
;
var config = {
    maxAllowedDirectionChange: 45,
    // cost of a diagonal step
    diagonalCost: function() {
        var step = this.step;
        return Math.ceil(Math.sqrt(step * step << 1));
    },
    // an array of directions to find next points on the route
    // different from start/end directions
    directions: function() {
        var step = this.step;
        var cost = this.cost();
        var diagonalCost = this.diagonalCost();
        return [
            {
                offsetX: step,
                offsetY: 0,
                cost: cost
            },
            {
                offsetX: step,
                offsetY: step,
                cost: diagonalCost
            },
            {
                offsetX: 0,
                offsetY: step,
                cost: cost
            },
            {
                offsetX: -step,
                offsetY: step,
                cost: diagonalCost
            },
            {
                offsetX: -step,
                offsetY: 0,
                cost: cost
            },
            {
                offsetX: -step,
                offsetY: -step,
                cost: diagonalCost
            },
            {
                offsetX: 0,
                offsetY: -step,
                cost: cost
            },
            {
                offsetX: step,
                offsetY: -step,
                cost: diagonalCost
            }
        ];
    },
    // a simple route used in situations when main routing method fails
    // (exceed max number of loop iterations, inaccessible)
    fallbackRoute: function(from, to, opt) {
        // Find a route which breaks by 45 degrees ignoring all obstacles.
        var theta = from.theta(to);
        var route = [];
        var a = {
            x: to.x,
            y: from.y
        };
        var b = {
            x: from.x,
            y: to.y
        };
        if (theta % 180 > 90) {
            var t = a;
            a = b;
            b = t;
        }
        var p1 = theta % 90 < 45 ? a : b;
        var l1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(from, p1);
        var alpha = 90 * Math.ceil(theta / 90);
        var p2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point.fromPolar(l1.squaredLength(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toRad(alpha + 135), p1);
        var l2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(to, p2);
        var intersectionPoint = l1.intersection(l2);
        var point = intersectionPoint ? intersectionPoint : to;
        var directionFrom = intersectionPoint ? point : from;
        var quadrant = 360 / opt.directions.length;
        var angleTheta = directionFrom.theta(to);
        var normalizedAngle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.normalizeAngle(angleTheta + quadrant / 2);
        var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);
        opt.previousDirectionAngle = directionAngle;
        if (point) route.push(point.round());
        route.push(to);
        return route;
    }
};
const metro = function(vertices, opt, linkView) {
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isFunction(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$manhattan$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["manhattan"])) {
        throw new Error('Metro requires the manhattan router.');
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$manhattan$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["manhattan"])(vertices, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$util$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.assign({}, config, opt), linkView);
};
}}),
"[project]/node_modules/@joint/core/src/routers/rightAngle.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "rightAngle": (()=>rightAngle)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/g/index.mjs [app-client] (ecmascript)");
;
const Directions = {
    AUTO: 'auto',
    LEFT: 'left',
    RIGHT: 'right',
    TOP: 'top',
    BOTTOM: 'bottom',
    ANCHOR_SIDE: 'anchor-side',
    MAGNET_SIDE: 'magnet-side'
};
const DEFINED_DIRECTIONS = [
    Directions.LEFT,
    Directions.RIGHT,
    Directions.TOP,
    Directions.BOTTOM
];
const OPPOSITE_DIRECTIONS = {
    [Directions.LEFT]: Directions.RIGHT,
    [Directions.RIGHT]: Directions.LEFT,
    [Directions.TOP]: Directions.BOTTOM,
    [Directions.BOTTOM]: Directions.TOP
};
const VERTICAL_DIRECTIONS = [
    Directions.TOP,
    Directions.BOTTOM
];
const ANGLE_DIRECTION_MAP = {
    0: Directions.RIGHT,
    180: Directions.LEFT,
    270: Directions.TOP,
    90: Directions.BOTTOM
};
function getSegmentAngle(line) {
    // TODO: the angle() method is general and therefore unnecessarily heavy for orthogonal links
    return line.angle();
}
function simplifyPoints(points) {
    // TODO: use own more efficient implementation (filter points that do not change direction).
    // To simplify segments that are almost aligned (start and end points differ by e.g. 0.5px), use a threshold of 1.
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Polyline(points).simplify({
        threshold: 1
    }).points;
}
function resolveSides(source, target) {
    const { point: sourcePoint, x0: sx0, y0: sy0, view: sourceView, bbox: sourceBBox, direction: sourceDirection } = source;
    const { point: targetPoint, x0: tx0, y0: ty0, view: targetView, bbox: targetBBox, direction: targetDirection } = target;
    let sourceSide;
    if (!sourceView) {
        const sourceLinkAnchorBBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect(sx0, sy0, 0, 0);
        sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);
    } else if (sourceView.model.isLink()) {
        sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);
    } else if (sourceDirection === Directions.ANCHOR_SIDE) {
        sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);
    } else if (sourceDirection === Directions.MAGNET_SIDE) {
        sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);
    } else {
        sourceSide = sourceDirection;
    }
    let targetSide;
    if (!targetView) {
        const targetLinkAnchorBBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect(tx0, ty0, 0, 0);
        targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);
    } else if (targetView.model.isLink()) {
        targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);
    } else if (targetDirection === Directions.ANCHOR_SIDE) {
        targetSide = targetBBox.sideNearestToPoint(targetPoint);
    } else if (targetDirection === Directions.MAGNET_SIDE) {
        targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);
    } else {
        targetSide = targetDirection;
    }
    return [
        sourceSide,
        targetSide
    ];
}
function resolveForTopSourceSide(source, target, nextInLine) {
    const { x0: sx0, y0: sy0, width, height, point: anchor, margin } = source;
    const sx1 = sx0 + width;
    const sy1 = sy0 + height;
    const smx0 = sx0 - margin;
    const smx1 = sx1 + margin;
    const smy0 = sy0 - margin;
    const { x: ax } = anchor;
    const { x0: tx, y0: ty } = target;
    if (tx === ax && ty < sy0) return Directions.BOTTOM;
    if (tx < ax && ty < smy0) {
        if (nextInLine.point.x === ax) return Directions.BOTTOM;
        return Directions.RIGHT;
    }
    if (tx > ax && ty < smy0) {
        if (nextInLine.point.x === ax) return Directions.BOTTOM;
        return Directions.LEFT;
    }
    if (tx < smx0 && ty > smy0) return Directions.TOP;
    if (tx > smx1 && ty > smy0) return Directions.TOP;
    if (tx >= smx0 && tx <= ax && ty > sy1) {
        if (nextInLine.point.x < tx) {
            return Directions.RIGHT;
        }
        return Directions.LEFT;
    }
    if (tx <= smx1 && tx >= ax && ty > sy1) {
        if (nextInLine.point.x < tx) {
            return Directions.RIGHT;
        }
        return Directions.LEFT;
    }
    return Directions.BOTTOM;
}
function resolveForBottomSourceSide(source, target, nextInLine) {
    const { x0: sx0, y0: sy0, width, height, point: anchor, margin } = source;
    const sx1 = sx0 + width;
    const sy1 = sy0 + height;
    const smx0 = sx0 - margin;
    const smx1 = sx1 + margin;
    const smy1 = sy1 + margin;
    const { x: ax } = anchor;
    const { x0: tx, y0: ty } = target;
    if (tx === ax && ty > sy1) return Directions.TOP;
    if (tx < ax && ty > smy1) {
        if (nextInLine.point.x === ax) return Directions.TOP;
        return Directions.RIGHT;
    }
    if (tx > ax && ty > smy1) {
        if (nextInLine.point.x === ax) return Directions.TOP;
        return Directions.LEFT;
    }
    if (tx < smx0 && ty < smy1) return Directions.BOTTOM;
    if (tx > smx1 && ty < smy1) return Directions.BOTTOM;
    if (tx >= smx0 && tx <= ax && ty < sy0) {
        if (nextInLine.point.x < tx) {
            return Directions.RIGHT;
        }
        return Directions.LEFT;
    }
    if (tx <= smx1 && tx >= ax && ty < sy0) {
        if (nextInLine.point.x < tx) {
            return Directions.RIGHT;
        }
        return Directions.LEFT;
    }
    return Directions.TOP;
}
function resolveForLeftSourceSide(source, target, nextInLine) {
    const { y0: sy0, x0: sx0, width, height, point: anchor, margin } = source;
    const sx1 = sx0 + width;
    const sy1 = sy0 + height;
    const smx0 = sx0 - margin;
    const smy0 = sy0 - margin;
    const smy1 = sy1 + margin;
    const { x: ax, y: ay } = anchor;
    const { x0: tx, y0: ty } = target;
    if (tx < ax && ty === ay) return Directions.RIGHT;
    if (tx <= smx0 && ty < ay) return Directions.BOTTOM;
    if (tx <= smx0 && ty > ay) return Directions.TOP;
    if (tx >= smx0 && ty < smy0) return Directions.LEFT;
    if (tx >= smx0 && ty > smy1) return Directions.LEFT;
    if (tx > sx1 && ty >= smy0 && ty <= ay) {
        if (nextInLine.point.y < ty) {
            return Directions.BOTTOM;
        }
        return Directions.TOP;
    }
    if (tx > sx1 && ty <= smy1 && ty >= ay) {
        if (nextInLine.point.y < ty) {
            return Directions.BOTTOM;
        }
        return Directions.TOP;
    }
    return Directions.RIGHT;
}
function resolveForRightSourceSide(source, target, nextInLine) {
    const { y0: sy0, x0: sx0, width, height, point: anchor, margin } = source;
    const sx1 = sx0 + width;
    const sy1 = sy0 + height;
    const smx1 = sx1 + margin;
    const smy0 = sy0 - margin;
    const smy1 = sy1 + margin;
    const { x: ax, y: ay } = anchor;
    const { x0: tx, y0: ty } = target;
    if (tx > ax && ty === ay) return Directions.LEFT;
    if (tx >= smx1 && ty < ay) return Directions.BOTTOM;
    if (tx >= smx1 && ty > ay) return Directions.TOP;
    if (tx <= smx1 && ty < smy0) return Directions.RIGHT;
    if (tx <= smx1 && ty > smy1) return Directions.RIGHT;
    if (tx < sx0 && ty >= smy0 && ty <= ay) {
        if (nextInLine.point.y < ty) {
            return Directions.BOTTOM;
        }
        return Directions.TOP;
    }
    if (tx < sx0 && ty <= smy1 && ty >= ay) {
        if (nextInLine.point.y < ty) {
            return Directions.BOTTOM;
        }
        return Directions.TOP;
    }
    return Directions.LEFT;
}
function resolveInitialDirection(source, target, nextInLine) {
    const [sourceSide] = resolveSides(source, target);
    switch(sourceSide){
        case Directions.TOP:
            return resolveForTopSourceSide(source, target, nextInLine);
        case Directions.RIGHT:
            return resolveForRightSourceSide(source, target, nextInLine);
        case Directions.BOTTOM:
            return resolveForBottomSourceSide(source, target, nextInLine);
        case Directions.LEFT:
            return resolveForLeftSourceSide(source, target, nextInLine);
    }
}
function getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {
    const tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));
    const roundedAngle = Math.round(getSegmentAngle(tangent) / 90) * 90;
    if (roundedAngle % 180 === 0 && linkOrigin.y === connectionPoint.y) {
        return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;
    } else if (linkOrigin.x === connectionPoint.x) {
        return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;
    }
    switch(roundedAngle){
        case 0:
        case 180:
        case 360:
            return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;
        case 90:
        case 270:
            return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;
    }
}
function pointDataFromAnchor(view, point, bbox, direction, isPort, fallBackAnchor, margin) {
    if (direction === Directions.AUTO) {
        direction = isPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;
    }
    const isElement = view && view.model.isElement();
    const { x: x0, y: y0, width = 0, height = 0 } = isElement ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect.fromRectUnion(bbox, view.model.getBBox()) : fallBackAnchor;
    return {
        point,
        x0,
        y0,
        view,
        bbox,
        width,
        height,
        direction,
        margin: isElement ? margin : 0
    };
}
function pointDataFromVertex({ x, y }) {
    const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Point(x, y);
    return {
        point,
        x0: point.x,
        y0: point.y,
        view: null,
        bbox: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect(x, y, 0, 0),
        width: 0,
        height: 0,
        direction: null,
        margin: 0
    };
}
function getOutsidePoint(side, pointData, margin) {
    const outsidePoint = pointData.point.clone();
    const { x0, y0, width, height } = pointData;
    switch(side){
        case 'left':
            outsidePoint.x = x0 - margin;
            break;
        case 'right':
            outsidePoint.x = x0 + width + margin;
            break;
        case 'top':
            outsidePoint.y = y0 - margin;
            break;
        case 'bottom':
            outsidePoint.y = y0 + height + margin;
            break;
    }
    return outsidePoint;
}
function createLoop(from, to, { dx = 0, dy = 0 }) {
    const p1 = {
        x: from.point.x + dx,
        y: from.point.y + dy
    };
    const p2 = {
        x: to.point.x + dx,
        y: to.point.y + dy
    };
    return [
        from.point,
        p1,
        p2,
        to.point
    ];
}
function loopSegment(from, to, connectionSegmentAngle, margin) {
    // Find out the loop coordinates.
    const angle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.normalizeAngle(connectionSegmentAngle - 90);
    let dx = 0;
    let dy = 0;
    if (angle === 90) {
        dy = -margin;
    } else if (angle === 180) {
        dx = -margin;
    } else if (angle === 270) {
        dy = margin;
    } else if (angle === 0) {
        dx = margin;
    }
    const loopRoute = createLoop(from, to, {
        dx,
        dy
    });
    const secondCreatedPoint = loopRoute[2];
    const loopEndSegment = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(to.point, secondCreatedPoint);
    // The direction in which the loop should continue.
    const continueDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];
    return {
        loopRoute,
        continueDirection
    };
}
// Calculates the distances along the horizontal axis for the left and right route.
function getHorizontalDistance(source, target) {
    const { x0: sx0, x1: sx1, outsidePoint: sourcePoint } = source;
    const { x0: tx0, x1: tx1, outsidePoint: targetPoint } = target;
    // Furthest left boundary
    let leftBoundary = Math.min(sx0, tx0);
    // Furthest right boundary
    let rightBoundary = Math.max(sx1, tx1);
    // If the source and target elements are on the same side, we need to figure out what shape defines the boundary.
    if (source.direction === target.direction) {
        const aboveShape = source.y0 < target.y0 ? source : target;
        const belowShape = aboveShape === source ? target : source;
        // The source and target anchors are on the top => then the `aboveShape` defines the boundary.
        // The source and target anchors are on the bottom => then the `belowShape` defines the boundary.
        const boundaryDefiningShape = source.direction === Directions.TOP ? aboveShape : belowShape;
        leftBoundary = boundaryDefiningShape.x0;
        rightBoundary = boundaryDefiningShape.x1;
    }
    const { x: sox } = sourcePoint;
    const { x: tox } = targetPoint;
    // Calculate the distances for the left route
    const leftDistance1 = Math.abs(sox - leftBoundary);
    const leftDistance2 = Math.abs(tox - leftBoundary);
    const leftD = leftDistance1 + leftDistance2;
    // Calculate the distances for the right route
    const rightDistance1 = Math.abs(sox - rightBoundary);
    const rightDistance2 = Math.abs(tox - rightBoundary);
    const rightD = rightDistance1 + rightDistance2;
    return [
        leftD,
        rightD
    ];
}
// Calculates the distances along the vertical axis for the top and bottom route.
function getVerticalDistance(source, target) {
    const { y0: sy0, y1: sy1, outsidePoint: sourcePoint } = source;
    const { y0: ty0, y1: ty1, outsidePoint: targetPoint } = target;
    // Furthest top boundary
    let topBoundary = Math.min(sy0, ty0);
    // Furthest bottom boundary
    let bottomBoundary = Math.max(sy1, ty1);
    // If the source and target elements are on the same side, we need to figure out what shape defines the boundary.
    if (source.direction === target.direction) {
        const leftShape = source.x0 < target.x0 ? source : target;
        const rightShape = leftShape === source ? target : source;
        // The source and target anchors are on the left => then the `leftShape` defines the boundary.
        // The source and target anchors are on the right => then the `rightShape` defines the boundary.
        const boundaryDefiningShape = source.direction === Directions.LEFT ? leftShape : rightShape;
        topBoundary = boundaryDefiningShape.y0;
        bottomBoundary = boundaryDefiningShape.y1;
    }
    const { y: soy } = sourcePoint;
    const { y: toy } = targetPoint;
    // Calculate the distances for the top route
    const topDistance1 = Math.abs(soy - topBoundary);
    const topDistance2 = Math.abs(toy - topBoundary);
    const topD = topDistance1 + topDistance2;
    // Calculate the distances for the bottom route
    const bottomDistance1 = Math.abs(soy - bottomBoundary);
    const bottomDistance2 = Math.abs(toy - bottomBoundary);
    const bottomD = bottomDistance1 + bottomDistance2;
    return [
        topD,
        bottomD
    ];
}
// Inflate bbox in 3 directions depending on the direction of the anchor
// don't inflate in the opposite direction of the anchor
function moveAndExpandBBox(bbox, direction, margin) {
    switch(direction){
        case Directions.LEFT:
            bbox.inflate(0, margin).moveAndExpand({
                x: -margin,
                width: margin
            });
            break;
        case Directions.RIGHT:
            bbox.inflate(0, margin).moveAndExpand({
                width: margin
            });
            break;
        case Directions.TOP:
            bbox.inflate(margin, 0).moveAndExpand({
                y: -margin,
                height: margin
            });
            break;
        case Directions.BOTTOM:
            bbox.inflate(margin, 0).moveAndExpand({
                height: margin
            });
            break;
    }
    return bbox;
}
function routeBetweenPoints(source, target, opt = {}) {
    const { point: sourcePoint, x0: sx0, y0: sy0, width: sourceWidth, height: sourceHeight, margin: sourceMargin } = source;
    const { point: targetPoint, x0: tx0, y0: ty0, width: targetWidth, height: targetHeight, margin: targetMargin } = target;
    const { targetInSourceBBox = false } = opt;
    const tx1 = tx0 + targetWidth;
    const ty1 = ty0 + targetHeight;
    const sx1 = sx0 + sourceWidth;
    const sy1 = sy0 + sourceHeight;
    // Key coordinates including the margin
    const smx0 = sx0 - sourceMargin;
    const smx1 = sx1 + sourceMargin;
    const smy0 = sy0 - sourceMargin;
    const smy1 = sy1 + sourceMargin;
    const tmx0 = tx0 - targetMargin;
    const tmx1 = tx1 + targetMargin;
    const tmy0 = ty0 - targetMargin;
    const tmy1 = ty1 + targetMargin;
    const [sourceSide, targetSide] = resolveSides(source, target);
    const sourceOutsidePoint = getOutsidePoint(sourceSide, {
        point: sourcePoint,
        x0: sx0,
        y0: sy0,
        width: sourceWidth,
        height: sourceHeight
    }, sourceMargin);
    const targetOutsidePoint = getOutsidePoint(targetSide, {
        point: targetPoint,
        x0: tx0,
        y0: ty0,
        width: targetWidth,
        height: targetHeight
    }, targetMargin);
    const { x: sox, y: soy } = sourceOutsidePoint;
    const { x: tox, y: toy } = targetOutsidePoint;
    const tcx = (tx0 + tx1) / 2;
    const tcy = (ty0 + ty1) / 2;
    const scx = (sx0 + sx1) / 2;
    const scy = (sy0 + sy1) / 2;
    const middleOfVerticalSides = (scx < tcx ? sx1 + tx0 : tx1 + sx0) / 2;
    const middleOfHorizontalSides = (scy < tcy ? sy1 + ty0 : ty1 + sy0) / 2;
    const sourceBBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect(sx0, sy0, sourceWidth, sourceHeight);
    const targetBBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Rect(tx0, ty0, targetWidth, targetHeight);
    const inflatedSourceBBox = sourceBBox.clone().inflate(sourceMargin);
    const inflatedTargetBBox = targetBBox.clone().inflate(targetMargin);
    const sourceForDistance = Object.assign({}, source, {
        x1: sx1,
        y1: sy1,
        outsidePoint: sourceOutsidePoint,
        direction: sourceSide
    });
    const targetForDistance = Object.assign({}, target, {
        x1: tx1,
        y1: ty1,
        outsidePoint: targetOutsidePoint,
        direction: targetSide
    });
    // Distances used to determine the shortest route along the connections on horizontal sides for
    // bottom => bottom
    // top => bottom
    // bottom => top
    // top => top
    const [leftD, rightD] = getHorizontalDistance(sourceForDistance, targetForDistance);
    // Distances used to determine the shortest route along the connection on vertical sides for
    // left => left
    // left => right
    // right => right
    // right => left
    const [topD, bottomD] = getVerticalDistance(sourceForDistance, targetForDistance);
    // All possible combinations of source and target sides
    if (sourceSide === 'left' && targetSide === 'right') {
        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);
        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);
        // Use S-shaped connection
        if (isPointInsideSource || isPointInsideTarget) {
            const middleOfAnchors = (soy + toy) / 2;
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: sox,
                    y: middleOfAnchors
                },
                {
                    x: tox,
                    y: middleOfAnchors
                },
                {
                    x: tox,
                    y: toy
                }
            ];
        }
        if (smx0 < tox) {
            let y = middleOfHorizontalSides;
            let x1 = sox;
            let x2 = tox;
            const isUpwardsShorter = topD < bottomD;
            // If the source and target elements overlap, we need to make sure the connection
            // goes around the target element.
            if (y >= smy0 && y <= smy1 || y >= tmy0 && y <= tmy1) {
                if (smy1 >= tmy0 && isUpwardsShorter) {
                    y = Math.min(tmy0, smy0);
                } else if (smy0 <= tmy1 && !isUpwardsShorter) {
                    y = Math.max(tmy1, smy1);
                }
                // This handles the case when the source and target elements overlap as well as
                // the case when the source is to the left of the target element.
                x1 = Math.min(sox, tmx0);
                x2 = Math.max(tox, smx1);
                // This is an edge case when the source and target intersect and
                if (isUpwardsShorter && soy < ty0 || !isUpwardsShorter && soy > ty1) {
                    // the path should no longer rely on minimal x boundary in `x1`
                    x1 = sox;
                } else if (isUpwardsShorter && toy < sy0 || !isUpwardsShorter && toy > sy1) {
                    // the path should no longer rely on maximal x boundary in `x2`
                    x2 = tox;
                }
            }
            return [
                {
                    x: x1,
                    y: soy
                },
                {
                    x: x1,
                    y
                },
                {
                    x: x2,
                    y
                },
                {
                    x: x2,
                    y: toy
                }
            ];
        }
        const x = (sox + tox) / 2;
        return [
            {
                x,
                y: soy
            },
            {
                x,
                y: toy
            }
        ];
    } else if (sourceSide === 'right' && targetSide === 'left') {
        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);
        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);
        // Use S-shaped connection
        if (isPointInsideSource || isPointInsideTarget) {
            const middleOfAnchors = (soy + toy) / 2;
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: sox,
                    y: middleOfAnchors
                },
                {
                    x: tox,
                    y: middleOfAnchors
                },
                {
                    x: tox,
                    y: toy
                }
            ];
        }
        if (smx1 > tox) {
            let y = middleOfHorizontalSides;
            let x1 = sox;
            let x2 = tox;
            const isUpwardsShorter = topD < bottomD;
            // If the source and target elements overlap, we need to make sure the connection
            // goes around the target element.
            if (y >= smy0 && y <= smy1 || y >= tmy0 && y <= tmy1) {
                if (smy1 >= tmy0 && isUpwardsShorter) {
                    y = Math.min(tmy0, smy0);
                } else if (smy0 <= tmy1 && !isUpwardsShorter) {
                    y = Math.max(tmy1, smy1);
                }
                // This handles the case when the source and target elements overlap as well as
                // the case when the source is to the left of the target element.
                x1 = Math.max(sox, tmx1);
                x2 = Math.min(tox, smx0);
                // This is an edge case when the source and target intersect and
                if (isUpwardsShorter && soy < ty0 || !isUpwardsShorter && soy > ty1) {
                    // the path should no longer rely on maximal x boundary in `x1`
                    x1 = sox;
                } else if (isUpwardsShorter && toy < sy0 || !isUpwardsShorter && toy > sy1) {
                    // the path should no longer rely on minimal x boundary in `x2`
                    x2 = tox;
                }
            }
            return [
                {
                    x: x1,
                    y: soy
                },
                {
                    x: x1,
                    y
                },
                {
                    x: x2,
                    y
                },
                {
                    x: x2,
                    y: toy
                }
            ];
        }
        const x = (sox + tox) / 2;
        return [
            {
                x,
                y: soy
            },
            {
                x,
                y: toy
            }
        ];
    } else if (sourceSide === 'top' && targetSide === 'bottom') {
        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);
        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);
        // Use S-shaped connection
        if (isPointInsideSource || isPointInsideTarget) {
            const middleOfAnchors = (sox + tox) / 2;
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: middleOfAnchors,
                    y: soy
                },
                {
                    x: middleOfAnchors,
                    y: toy
                },
                {
                    x: tox,
                    y: toy
                }
            ];
        }
        if (smy0 < toy) {
            let x = middleOfVerticalSides;
            let y1 = soy;
            let y2 = toy;
            const isLeftShorter = leftD < rightD;
            // If the source and target elements overlap, we need to make sure the connection
            // goes around the target element.
            if (x >= smx0 && x <= smx1 || x >= tmx0 && x <= tmx1) {
                if (smx1 >= tmx0 && isLeftShorter) {
                    x = Math.min(tmx0, smx0);
                } else if (smx0 <= tmx1 && !isLeftShorter) {
                    x = Math.max(tmx1, smx1);
                }
                // This handles the case when the source and target elements overlap as well as
                // the case when the source is to the left of the target element.
                y1 = Math.min(soy, tmy0);
                y2 = Math.max(toy, smy1);
                // This is an edge case when the source and target intersect and
                if (isLeftShorter && sox < tx0 || !isLeftShorter && sox > tx1) {
                    // the path should no longer rely on minimal y boundary in `y1`
                    y1 = soy;
                } else if (isLeftShorter && tox < sx0 || !isLeftShorter && tox > sx1) {
                    // the path should no longer rely on maximal y boundary in `y2`
                    y2 = toy;
                }
            }
            return [
                {
                    x: sox,
                    y: y1
                },
                {
                    x,
                    y: y1
                },
                {
                    x,
                    y: y2
                },
                {
                    x: tox,
                    y: y2
                }
            ];
        }
        const y = (soy + toy) / 2;
        return [
            {
                x: sox,
                y
            },
            {
                x: tox,
                y
            }
        ];
    } else if (sourceSide === 'bottom' && targetSide === 'top') {
        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);
        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);
        // Use S-shaped connection
        if (isPointInsideSource || isPointInsideTarget) {
            const middleOfAnchors = (sox + tox) / 2;
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: middleOfAnchors,
                    y: soy
                },
                {
                    x: middleOfAnchors,
                    y: toy
                },
                {
                    x: tox,
                    y: toy
                }
            ];
        }
        if (smy1 > toy) {
            let x = middleOfVerticalSides;
            let y1 = soy;
            let y2 = toy;
            const isLeftShorter = leftD < rightD;
            // If the source and target elements overlap, we need to make sure the connection
            // goes around the target element.
            if (x >= smx0 && x <= smx1 || x >= tmx0 && x <= tmx1) {
                if (smx1 >= tmx0 && isLeftShorter) {
                    x = Math.min(tmx0, smx0);
                } else if (smx0 <= tmx1 && !isLeftShorter) {
                    x = Math.max(tmx1, smx1);
                }
                // This handles the case when the source and target elements overlap as well as
                // the case when the source is to the left of the target element.
                y1 = Math.max(soy, tmy1);
                y2 = Math.min(toy, smy0);
                // This is an edge case when the source and target intersect and
                if (isLeftShorter && sox < tx0 || !isLeftShorter && sox > tx1) {
                    // the path should no longer rely on maximal y boundary in `y1`
                    y1 = soy;
                } else if (isLeftShorter && tox < sx0 || !isLeftShorter && tox > sx1) {
                    // the path should no longer rely on minimal y boundary in `y2`
                    y2 = toy;
                }
            }
            return [
                {
                    x: sox,
                    y: y1
                },
                {
                    x,
                    y: y1
                },
                {
                    x,
                    y: y2
                },
                {
                    x: tox,
                    y: y2
                }
            ];
        }
        const y = (soy + toy) / 2;
        return [
            {
                x: sox,
                y
            },
            {
                x: tox,
                y
            }
        ];
    } else if (sourceSide === 'top' && targetSide === 'top') {
        const useUShapeConnection = targetInSourceBBox || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.intersection.rectWithRect(inflatedSourceBBox, targetBBox) || soy <= ty0 && (inflatedSourceBBox.bottomRight().x <= tox || inflatedSourceBBox.bottomLeft().x >= tox) || soy >= ty0 && (inflatedTargetBBox.bottomRight().x <= sox || inflatedTargetBBox.bottomLeft().x >= sox);
        // U-shape connection is a straight line if `sox` and `tox` are the same
        if (useUShapeConnection && sox !== tox) {
            return [
                {
                    x: sox,
                    y: Math.min(soy, toy)
                },
                {
                    x: tox,
                    y: Math.min(soy, toy)
                }
            ];
        }
        let x;
        let y1 = Math.min((sy1 + ty0) / 2, toy);
        let y2 = Math.min((sy0 + ty1) / 2, soy);
        if (toy < soy) {
            // Use the shortest path along the connections on horizontal sides
            if (rightD > leftD) {
                x = Math.min(sox, tmx0);
            } else {
                x = Math.max(sox, tmx1);
            }
        } else {
            if (rightD > leftD) {
                x = Math.min(tox, smx0);
            } else {
                x = Math.max(tox, smx1);
            }
        }
        return [
            {
                x: sox,
                y: y2
            },
            {
                x,
                y: y2
            },
            {
                x,
                y: y1
            },
            {
                x: tox,
                y: y1
            }
        ];
    } else if (sourceSide === 'bottom' && targetSide === 'bottom') {
        const useUShapeConnection = targetInSourceBBox || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.intersection.rectWithRect(inflatedSourceBBox, targetBBox) || soy >= toy && (inflatedSourceBBox.topRight().x <= tox || inflatedSourceBBox.topLeft().x >= tox) || soy <= toy && (inflatedTargetBBox.topRight().x <= sox || inflatedTargetBBox.topLeft().x >= sox);
        // U-shape connection is a straight line if `sox` and `tox` are the same
        if (useUShapeConnection && sox !== tox) {
            return [
                {
                    x: sox,
                    y: Math.max(soy, toy)
                },
                {
                    x: tox,
                    y: Math.max(soy, toy)
                }
            ];
        }
        let x;
        let y1 = Math.max((sy0 + ty1) / 2, toy);
        let y2 = Math.max((sy1 + ty0) / 2, soy);
        if (toy > soy) {
            // Use the shortest path along the connections on horizontal sides
            if (rightD > leftD) {
                x = Math.min(sox, tmx0);
            } else {
                x = Math.max(sox, tmx1);
            }
        } else {
            if (rightD > leftD) {
                x = Math.min(tox, smx0);
            } else {
                x = Math.max(tox, smx1);
            }
        }
        return [
            {
                x: sox,
                y: y2
            },
            {
                x,
                y: y2
            },
            {
                x,
                y: y1
            },
            {
                x: tox,
                y: y1
            }
        ];
    } else if (sourceSide === 'left' && targetSide === 'left') {
        const useUShapeConnection = targetInSourceBBox || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.intersection.rectWithRect(inflatedSourceBBox, targetBBox) || sox <= tox && (inflatedSourceBBox.bottomRight().y <= toy || inflatedSourceBBox.topRight().y >= toy) || sox >= tox && (inflatedTargetBBox.bottomRight().y <= soy || inflatedTargetBBox.topRight().y >= soy);
        // U-shape connection is a straight line if `soy` and `toy` are the same
        if (useUShapeConnection && soy !== toy) {
            return [
                {
                    x: Math.min(sox, tox),
                    y: soy
                },
                {
                    x: Math.min(sox, tox),
                    y: toy
                }
            ];
        }
        let y;
        let x1 = Math.min((sx1 + tx0) / 2, tox);
        let x2 = Math.min((sx0 + tx1) / 2, sox);
        if (tox > sox) {
            if (topD <= bottomD) {
                y = Math.min(smy0, toy);
            } else {
                y = Math.max(smy1, toy);
            }
        } else {
            if (topD <= bottomD) {
                y = Math.min(tmy0, soy);
            } else {
                y = Math.max(tmy1, soy);
            }
        }
        return [
            {
                x: x2,
                y: soy
            },
            {
                x: x2,
                y
            },
            {
                x: x1,
                y
            },
            {
                x: x1,
                y: toy
            }
        ];
    } else if (sourceSide === 'right' && targetSide === 'right') {
        const useUShapeConnection = targetInSourceBBox || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.intersection.rectWithRect(inflatedSourceBBox, targetBBox) || sox >= tox && (inflatedSourceBBox.bottomLeft().y <= toy || inflatedSourceBBox.topLeft().y >= toy) || sox <= tox && (inflatedTargetBBox.bottomLeft().y <= soy || inflatedTargetBBox.topLeft().y >= soy);
        // U-shape connection is a straight line if `soy` and `toy` are the same
        if (useUShapeConnection && soy !== toy) {
            return [
                {
                    x: Math.max(sox, tox),
                    y: soy
                },
                {
                    x: Math.max(sox, tox),
                    y: toy
                }
            ];
        }
        let y;
        let x1 = Math.max((sx0 + tx1) / 2, tox);
        let x2 = Math.max((sx1 + tx0) / 2, sox);
        if (tox <= sox) {
            if (topD <= bottomD) {
                y = Math.min(smy0, toy);
            } else {
                y = Math.max(smy1, toy);
            }
        } else {
            if (topD <= bottomD) {
                y = Math.min(tmy0, soy);
            } else {
                y = Math.max(tmy1, soy);
            }
        }
        return [
            {
                x: x2,
                y: soy
            },
            {
                x: x2,
                y
            },
            {
                x: x1,
                y
            },
            {
                x: x1,
                y: toy
            }
        ];
    } else if (sourceSide === 'top' && targetSide === 'right') {
        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);
        // The target point is inside the source element
        if (isPointInsideSource) {
            if (sox <= tmx1) {
                const x = Math.max(sox + sourceMargin, tox);
                const y = Math.min(smy0, tmy0);
                // Target anchor is on the right side of the source anchor
                return [
                    {
                        x: sox,
                        y
                    },
                    {
                        x: x,
                        y
                    },
                    {
                        x: x,
                        y: toy
                    }
                ];
            }
            // Target anchor is on the left side of the source anchor
            // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor
            const anchorMiddleX = (sox - sourceMargin + tox) / 2;
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: anchorMiddleX,
                    y: soy
                },
                {
                    x: anchorMiddleX,
                    y: toy
                }
            ];
        }
        if (smy0 > toy) {
            if (sox < tox) {
                let y = tmy0;
                if (tmy1 <= smy0 && tmx1 >= sox) {
                    y = middleOfHorizontalSides;
                }
                return [
                    {
                        x: sox,
                        y
                    },
                    {
                        x: tox,
                        y
                    },
                    {
                        x: tox,
                        y: toy
                    }
                ];
            }
            return [
                {
                    x: sox,
                    y: toy
                }
            ];
        }
        const x = Math.max(middleOfVerticalSides, tmx1);
        if (sox > tox && sy1 >= toy) {
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x,
                    y: soy
                },
                {
                    x,
                    y: toy
                }
            ];
        }
        if (x > smx0 && soy < ty1) {
            const y = Math.min(smy0, tmy0);
            const x = Math.max(smx1, tmx1);
            return [
                {
                    x: sox,
                    y
                },
                {
                    x,
                    y
                },
                {
                    x,
                    y: toy
                }
            ];
        }
        return [
            {
                x: sox,
                y: soy
            },
            {
                x,
                y: soy
            },
            {
                x,
                y: toy
            }
        ];
    } else if (sourceSide === 'top' && targetSide === 'left') {
        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);
        // The target point is inside the source element
        if (isPointInsideSource) {
            if (sox >= tmx0) {
                const x = Math.min(sox - sourceMargin, tox);
                const y = Math.min(smy0, tmy0);
                // Target anchor is on the left side of the source anchor
                return [
                    {
                        x: sox,
                        y
                    },
                    {
                        x: x,
                        y
                    },
                    {
                        x: x,
                        y: toy
                    }
                ];
            }
            // Target anchor is on the right side of the source anchor
            // Add the `sourceMargin` since the source anchor is on the left side of the target anchor
            const anchorMiddleX = (sox + sourceMargin + tox) / 2;
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: anchorMiddleX,
                    y: soy
                },
                {
                    x: anchorMiddleX,
                    y: toy
                }
            ];
        }
        if (smy0 > toy) {
            if (sox > tox) {
                let y = tmy0;
                if (tmy1 <= smy0 && tmx0 <= sox) {
                    y = middleOfHorizontalSides;
                }
                return [
                    {
                        x: sox,
                        y
                    },
                    {
                        x: tox,
                        y
                    },
                    {
                        x: tox,
                        y: toy
                    }
                ];
            }
            return [
                {
                    x: sox,
                    y: toy
                }
            ];
        }
        const x = Math.min(tmx0, middleOfVerticalSides);
        if (sox < tox && sy1 >= toy) {
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x,
                    y: soy
                },
                {
                    x,
                    y: toy
                }
            ];
        }
        if (x < smx1 && soy < ty1) {
            const y = Math.min(smy0, tmy0);
            const x = Math.min(smx0, tmx0);
            return [
                {
                    x: sox,
                    y
                },
                {
                    x,
                    y
                },
                {
                    x,
                    y: toy
                }
            ];
        }
        return [
            {
                x: sox,
                y: soy
            },
            {
                x,
                y: soy
            },
            {
                x,
                y: toy
            }
        ];
    } else if (sourceSide === 'bottom' && targetSide === 'right') {
        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);
        // The target point is inside the source element
        if (isPointInsideSource) {
            if (sox <= tmx1) {
                const x = Math.max(sox + sourceMargin, tox);
                const y = Math.max(smy1, tmy1);
                // Target anchor is on the right side of the source anchor
                return [
                    {
                        x: sox,
                        y
                    },
                    {
                        x,
                        y
                    },
                    {
                        x,
                        y: toy
                    }
                ];
            }
            // Target anchor is on the left side of the source anchor
            // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor
            const anchorMiddleX = (sox - sourceMargin + tox) / 2;
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: anchorMiddleX,
                    y: soy
                },
                {
                    x: anchorMiddleX,
                    y: toy
                }
            ];
        }
        if (smy1 < toy) {
            if (sox < tox) {
                let y = tmy1;
                if (tmy0 >= smy1 && tmx1 >= sox) {
                    y = middleOfHorizontalSides;
                }
                return [
                    {
                        x: sox,
                        y
                    },
                    {
                        x: tox,
                        y
                    },
                    {
                        x: tox,
                        y: toy
                    }
                ];
            }
            return [
                {
                    x: sox,
                    y: toy
                }
            ];
        }
        const x = Math.max(middleOfVerticalSides, tmx1);
        if (sox > tox && sy0 <= toy) {
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x,
                    y: soy
                },
                {
                    x,
                    y: toy
                }
            ];
        }
        if (x > smx0 && soy > ty0) {
            const y = Math.max(smy1, tmy1);
            const x = Math.max(smx1, tmx1);
            return [
                {
                    x: sox,
                    y
                },
                {
                    x,
                    y
                },
                {
                    x,
                    y: toy
                }
            ];
        }
        return [
            {
                x: sox,
                y: soy
            },
            {
                x,
                y: soy
            },
            {
                x,
                y: toy
            }
        ];
    } else if (sourceSide === 'bottom' && targetSide === 'left') {
        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);
        // The target point is inside the source element
        if (isPointInsideSource) {
            if (sox >= tmx0) {
                const x = Math.min(sox - sourceMargin, tox);
                const y = Math.max(smy1, tmy1);
                // Target anchor is on the left side of the source anchor
                return [
                    {
                        x: sox,
                        y
                    },
                    {
                        x,
                        y
                    },
                    {
                        x,
                        y: toy
                    }
                ];
            }
            // Target anchor is on the right side of the source anchor
            // Add the `sourceMargin` since the source anchor is on the left side of the target anchor
            const anchorMiddleX = (sox + sourceMargin + tox) / 2;
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: anchorMiddleX,
                    y: soy
                },
                {
                    x: anchorMiddleX,
                    y: toy
                }
            ];
        }
        if (smy1 < toy) {
            if (sox > tox) {
                let y = tmy1;
                if (tmy0 >= smy1 && tmx0 <= sox) {
                    y = middleOfHorizontalSides;
                }
                return [
                    {
                        x: sox,
                        y
                    },
                    {
                        x: tox,
                        y
                    },
                    {
                        x: tox,
                        y: toy
                    }
                ];
            }
            return [
                {
                    x: sox,
                    y: toy
                }
            ];
        }
        const x = Math.min(tmx0, middleOfVerticalSides);
        if (sox < tox && sy0 <= toy) {
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x,
                    y: soy
                },
                {
                    x,
                    y: toy
                }
            ];
        }
        if (x < smx1 && soy > ty0) {
            const y = Math.max(smy1, tmy1);
            const x = Math.min(smx0, tmx0);
            return [
                {
                    x: sox,
                    y
                },
                {
                    x,
                    y
                },
                {
                    x,
                    y: toy
                }
            ];
        }
        return [
            {
                x: sox,
                y: soy
            },
            {
                x,
                y: soy
            },
            {
                x,
                y: toy
            }
        ];
    } else if (sourceSide === 'left' && targetSide === 'bottom') {
        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);
        // The target point is inside the source element
        if (isPointInsideSource) {
            if (soy <= tmy1) {
                const x = Math.min(smx0, tmx0);
                const y = Math.max(soy + sourceMargin, toy);
                return [
                    {
                        x,
                        y: soy
                    },
                    {
                        x,
                        y
                    },
                    {
                        x: tox,
                        y
                    }
                ];
            }
            // Target anchor is above the source anchor
            const anchorMiddleY = (soy - sourceMargin + toy) / 2;
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: sox,
                    y: anchorMiddleY
                },
                {
                    x: tox,
                    y: anchorMiddleY
                }
            ];
        }
        if (smx0 > tox) {
            if (soy < toy) {
                let x = tmx0;
                if (tmx1 <= smx0 && tmy1 >= soy) {
                    x = middleOfVerticalSides;
                }
                return [
                    {
                        x,
                        y: soy
                    },
                    {
                        x,
                        y: toy
                    },
                    {
                        x: tox,
                        y: toy
                    }
                ];
            }
            return [
                {
                    x: tox,
                    y: soy
                }
            ];
        }
        const y = Math.max(tmy1, middleOfHorizontalSides);
        if (soy > toy && sx1 >= tox) {
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: sox,
                    y
                },
                {
                    x: tox,
                    y
                }
            ];
        }
        if (y > smy0 && sox < tx1) {
            const x = Math.min(smx0, tmx0);
            const y = Math.max(smy1, tmy1);
            return [
                {
                    x,
                    y: soy
                },
                {
                    x,
                    y
                },
                {
                    x: tox,
                    y
                }
            ];
        }
        return [
            {
                x: sox,
                y: soy
            },
            {
                x: sox,
                y
            },
            {
                x: tox,
                y
            }
        ];
    } else if (sourceSide === 'left' && targetSide === 'top') {
        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);
        // The target point is inside the source element
        if (isPointInsideSource) {
            if (soy >= tmy0) {
                const y = Math.min(soy - sourceMargin, toy);
                const x = Math.min(smx0, tmx0);
                // Target anchor is on the top side of the source anchor
                return [
                    {
                        x,
                        y: soy
                    },
                    {
                        x,
                        y
                    },
                    {
                        x: tox,
                        y
                    }
                ];
            }
            // Target anchor is below the source anchor
            // Add the `sourceMargin` since the source anchor is above the target anchor
            const anchorMiddleY = (soy + sourceMargin + toy) / 2;
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: sox,
                    y: anchorMiddleY
                },
                {
                    x: tox,
                    y: anchorMiddleY
                }
            ];
        }
        if (smx0 > tox) {
            if (soy > toy) {
                let x = tmx0;
                if (tmx1 <= smx0 && tmy0 <= soy) {
                    x = middleOfVerticalSides;
                }
                return [
                    {
                        x,
                        y: soy
                    },
                    {
                        x,
                        y: toy
                    },
                    {
                        x: tox,
                        y: toy
                    }
                ];
            }
            return [
                {
                    x: tox,
                    y: soy
                }
            ];
        }
        const y = Math.min(tmy0, middleOfHorizontalSides);
        if (soy < toy && sx1 >= tox) {
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: sox,
                    y
                },
                {
                    x: tox,
                    y
                }
            ];
        }
        if (y < smy1 && sox < tx1) {
            const x = Math.min(smx0, tmx0);
            const y = Math.min(smy0, tmy0);
            return [
                {
                    x,
                    y: soy
                },
                {
                    x,
                    y
                },
                {
                    x: tox,
                    y
                }
            ];
        }
        return [
            {
                x: sox,
                y: soy
            },
            {
                x: sox,
                y
            },
            {
                x: tox,
                y
            }
        ];
    } else if (sourceSide === 'right' && targetSide === 'top') {
        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);
        // The target point is inside the source element
        if (isPointInsideSource) {
            if (soy >= tmy0) {
                const x = Math.max(smx1, tmx1);
                const y = Math.min(soy - sourceMargin, toy);
                // Target anchor is on the top side of the source anchor
                return [
                    {
                        x,
                        y: soy
                    },
                    {
                        x,
                        y
                    },
                    {
                        x: tox,
                        y
                    }
                ];
            }
            // Target anchor is below the source anchor
            // Adjust sourceMargin calculation since the source anchor is now on the right
            const anchorMiddleY = (soy + sourceMargin + toy) / 2;
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: sox,
                    y: anchorMiddleY
                },
                {
                    x: tox,
                    y: anchorMiddleY
                }
            ];
        }
        if (smx1 < tox) {
            if (soy > toy) {
                let x = tmx1;
                if (tmx0 >= smx1 && tmy0 <= soy) {
                    x = middleOfVerticalSides;
                }
                return [
                    {
                        x,
                        y: soy
                    },
                    {
                        x,
                        y: toy
                    },
                    {
                        x: tox,
                        y: toy
                    }
                ];
            }
            return [
                {
                    x: tox,
                    y: soy
                }
            ];
        }
        const y = Math.min(tmy0, middleOfHorizontalSides);
        if (soy < toy && sx0 <= tox) {
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: sox,
                    y
                },
                {
                    x: tox,
                    y
                }
            ];
        }
        if (y < smy1 && sox > tx0) {
            const x = Math.max(smx1, tmx1);
            const y = Math.min(smy0, tmy0);
            return [
                {
                    x,
                    y: soy
                },
                {
                    x,
                    y
                },
                {
                    x: tox,
                    y
                }
            ];
        }
        return [
            {
                x: sox,
                y: soy
            },
            {
                x: sox,
                y
            },
            {
                x: tox,
                y
            }
        ];
    } else if (sourceSide === 'right' && targetSide === 'bottom') {
        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);
        // The target point is inside the source element
        if (isPointInsideSource) {
            if (soy <= tmy1) {
                const x = Math.max(smx1, tmx1);
                const y = Math.max(soy + sourceMargin, toy);
                return [
                    {
                        x,
                        y: soy
                    },
                    {
                        x,
                        y
                    },
                    {
                        x: tox,
                        y
                    }
                ];
            }
            // Target anchor is above the source anchor
            const anchorMiddleY = (soy - sourceMargin + toy) / 2;
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: sox,
                    y: anchorMiddleY
                },
                {
                    x: tox,
                    y: anchorMiddleY
                }
            ];
        }
        if (smx1 < tox) {
            if (soy < toy) {
                let x = tmx1;
                if (tmx0 >= smx1 && tmy1 >= soy) {
                    x = middleOfVerticalSides;
                }
                return [
                    {
                        x,
                        y: soy
                    },
                    {
                        x,
                        y: toy
                    },
                    {
                        x: tox,
                        y: toy
                    }
                ];
            }
            return [
                {
                    x: tox,
                    y: soy
                }
            ];
        }
        const y = Math.max(tmy1, middleOfHorizontalSides);
        if (soy > toy && sx0 <= tox) {
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: sox,
                    y
                },
                {
                    x: tox,
                    y
                }
            ];
        }
        if (y > smy0 && sox > tx0) {
            const x = Math.max(smx1, tmx1);
            const y = Math.max(smy1, tmy1);
            return [
                {
                    x,
                    y: soy
                },
                {
                    x,
                    y
                },
                {
                    x: tox,
                    y
                }
            ];
        }
        return [
            {
                x: sox,
                y: soy
            },
            {
                x: sox,
                y
            },
            {
                x: tox,
                y
            }
        ];
    }
}
function getLoopCoordinates(direction, angle, margin) {
    const isHorizontal = direction === Directions.LEFT || direction === Directions.RIGHT;
    let dx = 0;
    let dy = 0;
    switch(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.normalizeAngle(Math.round(angle))){
        case 0:
        case 90:
            dx = isHorizontal ? 0 : margin;
            dy = isHorizontal ? margin : 0;
            break;
        case 180:
        case 270:
            dx = isHorizontal ? 0 : -margin;
            dy = isHorizontal ? -margin : 0;
            break;
    }
    return {
        dx,
        dy
    };
}
function rightAngleRouter(vertices, opt, linkView) {
    const { sourceDirection = Directions.AUTO, targetDirection = Directions.AUTO } = opt;
    const margin = opt.margin || 20;
    const useVertices = opt.useVertices || false;
    const isSourcePort = !!linkView.model.source().port;
    const sourcePoint = pointDataFromAnchor(linkView.sourceView, linkView.sourceAnchor, linkView.sourceBBox, sourceDirection, isSourcePort, linkView.sourceAnchor, margin);
    const isTargetPort = !!linkView.model.target().port;
    const targetPoint = pointDataFromAnchor(linkView.targetView, linkView.targetAnchor, linkView.targetBBox, targetDirection, isTargetPort, linkView.targetAnchor, margin);
    let resultVertices = [];
    if (!useVertices || vertices.length === 0) {
        return simplifyPoints(routeBetweenPoints(sourcePoint, targetPoint));
    }
    const verticesData = vertices.map((v)=>pointDataFromVertex(v));
    const [firstVertex] = verticesData;
    const [resolvedSourceDirection] = resolveSides(sourcePoint, firstVertex);
    const isElement = sourcePoint.view && sourcePoint.view.model.isElement();
    const sourceBBox = isElement ? moveAndExpandBBox(sourcePoint.view.model.getBBox(), resolvedSourceDirection, margin) : null;
    const isVertexInside = isElement ? sourceBBox.containsPoint(firstVertex.point) : false;
    if (isVertexInside) {
        const outsidePoint = getOutsidePoint(resolvedSourceDirection, sourcePoint, margin);
        const firstPointOverlap = outsidePoint.equals(firstVertex.point);
        const alignsVertically = sourcePoint.point.x === firstVertex.point.x;
        const alignsHorizontally = sourcePoint.point.y === firstVertex.point.y;
        const isVerticalAndAligns = alignsVertically && (resolvedSourceDirection === Directions.TOP || resolvedSourceDirection === Directions.BOTTOM);
        const isHorizontalAndAligns = alignsHorizontally && (resolvedSourceDirection === Directions.LEFT || resolvedSourceDirection === Directions.RIGHT);
        const firstSegment = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(sourcePoint.point, outsidePoint);
        const isVertexOnSegment = firstSegment.containsPoint(firstVertex.point);
        const isVertexAlignedAndInside = isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns);
        if (firstPointOverlap) {
            resultVertices.push(sourcePoint.point, firstVertex.point);
            // Set the access direction as the opposite of the source direction that will be used to connect the route with the next vertex
            firstVertex.direction = OPPOSITE_DIRECTIONS[resolvedSourceDirection];
        } else if (isVertexOnSegment || isVertexAlignedAndInside) {
            // Case where there is a need to create a loop
            const angle = getSegmentAngle(isVertexOnSegment ? firstSegment : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(sourcePoint.point, firstVertex.point));
            const { dx, dy } = getLoopCoordinates(resolvedSourceDirection, angle, margin);
            const loop = createLoop({
                point: outsidePoint
            }, firstVertex, {
                dx,
                dy
            });
            const secondCreatedPoint = loop[2];
            const loopEndSegment = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(firstVertex.point, secondCreatedPoint);
            const accessDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];
            firstVertex.direction = accessDirection;
            resultVertices.push(...loop);
        } else {
            // No need to create a route, use the `routeBetweenPoints` to construct a route
            firstVertex.direction = resolvedSourceDirection;
            firstVertex.margin = margin;
            resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex, {
                targetInSourceBBox: true
            }), firstVertex.point);
        }
    } else {
        // The first point responsible for the initial direction of the route
        const next = verticesData[1] || targetPoint;
        const direction = resolveInitialDirection(sourcePoint, firstVertex, next);
        firstVertex.direction = direction;
        resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex), firstVertex.point);
    }
    for(let i = 0; i < verticesData.length - 1; i++){
        const from = verticesData[i];
        const to = verticesData[i + 1];
        const connectionSegment = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(from.point, to.point);
        const connectionSegmentAngle = getSegmentAngle(connectionSegment);
        if (connectionSegmentAngle % 90 === 0) {
            // Segment is horizontal or vertical
            const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];
            const simplifiedRoute = simplifyPoints([
                ...resultVertices,
                from.point
            ]);
            // const simplifiedRoute2 = simplifyPoints([from.point, ...resultVertices]);
            // Find out the direction that is used to connect the current route with the next vertex
            const accessSegment = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(simplifiedRoute[simplifiedRoute.length - 2], simplifiedRoute[simplifiedRoute.length - 1]);
            // const accessSegment2 = new g.Line(simplifiedRoute2[simplifiedRoute2.length - 2], simplifiedRoute2[simplifiedRoute2.length - 1]);
            const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];
            // const accessDirection2 = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment2))];
            // console.log(accessDirection);
            // console.log(accessDirection2);
            // if (accessDirection !== accessDirection2) {
            //     console.log('error');
            // }
            // console.log('------------------');
            if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {
                // The directions are not opposite, so we can connect the vertices directly
                resultVertices.push(from.point, to.point);
                const [, toDirection] = resolveSides(from, to);
                to.direction = toDirection;
            } else {
                // The directions are overlapping, so we need to create a loop
                const { loopRoute, continueDirection } = loopSegment(from, to, connectionSegmentAngle, margin);
                to.direction = continueDirection;
                // Constructing a loop
                resultVertices.push(...loopRoute);
            }
            continue;
        }
        // Vertices are not aligned vertically nor horizontally
        // so we need to route between them
        const [fromDirection, toDirection] = resolveDirection(from, to);
        from.direction = fromDirection;
        to.direction = toDirection;
        resultVertices.push(...routeBetweenPoints(from, to), to.point);
    }
    const lastVertex = verticesData[verticesData.length - 1];
    if (targetPoint.view && targetPoint.view.model.isElement()) {
        const [, resolvedTargetDirection] = resolveSides(lastVertex, targetPoint);
        const outsidePoint = getOutsidePoint(resolvedTargetDirection, targetPoint, margin);
        // the last point of `simplified` array is the last defined vertex
        // this will ensure that the last segment continues in a straight line
        const simplified = simplifyPoints([
            ...resultVertices,
            lastVertex.point
        ]);
        const simplifiedSegment = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(simplified[simplified.length - 2], simplified[simplified.length - 1]);
        const simplifiedSegmentAngle = Math.round(getSegmentAngle(simplifiedSegment));
        const definedDirection = ANGLE_DIRECTION_MAP[simplifiedSegmentAngle];
        const lastPointOverlap = outsidePoint.equals(lastVertex.point);
        if (!lastPointOverlap || lastPointOverlap && definedDirection === resolvedTargetDirection) {
            lastVertex.direction = definedDirection;
            let lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);
            const [p1, p2] = simplifyPoints([
                ...lastSegmentRoute,
                targetPoint.point
            ]);
            const lastSegment = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(p1, p2);
            const roundedLastSegmentAngle = Math.round(getSegmentAngle(lastSegment));
            const lastSegmentDirection = ANGLE_DIRECTION_MAP[roundedLastSegmentAngle];
            const targetBBox = moveAndExpandBBox(targetPoint.view.model.getBBox(), resolvedTargetDirection, margin);
            const alignsVertically = lastVertex.point.x === targetPoint.point.x;
            const alignsHorizontally = lastVertex.point.y === targetPoint.point.y;
            const isVertexInside = targetBBox.containsPoint(lastVertex.point);
            const isVerticalAndAligns = alignsVertically && (resolvedTargetDirection === Directions.TOP || resolvedTargetDirection === Directions.BOTTOM);
            const isHorizontalAndAligns = alignsHorizontally && (resolvedTargetDirection === Directions.LEFT || resolvedTargetDirection === Directions.RIGHT);
            if (!lastPointOverlap && isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns)) {
                // Handle special cases when the last vertex is inside the target element
                // and in is aligned with the connection point => construct a loop
                const { dx, dy } = getLoopCoordinates(resolvedTargetDirection, simplifiedSegmentAngle, margin);
                lastSegmentRoute = createLoop(lastVertex, {
                    point: outsidePoint
                }, {
                    dx,
                    dy
                });
            } else if (isVertexInside && resolvedTargetDirection !== OPPOSITE_DIRECTIONS[definedDirection]) {
                lastVertex.margin = margin;
                lastVertex.direction = resolvedTargetDirection;
                lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);
            } else if (lastSegmentDirection !== definedDirection && definedDirection === OPPOSITE_DIRECTIONS[lastSegmentDirection]) {
                lastVertex.margin = margin;
                lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);
            }
            resultVertices.push(...lastSegmentRoute);
        }
    } else {
        // since the target is only a point we can apply the same logic as if we connected two verticesData
        const from = lastVertex;
        const to = targetPoint;
        const connectionSegment = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(from.point, to.point);
        const connectionSegmentAngle = getSegmentAngle(connectionSegment);
        if (connectionSegmentAngle % 90 === 0) {
            // Segment is horizontal or vertical
            const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];
            const simplifiedRoute = simplifyPoints(resultVertices);
            // Find out the direction that is used to connect the current route with the next vertex
            const accessSegment = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$g$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Line(simplifiedRoute[simplifiedRoute.length - 2], from.point);
            const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];
            if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {
                // The directions are not opposite, so we can connect the vertices directly by adding the first point
                // the target point is handled separately
                resultVertices.push(from.point);
            } else {
                // The directions are overlapping, so we need to create a loop
                const { loopRoute } = loopSegment(from, to, connectionSegmentAngle, margin);
                // Remove the last point since it is the target that is handled separately
                loopRoute.pop();
                // Constructing a loop
                resultVertices.push(...loopRoute);
            }
        } else {
            // The last vertex and the target are not aligned vertically nor horizontally
            // so we need to route between them
            const [fromDirection, toDirection] = resolveDirection(from, to);
            from.direction = fromDirection;
            to.direction = toDirection;
            resultVertices.push(...routeBetweenPoints(from, to));
        }
    }
    return simplifyPoints(resultVertices);
}
function resolveDirection(from, to) {
    const accessDirection = from.direction;
    const isDirectionVertical = VERTICAL_DIRECTIONS.includes(accessDirection);
    let sourceDirection = from.direction;
    let targetDirection = to.direction;
    if (isDirectionVertical) {
        const isToAbove = from.point.y > to.point.y;
        const dx = to.point.x - from.point.x;
        if (accessDirection === Directions.BOTTOM) {
            // If isToAbove === false and we need figure out if to go left or right
            sourceDirection = isToAbove ? OPPOSITE_DIRECTIONS[accessDirection] : dx >= 0 ? Directions.RIGHT : Directions.LEFT;
            if (dx > 0) {
                targetDirection = isToAbove ? Directions.LEFT : Directions.TOP;
            } else if (dx < 0) {
                targetDirection = isToAbove ? Directions.RIGHT : Directions.TOP;
            }
        } else {
            // If isToAbove === true and we need figure out if to go left or right
            sourceDirection = isToAbove ? dx >= 0 ? Directions.RIGHT : Directions.LEFT : OPPOSITE_DIRECTIONS[accessDirection];
            if (dx > 0) {
                targetDirection = isToAbove ? Directions.BOTTOM : Directions.LEFT;
            } else if (dx < 0) {
                targetDirection = isToAbove ? Directions.BOTTOM : Directions.RIGHT;
            }
        }
    } else {
        const isToLeft = from.point.x > to.point.x;
        const dy = to.point.y - from.point.y;
        if (accessDirection === Directions.RIGHT) {
            sourceDirection = isToLeft ? OPPOSITE_DIRECTIONS[accessDirection] : dy >= 0 ? Directions.BOTTOM : Directions.TOP;
            if (dy > 0) {
                targetDirection = isToLeft ? Directions.TOP : Directions.LEFT;
            } else if (dy < 0) {
                targetDirection = isToLeft ? Directions.BOTTOM : Directions.LEFT;
            }
        } else {
            sourceDirection = isToLeft ? dy >= 0 ? Directions.BOTTOM : Directions.TOP : OPPOSITE_DIRECTIONS[accessDirection];
            if (dy > 0) {
                targetDirection = isToLeft ? Directions.RIGHT : Directions.TOP;
            } else if (dy < 0) {
                targetDirection = isToLeft ? Directions.RIGHT : Directions.BOTTOM;
            }
        }
    }
    return [
        sourceDirection,
        targetDirection
    ];
}
rightAngleRouter.Directions = Directions;
const rightAngle = rightAngleRouter;
}}),
"[project]/node_modules/@joint/core/src/routers/index.mjs [app-client] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "manhattan": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$manhattan$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["manhattan"]),
    "metro": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$metro$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["metro"]),
    "normal": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$normal$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normal"]),
    "oneSide": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$oneSide$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["oneSide"]),
    "orthogonal": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$orthogonal$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["orthogonal"]),
    "rightAngle": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$rightAngle$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rightAngle"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$normal$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/routers/normal.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$oneSide$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/routers/oneSide.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$orthogonal$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/routers/orthogonal.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$manhattan$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/routers/manhattan.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$metro$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/routers/metro.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$rightAngle$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/routers/rightAngle.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/routers/index.mjs [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@joint/core/src/routers/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "manhattan": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["manhattan"]),
    "metro": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["metro"]),
    "normal": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["normal"]),
    "oneSide": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["oneSide"]),
    "orthogonal": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["orthogonal"]),
    "rightAngle": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["rightAngle"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/routers/index.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$joint$2f$core$2f$src$2f$routers$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_import__("[project]/node_modules/@joint/core/src/routers/index.mjs [app-client] (ecmascript) <exports>");
}}),
}]);

//# sourceMappingURL=node_modules_%40joint_core_src_routers_d74694._.js.map